{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/RTLgenproof.v","fileSamples":[{"statement":"forall (id1 id2 : positive) (r : reg),\n(PTree.empty reg) ! id1 = Some r ->\n(PTree.empty reg) ! id2 = Some r -> id1 = id2.","conclusion":"forall (id1 id2 : positive) (r : reg),\n(PTree.empty reg) ! id1 = Some r ->\n(PTree.empty reg) ! id2 = Some r -> id1 = id2","hypotheses":"","proofString":"intros until r.\nrewrite PTree.gempty.\ncongruence."},{"statement":"(id1 id2 : positive) (r : reg) : (PTree.empty reg) ! id1 = Some r ->\n(PTree.empty reg) ! id2 = Some r -> id1 = id2.","conclusion":"(PTree.empty reg) ! id1 = Some r ->\n(PTree.empty reg) ! id2 = Some r -> id1 = id2","hypotheses":"(id1 id2 : positive) (r : reg)","proofString":"rewrite PTree.gempty.\ncongruence."},{"statement":"(id1 id2 : positive) (r : reg) : None = Some r -> (PTree.empty reg) ! id2 = Some r -> id1 = id2.","conclusion":"None = Some r -> (PTree.empty reg) ! id2 = Some r -> id1 = id2","hypotheses":"(id1 id2 : positive) (r : reg)","proofString":"congruence."},{"statement":"forall (id : positive) (r : reg),\n(PTree.empty reg) ! id = Some r -> False -> False.","conclusion":"forall (id : positive) (r : reg),\n(PTree.empty reg) ! id = Some r -> False -> False","hypotheses":"","proofString":"tauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (map' : mapping) (i : state_incr s1 s2) (H : add_var map name s1 = OK (r, map') s2 i) (H0 : map_wf map) (H1 : map_valid map s1) : map_wf map'.","conclusion":"map_wf map'","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (map' : mapping) (i : state_incr s1 s2) (H : add_var map name s1 = OK (r, map') s2 i) (H0 : map_wf map) (H1 : map_valid map s1)","proofString":"monadInv H.\napply mk_map_wf; simpl.\nintros until r0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id1 name); destruct (peq id2 name).\ncongruence.\nintros.\ninv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg.\nintros.\ninv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg.\ninv H0.\neauto.\nintros until r0.\nrewrite PTree.gsspec.\ndestruct (peq id name).\nintros.\ninv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg.\ninv H0; eauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : map_wf\n  {|\n    map_vars := PTree.set name r (map_vars map);\n    map_letvars := map_letvars map\n  |}.","conclusion":"map_wf\n  {|\n    map_vars := PTree.set name r (map_vars map);\n    map_letvars := map_letvars map\n  |}","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2)","proofString":"apply mk_map_wf; simpl.\nintros until r0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id1 name); destruct (peq id2 name).\ncongruence.\nintros.\ninv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg.\nintros.\ninv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg.\ninv H0.\neauto.\nintros until r0.\nrewrite PTree.gsspec.\ndestruct (peq id name).\nintros.\ninv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg.\ninv H0; eauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : forall (id1 id2 : positive) (r0 : reg),\n(PTree.set name r (map_vars map)) ! id1 = Some r0 ->\n(PTree.set name r (map_vars map)) ! id2 = Some r0 -> id1 = id2.","conclusion":"forall (id1 id2 : positive) (r0 : reg),\n(PTree.set name r (map_vars map)) ! id1 = Some r0 ->\n(PTree.set name r (map_vars map)) ! id2 = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2)","proofString":"intros until r0.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id1 name); destruct (peq id2 name).\ncongruence.\nintros.\ninv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg.\nintros.\ninv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg.\ninv H0.\neauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) : (PTree.set name r (map_vars map)) ! id1 = Some r0 ->\n(PTree.set name r (map_vars map)) ! id2 = Some r0 -> id1 = id2.","conclusion":"(PTree.set name r (map_vars map)) ! id1 = Some r0 ->\n(PTree.set name r (map_vars map)) ! id2 = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg)","proofString":"repeat rewrite PTree.gsspec.\ndestruct (peq id1 name); destruct (peq id2 name).\ncongruence.\nintros.\ninv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg.\nintros.\ninv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg.\ninv H0.\neauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) : (if peq id1 name then Some r else (map_vars map) ! id1) = Some r0 ->\n(if peq id2 name then Some r else (map_vars map) ! id2) = Some r0 ->\nid1 = id2.","conclusion":"(if peq id1 name then Some r else (map_vars map) ! id1) = Some r0 ->\n(if peq id2 name then Some r else (map_vars map) ! id2) = Some r0 ->\nid1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg)","proofString":"destruct (peq id1 name); destruct (peq id2 name).\ncongruence.\nintros.\ninv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg.\nintros.\ninv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg.\ninv H0.\neauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (e : id1 = name) (e0 : id2 = name) : Some r = Some r0 -> Some r = Some r0 -> id1 = id2.","conclusion":"Some r = Some r0 -> Some r = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (e : id1 = name) (e0 : id2 = name)","proofString":"congruence."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (e : id1 = name) (n : id2 <> name) : Some r = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2.","conclusion":"Some r = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (e : id1 = name) (n : id2 <> name)","proofString":"intros.\ninv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (e : id1 = name) (n : id2 <> name) (H : Some r = Some r0) (H2 : (map_vars map) ! id2 = Some r0) : id1 = id2.","conclusion":"id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (e : id1 = name) (n : id2 <> name) (H : Some r = Some r0) (H2 : (map_vars map) ! id2 = Some r0)","proofString":"inv H.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0) : name = id2.","conclusion":"name = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0)","proofString":"exfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0) : False.","conclusion":"False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0)","proofString":"apply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id2; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0) : reg_valid r0 s1.","conclusion":"reg_valid r0 s1","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0)","proofString":"apply H1.\nleft; exists id2; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0) : reg_in_map map r0.","conclusion":"reg_in_map map r0","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0)","proofString":"left; exists id2; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0) : reg_fresh r0 s1.","conclusion":"reg_fresh r0 s1","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id2 : positive) (n : id2 <> name) (H2 : (map_vars map) ! id2 = Some r0)","proofString":"eauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (e : id2 = name) : (map_vars map) ! id1 = Some r0 -> Some r = Some r0 -> id1 = id2.","conclusion":"(map_vars map) ! id1 = Some r0 -> Some r = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (e : id2 = name)","proofString":"intros.\ninv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (e : id2 = name) (H : (map_vars map) ! id1 = Some r0) (H2 : Some r = Some r0) : id1 = id2.","conclusion":"id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (e : id2 = name) (H : (map_vars map) ! id1 = Some r0) (H2 : Some r = Some r0)","proofString":"inv H2.\nexfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0) : id1 = name.","conclusion":"id1 = name","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0)","proofString":"exfalso.\napply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0) : False.","conclusion":"False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0)","proofString":"apply valid_fresh_absurd with r0 s1.\napply H1.\nleft; exists id1; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0) : reg_valid r0 s1.","conclusion":"reg_valid r0 s1","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0)","proofString":"apply H1.\nleft; exists id1; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0) : reg_in_map map r0.","conclusion":"reg_in_map map r0","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0)","proofString":"left; exists id1; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0) : reg_fresh r0 s1.","conclusion":"reg_fresh r0 s1","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (id1 : positive) (n : id1 <> name) (H : (map_vars map) ! id1 = Some r0)","proofString":"eauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (n0 : id2 <> name) : (map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2.","conclusion":"(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (n0 : id2 <> name)","proofString":"inv H0.\neauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (n0 : id2 <> name) (map_wf_inj0 : forall (id0 id3 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> (map_vars map) ! id3 = Some r1 -> id0 = id3) (map_wf_disj0 : forall (id : positive) (r1 : reg),\n(map_vars map) ! id = Some r1 -> In r1 (map_letvars map) -> False) : (map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2.","conclusion":"(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id1 id2 : positive) (r0 : reg) (n : id1 <> name) (n0 : id2 <> name) (map_wf_inj0 : forall (id0 id3 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> (map_vars map) ! id3 = Some r1 -> id0 = id3) (map_wf_disj0 : forall (id : positive) (r1 : reg),\n(map_vars map) ! id = Some r1 -> In r1 (map_letvars map) -> False)","proofString":"eauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) : forall (id : positive) (r0 : reg),\n(PTree.set name r (map_vars map)) ! id = Some r0 ->\nIn r0 (map_letvars map) -> False.","conclusion":"forall (id : positive) (r0 : reg),\n(PTree.set name r (map_vars map)) ! id = Some r0 ->\nIn r0 (map_letvars map) -> False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2)","proofString":"intros until r0.\nrewrite PTree.gsspec.\ndestruct (peq id name).\nintros.\ninv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg.\ninv H0; eauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) : (PTree.set name r (map_vars map)) ! id = Some r0 ->\nIn r0 (map_letvars map) -> False.","conclusion":"(PTree.set name r (map_vars map)) ! id = Some r0 ->\nIn r0 (map_letvars map) -> False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg)","proofString":"rewrite PTree.gsspec.\ndestruct (peq id name).\nintros.\ninv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg.\ninv H0; eauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) : (if peq id name then Some r else (map_vars map) ! id) = Some r0 ->\nIn r0 (map_letvars map) -> False.","conclusion":"(if peq id name then Some r else (map_vars map) ! id) = Some r0 ->\nIn r0 (map_letvars map) -> False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg)","proofString":"destruct (peq id name).\nintros.\ninv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg.\ninv H0; eauto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) (e : id = name) : Some r = Some r0 -> In r0 (map_letvars map) -> False.","conclusion":"Some r = Some r0 -> In r0 (map_letvars map) -> False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) (e : id = name)","proofString":"intros.\ninv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) (e : id = name) (H : Some r = Some r0) (H2 : In r0 (map_letvars map)) : False.","conclusion":"False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) (e : id = name) (H : Some r = Some r0) (H2 : In r0 (map_letvars map))","proofString":"inv H.\napply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map)) : False.","conclusion":"False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map))","proofString":"apply valid_fresh_absurd with r0 s1.\napply H1.\nright; auto.\neauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map)) : reg_valid r0 s1.","conclusion":"reg_valid r0 s1","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map))","proofString":"apply H1.\nright; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map)) : reg_in_map map r0.","conclusion":"reg_in_map map r0","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map))","proofString":"right; auto."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map)) : reg_fresh r0 s1.","conclusion":"reg_fresh r0 s1","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (r0 : reg) (EQ : new_reg s1 = OK r0 s2 INCR) (INCR0 : state_incr s2 s2) (H2 : In r0 (map_letvars map))","proofString":"eauto with rtlg."},{"statement":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) (n : id <> name) : (map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False.","conclusion":"(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False","hypotheses":"(s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (INCR : state_incr s1 s2) (EQ : new_reg s1 = OK r s2 INCR) (INCR0 : state_incr s2 s2) (id : positive) (r0 : reg) (n : id <> name)","proofString":"inv H0; eauto."},{"statement":"(s2 : state) (map' : mapping) (H1 : map_valid map' s2) (i : state_incr s2 s2) (H0 : map_wf map') : map_wf map'.","conclusion":"map_wf map'","hypotheses":"(s2 : state) (map' : mapping) (H1 : map_valid map' s2) (i : state_incr s2 s2) (H0 : map_wf map')","proofString":"auto."},{"statement":"(a : ident) (names : list ident) (IHnames : forall (s0 s3 : state) (map0 map'0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 names s0 = OK (rl, map'0) s3 i0 ->\nmap_wf map0 -> map_valid map0 s0 -> map_wf map'0) (s1 s2 : state) (map map' : mapping) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map names s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map') s2 INCR1) (INCR2 : state_incr s2 s2) : map_wf map'.","conclusion":"map_wf map'","hypotheses":"(a : ident) (names : list ident) (IHnames : forall (s0 s3 : state) (map0 map'0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 names s0 = OK (rl, map'0) s3 i0 ->\nmap_wf map0 -> map_valid map0 s0 -> map_wf map'0) (s1 s2 : state) (map map' : mapping) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map names s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map') s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"exploit add_vars_valid; eauto.\nintros [A B].\neapply add_var_wf; eauto."},{"statement":"(a : ident) (names : list ident) (IHnames : forall (s0 s3 : state) (map0 map'0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 names s0 = OK (rl, map'0) s3 i0 ->\nmap_wf map0 -> map_valid map0 s0 -> map_wf map'0) (s1 s2 : state) (map map' : mapping) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map names s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map') s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid x s /\\ map_valid x0 s -> map_wf map'.","conclusion":"regs_valid x s /\\ map_valid x0 s -> map_wf map'","hypotheses":"(a : ident) (names : list ident) (IHnames : forall (s0 s3 : state) (map0 map'0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 names s0 = OK (rl, map'0) s3 i0 ->\nmap_wf map0 -> map_valid map0 s0 -> map_wf map'0) (s1 s2 : state) (map map' : mapping) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map names s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map') s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"intros [A B].\neapply add_var_wf; eauto."},{"statement":"(a : ident) (names : list ident) (IHnames : forall (s0 s3 : state) (map0 map'0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 names s0 = OK (rl, map'0) s3 i0 ->\nmap_wf map0 -> map_valid map0 s0 -> map_wf map'0) (s1 s2 : state) (map map' : mapping) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map names s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map') s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) : map_wf map'.","conclusion":"map_wf map'","hypotheses":"(a : ident) (names : list ident) (IHnames : forall (s0 s3 : state) (map0 map'0 : mapping) (rl : list reg)\n  (i0 : state_incr s0 s3),\nadd_vars map0 names s0 = OK (rl, map'0) s3 i0 ->\nmap_wf map0 -> map_valid map0 s0 -> map_wf map'0) (s1 s2 : state) (map map' : mapping) (i : state_incr s1 s2) (H0 : map_wf map) (H1 : map_valid map s1) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map names s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map') s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s)","proofString":"eapply add_var_wf; eauto."},{"statement":"(map : mapping) (r : reg) (H : map_wf map) (H0 : ~ reg_in_map map r) : map_wf (add_letvar map r).","conclusion":"map_wf (add_letvar map r)","hypotheses":"(map : mapping) (r : reg) (H : map_wf map) (H0 : ~ reg_in_map map r)","proofString":"inv H.\nunfold add_letvar; constructor; simpl.\nauto.\nintros.\nelim H1; intro.\nsubst r0.\nelim H0.\nleft; exists id; auto.\neauto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False) : map_wf (add_letvar map r).","conclusion":"map_wf (add_letvar map r)","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False)","proofString":"unfold add_letvar; constructor; simpl.\nauto.\nintros.\nelim H1; intro.\nsubst r0.\nelim H0.\nleft; exists id; auto.\neauto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False) : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2.","conclusion":"forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False)","proofString":"auto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False) : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> r = r0 \\/ In r0 (map_letvars map) -> False.","conclusion":"forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> r = r0 \\/ In r0 (map_letvars map) -> False","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id : positive) (r0 : reg),\n(map_vars map) ! id = Some r0 -> In r0 (map_letvars map) -> False)","proofString":"intros.\nelim H1; intro.\nsubst r0.\nelim H0.\nleft; exists id; auto.\neauto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r1 : reg),\n(map_vars map) ! id1 = Some r1 -> (map_vars map) ! id2 = Some r1 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> In r1 (map_letvars map) -> False) (id : positive) (r0 : reg) (H : (map_vars map) ! id = Some r0) (H1 : r = r0 \\/ In r0 (map_letvars map)) : False.","conclusion":"False","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r1 : reg),\n(map_vars map) ! id1 = Some r1 -> (map_vars map) ! id2 = Some r1 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> In r1 (map_letvars map) -> False) (id : positive) (r0 : reg) (H : (map_vars map) ! id = Some r0) (H1 : r = r0 \\/ In r0 (map_letvars map))","proofString":"elim H1; intro.\nsubst r0.\nelim H0.\nleft; exists id; auto.\neauto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r1 : reg),\n(map_vars map) ! id1 = Some r1 -> (map_vars map) ! id2 = Some r1 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> In r1 (map_letvars map) -> False) (id : positive) (r0 : reg) (H : (map_vars map) ! id = Some r0) (H1 : r = r0 \\/ In r0 (map_letvars map)) (H2 : r = r0) : False.","conclusion":"False","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r1 : reg),\n(map_vars map) ! id1 = Some r1 -> (map_vars map) ! id2 = Some r1 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> In r1 (map_letvars map) -> False) (id : positive) (r0 : reg) (H : (map_vars map) ! id = Some r0) (H1 : r = r0 \\/ In r0 (map_letvars map)) (H2 : r = r0)","proofString":"subst r0.\nelim H0.\nleft; exists id; auto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (id : positive) (H1 : r = r \\/ In r (map_letvars map)) (H : (map_vars map) ! id = Some r) : False.","conclusion":"False","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (id : positive) (H1 : r = r \\/ In r (map_letvars map)) (H : (map_vars map) ! id = Some r)","proofString":"elim H0.\nleft; exists id; auto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (id : positive) (H1 : r = r \\/ In r (map_letvars map)) (H : (map_vars map) ! id = Some r) : reg_in_map map r.","conclusion":"reg_in_map map r","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (id : positive) (H1 : r = r \\/ In r (map_letvars map)) (H : (map_vars map) ! id = Some r)","proofString":"left; exists id; auto."},{"statement":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r1 : reg),\n(map_vars map) ! id1 = Some r1 -> (map_vars map) ! id2 = Some r1 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> In r1 (map_letvars map) -> False) (id : positive) (r0 : reg) (H : (map_vars map) ! id = Some r0) (H1 : r = r0 \\/ In r0 (map_letvars map)) (H2 : In r0 (map_letvars map)) : False.","conclusion":"False","hypotheses":"(map : mapping) (r : reg) (H0 : ~ reg_in_map map r) (map_wf_inj0 : forall (id1 id2 : positive) (r1 : reg),\n(map_vars map) ! id1 = Some r1 -> (map_vars map) ! id2 = Some r1 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r1 : reg),\n(map_vars map) ! id0 = Some r1 -> In r1 (map_letvars map) -> False) (id : positive) (r0 : reg) (H : (map_vars map) ! id = Some r0) (H1 : r = r0 \\/ In r0 (map_letvars map)) (H2 : In r0 (map_letvars map))","proofString":"eauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r)","proofString":"exploit me_vars; eauto.\nintros [r' [EQ' RS]].\nreplace r with r'.\nauto.\ncongruence."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) : (exists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v rs # r0) ->\nVal.lessdef v rs # r.","conclusion":"(exists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v rs # r0) ->\nVal.lessdef v rs # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r)","proofString":"intros [r' [EQ' RS]].\nreplace r with r'.\nauto.\ncongruence."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) (r' : reg) (EQ' : (map_vars map) ! id = Some r') (RS : Val.lessdef v rs # r') : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) (r' : reg) (EQ' : (map_vars map) ! id = Some r') (RS : Val.lessdef v rs # r')","proofString":"replace r with r'.\nauto.\ncongruence."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) (r' : reg) (EQ' : (map_vars map) ! id = Some r') (RS : Val.lessdef v rs # r') : Val.lessdef v rs # r'.","conclusion":"Val.lessdef v rs # r'","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) (r' : reg) (EQ' : (map_vars map) ! id = Some r') (RS : Val.lessdef v rs # r')","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) (r' : reg) (EQ' : (map_vars map) ! id = Some r') (RS : Val.lessdef v rs # r') : r' = r.","conclusion":"r' = r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (v : val) (r : reg) (H : match_env map e le rs) (H0 : e ! id = Some v) (H1 : (map_vars map) ! id = Some r) (r' : reg) (EQ' : (map_vars map) ! id = Some r') (RS : Val.lessdef v rs # r')","proofString":"congruence."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (idx : nat) (v : val) (r : reg) (H : match_env map e le rs) (H0 : nth_error le idx = Some v) (H1 : nth_error (map_letvars map) idx = Some r) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (idx : nat) (v : val) (r : reg) (H : match_env map e le rs) (H0 : nth_error le idx = Some v) (H1 : nth_error (map_letvars map) idx = Some r)","proofString":"exploit me_letvars; eauto.\nclear H.\nrevert le H0 H1.\ngeneralize (map_letvars map).\nclear map.\ninduction idx; simpl; intros.\ninversion H; subst le; inversion H0.\nsubst v1.\ndestruct l; inversion H1.\nsubst r0.\ninversion H2.\nsubst v2.\nauto.\ndestruct l; destruct le; try discriminate.\neapply IHidx; eauto.\ninversion H.\nauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (idx : nat) (v : val) (r : reg) (H : match_env map e le rs) (H0 : nth_error le idx = Some v) (H1 : nth_error (map_letvars map) idx = Some r) : Val.lessdef_list le rs ## (map_letvars map) -> Val.lessdef v rs # r.","conclusion":"Val.lessdef_list le rs ## (map_letvars map) -> Val.lessdef v rs # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (idx : nat) (v : val) (r : reg) (H : match_env map e le rs) (H0 : nth_error le idx = Some v) (H1 : nth_error (map_letvars map) idx = Some r)","proofString":"clear H.\nrevert le H0 H1.\ngeneralize (map_letvars map).\nclear map.\ninduction idx; simpl; intros.\ninversion H; subst le; inversion H0.\nsubst v1.\ndestruct l; inversion H1.\nsubst r0.\ninversion H2.\nsubst v2.\nauto.\ndestruct l; destruct le; try discriminate.\neapply IHidx; eauto.\ninversion H.\nauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (idx : nat) (v : val) (r : reg) (H0 : nth_error le idx = Some v) (H1 : nth_error (map_letvars map) idx = Some r) : Val.lessdef_list le rs ## (map_letvars map) -> Val.lessdef v rs # r.","conclusion":"Val.lessdef_list le rs ## (map_letvars map) -> Val.lessdef v rs # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (idx : nat) (v : val) (r : reg) (H0 : nth_error le idx = Some v) (H1 : nth_error (map_letvars map) idx = Some r)","proofString":"revert le H0 H1.\ngeneralize (map_letvars map).\nclear map.\ninduction idx; simpl; intros.\ninversion H; subst le; inversion H0.\nsubst v1.\ndestruct l; inversion H1.\nsubst r0.\ninversion H2.\nsubst v2.\nauto.\ndestruct l; destruct le; try discriminate.\neapply IHidx; eauto.\ninversion H.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (le : letenv) (H0 : match le with\n| nil => None\n| x :: _ => Some x\nend = Some v) (H1 : match l with\n| nil => None\n| x :: _ => Some x\nend = Some r) (H : Val.lessdef_list le rs ## l) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (le : letenv) (H0 : match le with\n| nil => None\n| x :: _ => Some x\nend = Some v) (H1 : match l with\n| nil => None\n| x :: _ => Some x\nend = Some r) (H : Val.lessdef_list le rs ## l)","proofString":"inversion H; subst le; inversion H0.\nsubst v1.\ndestruct l; inversion H1.\nsubst r0.\ninversion H2.\nsubst v2.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (v1 : val) (H0 : Some v1 = Some v) (H1 : match l with\n| nil => None\n| x :: _ => Some x\nend = Some r) (vl1 : list val) (H : Val.lessdef_list (v1 :: vl1) rs ## l) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v1 v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## l) (H6 : v1 = v) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (v1 : val) (H0 : Some v1 = Some v) (H1 : match l with\n| nil => None\n| x :: _ => Some x\nend = Some r) (vl1 : list val) (H : Val.lessdef_list (v1 :: vl1) rs ## l) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v1 v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## l) (H6 : v1 = v)","proofString":"subst v1.\ndestruct l; inversion H1.\nsubst r0.\ninversion H2.\nsubst v2.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : match l with\n| nil => None\n| x :: _ => Some x\nend = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## l) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## l) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : match l with\n| nil => None\n| x :: _ => Some x\nend = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## l) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## l)","proofString":"destruct l; inversion H1.\nsubst r0.\ninversion H2.\nsubst v2.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r r0 : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r0 = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r0 :: l)) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## (r0 :: l)) (H6 : r0 = r) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r r0 : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r0 = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r0 :: l)) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## (r0 :: l)) (H6 : r0 = r)","proofString":"subst r0.\ninversion H2.\nsubst v2.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r :: l)) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## (r :: l)) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r :: l)) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## (r :: l))","proofString":"inversion H2.\nsubst v2.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r :: l)) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## (r :: l)) (H6 : v2 = rs # r) (H7 : vl2 = rs ## l) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r :: l)) (v2 : val) (vl2 : list val) (H3 : Val.lessdef v v2) (H5 : Val.lessdef_list vl1 vl2) (H2 : v2 :: vl2 = rs ## (r :: l)) (H6 : v2 = rs # r) (H7 : vl2 = rs ## l)","proofString":"subst v2.\nauto."},{"statement":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r :: l)) (vl2 : list val) (H3 : Val.lessdef v rs # r) (H5 : Val.lessdef_list vl1 vl2) (H2 : rs # r :: vl2 = rs ## (r :: l)) (H7 : vl2 = rs ## l) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (v : val) (r : reg) (l : list reg) (H0 : Some v = Some v) (H1 : Some r = Some r) (vl1 : list val) (H : Val.lessdef_list (v :: vl1) rs ## (r :: l)) (vl2 : list val) (H3 : Val.lessdef v rs # r) (H5 : Val.lessdef_list vl1 vl2) (H2 : rs # r :: vl2 = rs ## (r :: l)) (H7 : vl2 = rs ## l)","proofString":"auto."},{"statement":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (l : list reg) (le : letenv) (H0 : match le with\n| nil => None\n| _ :: l0 => nth_error l0 idx\nend = Some v) (H1 : match l with\n| nil => None\n| _ :: l0 => nth_error l0 idx\nend = Some r) (H : Val.lessdef_list le rs ## l) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (l : list reg) (le : letenv) (H0 : match le with\n| nil => None\n| _ :: l0 => nth_error l0 idx\nend = Some v) (H1 : match l with\n| nil => None\n| _ :: l0 => nth_error l0 idx\nend = Some r) (H : Val.lessdef_list le rs ## l)","proofString":"destruct l; destruct le; try discriminate.\neapply IHidx; eauto.\ninversion H.\nauto."},{"statement":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (r0 : reg) (l : list reg) (v0 : val) (le : list val) (H0 : nth_error le idx = Some v) (H1 : nth_error l idx = Some r) (H : Val.lessdef_list (v0 :: le) rs ## (r0 :: l)) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (r0 : reg) (l : list reg) (v0 : val) (le : list val) (H0 : nth_error le idx = Some v) (H1 : nth_error l idx = Some r) (H : Val.lessdef_list (v0 :: le) rs ## (r0 :: l))","proofString":"eapply IHidx; eauto.\ninversion H.\nauto."},{"statement":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (r0 : reg) (l : list reg) (v0 : val) (le : list val) (H0 : nth_error le idx = Some v) (H1 : nth_error l idx = Some r) (H : Val.lessdef_list (v0 :: le) rs ## (r0 :: l)) : Val.lessdef_list le rs ## l.","conclusion":"Val.lessdef_list le rs ## l","hypotheses":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (r0 : reg) (l : list reg) (v0 : val) (le : list val) (H0 : nth_error le idx = Some v) (H1 : nth_error l idx = Some r) (H : Val.lessdef_list (v0 :: le) rs ## (r0 :: l))","proofString":"inversion H.\nauto."},{"statement":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (r0 : reg) (l : list reg) (v0 : val) (le : list val) (H0 : nth_error le idx = Some v) (H1 : nth_error l idx = Some r) (H : Val.lessdef_list (v0 :: le) rs ## (r0 :: l)) (v1 v2 : val) (vl1 vl2 : list val) (H5 : Val.lessdef v0 rs # r0) (H7 : Val.lessdef_list le rs ## l) (H2 : v1 = v0) (H3 : vl1 = le) (H4 : v2 = rs # r0) (H6 : vl2 = rs ## l) : Val.lessdef_list le rs ## l.","conclusion":"Val.lessdef_list le rs ## l","hypotheses":"(e : env) (rs : regset) (idx : nat) (v : val) (r : reg) (IHidx : forall (l0 : list reg) (le0 : letenv),\nnth_error le0 idx = Some v ->\nnth_error l0 idx = Some r ->\nVal.lessdef_list le0 rs ## l0 -> Val.lessdef v rs # r) (r0 : reg) (l : list reg) (v0 : val) (le : list val) (H0 : nth_error le idx = Some v) (H1 : nth_error l idx = Some r) (H : Val.lessdef_list (v0 :: le) rs ## (r0 :: l)) (v1 v2 : val) (vl1 vl2 : list val) (H5 : Val.lessdef v0 rs # r0) (H7 : Val.lessdef_list le rs ## l) (H2 : v1 = v0) (H3 : vl1 = le) (H4 : v2 = rs # r0) (H6 : vl2 = rs ## l)","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) : match_env map e le rs'.","conclusion":"match_env map e le rs'","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r)","proofString":"inversion H.\napply mk_match_env.\nintros.\nexploit me_vars0; eauto.\nintros [r [A B]].\nexists r; split.\nauto.\nrewrite H0; auto.\nleft; exists id; auto.\nreplace (rs'##(map_letvars map)) with (rs ## (map_letvars map)).\nauto.\napply list_map_exten.\nintros.\napply H0.\nright; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : match_env map e le rs'.","conclusion":"match_env map e le rs'","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"apply mk_match_env.\nintros.\nexploit me_vars0; eauto.\nintros [r [A B]].\nexists r; split.\nauto.\nrewrite H0; auto.\nleft; exists id; auto.\nreplace (rs'##(map_letvars map)) with (rs ## (map_letvars map)).\nauto.\napply list_map_exten.\nintros.\napply H0.\nright; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs' # r.","conclusion":"forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs' # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"intros.\nexploit me_vars0; eauto.\nintros [r [A B]].\nexists r; split.\nauto.\nrewrite H0; auto.\nleft; exists id; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r : reg, (map_vars map) ! id0 = Some r /\\ Val.lessdef v0 rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) : exists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs' # r.","conclusion":"exists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs' # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r : reg, (map_vars map) ! id0 = Some r /\\ Val.lessdef v0 rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v)","proofString":"exploit me_vars0; eauto.\nintros [r [A B]].\nexists r; split.\nauto.\nrewrite H0; auto.\nleft; exists id; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r : reg, (map_vars map) ! id0 = Some r /\\ Val.lessdef v0 rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) : (exists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs' # r.","conclusion":"(exists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs' # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r : reg, (map_vars map) ! id0 = Some r /\\ Val.lessdef v0 rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v)","proofString":"intros [r [A B]].\nexists r; split.\nauto.\nrewrite H0; auto.\nleft; exists id; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r) : exists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v rs' # r0.","conclusion":"exists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v rs' # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r)","proofString":"exists r; split.\nauto.\nrewrite H0; auto.\nleft; exists id; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r) : (map_vars map) ! id = Some r.","conclusion":"(map_vars map) ! id = Some r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r)","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r) : Val.lessdef v rs' # r.","conclusion":"Val.lessdef v rs' # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r)","proofString":"rewrite H0; auto.\nleft; exists id; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r) : reg_in_map map r.","conclusion":"reg_in_map map r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = rs # r0) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id : positive) (v : val) (H1 : e ! id = Some v) (r : reg) (A : (map_vars map) ! id = Some r) (B : Val.lessdef v rs # r)","proofString":"left; exists id; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : Val.lessdef_list le rs' ## (map_letvars map).","conclusion":"Val.lessdef_list le rs' ## (map_letvars map)","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"replace (rs'##(map_letvars map)) with (rs ## (map_letvars map)).\nauto.\napply list_map_exten.\nintros.\napply H0.\nright; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : Val.lessdef_list le rs ## (map_letvars map).","conclusion":"Val.lessdef_list le rs ## (map_letvars map)","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : rs ## (map_letvars map) = rs' ## (map_letvars map).","conclusion":"rs ## (map_letvars map) = rs' ## (map_letvars map)","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"apply list_map_exten.\nintros.\napply H0.\nright; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : forall x : positive, In x (map_letvars map) -> rs' # x = rs # x.","conclusion":"forall x : positive, In x (map_letvars map) -> rs' # x = rs # x","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"intros.\napply H0.\nright; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H1 : In x (map_letvars map)) : rs' # x = rs # x.","conclusion":"rs' # x = rs # x","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H1 : In x (map_letvars map))","proofString":"apply H0.\nright; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H1 : In x (map_letvars map)) : reg_in_map map x.","conclusion":"reg_in_map map x","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (rs' : Regmap.t val) (H : match_env map e le rs) (H0 : forall r : reg, reg_in_map map r -> rs' # r = rs # r) (me_vars0 : forall (id : positive) (v : val),\ne ! id = Some v ->\nexists r : reg, (map_vars map) ! id = Some r /\\ Val.lessdef v rs # r) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H1 : In x (map_letvars map))","proofString":"right; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) : match_env map e le rs # r <- v.","conclusion":"match_env map e le rs # r <- v","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r)","proofString":"apply match_env_invariant with rs; auto.\nintros.\ncase (Reg.eq r r0); intro.\nsubst r0; contradiction.\napply Regmap.gso; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) : forall r0 : reg, reg_in_map map r0 -> (rs # r <- v) # r0 = rs # r0.","conclusion":"forall r0 : reg, reg_in_map map r0 -> (rs # r <- v) # r0 = rs # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r)","proofString":"intros.\ncase (Reg.eq r r0); intro.\nsubst r0; contradiction.\napply Regmap.gso; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) (r0 : reg) (H1 : reg_in_map map r0) : (rs # r <- v) # r0 = rs # r0.","conclusion":"(rs # r <- v) # r0 = rs # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) (r0 : reg) (H1 : reg_in_map map r0)","proofString":"case (Reg.eq r r0); intro.\nsubst r0; contradiction.\napply Regmap.gso; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) (r0 : reg) (H1 : reg_in_map map r0) (e0 : r = r0) : (rs # r <- v) # r0 = rs # r0.","conclusion":"(rs # r <- v) # r0 = rs # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) (r0 : reg) (H1 : reg_in_map map r0) (e0 : r = r0)","proofString":"subst r0; contradiction."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) (r0 : reg) (H1 : reg_in_map map r0) (n : r <> r0) : (rs # r <- v) # r0 = rs # r0.","conclusion":"(rs # r <- v) # r0 = rs # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v : val) (H : match_env map e le rs) (H0 : ~ reg_in_map map r) (r0 : reg) (H1 : reg_in_map map r0) (n : r <> r0)","proofString":"apply Regmap.gso; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) : match_env map (PTree.set id v e) le rs # r <- tv.","conclusion":"match_env map (PTree.set id v e) le rs # r <- tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs)","proofString":"inversion H0.\ninversion H2.\napply mk_match_env.\nintros id' v'.\nrewrite PTree.gsspec.\ndestruct (peq id' id); intros.\nsubst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto.\nexploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto.\nerewrite list_map_exten.\neauto.\nintros.\nsymmetry.\napply PMap.gso.\nred; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) : match_env map (PTree.set id v e) le rs # r <- tv.","conclusion":"match_env map (PTree.set id v e) le rs # r <- tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False)","proofString":"inversion H2.\napply mk_match_env.\nintros id' v'.\nrewrite PTree.gsspec.\ndestruct (peq id' id); intros.\nsubst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto.\nexploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto.\nerewrite list_map_exten.\neauto.\nintros.\nsymmetry.\napply PMap.gso.\nred; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : match_env map (PTree.set id v e) le rs # r <- tv.","conclusion":"match_env map (PTree.set id v e) le rs # r <- tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"apply mk_match_env.\nintros id' v'.\nrewrite PTree.gsspec.\ndestruct (peq id' id); intros.\nsubst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto.\nexploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto.\nerewrite list_map_exten.\neauto.\nintros.\nsymmetry.\napply PMap.gso.\nred; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : forall (id0 : positive) (v0 : val),\n(PTree.set id v e) ! id0 = Some v0 ->\nexists r0 : reg,\n  (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 (rs # r <- tv) # r0.","conclusion":"forall (id0 : positive) (v0 : val),\n(PTree.set id v e) ! id0 = Some v0 ->\nexists r0 : reg,\n  (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"intros id' v'.\nrewrite PTree.gsspec.\ndestruct (peq id' id); intros.\nsubst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto.\nexploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) : (PTree.set id v e) ! id' = Some v' ->\nexists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"(PTree.set id v e) ! id' = Some v' ->\nexists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val)","proofString":"rewrite PTree.gsspec.\ndestruct (peq id' id); intros.\nsubst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto.\nexploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) : (if peq id' id then Some v else e ! id') = Some v' ->\nexists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"(if peq id' id then Some v else e ! id') = Some v' ->\nexists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val)","proofString":"destruct (peq id' id); intros.\nsubst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto.\nexploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (e0 : id' = id) (H3 : Some v = Some v') : exists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"exists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (e0 : id' = id) (H3 : Some v = Some v')","proofString":"subst id'.\ninv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (v' : val) (H3 : Some v = Some v') : exists r0 : reg,\n  (map_vars map) ! id = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"exists r0 : reg,\n  (map_vars map) ! id = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (v' : val) (H3 : Some v = Some v')","proofString":"inv H3.\nexists r; split.\nauto.\nrewrite PMap.gss.\nauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : exists r0 : reg,\n  (map_vars map) ! id = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"exists r0 : reg,\n  (map_vars map) ! id = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"exists r; split.\nauto.\nrewrite PMap.gss.\nauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : (map_vars map) ! id = Some r.","conclusion":"(map_vars map) ! id = Some r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : Val.lessdef v' (rs # r <- tv) # r.","conclusion":"Val.lessdef v' (rs # r <- tv) # r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"rewrite PMap.gss.\nauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : Val.lessdef v' tv.","conclusion":"Val.lessdef v' tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (tv v' : val) (H : Val.lessdef v' tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v : val),\ne ! id0 = Some v ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') : exists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"exists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v')","proofString":"exploit me_vars0; eauto.\nintros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') : (exists r0 : reg, (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' rs # r0) ->\nexists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"(exists r0 : reg, (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' rs # r0) ->\nexists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v')","proofString":"intros [r' [A B]].\nexists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r') : exists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0.","conclusion":"exists r0 : reg,\n  (map_vars map) ! id' = Some r0 /\\ Val.lessdef v' (rs # r <- tv) # r0","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r')","proofString":"exists r'; split.\nauto.\nrewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r') : (map_vars map) ! id' = Some r'.","conclusion":"(map_vars map) ! id' = Some r'","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r')","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r') : Val.lessdef v' (rs # r <- tv) # r'.","conclusion":"Val.lessdef v' (rs # r <- tv) # r'","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r')","proofString":"rewrite PMap.gso; auto.\nred; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r') : r' <> r.","conclusion":"r' <> r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r')","proofString":"red; intros.\nsubst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r') (H4 : r' = r) : False.","conclusion":"False","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (r' : reg) (A : (map_vars map) ! id' = Some r') (B : Val.lessdef v' rs # r') (H4 : r' = r)","proofString":"subst r'.\nelim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (B : Val.lessdef v' rs # r) (A : (map_vars map) ! id' = Some r) : False.","conclusion":"False","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (B : Val.lessdef v' rs # r) (A : (map_vars map) ! id' = Some r)","proofString":"elim n.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (B : Val.lessdef v' rs # r) (A : (map_vars map) ! id' = Some r) : id' = id.","conclusion":"id' = id","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (id' : positive) (v' : val) (n : id' <> id) (H3 : e ! id' = Some v') (B : Val.lessdef v' rs # r) (A : (map_vars map) ! id' = Some r)","proofString":"eauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : Val.lessdef_list le (rs # r <- tv) ## (map_letvars map).","conclusion":"Val.lessdef_list le (rs # r <- tv) ## (map_letvars map)","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"erewrite list_map_exten.\neauto.\nintros.\nsymmetry.\napply PMap.gso.\nred; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map)) : (fun r0 : positive => rs # r0) x = (rs # r <- tv) # x.","conclusion":"(fun r0 : positive => rs # r0) x = (rs # r <- tv) # x","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map))","proofString":"symmetry.\napply PMap.gso.\nred; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map)) : (rs # r <- tv) # x = rs # x.","conclusion":"(rs # r <- tv) # x = rs # x","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map))","proofString":"apply PMap.gso.\nred; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map)) : x <> r.","conclusion":"x <> r","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map))","proofString":"red; intros.\nsubst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map)) (H4 : x = r) : False.","conclusion":"False","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (x : positive) (H3 : In x (map_letvars map)) (H4 : x = r)","proofString":"subst x.\neauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (H3 : In r (map_letvars map)) : False.","conclusion":"False","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (id : positive) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : (map_vars map) ! id = Some r) (H2 : match_env map e le rs) (map_wf_inj0 : forall (id1 id2 : positive) (r0 : reg),\n(map_vars map) ! id1 = Some r0 -> (map_vars map) ! id2 = Some r0 -> id1 = id2) (map_wf_disj0 : forall (id0 : positive) (r0 : reg),\n(map_vars map) ! id0 = Some r0 -> In r0 (map_letvars map) -> False) (me_vars0 : forall (id0 : positive) (v0 : val),\ne ! id0 = Some v0 ->\nexists r0 : reg, (map_vars map) ! id0 = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) (H3 : In r (map_letvars map))","proofString":"eauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (dst : option ident) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : reg_map_ok map r dst) (H2 : match_env map e le rs) : match_env map (set_optvar dst v e) le rs # r <- tv.","conclusion":"match_env map (set_optvar dst v e) le rs # r <- tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (dst : option ident) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : reg_map_ok map r dst) (H2 : match_env map e le rs)","proofString":"inv H1; simpl.\neapply match_env_update_temp; eauto.\neapply match_env_update_var; eauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (H3 : ~ reg_in_map map r) : match_env map e le rs # r <- tv.","conclusion":"match_env map e le rs # r <- tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (H3 : ~ reg_in_map map r)","proofString":"eapply match_env_update_temp; eauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (id : positive) (H3 : (map_vars map) ! id = Some r) : match_env map (PTree.set id v e) le rs # r <- tv.","conclusion":"match_env map (PTree.set id v e) le rs # r <- tv","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : reg) (v tv : val) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (id : positive) (H3 : (map_vars map) ! id = Some r)","proofString":"eapply match_env_update_var; eauto."},{"statement":"(map : mapping) (res : builtin_res ident) (v : val) (e : env) (le : letenv) (tres : builtin_res reg) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : tr_builtin_res map res tres) (H2 : match_env map e le rs) : match_env map (set_builtin_res res v e) le (regmap_setres tres tv rs).","conclusion":"match_env map (set_builtin_res res v e) le (regmap_setres tres tv rs)","hypotheses":"(map : mapping) (res : builtin_res ident) (v : val) (e : env) (le : letenv) (tres : builtin_res reg) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H1 : tr_builtin_res map res tres) (H2 : match_env map e le rs)","proofString":"inv H1; simpl.\neapply match_env_update_var; eauto.\nauto.\neapply match_env_update_temp; eauto."},{"statement":"(map : mapping) (v : val) (e : env) (le : letenv) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (id : positive) (r : reg) (H3 : (map_vars map) ! id = Some r) : match_env map (PTree.set id v e) le rs # r <- tv.","conclusion":"match_env map (PTree.set id v e) le rs # r <- tv","hypotheses":"(map : mapping) (v : val) (e : env) (le : letenv) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (id : positive) (r : reg) (H3 : (map_vars map) ! id = Some r)","proofString":"eapply match_env_update_var; eauto."},{"statement":"(map : mapping) (v : val) (e : env) (le : letenv) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) : match_env map e le rs.","conclusion":"match_env map e le rs","hypotheses":"(map : mapping) (v : val) (e : env) (le : letenv) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs)","proofString":"auto."},{"statement":"(map : mapping) (v : val) (e : env) (le : letenv) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (r : reg) (H3 : ~ reg_in_map map r) : match_env map e le rs # r <- tv.","conclusion":"match_env map e le rs # r <- tv","hypotheses":"(map : mapping) (v : val) (e : env) (le : letenv) (tv : val) (rs : regset) (H : Val.lessdef v tv) (H0 : map_wf map) (H2 : match_env map e le rs) (r : reg) (H3 : ~ reg_in_map map r)","proofString":"eapply match_env_update_temp; eauto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : positive) (v : val) (H : match_env map e le rs) (H0 : Val.lessdef v rs # r) : match_env (add_letvar map r) e (v :: le) rs.","conclusion":"match_env (add_letvar map r) e (v :: le) rs","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : positive) (v : val) (H : match_env map e le rs) (H0 : Val.lessdef v rs # r)","proofString":"inv H.\nunfold add_letvar.\napply mk_match_env; simpl; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : positive) (v : val) (H0 : Val.lessdef v rs # r) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : match_env (add_letvar map r) e (v :: le) rs.","conclusion":"match_env (add_letvar map r) e (v :: le) rs","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : positive) (v : val) (H0 : Val.lessdef v rs # r) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"unfold add_letvar.\napply mk_match_env; simpl; auto."},{"statement":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : positive) (v : val) (H0 : Val.lessdef v rs # r) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map)) : match_env {| map_vars := map_vars map; map_letvars := r :: map_letvars map |}\n  e (v :: le) rs.","conclusion":"match_env {| map_vars := map_vars map; map_letvars := r :: map_letvars map |}\n  e (v :: le) rs","hypotheses":"(map : mapping) (e : env) (le : letenv) (rs : regset) (r : positive) (v : val) (H0 : Val.lessdef v rs # r) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list le rs ## (map_letvars map))","proofString":"apply mk_match_env; simpl; auto."},{"statement":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (H : match_env {| map_vars := map_vars map; map_letvars := r :: map_letvars map |}\n  e (v :: le) rs) : match_env map e le rs.","conclusion":"match_env map e le rs","hypotheses":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (H : match_env {| map_vars := map_vars map; map_letvars := r :: map_letvars map |}\n  e (v :: le) rs)","proofString":"inv H.\nsimpl in *.\nconstructor.\nauto.\ninversion me_letvars0.\nauto."},{"statement":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg,\n  (map_vars\n     {| map_vars := map_vars map; map_letvars := r :: map_letvars map |})\n  ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le)\n  rs\n  ## (map_letvars\n        {| map_vars := map_vars map; map_letvars := r :: map_letvars map |})) : match_env map e le rs.","conclusion":"match_env map e le rs","hypotheses":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg,\n  (map_vars\n     {| map_vars := map_vars map; map_letvars := r :: map_letvars map |})\n  ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le)\n  rs\n  ## (map_letvars\n        {| map_vars := map_vars map; map_letvars := r :: map_letvars map |}))","proofString":"simpl in *.\nconstructor.\nauto.\ninversion me_letvars0.\nauto."},{"statement":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map))) : match_env map e le rs.","conclusion":"match_env map e le rs","hypotheses":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map)))","proofString":"constructor.\nauto.\ninversion me_letvars0.\nauto."},{"statement":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map))) : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0.","conclusion":"forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0","hypotheses":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map)))","proofString":"auto."},{"statement":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map))) : Val.lessdef_list le rs ## (map_letvars map).","conclusion":"Val.lessdef_list le rs ## (map_letvars map)","hypotheses":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map)))","proofString":"inversion me_letvars0.\nauto."},{"statement":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map))) (v1 v2 : val) (vl1 vl2 : list val) (H2 : Val.lessdef v rs # r) (H4 : Val.lessdef_list le rs ## (map_letvars map)) (H : v1 = v) (H0 : vl1 = le) (H1 : v2 = rs # r) (H3 : vl2 = rs ## (map_letvars map)) : Val.lessdef_list le rs ## (map_letvars map).","conclusion":"Val.lessdef_list le rs ## (map_letvars map)","hypotheses":"(map : mapping) (e : env) (le : list val) (rs : regset) (r : reg) (v : val) (me_vars0 : forall (id : positive) (v0 : val),\ne ! id = Some v0 ->\nexists r0 : reg, (map_vars map) ! id = Some r0 /\\ Val.lessdef v0 rs # r0) (me_letvars0 : Val.lessdef_list (v :: le) (rs # r :: rs ## (map_letvars map))) (v1 v2 : val) (vl1 vl2 : list val) (H2 : Val.lessdef v rs # r) (H4 : Val.lessdef_list le rs ## (map_letvars map)) (H : v1 = v) (H0 : vl1 = le) (H1 : v2 = rs # r) (H3 : vl2 = rs ## (map_letvars map))","proofString":"auto."},{"statement":"(map : mapping) (H : map_letvars map = nil) : match_env map (PTree.empty val) nil (Regmap.init Vundef).","conclusion":"match_env map (PTree.empty val) nil (Regmap.init Vundef)","hypotheses":"(map : mapping) (H : map_letvars map = nil)","proofString":"apply mk_match_env.\nintros.\nrewrite PTree.gempty in H0.\ndiscriminate.\nrewrite H.\nconstructor."},{"statement":"(map : mapping) (H : map_letvars map = nil) : forall (id : positive) (v : val),\n(PTree.empty val) ! id = Some v ->\nexists r : reg,\n  (map_vars map) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"forall (id : positive) (v : val),\n(PTree.empty val) ! id = Some v ->\nexists r : reg,\n  (map_vars map) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(map : mapping) (H : map_letvars map = nil)","proofString":"intros.\nrewrite PTree.gempty in H0.\ndiscriminate."},{"statement":"(map : mapping) (H : map_letvars map = nil) (id : positive) (v : val) (H0 : (PTree.empty val) ! id = Some v) : exists r : reg,\n  (map_vars map) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"exists r : reg,\n  (map_vars map) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(map : mapping) (H : map_letvars map = nil) (id : positive) (v : val) (H0 : (PTree.empty val) ! id = Some v)","proofString":"rewrite PTree.gempty in H0.\ndiscriminate."},{"statement":"(map : mapping) (H : map_letvars map = nil) (id : positive) (v : val) (H0 : None = Some v) : exists r : reg,\n  (map_vars map) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"exists r : reg,\n  (map_vars map) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(map : mapping) (H : map_letvars map = nil) (id : positive) (v : val) (H0 : None = Some v)","proofString":"discriminate."},{"statement":"(map : mapping) (H : map_letvars map = nil) : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars map).","conclusion":"Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars map)","hypotheses":"(map : mapping) (H : map_letvars map = nil)","proofString":"rewrite H.\nconstructor."},{"statement":"(map : mapping) (H : map_letvars map = nil) : Val.lessdef_list nil (Regmap.init Vundef) ## nil.","conclusion":"Val.lessdef_list nil (Regmap.init Vundef) ## nil","hypotheses":"(map : mapping) (H : map_letvars map = nil)","proofString":"constructor."},{"statement":"(rl : list reg) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H : add_vars init_mapping nil s1 = OK (rl, map2) s2 i) (H0 : Val.lessdef_list vl tvl) : match_env map2 (set_params vl nil) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl rl) # r = Vundef).","conclusion":"match_env map2 (set_params vl nil) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl rl) # r = Vundef)","hypotheses":"(rl : list reg) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H : add_vars init_mapping nil s1 = OK (rl, map2) s2 i) (H0 : Val.lessdef_list vl tvl)","proofString":"inv H.\nsplit.\napply match_env_empty.\nauto.\nintros.\nsimpl.\napply Regmap.gi."},{"statement":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) : match_env init_mapping (set_params vl nil) nil (init_regs tvl nil) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl nil) # r = Vundef).","conclusion":"match_env init_mapping (set_params vl nil) nil (init_regs tvl nil) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl nil) # r = Vundef)","hypotheses":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl)","proofString":"split.\napply match_env_empty.\nauto.\nintros.\nsimpl.\napply Regmap.gi."},{"statement":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) : match_env init_mapping (set_params vl nil) nil (init_regs tvl nil).","conclusion":"match_env init_mapping (set_params vl nil) nil (init_regs tvl nil)","hypotheses":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl)","proofString":"apply match_env_empty.\nauto."},{"statement":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) : map_letvars init_mapping = nil.","conclusion":"map_letvars init_mapping = nil","hypotheses":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl)","proofString":"auto."},{"statement":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) : forall r : reg, reg_fresh r s2 -> (init_regs tvl nil) # r = Vundef.","conclusion":"forall r : reg, reg_fresh r s2 -> (init_regs tvl nil) # r = Vundef","hypotheses":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl)","proofString":"intros.\nsimpl.\napply Regmap.gi."},{"statement":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) (r : reg) (H : reg_fresh r s2) : (init_regs tvl nil) # r = Vundef.","conclusion":"(init_regs tvl nil) # r = Vundef","hypotheses":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) (r : reg) (H : reg_fresh r s2)","proofString":"simpl.\napply Regmap.gi."},{"statement":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) (r : reg) (H : reg_fresh r s2) : (Regmap.init Vundef) # r = Vundef.","conclusion":"(Regmap.init Vundef) # r = Vundef","hypotheses":"(s2 : state) (vl tvl : list val) (i : state_incr s2 s2) (H0 : Val.lessdef_list vl tvl) (r : reg) (H : reg_fresh r s2)","proofString":"apply Regmap.gi."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl0 : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl0, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl0) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl0) # r = Vundef)) (rl : list reg) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H : add_vars init_mapping (a :: il) s1 = OK (rl, map2) s2 i) (H0 : Val.lessdef_list vl tvl) : match_env map2 (set_params vl (a :: il)) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl rl) # r = Vundef).","conclusion":"match_env map2 (set_params vl (a :: il)) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl rl) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl0 : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl0, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl0) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl0) # r = Vundef)) (rl : list reg) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H : add_vars init_mapping (a :: il) s1 = OK (rl, map2) s2 i) (H0 : Val.lessdef_list vl tvl)","proofString":"monadInv H.\nsimpl.\nexploit add_vars_valid; eauto.\napply init_mapping_valid.\nintros [A B].\nexploit add_var_valid; eauto.\nintros [A' B'].\nclear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : match_env map2 (set_params vl (a :: il)) nil (init_regs tvl (x1 :: x)) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl (x1 :: x)) # r = Vundef).","conclusion":"match_env map2 (set_params vl (a :: il)) nil (init_regs tvl (x1 :: x)) /\\\n(forall r : reg, reg_fresh r s2 -> (init_regs tvl (x1 :: x)) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"simpl.\nexploit add_vars_valid; eauto.\napply init_mapping_valid.\nintros [A B].\nexploit add_var_valid; eauto.\nintros [A' B'].\nclear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"exploit add_vars_valid; eauto.\napply init_mapping_valid.\nintros [A B].\nexploit add_var_valid; eauto.\nintros [A' B'].\nclear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : map_valid init_mapping s1.","conclusion":"map_valid init_mapping s1","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"apply init_mapping_valid."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : regs_valid x s /\\ map_valid x0 s ->\nmatch_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"regs_valid x s /\\ map_valid x0 s ->\nmatch_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"intros [A B].\nexploit add_var_valid; eauto.\nintros [A' B'].\nclear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) : match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s)","proofString":"exploit add_var_valid; eauto.\nintros [A' B'].\nclear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) : reg_valid x1 s2 /\\ map_valid map2 s2 ->\nmatch_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"reg_valid x1 s2 /\\ map_valid map2 s2 ->\nmatch_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s)","proofString":"intros [A' B'].\nclear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (B' : map_valid map2 s2) : match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (B' : map_valid map2 s2)","proofString":"clear B'.\nmonadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) : match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"match_env map2\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map0 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map0) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map0 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 : state) (map2 : mapping) (s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2)","proofString":"monadInv EQ1.\ndestruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map2 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |}\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |}\n  match vl with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end nil\n  match tvl with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs x) # x1 <- v1\n  end /\\\n(forall r : reg,\n reg_fresh r s2 ->\n match tvl with\n | nil => Regmap.init Vundef\n | v1 :: vs => (init_regs vs x) # x1 <- v1\n end # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl0 tvl0 : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl0 tvl0 ->\nmatch_env map2 (set_params vl0 il) nil (init_regs tvl0 rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl0 rl) # r = Vundef)) (s1 s2 : state) (vl tvl : list val) (i : state_incr s1 s2) (H0 : Val.lessdef_list vl tvl) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"destruct H0 as [ | v1 tv1 vs tvs].\ndestruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi.\ndestruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef) /\\\n(forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef) /\\\n(forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"destruct (IHil _ _ _ _ nil nil _ EQ) as [ME UNDEF].\nconstructor.\ninv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"constructor."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (ME : match_env x0 (set_params nil il) nil (init_regs nil x)) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef) /\\\n(forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef) /\\\n(forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (ME : match_env x0 (set_params nil il) nil (init_regs nil x)) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef)","proofString":"inv ME.\nsplit.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0)) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef) /\\\n(forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef) /\\\n(forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0))","proofString":"split.\nreplace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity.\nintros.\napply Regmap.gi."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0)) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0))","proofString":"replace (init_regs nil x) with (Regmap.init Vundef) in me_vars0, me_letvars0.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto.\ndestruct x; reflexivity."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_params nil il)) nil \n  (Regmap.init Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0))","proofString":"constructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto.\neauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) : forall (id : positive) (v : val),\n(PTree.set a Vundef (set_params nil il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"forall (id : positive) (v : val),\n(PTree.set a Vundef (set_params nil il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0))","proofString":"intros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) : (PTree.set a Vundef (set_params nil il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"(PTree.set a Vundef (set_params nil il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"repeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) : (if peq id a then Some Vundef else (set_params nil il) ! id) = Some v ->\nexists r : reg,\n  (if peq id a then Some x1 else (map_vars x0) ! id) = Some r /\\\n  Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"(if peq id a then Some Vundef else (set_params nil il) ! id) = Some v ->\nexists r : reg,\n  (if peq id a then Some x1 else (map_vars x0) ! id) = Some r /\\\n  Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"destruct (peq id a); intros.\nsubst a.\ninv H.\nexists x1; split.\nauto.\nconstructor.\neauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) (e : id = a) (H : Some Vundef = Some v) : exists r : reg, Some x1 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"exists r : reg, Some x1 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) (e : id = a) (H : Some Vundef = Some v)","proofString":"subst a.\ninv H.\nexists x1; split.\nauto.\nconstructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) (H : Some Vundef = Some v) : exists r : reg, Some x1 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"exists r : reg, Some x1 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) (H : Some Vundef = Some v)","proofString":"inv H.\nexists x1; split.\nauto.\nconstructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params nil il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef Vundef (Regmap.init Vundef) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef Vundef (Regmap.init Vundef) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params nil il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive)","proofString":"exists x1; split.\nauto.\nconstructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params nil il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) : Some x1 = Some x1.","conclusion":"Some x1 = Some x1","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params nil il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive)","proofString":"auto."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params nil il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) : Val.lessdef Vundef (Regmap.init Vundef) # x1.","conclusion":"Val.lessdef Vundef (Regmap.init Vundef) # x1","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params nil il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive)","proofString":"constructor."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H : (set_params nil il) ! id = Some v) : exists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r.","conclusion":"exists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params nil il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H : (set_params nil il) ! id = Some v)","proofString":"eauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)) : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0).","conclusion":"Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (Regmap.init Vundef) # r) (me_letvars0 : Val.lessdef_list nil (Regmap.init Vundef) ## (map_letvars x0))","proofString":"eauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0)) : Regmap.init Vundef = init_regs nil x.","conclusion":"Regmap.init Vundef = init_regs nil x","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0))","proofString":"destruct x; reflexivity."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0)) : forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef.","conclusion":"forall r : reg, reg_fresh r s2 -> (Regmap.init Vundef) # r = Vundef","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs nil x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs nil x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0))","proofString":"intros.\napply Regmap.gi."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs nil x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs nil x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0)) (r : reg) (H : reg_fresh r s2) : (Regmap.init Vundef) # r = Vundef.","conclusion":"(Regmap.init Vundef) # r = Vundef","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs nil x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params nil il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs nil x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs nil x) ## (map_letvars x0)) (r : reg) (H : reg_fresh r s2)","proofString":"apply Regmap.gi."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1 /\\\n(forall r : reg,\n reg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1 /\\\n(forall r : reg,\n reg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"destruct (IHil _ _ _ _ _ _ _ EQ H0) as [ME UNDEF].\ninv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (ME : match_env x0 (set_params vs il) nil (init_regs tvs x)) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1 /\\\n(forall r : reg,\n reg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1 /\\\n(forall r : reg,\n reg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (ME : match_env x0 (set_params vs il) nil (init_regs tvs x)) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef)","proofString":"inv ME.\nsplit.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1 /\\\n(forall r : reg,\n reg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef).","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1 /\\\n(forall r : reg,\n reg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0))","proofString":"split.\nconstructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0.\nintros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1.","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a v1 (set_params vs il)) nil (init_regs tvs x) # x1 <- tv1","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0))","proofString":"constructor; simpl.\nintros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg.\ndestruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) : forall (id : positive) (v : val),\n(PTree.set a v1 (set_params vs il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"forall (id : positive) (v : val),\n(PTree.set a v1 (set_params vs il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0))","proofString":"intros id v.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) : (PTree.set a v1 (set_params vs il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"(PTree.set a v1 (set_params vs il)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"repeat rewrite PTree.gsspec.\ndestruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) : (if peq id a then Some v1 else (set_params vs il) ! id) = Some v ->\nexists r : reg,\n  (if peq id a then Some x1 else (map_vars x0) ! id) = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"(if peq id a then Some v1 else (set_params vs il) ! id) = Some v ->\nexists r : reg,\n  (if peq id a then Some x1 else (map_vars x0) ! id) = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"destruct (peq id a); intros.\nsubst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto.\nexploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (e : id = a) (H1 : Some v1 = Some v) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (e : id = a) (H1 : Some v1 = Some v)","proofString":"subst a.\ninv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (H1 : Some v1 = Some v) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (H1 : Some v1 = Some v)","proofString":"inv H.\ninv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor.\ninv H1.\neexists; eauto."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (tv1 : val) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (H1 : Some tv1 = Some v) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (tv1 : val) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (H1 : Some tv1 = Some v)","proofString":"inv H1.\nexists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- v) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- v) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"exists x1; split.\nauto.\nrewrite Regmap.gss.\nconstructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) : Some x1 = Some x1.","conclusion":"Some x1 = Some x1","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"auto."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) : Val.lessdef v ((init_regs tvs x) # x1 <- v) # x1.","conclusion":"Val.lessdef v ((init_regs tvs x) # x1 <- v) # x1","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"rewrite Regmap.gss.\nconstructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) : Val.lessdef v v.","conclusion":"Val.lessdef v v","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val)","proofString":"constructor."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (tv1 : val) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (H1 : Some Vundef = Some v) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (tv1 : val) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (H1 : Some Vundef = Some v)","proofString":"inv H1.\neexists; eauto."},{"statement":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (tv1 : val) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params vs il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) : exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef Vundef ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  Some x1 = Some r /\\ Val.lessdef Vundef ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (tv1 : val) (vs tvs : list val) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v : val),\n(set_params vs il) ! id0 = Some v ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive)","proofString":"eexists; eauto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) : exists r : reg,\n  (map_vars x0) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  (map_vars x0) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v)","proofString":"exploit me_vars0; eauto.\nintros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) : (exists r : reg,\n   (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"(exists r : reg,\n   (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v)","proofString":"intros [r' [C D]].\nexists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : exists r : reg,\n  (map_vars x0) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r.","conclusion":"exists r : reg,\n  (map_vars x0) ! id = Some r /\\\n  Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"exists r'; split.\nauto.\nrewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : (map_vars x0) ! id = Some r'.","conclusion":"(map_vars x0) ! id = Some r'","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r'.","conclusion":"Val.lessdef v ((init_regs tvs x) # x1 <- tv1) # r'","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"rewrite Regmap.gso.\nauto.\napply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : Val.lessdef v (init_regs tvs x) # r'.","conclusion":"Val.lessdef v (init_regs tvs x) # r'","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : r' <> x1.","conclusion":"r' <> x1","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"apply valid_fresh_different with s.\napply B.\nleft; exists id; auto.\neauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : reg_valid r' s.","conclusion":"reg_valid r' s","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"apply B.\nleft; exists id; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : reg_in_map x0 r'.","conclusion":"reg_in_map x0 r'","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"left; exists id; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r') : reg_fresh x1 s.","conclusion":"reg_fresh x1 s","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id0 : positive) (v0 : val),\n(set_params vs il) ! id0 = Some v0 ->\nexists r : reg,\n  (map_vars x0) ! id0 = Some r /\\ Val.lessdef v0 (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (id : positive) (v : val) (n : id <> a) (H1 : (set_params vs il) ! id = Some v) (r' : reg) (C : (map_vars x0) ! id = Some r') (D : Val.lessdef v (init_regs tvs x) # r')","proofString":"eauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) : Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## (map_letvars x0).","conclusion":"Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## (map_letvars x0)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0))","proofString":"destruct (map_letvars x0).\nauto.\nsimpl in me_letvars0.\ninversion me_letvars0."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## nil) : Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## nil.","conclusion":"Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## nil","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## nil)","proofString":"auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (r : reg) (l : list reg) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (r :: l)) : Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## (r :: l).","conclusion":"Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## (r :: l)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (r : reg) (l : list reg) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (r :: l))","proofString":"simpl in me_letvars0.\ninversion me_letvars0."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (r : reg) (l : list reg) (me_letvars0 : Val.lessdef_list nil ((init_regs tvs x) # r :: (init_regs tvs x) ## l)) : Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## (r :: l).","conclusion":"Val.lessdef_list nil ((init_regs tvs x) # x1 <- tv1) ## (r :: l)","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (r : reg) (l : list reg) (me_letvars0 : Val.lessdef_list nil ((init_regs tvs x) # r :: (init_regs tvs x) ## l))","proofString":"inversion me_letvars0."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) : forall r : reg,\nreg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef.","conclusion":"forall r : reg,\nreg_fresh r s2 -> ((init_regs tvs x) # x1 <- tv1) # r = Vundef","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r : reg, reg_fresh r s3 -> (init_regs tvl rl) # r = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r : reg, reg_fresh r s -> (init_regs tvs x) # r = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r : reg,\n  (map_vars x0) ! id = Some r /\\ Val.lessdef v (init_regs tvs x) # r) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0))","proofString":"intros.\nrewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2) : ((init_regs tvs x) # x1 <- tv1) # r = Vundef.","conclusion":"((init_regs tvs x) # x1 <- tv1) # r = Vundef","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2)","proofString":"rewrite Regmap.gso.\napply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg.\napply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2) : (init_regs tvs x) # r = Vundef.","conclusion":"(init_regs tvs x) # r = Vundef","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2)","proofString":"apply UNDEF.\napply reg_fresh_decr with s2; eauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2) : reg_fresh r s.","conclusion":"reg_fresh r s","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2)","proofString":"apply reg_fresh_decr with s2; eauto with rtlg."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2) : r <> x1.","conclusion":"r <> x1","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2)","proofString":"apply not_eq_sym.\napply valid_fresh_different with s2; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2) : x1 <> r.","conclusion":"x1 <> r","hypotheses":"(a : ident) (il : list ident) (IHil : forall (rl : list reg) (s0 : state) (map2 : mapping) \n  (s3 : state) (vl tvl : list val) (i0 : state_incr s0 s3),\nadd_vars init_mapping il s0 = OK (rl, map2) s3 i0 ->\nVal.lessdef_list vl tvl ->\nmatch_env map2 (set_params vl il) nil (init_regs tvl rl) /\\\n(forall r0 : reg, reg_fresh r0 s3 -> (init_regs tvl rl) # r0 = Vundef)) (s1 s2 : state) (i : state_incr s1 s2) (v1 tv1 : val) (vs tvs : list val) (H : Val.lessdef v1 tv1) (H0 : Val.lessdef_list vs tvs) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars init_mapping il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (A : regs_valid x s) (B : map_valid x0 s) (A' : reg_valid x1 s2) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (UNDEF : forall r0 : reg, reg_fresh r0 s -> (init_regs tvs x) # r0 = Vundef) (me_vars0 : forall (id : positive) (v : val),\n(set_params vs il) ! id = Some v ->\nexists r0 : reg,\n  (map_vars x0) ! id = Some r0 /\\ Val.lessdef v (init_regs tvs x) # r0) (me_letvars0 : Val.lessdef_list nil (init_regs tvs x) ## (map_letvars x0)) (r : reg) (H1 : reg_fresh r s2)","proofString":"apply valid_fresh_different with s2; auto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (rl : list reg) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (H2 : ret (nil, map1) s1 = OK (rl, map2) s2 i) : match_env map2 e le rs.","conclusion":"match_env map2 e le rs","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (rl : list reg) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (H2 : ret (nil, map1) s1 = OK (rl, map2) s2 i)","proofString":"inv H2.\nauto."},{"statement":"(map2 : mapping) (H : map_wf map2) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s2 s2) (H0 : match_env map2 e le rs) (H1 : forall r : reg, reg_fresh r s2 -> rs # r = Vundef) : match_env map2 e le rs.","conclusion":"match_env map2 e le rs","hypotheses":"(map2 : mapping) (H : map_wf map2) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s2 s2) (H0 : match_env map2 e le rs) (H1 : forall r : reg, reg_fresh r s2 -> rs # r = Vundef)","proofString":"auto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl0 : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl0, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (rl : list reg) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (H2 : (do (rl0, map0)<- add_vars map1 il;\n do (r1, map3)<- add_var map0 a; ret (r1 :: rl0, map3)) s1 =\nOK (rl, map2) s2 i) : match_env map2 (PTree.set a Vundef (set_locals il e)) le rs.","conclusion":"match_env map2 (PTree.set a Vundef (set_locals il e)) le rs","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl0 : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl0, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (rl : list reg) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (H2 : (do (rl0, map0)<- add_vars map1 il;\n do (r1, map3)<- add_var map0 a; ret (r1 :: rl0, map3)) s1 =\nOK (rl, map2) s2 i)","proofString":"monadInv H2.\nexploit IHil; eauto.\nintro.\nmonadInv EQ1.\nconstructor.\nintros id v.\nsimpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto.\nsimpl.\neapply me_letvars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : match_env map2 (PTree.set a Vundef (set_locals il e)) le rs.","conclusion":"match_env map2 (PTree.set a Vundef (set_locals il e)) le rs","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"exploit IHil; eauto.\nintro.\nmonadInv EQ1.\nconstructor.\nintros id v.\nsimpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto.\nsimpl.\neapply me_letvars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) : match_env x0 (set_locals il e) le rs ->\nmatch_env map2 (PTree.set a Vundef (set_locals il e)) le rs.","conclusion":"match_env x0 (set_locals il e) le rs ->\nmatch_env map2 (PTree.set a Vundef (set_locals il e)) le rs","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2)","proofString":"intro.\nmonadInv EQ1.\nconstructor.\nintros id v.\nsimpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto.\nsimpl.\neapply me_letvars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) : match_env map2 (PTree.set a Vundef (set_locals il e)) le rs.","conclusion":"match_env map2 (PTree.set a Vundef (set_locals il e)) le rs","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map0 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map0) s0 i0 ->\nmatch_env map0 (set_locals il e0) le0 rs0) (map2 : mapping) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (EQ1 : add_var x0 a s = OK (x1, map2) s2 INCR1) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs)","proofString":"monadInv EQ1.\nconstructor.\nintros id v.\nsimpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto.\nsimpl.\neapply me_letvars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_locals il e)) le rs.","conclusion":"match_env\n  {|\n    map_vars := PTree.set a x1 (map_vars x0); map_letvars := map_letvars x0\n  |} (PTree.set a Vundef (set_locals il e)) le rs","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"constructor.\nintros id v.\nsimpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto.\nsimpl.\neapply me_letvars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : forall (id : positive) (v : val),\n(PTree.set a Vundef (set_locals il e)) ! id = Some v ->\nexists r : reg,\n  (map_vars\n     {|\n       map_vars := PTree.set a x1 (map_vars x0);\n       map_letvars := map_letvars x0\n     |}) ! id = Some r /\\ Val.lessdef v rs # r.","conclusion":"forall (id : positive) (v : val),\n(PTree.set a Vundef (set_locals il e)) ! id = Some v ->\nexists r : reg,\n  (map_vars\n     {|\n       map_vars := PTree.set a x1 (map_vars x0);\n       map_letvars := map_letvars x0\n     |}) ! id = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"intros id v.\nsimpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) : (PTree.set a Vundef (set_locals il e)) ! id = Some v ->\nexists r : reg,\n  (map_vars\n     {|\n       map_vars := PTree.set a x1 (map_vars x0);\n       map_letvars := map_letvars x0\n     |}) ! id = Some r /\\ Val.lessdef v rs # r.","conclusion":"(PTree.set a Vundef (set_locals il e)) ! id = Some v ->\nexists r : reg,\n  (map_vars\n     {|\n       map_vars := PTree.set a x1 (map_vars x0);\n       map_letvars := map_letvars x0\n     |}) ! id = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val)","proofString":"simpl.\nrepeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) : (PTree.set a Vundef (set_locals il e)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\ Val.lessdef v rs # r.","conclusion":"(PTree.set a Vundef (set_locals il e)) ! id = Some v ->\nexists r : reg,\n  (PTree.set a x1 (map_vars x0)) ! id = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val)","proofString":"repeat rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) : (if peq id a then Some Vundef else (set_locals il e) ! id) = Some v ->\nexists r : reg,\n  (if peq id a then Some x1 else (map_vars x0) ! id) = Some r /\\\n  Val.lessdef v rs # r.","conclusion":"(if peq id a then Some Vundef else (set_locals il e) ! id) = Some v ->\nexists r : reg,\n  (if peq id a then Some x1 else (map_vars x0) ! id) = Some r /\\\n  Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val)","proofString":"destruct (peq id a).\nsubst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor.\neauto with rtlg.\nintros.\neapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e1 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e1 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e1) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (e0 : id = a) : Some Vundef = Some v ->\nexists r : reg, Some x1 = Some r /\\ Val.lessdef v rs # r.","conclusion":"Some Vundef = Some v ->\nexists r : reg, Some x1 = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e1 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e1 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e1) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (e0 : id = a)","proofString":"subst a.\nintro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) : Some Vundef = Some v ->\nexists r : reg, Some x1 = Some r /\\ Val.lessdef v rs # r.","conclusion":"Some Vundef = Some v ->\nexists r : reg, Some x1 = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val)","proofString":"intro.\nexists x1.\nsplit.\nauto.\ninv H3.\nconstructor."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v) : exists r : reg, Some x1 = Some r /\\ Val.lessdef v rs # r.","conclusion":"exists r : reg, Some x1 = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v)","proofString":"exists x1.\nsplit.\nauto.\ninv H3.\nconstructor."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v) : Some x1 = Some x1 /\\ Val.lessdef v rs # x1.","conclusion":"Some x1 = Some x1 /\\ Val.lessdef v rs # x1","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v)","proofString":"split.\nauto.\ninv H3.\nconstructor."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v) : Some x1 = Some x1.","conclusion":"Some x1 = Some x1","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v)","proofString":"auto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v) : Val.lessdef v rs # x1.","conclusion":"Val.lessdef v rs # x1","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (H3 : Some Vundef = Some v)","proofString":"inv H3.\nconstructor."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) : Val.lessdef Vundef rs # x1.","conclusion":"Val.lessdef Vundef rs # x1","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive)","proofString":"constructor."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (n : id <> a) : (set_locals il e) ! id = Some v ->\nexists r : reg, (map_vars x0) ! id = Some r /\\ Val.lessdef v rs # r.","conclusion":"(set_locals il e) ! id = Some v ->\nexists r : reg, (map_vars x0) ! id = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (n : id <> a)","proofString":"eauto with rtlg.\nintros.\neapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (n : id <> a) : (set_locals il e) ! id = Some v ->\nexists r : reg, (map_vars x0) ! id = Some r /\\ Val.lessdef v rs # r.","conclusion":"(set_locals il e) ! id = Some v ->\nexists r : reg, (map_vars x0) ! id = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (n : id <> a)","proofString":"intros.\neapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (n : id <> a) (H3 : (set_locals il e) ! id = Some v) : exists r : reg, (map_vars x0) ! id = Some r /\\ Val.lessdef v rs # r.","conclusion":"exists r : reg, (map_vars x0) ! id = Some r /\\ Val.lessdef v rs # r","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) (id : positive) (v : val) (n : id <> a) (H3 : (set_locals il e) ! id = Some v)","proofString":"eapply me_vars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : Val.lessdef_list le\n  rs\n  ## (map_letvars\n        {|\n          map_vars := PTree.set a x1 (map_vars x0);\n          map_letvars := map_letvars x0\n        |}).","conclusion":"Val.lessdef_list le\n  rs\n  ## (map_letvars\n        {|\n          map_vars := PTree.set a x1 (map_vars x0);\n          map_letvars := map_letvars x0\n        |})","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"simpl.\neapply me_letvars; eauto."},{"statement":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2) : Val.lessdef_list le rs ## (map_letvars x0).","conclusion":"Val.lessdef_list le rs ## (map_letvars x0)","hypotheses":"(map1 : mapping) (s1 : state) (H : map_wf map1) (a : ident) (il : list ident) (IHil : forall (rl : list reg) (map2 : mapping) (s0 : state) \n  (e0 : env) (le0 : letenv) (rs0 : regset) (i0 : state_incr s1 s0),\nmatch_env map1 e0 le0 rs0 ->\n(forall r : reg, reg_fresh r s1 -> rs0 # r = Vundef) ->\nadd_vars map1 il s1 = OK (rl, map2) s0 i0 ->\nmatch_env map2 (set_locals il e0) le0 rs0) (s2 : state) (e : env) (le : letenv) (rs : regset) (i : state_incr s1 s2) (H0 : match_env map1 e le rs) (H1 : forall r : reg, reg_fresh r s1 -> rs # r = Vundef) (x : list reg) (x0 : mapping) (s : state) (INCR : state_incr s1 s) (INCR0 : state_incr s s2) (EQ : add_vars map1 il s1 = OK (x, x0) s INCR) (x1 : reg) (INCR1 : state_incr s s2) (INCR2 : state_incr s2 s2) (H2 : match_env x0 (set_locals il e) le rs) (INCR3 : state_incr s s2) (EQ0 : new_reg s = OK x1 s2 INCR3) (INCR4 : state_incr s2 s2)","proofString":"eapply me_letvars; eauto."},{"statement":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) : match_env map2 (set_locals vars (set_params vparams params)) nil\n  (init_regs tvparams rparams).","conclusion":"match_env map2 (set_locals vars (set_params vparams params)) nil\n  (init_regs tvparams rparams)","hypotheses":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams)","proofString":"exploit match_set_params_init_regs; eauto.\nintros [A B].\neapply match_set_locals; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\napply init_mapping_valid."},{"statement":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams) /\\\n(forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef) ->\nmatch_env map2 (set_locals vars (set_params vparams params)) nil\n  (init_regs tvparams rparams).","conclusion":"match_env map1 (set_params vparams params) nil (init_regs tvparams rparams) /\\\n(forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef) ->\nmatch_env map2 (set_locals vars (set_params vparams params)) nil\n  (init_regs tvparams rparams)","hypotheses":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams)","proofString":"intros [A B].\neapply match_set_locals; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\napply init_mapping_valid."},{"statement":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef) : match_env map2 (set_locals vars (set_params vparams params)) nil\n  (init_regs tvparams rparams).","conclusion":"match_env map2 (set_locals vars (set_params vparams params)) nil\n  (init_regs tvparams rparams)","hypotheses":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef)","proofString":"eapply match_set_locals; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\napply init_mapping_valid."},{"statement":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef) : map_wf map1.","conclusion":"map_wf map1","hypotheses":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef)","proofString":"eapply add_vars_wf; eauto.\napply init_mapping_wf.\napply init_mapping_valid."},{"statement":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef) : map_wf init_mapping.","conclusion":"map_wf init_mapping","hypotheses":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef)","proofString":"apply init_mapping_wf."},{"statement":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef) : map_valid init_mapping s0.","conclusion":"map_valid init_mapping s0","hypotheses":"(params : list ident) (s0 : state) (rparams : list reg) (map1 : mapping) (s1 : state) (i1 : state_incr s0 s1) (vars : list ident) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (vparams tvparams : list val) (H : add_vars init_mapping params s0 = OK (rparams, map1) s1 i1) (H0 : add_vars map1 vars s1 = OK (rvars, map2) s2 i2) (H1 : Val.lessdef_list vparams tvparams) (A : match_env map1 (set_params vparams params) nil (init_regs tvparams rparams)) (B : forall r : reg, reg_fresh r s1 -> (init_regs tvparams rparams) # r = Vundef)","proofString":"apply init_mapping_valid."},{"statement":"(p : CminorSel.program) (tp : program) (H : transl_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : CminorSel.program) (tp : program) (H : transl_program p = OK tp)","proofString":"apply match_transform_partial_program; auto."},{"statement":"(f : CminorSel.fundef) (tf : fundef) : transl_fundef f = OK tf -> funsig tf = CminorSel.funsig f.","conclusion":"transl_fundef f = OK tf -> funsig tf = CminorSel.funsig f","hypotheses":"(f : CminorSel.fundef) (tf : fundef)","proofString":"unfold transl_fundef, transf_partial_fundef.\ncase f; intro.\nunfold transl_function.\ncase (transl_fun f0 (init_state)); simpl; intros.\ndiscriminate.\ndestruct p.\nsimpl in H.\ninversion H.\nreflexivity.\nintro.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) : match f with\n| Internal f0 =>\n    bind (transl_function f0) (fun f' : function => OK (Internal f'))\n| External ef => OK (External ef)\nend = OK tf -> funsig tf = CminorSel.funsig f.","conclusion":"match f with\n| Internal f0 =>\n    bind (transl_function f0) (fun f' : function => OK (Internal f'))\n| External ef => OK (External ef)\nend = OK tf -> funsig tf = CminorSel.funsig f","hypotheses":"(f : CminorSel.fundef) (tf : fundef)","proofString":"case f; intro.\nunfold transl_function.\ncase (transl_fun f0 (init_state)); simpl; intros.\ndiscriminate.\ndestruct p.\nsimpl in H.\ninversion H.\nreflexivity.\nintro.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) : bind (transl_function f0) (fun f' : function => OK (Internal f')) = OK tf ->\nfunsig tf = CminorSel.funsig (Internal f0).","conclusion":"bind (transl_function f0) (fun f' : function => OK (Internal f')) = OK tf ->\nfunsig tf = CminorSel.funsig (Internal f0)","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function)","proofString":"unfold transl_function.\ncase (transl_fun f0 (init_state)); simpl; intros.\ndiscriminate.\ndestruct p.\nsimpl in H.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) : bind\n  match transl_fun f0 init_state with\n  | RTLgen.Error msg => Error msg\n  | RTLgen.OK (nentry, rparams) s _ =>\n      OK\n        {|\n          fn_sig := CminorSel.fn_sig f0;\n          fn_params := rparams;\n          fn_stacksize := fn_stackspace f0;\n          fn_code := st_code s;\n          fn_entrypoint := nentry\n        |}\n  end (fun f' : function => OK (Internal f')) = OK tf ->\nfunsig tf = CminorSel.funsig (Internal f0).","conclusion":"bind\n  match transl_fun f0 init_state with\n  | RTLgen.Error msg => Error msg\n  | RTLgen.OK (nentry, rparams) s _ =>\n      OK\n        {|\n          fn_sig := CminorSel.fn_sig f0;\n          fn_params := rparams;\n          fn_stacksize := fn_stackspace f0;\n          fn_code := st_code s;\n          fn_entrypoint := nentry\n        |}\n  end (fun f' : function => OK (Internal f')) = OK tf ->\nfunsig tf = CminorSel.funsig (Internal f0)","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function)","proofString":"case (transl_fun f0 (init_state)); simpl; intros.\ndiscriminate.\ndestruct p.\nsimpl in H.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (e : errmsg) (H : Error e = OK tf) : funsig tf = CminorSel.fn_sig f0.","conclusion":"funsig tf = CminorSel.fn_sig f0","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (e : errmsg) (H : Error e = OK tf)","proofString":"discriminate."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (p : node * list reg) (s' : state) (s : state_incr init_state s') (H : bind\n  (let (nentry, rparams) := p in\n   OK\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := rparams;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := nentry\n     |}) (fun f' : function => OK (Internal f')) = \nOK tf) : funsig tf = CminorSel.fn_sig f0.","conclusion":"funsig tf = CminorSel.fn_sig f0","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (p : node * list reg) (s' : state) (s : state_incr init_state s') (H : bind\n  (let (nentry, rparams) := p in\n   OK\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := rparams;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := nentry\n     |}) (fun f' : function => OK (Internal f')) = \nOK tf)","proofString":"destruct p.\nsimpl in H.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (n : node) (l : list reg) (s' : state) (s : state_incr init_state s') (H : bind\n  (OK\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) (fun f' : function => OK (Internal f')) = \nOK tf) : funsig tf = CminorSel.fn_sig f0.","conclusion":"funsig tf = CminorSel.fn_sig f0","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (n : node) (l : list reg) (s' : state) (s : state_incr init_state s') (H : bind\n  (OK\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) (fun f' : function => OK (Internal f')) = \nOK tf)","proofString":"simpl in H.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (n : node) (l : list reg) (s' : state) (s : state_incr init_state s') (H : OK\n  (Internal\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) = OK tf) : funsig tf = CminorSel.fn_sig f0.","conclusion":"funsig tf = CminorSel.fn_sig f0","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (n : node) (l : list reg) (s' : state) (s : state_incr init_state s') (H : OK\n  (Internal\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) = OK tf)","proofString":"inversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (n : node) (l : list reg) (s' : state) (s : state_incr init_state s') (H : OK\n  (Internal\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) = OK tf) (H1 : Internal\n  {|\n    fn_sig := CminorSel.fn_sig f0;\n    fn_params := l;\n    fn_stacksize := fn_stackspace f0;\n    fn_code := st_code s';\n    fn_entrypoint := n\n  |} = tf) : funsig\n  (Internal\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) = CminorSel.fn_sig f0.","conclusion":"funsig\n  (Internal\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) = CminorSel.fn_sig f0","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (f0 : CminorSel.function) (n : node) (l : list reg) (s' : state) (s : state_incr init_state s') (H : OK\n  (Internal\n     {|\n       fn_sig := CminorSel.fn_sig f0;\n       fn_params := l;\n       fn_stacksize := fn_stackspace f0;\n       fn_code := st_code s';\n       fn_entrypoint := n\n     |}) = OK tf) (H1 : Internal\n  {|\n    fn_sig := CminorSel.fn_sig f0;\n    fn_params := l;\n    fn_stacksize := fn_stackspace f0;\n    fn_code := st_code s';\n    fn_entrypoint := n\n  |} = tf)","proofString":"reflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (e : external_function) : OK (External e) = OK tf -> funsig tf = CminorSel.funsig (External e).","conclusion":"OK (External e) = OK tf -> funsig tf = CminorSel.funsig (External e)","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (e : external_function)","proofString":"intro.\ninversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (e : external_function) (H : OK (External e) = OK tf) : funsig tf = CminorSel.funsig (External e).","conclusion":"funsig tf = CminorSel.funsig (External e)","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (e : external_function) (H : OK (External e) = OK tf)","proofString":"inversion H.\nreflexivity."},{"statement":"(f : CminorSel.fundef) (tf : fundef) (e : external_function) (H : OK (External e) = OK tf) (H1 : External e = tf) : funsig (External e) = CminorSel.funsig (External e).","conclusion":"funsig (External e) = CminorSel.funsig (External e)","hypotheses":"(f : CminorSel.fundef) (tf : fundef) (e : external_function) (H : OK (External e) = OK tf) (H1 : External e = tf)","proofString":"reflexivity."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H : tr_move (fn_code f) ns r1 nd r2) : exists rs' : regset,\n  star step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\\\n  rs' # r2 = rs # r1 /\\ (forall r : reg, r <> r2 -> rs' # r = rs # r).","conclusion":"exists rs' : regset,\n  star step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\\\n  rs' # r2 = rs # r1 /\\ (forall r : reg, r <> r2 -> rs' # r = rs # r)","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H : tr_move (fn_code f) ns r1 nd r2)","proofString":"inv H.\nexists rs; split.\nconstructor.\nauto.\nexists (rs#r2 <- (rs#r1)); split.\napply star_one.\neapply exec_Iop.\neauto.\nauto.\nsplit.\napply Regmap.gss.\nintros; apply Regmap.gso; auto."},{"statement":"(r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) : exists rs' : regset,\n  star step tge (State cs f sp nd rs m) E0 (State cs f sp nd rs' m) /\\\n  rs' # r2 = rs # r2 /\\ (forall r : reg, r <> r2 -> rs' # r = rs # r).","conclusion":"exists rs' : regset,\n  star step tge (State cs f sp nd rs m) E0 (State cs f sp nd rs' m) /\\\n  rs' # r2 = rs # r2 /\\ (forall r : reg, r <> r2 -> rs' # r = rs # r)","hypotheses":"(r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem)","proofString":"exists rs; split.\nconstructor.\nauto."},{"statement":"(r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) : star step tge (State cs f sp nd rs m) E0 (State cs f sp nd rs m).","conclusion":"star step tge (State cs f sp nd rs m) E0 (State cs f sp nd rs m)","hypotheses":"(r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem)","proofString":"constructor."},{"statement":"(r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) : rs # r2 = rs # r2 /\\ (forall r : reg, r <> r2 -> rs # r = rs # r).","conclusion":"rs # r2 = rs # r2 /\\ (forall r : reg, r <> r2 -> rs # r = rs # r)","hypotheses":"(r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem)","proofString":"auto."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd)) : exists rs' : regset,\n  star step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\\\n  rs' # r2 = rs # r1 /\\ (forall r : reg, r <> r2 -> rs' # r = rs # r).","conclusion":"exists rs' : regset,\n  star step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\\\n  rs' # r2 = rs # r1 /\\ (forall r : reg, r <> r2 -> rs' # r = rs # r)","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd))","proofString":"exists (rs#r2 <- (rs#r1)); split.\napply star_one.\neapply exec_Iop.\neauto.\nauto.\nsplit.\napply Regmap.gss.\nintros; apply Regmap.gso; auto."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd)) : star step tge (State cs f sp ns rs m) E0\n  (State cs f sp nd rs # r2 <- (rs # r1) m).","conclusion":"star step tge (State cs f sp ns rs m) E0\n  (State cs f sp nd rs # r2 <- (rs # r1) m)","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd))","proofString":"apply star_one.\neapply exec_Iop.\neauto.\nauto."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd)) : step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs # r2 <- (rs # r1) m).","conclusion":"step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs # r2 <- (rs # r1) m)","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd))","proofString":"eapply exec_Iop.\neauto.\nauto."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd)) : (rs # r2 <- (rs # r1)) # r2 = rs # r1 /\\\n(forall r : reg, r <> r2 -> (rs # r2 <- (rs # r1)) # r = rs # r).","conclusion":"(rs # r2 <- (rs # r1)) # r2 = rs # r1 /\\\n(forall r : reg, r <> r2 -> (rs # r2 <- (rs # r1)) # r = rs # r)","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd))","proofString":"split.\napply Regmap.gss.\nintros; apply Regmap.gso; auto."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd)) : (rs # r2 <- (rs # r1)) # r2 = rs # r1.","conclusion":"(rs # r2 <- (rs # r1)) # r2 = rs # r1","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd))","proofString":"apply Regmap.gss."},{"statement":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd)) : forall r : reg, r <> r2 -> (rs # r2 <- (rs # r1)) # r = rs # r.","conclusion":"forall r : reg, r <> r2 -> (rs # r2 <- (rs # r1)) # r = rs # r","hypotheses":"(r1 : reg) (ns : node) (r2 : reg) (nd : node) (cs : list stackframe) (f : function) (sp : val) (rs : regset) (m : mem) (H0 : (fn_code f) ! ns = Some (Iop Omove (r1 :: nil) r2 nd))","proofString":"intros; apply Regmap.gso; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Evar id) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Evar id) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit match_env_find_var; eauto.\nintro EQ.\nexploit tr_move_correct; eauto.\nintros [rs' [A [B C]]].\nexists rs'; exists tm; split.\neauto.\ndestruct H2 as [[D E] | [D E]].\nsubst r dst.\nsimpl.\nassert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto.\nsplit.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto.\nsplit.\ncongruence.\nsplit.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd)","proofString":"exploit match_env_find_var; eauto.\nintro EQ.\nexploit tr_move_correct; eauto.\nintros [rs' [A [B C]]].\nexists rs'; exists tm; split.\neauto.\ndestruct H2 as [[D E] | [D E]].\nsubst r dst.\nsimpl.\nassert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto.\nsplit.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto.\nsplit.\ncongruence.\nsplit.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) : Val.lessdef v rs # r ->\nexists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'.","conclusion":"Val.lessdef v rs # r ->\nexists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd)","proofString":"intro EQ.\nexploit tr_move_correct; eauto.\nintros [rs' [A [B C]]].\nexists rs'; exists tm; split.\neauto.\ndestruct H2 as [[D E] | [D E]].\nsubst r dst.\nsimpl.\nassert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto.\nsplit.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto.\nsplit.\ncongruence.\nsplit.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r)","proofString":"exploit tr_move_correct; eauto.\nintros [rs' [A [B C]]].\nexists rs'; exists tm; split.\neauto.\ndestruct H2 as [[D E] | [D E]].\nsubst r dst.\nsimpl.\nassert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto.\nsplit.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto.\nsplit.\ncongruence.\nsplit.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : rd = r) (E : dst = None) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm.","conclusion":"match_env map (set_optvar dst v e) le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : rd = r) (E : dst = None) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"subst r dst.\nsimpl.\nassert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) : match_env map (set_optvar None v e) le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm.","conclusion":"match_env map (set_optvar None v e) le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r)","proofString":"simpl.\nassert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) : match_env map e le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm.","conclusion":"match_env map e le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r)","proofString":"assert (forall r, rs'#r = rs#r).\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\nsplit.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) : forall r : positive, rs' # r = rs # r.","conclusion":"forall r : positive, rs' # r = rs # r","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r)","proofString":"intros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) (r : positive) : rs' # r = rs # r.","conclusion":"rs' # r = rs # r","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) (r : positive)","proofString":"destruct (Reg.eq r rd).\nsubst r.\nauto.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) (r : positive) (e0 : r = rd) : rs' # r = rs # r.","conclusion":"rs' # r = rs # r","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) (r : positive) (e0 : r = rd)","proofString":"subst r.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) : rs' # rd = rs # rd.","conclusion":"rs' # rd = rs # rd","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r)","proofString":"auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) (r : positive) (n : r <> rd) : rs' # r = rs # r.","conclusion":"rs' # r = rs # r","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) (r : positive) (n : r <> rd)","proofString":"auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r) : match_env map e le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm.","conclusion":"match_env map e le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r)","proofString":"split.\neapply match_env_invariant; eauto.\nsplit.\ncongruence.\nsplit; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r) : match_env map e le rs'.","conclusion":"match_env map e le rs'","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r)","proofString":"eapply match_env_invariant; eauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r) : Val.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm.","conclusion":"Val.lessdef v rs' # rd /\\\n(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r)","proofString":"split.\ncongruence.\nsplit; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r) : Val.lessdef v rs' # rd.","conclusion":"Val.lessdef v rs' # rd","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r)","proofString":"congruence."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r) : (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm.","conclusion":"(forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : (map_vars map) ! id = Some rd) (EQ : Val.lessdef v rs # rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # rd) (C : forall r : reg, r <> rd -> rs' # r = rs # r) (H0 : forall r : positive, rs' # r = rs # r)","proofString":"split; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm.","conclusion":"match_env map (set_optvar dst v e) le rs' /\\\nVal.lessdef v rs' # rd /\\\n(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"split.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto.\nsplit.\ncongruence.\nsplit.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs'.","conclusion":"match_env map (set_optvar dst v e) le rs'","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"apply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs # rd <- (rs # r).","conclusion":"match_env map (set_optvar dst v e) le rs # rd <- (rs # r)","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"apply match_env_update_dest; auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : forall r0 : reg, reg_in_map map r0 -> rs' # r0 = (rs # rd <- (rs # r)) # r0.","conclusion":"forall r0 : reg, reg_in_map map r0 -> rs' # r0 = (rs # rd <- (rs # r)) # r0","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"intros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) : rs' # r0 = (rs # rd <- (rs # r)) # r0.","conclusion":"rs' # r0 = (rs # rd <- (rs # r)) # r0","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq r0 rd).\ncongruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) : rs' # r0 = (if peq r0 rd then rs # r else rs # r0).","conclusion":"rs' # r0 = (if peq r0 rd then rs # r else rs # r0)","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0)","proofString":"destruct (peq r0 rd).\ncongruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) (e0 : r0 = rd) : rs' # r0 = rs # r.","conclusion":"rs' # r0 = rs # r","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) (e0 : r0 = rd)","proofString":"congruence."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) (n : r0 <> rd) : rs' # r0 = rs # r0.","conclusion":"rs' # r0 = rs # r0","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) (n : r0 <> rd)","proofString":"auto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : Val.lessdef v rs' # rd /\\\n(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm.","conclusion":"Val.lessdef v rs' # rd /\\\n(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"split.\ncongruence.\nsplit.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : Val.lessdef v rs' # rd.","conclusion":"Val.lessdef v rs' # rd","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"congruence."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm.","conclusion":"(forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"split.\nintros.\napply C.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0.","conclusion":"forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"intros.\napply C.\nintuition congruence."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr) : rs' # r0 = rs # r0.","conclusion":"rs' # r0 = rs # r0","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr)","proofString":"apply C.\nintuition congruence."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr) : r0 <> rd.","conclusion":"r0 <> rd","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r1 : reg, r1 <> rd -> rs' # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr)","proofString":"intuition congruence."},{"statement":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0) : Mem.extends m tm.","conclusion":"Mem.extends m tm","hypotheses":"(le : letenv) (id : positive) (v : val) (H : e ! id = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : (map_vars map) ! id = Some r) (D : reg_map_ok map rd dst) (E : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (EQ : Val.lessdef v rs # r) (rs' : regset) (A : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm)) (B : rs' # rd = rs # r) (C : forall r0 : reg, r0 <> rd -> rs' # r0 = rs # r0)","proofString":"auto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Eop op args) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Eop op args) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].\nedestruct eval_operation_lessdef as [v' []]; eauto.\nexists (rs1#rd <- v'); exists tm1.\nsplit.\neapply star_right.\neexact EX1.\neapply exec_Iop; eauto.\nrewrite (@eval_operation_preserved CminorSel.fundef _ _ _ ge tge).\neauto.\nexact symbols_preserved.\ntraceEq.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].\nedestruct eval_operation_lessdef as [v' []]; eauto.\nexists (rs1#rd <- v'); exists tm1.\nsplit.\neapply star_right.\neexact EX1.\neapply exec_Iop; eauto.\nrewrite (@eval_operation_preserved CminorSel.fundef _ _ _ ge tge).\neauto.\nexact symbols_preserved.\ntraceEq.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : eval_operation tge sp op rs1 ## rl tm1 = Some v'.","conclusion":"eval_operation tge sp op rs1 ## rl tm1 = Some v'","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"rewrite (@eval_operation_preserved CminorSel.fundef _ _ _ ge tge).\neauto.\nexact symbols_preserved."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : eval_operation ge sp op rs1 ## rl tm1 = Some v'.","conclusion":"eval_operation ge sp op rs1 ## rl tm1 = Some v'","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"eauto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s.","conclusion":"forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"exact symbols_preserved."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : match_env map (set_optvar dst v e) le rs1 # rd <- v'.","conclusion":"match_env map (set_optvar dst v e) le rs1 # rd <- v'","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"eauto with rtlg."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"split.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : Val.lessdef v (rs1 # rd <- v') # rd.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"rewrite Regmap.gss.\nauto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : Val.lessdef v v'.","conclusion":"Val.lessdef v v'","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"auto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : (forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1.","conclusion":"(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"split.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r.","conclusion":"forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"intros.\nrewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') (r : reg) (H6 : In r pr) : (rs1 # rd <- v') # r = rs # r.","conclusion":"(rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') (r : reg) (H6 : In r pr)","proofString":"rewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') (r : reg) (H6 : In r pr) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') (r : reg) (H6 : In r pr)","proofString":"auto."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') (r : reg) (H6 : In r pr) : r <> rd.","conclusion":"r <> rd","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') (r : reg) (H6 : In r pr)","proofString":"intuition congruence."},{"statement":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v') : Mem.extends m tm1.","conclusion":"Mem.extends m tm1","hypotheses":"(le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_operation ge sp op vargs m = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Iop op rl rd nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vargs rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (H2 : eval_operation ge sp op rs1 ## rl tm1 = Some v') (H3 : Val.lessdef v v')","proofString":"auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Eload chunk addr args) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Eload chunk addr args) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nedestruct eval_addressing_lessdef as [vaddr' []]; eauto.\nedestruct Mem.loadv_extends as [v' []]; eauto.\nexists (rs1#rd <- v'); exists tm1.\nsplit.\neapply star_right.\neexact EX1.\neapply exec_Iload.\neauto.\ninstantiate (1 := vaddr').\nrewrite <- H3.\napply eval_addressing_preserved.\nexact symbols_preserved.\nauto.\ntraceEq.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nedestruct eval_addressing_lessdef as [vaddr' []]; eauto.\nedestruct Mem.loadv_extends as [v' []]; eauto.\nexists (rs1#rd <- v'); exists tm1.\nsplit.\neapply star_right.\neexact EX1.\neapply exec_Iload.\neauto.\ninstantiate (1 := vaddr').\nrewrite <- H3.\napply eval_addressing_preserved.\nexact symbols_preserved.\nauto.\ntraceEq.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : eval_addressing tge sp addr rs1 ## rl = Some vaddr'.","conclusion":"eval_addressing tge sp addr rs1 ## rl = Some vaddr'","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"rewrite <- H3.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : eval_addressing tge sp addr rs1 ## rl = eval_addressing ge sp addr rs1 ## rl.","conclusion":"eval_addressing tge sp addr rs1 ## rl = eval_addressing ge sp addr rs1 ## rl","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s.","conclusion":"forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"exact symbols_preserved."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : match_env map (set_optvar dst v e) le rs1 # rd <- v'.","conclusion":"match_env map (set_optvar dst v e) le rs1 # rd <- v'","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"eauto with rtlg."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"split.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : Val.lessdef v (rs1 # rd <- v') # rd.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"rewrite Regmap.gss.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : Val.lessdef v v'.","conclusion":"Val.lessdef v v'","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : (forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1.","conclusion":"(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm1","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"split.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r.","conclusion":"forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"intros.\nrewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') (r : reg) (H8 : In r pr) : (rs1 # rd <- v') # r = rs # r.","conclusion":"(rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') (r : reg) (H8 : In r pr)","proofString":"rewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') (r : reg) (H8 : In r pr) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') (r : reg) (H8 : In r pr)","proofString":"auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') (r : reg) (H8 : In r pr) : r <> rd.","conclusion":"r <> rd","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') (r : reg) (H8 : In r pr)","proofString":"intuition congruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v') : Mem.extends m tm1.","conclusion":"Mem.extends m tm1","hypotheses":"(le : letenv) (chunk : memory_chunk) (addr : addressing) (args : exprlist) (vargs : list val) (vaddr v : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : transl_exprlist_prop le args vargs) (H1 : eval_addressing ge sp addr vargs = Some vaddr) (H2 : Mem.loadv chunk m vaddr = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr args ns n1 rl) (H9 : (fn_code f) ! n1 = Some (Iload chunk addr rl rd nd)) (H14 : reg_map_ok map rd dst) (H15 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vargs rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (vaddr' : val) (H3 : eval_addressing ge sp addr rs1 ## rl = Some vaddr') (H4 : Val.lessdef vaddr vaddr') (v' : val) (H5 : Mem.loadv chunk tm1 vaddr' = Some v') (H7 : Val.lessdef v v')","proofString":"auto."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [OTHER1 EXT1]]]]].\nassert (tr_expr f.(fn_code) map pr (if va then ifso else ifnot) (if va then ntrue else nfalse) nd rd dst).\ndestruct va; auto.\nexploit H2; eauto.\nintros [rs2 [tm2 [EX2 [ME2 [RES2 [OTHER2 EXT2]]]]]].\nexists rs2; exists tm2.\nsplit.\neapply star_trans.\napply plus_star.\neexact EX1.\neexact EX2.\ntraceEq.\nsplit.\nassumption.\nsplit.\nassumption.\nsplit.\nintros.\ntransitivity (rs1#r); auto.\nauto."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : match_env map (set_optvar dst v e) le rs2.","conclusion":"match_env map (set_optvar dst v e) le rs2","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"assumption."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef v rs2 # rd /\\\n(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2.","conclusion":"Val.lessdef v rs2 # rd /\\\n(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"split.\nassumption.\nsplit.\nintros.\ntransitivity (rs1#r); auto.\nauto."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef v rs2 # rd.","conclusion":"Val.lessdef v rs2 # rd","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"assumption."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : (forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2.","conclusion":"(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"split.\nintros.\ntransitivity (rs1#r); auto.\nauto."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : forall r : reg, In r pr -> rs2 # r = rs # r.","conclusion":"forall r : reg, In r pr -> rs2 # r = rs # r","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"intros.\ntransitivity (rs1#r); auto."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H4 : In r pr) : rs2 # r = rs # r.","conclusion":"rs2 # r = rs # r","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H4 : In r pr)","proofString":"transitivity (rs1#r); auto."},{"statement":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_expr ge sp e m le (if va then ifso else ifnot) v) (H2 : transl_expr_prop le (if va then ifso else ifnot) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (ntrue nfalse : node) (H8 : tr_condition (fn_code f) map pr a ns ntrue nfalse) (H13 : tr_expr (fn_code f) map pr ifso ntrue nd rd dst) (H14 : tr_expr (fn_code f) map pr ifnot nfalse nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then ntrue else nfalse) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_expr (fn_code f) map pr (if va then ifso else ifnot)\n  (if va then ntrue else nfalse) nd rd dst) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp (if va then ntrue else nfalse) rs1 tm1) E0\n  (State cs f sp nd rs2 tm2)) (ME2 : match_env map (set_optvar dst v e) le rs2) (RES2 : Val.lessdef v rs2 # rd) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v2 e) le rs' /\\\n  Val.lessdef v2 rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v2 e) le rs' /\\\n  Val.lessdef v2 rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nassert (map_wf (add_letvar map r)).\neapply add_letvar_wf; eauto.\nexploit H2; eauto.\neapply match_env_bind_letvar; eauto.\nintros [rs2 [tm2 [EX2 [ME3 [RES2 [OTHER2 EXT2]]]]]].\nexists rs2; exists tm2.\nsplit.\neapply star_trans.\neexact EX1.\neexact EX2.\nauto.\nsplit.\neapply match_env_unbind_letvar; eauto.\nsplit.\nassumption.\nsplit.\nintros.\ntransitivity (rs1#r0); auto.\nauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : match_env map (set_optvar dst v2 e) le rs2.","conclusion":"match_env map (set_optvar dst v2 e) le rs2","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"eapply match_env_unbind_letvar; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : Val.lessdef v2 rs2 # rd /\\\n(forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0) /\\ Mem.extends m tm2.","conclusion":"Val.lessdef v2 rs2 # rd /\\\n(forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"split.\nassumption.\nsplit.\nintros.\ntransitivity (rs1#r0); auto.\nauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : Val.lessdef v2 rs2 # rd.","conclusion":"Val.lessdef v2 rs2 # rd","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"assumption."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : (forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0) /\\ Mem.extends m tm2.","conclusion":"(forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"split.\nintros.\ntransitivity (rs1#r0); auto.\nauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0.","conclusion":"forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"intros.\ntransitivity (rs1#r0); auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r1 : reg, In r1 pr -> rs1 # r1 = rs # r1) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r1 : reg, In r1 pr -> rs2 # r1 = rs1 # r1) (EXT2 : Mem.extends m tm2) (r0 : reg) (H4 : In r0 pr) : rs2 # r0 = rs # r0.","conclusion":"rs2 # r0 = rs # r0","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r1 : reg, In r1 pr -> rs1 # r1 = rs # r1) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r1 : reg, In r1 pr -> rs2 # r1 = rs1 # r1) (EXT2 : Mem.extends m tm2) (r0 : reg) (H4 : In r0 pr)","proofString":"transitivity (rs1#r0); auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_expr ge sp e m (v1 :: le) a2 v2) (H2 : transl_expr_prop (v1 :: le) a2 v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a1 ns n1 r None) (H13 : tr_expr (fn_code f) (add_letvar map r) pr a2 n1 nd rd dst) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME3 : match_env (add_letvar map r) (set_optvar dst v2 e) (v1 :: le) rs2) (RES2 : Val.lessdef v2 rs2 # rd) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd)","proofString":"exploit tr_move_correct; eauto.\nintros [rs1 [EX1 [RES1 OTHER1]]].\nexists rs1; exists tm.\nsplit.\neexact EX1.\nsplit.\ndestruct H2 as [[A B] | [A B]].\nsubst r dst; simpl.\napply match_env_invariant with rs.\nauto.\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\neapply match_env_find_letvar; eauto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd); auto.\ncongruence.\nsplit.\nrewrite RES1.\neapply match_env_find_letvar; eauto.\nsplit.\nintros.\ndestruct H2 as [[A B] | [A B]].\ndestruct (Reg.eq r0 rd); subst; auto.\napply OTHER1.\nintuition congruence.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs1.","conclusion":"match_env map (set_optvar dst v e) le rs1","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"destruct H2 as [[A B] | [A B]].\nsubst r dst; simpl.\napply match_env_invariant with rs.\nauto.\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto.\napply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\neapply match_env_find_letvar; eauto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd); auto.\ncongruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : rd = r) (B : dst = None) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs1.","conclusion":"match_env map (set_optvar dst v e) le rs1","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : rd = r) (B : dst = None) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"subst r dst; simpl.\napply match_env_invariant with rs.\nauto.\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r) : match_env map e le rs1.","conclusion":"match_env map e le rs1","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r)","proofString":"apply match_env_invariant with rs.\nauto.\nintros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r) : match_env map e le rs.","conclusion":"match_env map e le rs","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r)","proofString":"auto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r) : forall r : reg, reg_in_map map r -> rs1 # r = rs # r.","conclusion":"forall r : reg, reg_in_map map r -> rs1 # r = rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r)","proofString":"intros.\ndestruct (Reg.eq r rd).\nsubst r.\nauto.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) (r : reg) (H0 : reg_in_map map r) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) (r : reg) (H0 : reg_in_map map r)","proofString":"destruct (Reg.eq r rd).\nsubst r.\nauto.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) (r : reg) (H0 : reg_in_map map r) (e0 : r = rd) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) (r : reg) (H0 : reg_in_map map r) (e0 : r = rd)","proofString":"subst r.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r) (H0 : reg_in_map map rd) : rs1 # rd = rs # rd.","conclusion":"rs1 # rd = rs # rd","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r : reg, r <> rd -> rs1 # r = rs # r) (H0 : reg_in_map map rd)","proofString":"auto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) (r : reg) (H0 : reg_in_map map r) (n0 : r <> rd) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error (map_letvars map) n = Some rd) (H5 : tr_move (fn_code f) ns rd nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # rd) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) (r : reg) (H0 : reg_in_map map r) (n0 : r <> rd)","proofString":"auto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs1.","conclusion":"match_env map (set_optvar dst v e) le rs1","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"apply match_env_invariant with (rs#rd <- (rs#r)).\napply match_env_update_dest; auto.\neapply match_env_find_letvar; eauto.\nintros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd); auto.\ncongruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : match_env map (set_optvar dst v e) le rs # rd <- (rs # r).","conclusion":"match_env map (set_optvar dst v e) le rs # rd <- (rs # r)","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"apply match_env_update_dest; auto.\neapply match_env_find_letvar; eauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"eapply match_env_find_letvar; eauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : forall r0 : reg, reg_in_map map r0 -> rs1 # r0 = (rs # rd <- (rs # r)) # r0.","conclusion":"forall r0 : reg, reg_in_map map r0 -> rs1 # r0 = (rs # rd <- (rs # r)) # r0","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"intros.\nrewrite Regmap.gsspec.\ndestruct (peq r0 rd); auto.\ncongruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) : rs1 # r0 = (rs # rd <- (rs # r)) # r0.","conclusion":"rs1 # r0 = (rs # rd <- (rs # r)) # r0","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq r0 rd); auto.\ncongruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) : rs1 # r0 = (if peq r0 rd then rs # r else rs # r0).","conclusion":"rs1 # r0 = (if peq r0 rd then rs # r else rs # r0)","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0)","proofString":"destruct (peq r0 rd); auto.\ncongruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) (e0 : r0 = rd) : rs1 # r0 = rs # r.","conclusion":"rs1 # r0 = rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : reg_in_map map r0) (e0 : r0 = rd)","proofString":"congruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : Val.lessdef v rs1 # rd /\\\n(forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) /\\ Mem.extends m tm.","conclusion":"Val.lessdef v rs1 # rd /\\\n(forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) /\\ Mem.extends m tm","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"split.\nrewrite RES1.\neapply match_env_find_letvar; eauto.\nsplit.\nintros.\ndestruct H2 as [[A B] | [A B]].\ndestruct (Reg.eq r0 rd); subst; auto.\napply OTHER1.\nintuition congruence.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : Val.lessdef v rs1 # rd.","conclusion":"Val.lessdef v rs1 # rd","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"rewrite RES1.\neapply match_env_find_letvar; eauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : Val.lessdef v rs # r.","conclusion":"Val.lessdef v rs # r","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"eapply match_env_find_letvar; eauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : (forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) /\\ Mem.extends m tm.","conclusion":"(forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) /\\ Mem.extends m tm","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"split.\nintros.\ndestruct H2 as [[A B] | [A B]].\ndestruct (Reg.eq r0 rd); subst; auto.\napply OTHER1.\nintuition congruence.\nauto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0.","conclusion":"forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"intros.\ndestruct H2 as [[A B] | [A B]].\ndestruct (Reg.eq r0 rd); subst; auto.\napply OTHER1.\nintuition congruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr) : rs1 # r0 = rs # r0.","conclusion":"rs1 # r0 = rs # r0","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr)","proofString":"destruct H2 as [[A B] | [A B]].\ndestruct (Reg.eq r0 rd); subst; auto.\napply OTHER1.\nintuition congruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : rd = r) (B : dst = None) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr) : rs1 # r0 = rs # r0.","conclusion":"rs1 # r0 = rs # r0","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : rd = r) (B : dst = None) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr)","proofString":"destruct (Reg.eq r0 rd); subst; auto."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr) : rs1 # r0 = rs # r0.","conclusion":"rs1 # r0 = rs # r0","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr)","proofString":"apply OTHER1.\nintuition congruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr) : r0 <> rd.","conclusion":"r0 <> rd","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (A : reg_map_ok map rd dst) (B : ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r1 : reg, r1 <> rd -> rs1 # r1 = rs # r1) (r0 : reg) (H0 : In r0 pr)","proofString":"intuition congruence."},{"statement":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0) : Mem.extends m tm.","conclusion":"Mem.extends m tm","hypotheses":"(le : list val) (n : nat) (v : val) (H : nth_error le n = Some v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (H1 : nth_error (map_letvars map) n = Some r) (H2 : rd = r /\\ dst = None \\/ reg_map_ok map rd dst /\\ ~ In rd pr) (H5 : tr_move (fn_code f) ns r nd rd) (rs1 : regset) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs1 tm)) (RES1 : rs1 # rd = rs # r) (OTHER1 : forall r0 : reg, r0 <> rd -> rs1 # r0 = rs # r0)","proofString":"auto."},{"statement":"(ge0 : genv) (rs : regset) (sp0 : val) (m0 : mem) : eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0 nil nil.","conclusion":"eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0 nil nil","hypotheses":"(ge0 : genv) (rs : regset) (sp0 : val) (m0 : mem)","proofString":"constructor."},{"statement":"(ge0 : genv) (rs : regset) (sp0 : val) (m0 : mem) (a : reg) (rl : list reg) (IHrl : eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0\n  (map (BA (A:=reg)) rl) rs ## rl) : eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0\n  (BA a :: map (BA (A:=reg)) rl) (rs # a :: rs ## rl).","conclusion":"eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0\n  (BA a :: map (BA (A:=reg)) rl) (rs # a :: rs ## rl)","hypotheses":"(ge0 : genv) (rs : regset) (sp0 : val) (m0 : mem) (a : reg) (rl : list reg) (IHrl : eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0\n  (map (BA (A:=reg)) rl) rs ## rl)","proofString":"constructor; auto.\nconstructor."},{"statement":"(ge0 : genv) (rs : regset) (sp0 : val) (m0 : mem) (a : reg) (rl : list reg) (IHrl : eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0\n  (map (BA (A:=reg)) rl) rs ## rl) : Events.eval_builtin_arg ge0 (fun r : positive => rs # r) sp0 m0 (BA a) rs # a.","conclusion":"Events.eval_builtin_arg ge0 (fun r : positive => rs # r) sp0 m0 (BA a) rs # a","hypotheses":"(ge0 : genv) (rs : regset) (sp0 : val) (m0 : mem) (a : reg) (rl : list reg) (IHrl : eval_builtin_args ge0 (fun r : positive => rs # r) sp0 m0\n  (map (BA (A:=reg)) rl) rs ## rl)","proofString":"constructor."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Ebuiltin ef al) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Ebuiltin ef al) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].\nexploit external_call_mem_extends; eauto.\nintros [v' [tm2 [A [B [C D]]]]].\nexists (rs1#rd <- v'); exists tm2.\nsplit.\neapply star_right.\neexact EX1.\nchange (rs1#rd <- v') with (regmap_setres (BR rd) v' rs1).\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_trivial.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nreflexivity.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].\nexploit external_call_mem_extends; eauto.\nintros [v' [tm2 [A [B [C D]]]]].\nexists (rs1#rd <- v'); exists tm2.\nsplit.\neapply star_right.\neexact EX1.\nchange (rs1#rd <- v') with (regmap_setres (BR rd) v' rs1).\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_trivial.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nreflexivity.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"apply senv_preserved."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : match_env map (set_optvar dst v e) le rs1 # rd <- v'.","conclusion":"match_env map (set_optvar dst v e) le rs1 # rd <- v'","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"eauto with rtlg."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"split.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : Val.lessdef v (rs1 # rd <- v') # rd.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"rewrite Regmap.gss.\nauto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : Val.lessdef v v'.","conclusion":"Val.lessdef v v'","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"auto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : (forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2.","conclusion":"(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"split.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r.","conclusion":"forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"intros.\nrewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (r : reg) (H2 : In r pr) : (rs1 # rd <- v') # r = rs # r.","conclusion":"(rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (r : reg) (H2 : In r pr)","proofString":"rewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (r : reg) (H2 : In r pr) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (r : reg) (H2 : In r pr)","proofString":"auto."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (r : reg) (H2 : In r pr) : r <> rd.","conclusion":"r <> rd","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (r : reg) (H2 : In r pr)","proofString":"intuition congruence."},{"statement":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (ef : external_function) (al : exprlist) (vl : list val) (v : val) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H4 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H5 : (fn_code f) ! n1 = Some (Ibuiltin ef (List.map (BA (A:=reg)) rl) (BR rd) nd)) (H8 : reg_map_ok map rd dst) (H13 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2)","proofString":"auto."},{"statement":"(le : letenv) (id : ident) (sg : signature) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H1 : ef_sig ef = sg) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Eexternal id sg al) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (id : ident) (sg : signature) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H1 : ef_sig ef = sg) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (TE : tr_expr (fn_code f) map pr (Eexternal id sg al) ns nd rd dst) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H3; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].\nexploit external_call_mem_extends; eauto.\nintros [v' [tm2 [A [B [C D]]]]].\nexploit function_ptr_translated; eauto.\nsimpl.\nintros [tf [P Q]].\ninv Q.\nexists (rs1#rd <- v'); exists tm2.\nsplit.\neapply star_trans.\neexact EX1.\neapply star_left.\neapply exec_Icall; eauto.\nsimpl.\nrewrite symbols_preserved.\nrewrite H.\neauto.\nauto.\neapply star_left.\neapply exec_function_external.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\napply star_one.\napply exec_return.\nreflexivity.\nreflexivity.\nreflexivity.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map (set_optvar dst v e) le rs' /\\\n  Val.lessdef v rs' # rd /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr)","proofString":"exploit H3; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].\nexploit external_call_mem_extends; eauto.\nintros [v' [tm2 [A [B [C D]]]]].\nexploit function_ptr_translated; eauto.\nsimpl.\nintros [tf [P Q]].\ninv Q.\nexists (rs1#rd <- v'); exists tm2.\nsplit.\neapply star_trans.\neexact EX1.\neapply star_left.\neapply exec_Icall; eauto.\nsimpl.\nrewrite symbols_preserved.\nrewrite H.\neauto.\nauto.\neapply star_left.\neapply exec_function_external.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\napply star_one.\napply exec_return.\nreflexivity.\nreflexivity.\nreflexivity.\nsplit.\neauto with rtlg.\nsplit.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"apply senv_preserved."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : match_env map (set_optvar dst v e) le rs1 # rd <- v'.","conclusion":"match_env map (set_optvar dst v e) le rs1 # rd <- v'","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"eauto with rtlg."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd /\\\n(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"split.\nrewrite Regmap.gss.\nauto.\nsplit.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : Val.lessdef v (rs1 # rd <- v') # rd.","conclusion":"Val.lessdef v (rs1 # rd <- v') # rd","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"rewrite Regmap.gss.\nauto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : Val.lessdef v v'.","conclusion":"Val.lessdef v v'","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"auto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : (forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2.","conclusion":"(forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r) /\\\nMem.extends m tm2","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"split.\nintros.\nrewrite Regmap.gso.\nauto.\nintuition congruence.\nauto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r.","conclusion":"forall r : reg, In r pr -> (rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"intros.\nrewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) (r : reg) (H1 : In r pr) : (rs1 # rd <- v') # r = rs # r.","conclusion":"(rs1 # rd <- v') # r = rs # r","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) (r : reg) (H1 : In r pr)","proofString":"rewrite Regmap.gso.\nauto.\nintuition congruence."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) (r : reg) (H1 : In r pr) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) (r : reg) (H1 : In r pr)","proofString":"auto."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) (r : reg) (H1 : In r pr) : r <> rd.","conclusion":"r <> rd","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) (r : reg) (H1 : In r pr)","proofString":"intuition congruence."},{"statement":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef)) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (id : ident) (al : exprlist) (b : block) (ef : external_function) (vl : list val) (v : val) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some (External ef)) (H2 : eval_exprlist ge sp e m le al vl) (H3 : transl_exprlist_prop le al vl) (H4 : external_call ef ge vl m E0 v m) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rd : reg) (rs : regset) (dst : option ident) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H8 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H11 : (fn_code f) ! n1 = Some (Icall (ef_sig ef) (inr id) rl rd nd)) (H16 : reg_map_ok map rd dst) (H17 : ~ In rd pr) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RR1 : Val.lessdef_list vl rs1 ## rl) (RO1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (v' : val) (tm2 : mem) (A : external_call ef ge rs1 ## rl tm1 E0 v' tm2) (B : Val.lessdef v v') (C : Mem.extends m tm2) (D : Mem.unchanged_on (loc_out_of_bounds m) tm1 tm2) (P : Genv.find_funct_ptr tge b = Some (External ef))","proofString":"auto."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp nd rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map e le rs' /\\\n  Val.lessdef_list nil rs' ## nil /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp nd rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map e le rs' /\\\n  Val.lessdef_list nil rs' ## nil /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"exists rs; exists tm.\nsplit.\napply star_refl.\nsplit.\nassumption.\nsplit.\nconstructor.\nauto."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : star step tge (State cs f sp nd rs tm) E0 (State cs f sp nd rs tm) /\\\nmatch_env map e le rs /\\\nVal.lessdef_list nil rs ## nil /\\\n(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm.","conclusion":"star step tge (State cs f sp nd rs tm) E0 (State cs f sp nd rs tm) /\\\nmatch_env map e le rs /\\\nVal.lessdef_list nil rs ## nil /\\\n(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"split.\napply star_refl.\nsplit.\nassumption.\nsplit.\nconstructor.\nauto."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : star step tge (State cs f sp nd rs tm) E0 (State cs f sp nd rs tm).","conclusion":"star step tge (State cs f sp nd rs tm) E0 (State cs f sp nd rs tm)","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"apply star_refl."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : match_env map e le rs /\\\nVal.lessdef_list nil rs ## nil /\\\n(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm.","conclusion":"match_env map e le rs /\\\nVal.lessdef_list nil rs ## nil /\\\n(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"split.\nassumption.\nsplit.\nconstructor.\nauto."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : match_env map e le rs.","conclusion":"match_env map e le rs","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"assumption."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : Val.lessdef_list nil rs ## nil /\\\n(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm.","conclusion":"Val.lessdef_list nil rs ## nil /\\\n(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"split.\nconstructor.\nauto."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : Val.lessdef_list nil rs ## nil.","conclusion":"Val.lessdef_list nil rs ## nil","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"constructor."},{"statement":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : (forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm.","conclusion":"(forall r : reg, In r pr -> rs # r = rs # r) /\\ Mem.extends m tm","hypotheses":"(le : letenv) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"auto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) : exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map e le rs' /\\\n  Val.lessdef_list (v1 :: vl) rs' ## (r1 :: rl0) /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  match_env map e le rs' /\\\n  Val.lessdef_list (v1 :: vl) rs' ## (r1 :: rl0) /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nexploit H2; eauto.\nintros [rs2 [tm2 [EX2 [ME2 [RES2 [OTHER2 EXT2]]]]]].\nexists rs2; exists tm2.\nsplit.\neapply star_trans.\neexact EX1.\neexact EX2.\nauto.\nsplit.\nassumption.\nsplit.\nsimpl.\nconstructor.\nrewrite OTHER2.\nauto.\nsimpl; tauto.\nauto.\nsplit.\nintros.\ntransitivity (rs1#r).\napply OTHER2; auto.\nsimpl; tauto.\napply OTHER1; auto.\nauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : match_env map e le rs2.","conclusion":"match_env map e le rs2","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"assumption."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef_list (v1 :: vl) rs2 ## (r1 :: rl0) /\\\n(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2.","conclusion":"Val.lessdef_list (v1 :: vl) rs2 ## (r1 :: rl0) /\\\n(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"split.\nsimpl.\nconstructor.\nrewrite OTHER2.\nauto.\nsimpl; tauto.\nauto.\nsplit.\nintros.\ntransitivity (rs1#r).\napply OTHER2; auto.\nsimpl; tauto.\napply OTHER1; auto.\nauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef_list (v1 :: vl) rs2 ## (r1 :: rl0).","conclusion":"Val.lessdef_list (v1 :: vl) rs2 ## (r1 :: rl0)","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"simpl.\nconstructor.\nrewrite OTHER2.\nauto.\nsimpl; tauto.\nauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef_list (v1 :: vl) (rs2 # r1 :: rs2 ## rl0).","conclusion":"Val.lessdef_list (v1 :: vl) (rs2 # r1 :: rs2 ## rl0)","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"constructor.\nrewrite OTHER2.\nauto.\nsimpl; tauto.\nauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef v1 rs2 # r1.","conclusion":"Val.lessdef v1 rs2 # r1","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"rewrite OTHER2.\nauto.\nsimpl; tauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef v1 rs1 # r1.","conclusion":"Val.lessdef v1 rs1 # r1","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : In r1 (r1 :: pr).","conclusion":"In r1 (r1 :: pr)","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"simpl; tauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Val.lessdef_list vl rs2 ## rl0.","conclusion":"Val.lessdef_list vl rs2 ## rl0","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : (forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2.","conclusion":"(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"split.\nintros.\ntransitivity (rs1#r).\napply OTHER2; auto.\nsimpl; tauto.\napply OTHER1; auto.\nauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : forall r : reg, In r pr -> rs2 # r = rs # r.","conclusion":"forall r : reg, In r pr -> rs2 # r = rs # r","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"intros.\ntransitivity (rs1#r).\napply OTHER2; auto.\nsimpl; tauto.\napply OTHER1; auto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr) : rs2 # r = rs # r.","conclusion":"rs2 # r = rs # r","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr)","proofString":"transitivity (rs1#r).\napply OTHER2; auto.\nsimpl; tauto.\napply OTHER1; auto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr) : rs2 # r = rs1 # r.","conclusion":"rs2 # r = rs1 # r","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr)","proofString":"apply OTHER2; auto.\nsimpl; tauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr) : In r (r1 :: pr).","conclusion":"In r (r1 :: pr)","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr)","proofString":"simpl; tauto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr) : rs1 # r = rs # r.","conclusion":"rs1 # r = rs # r","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r0 : reg, In r0 (r1 :: pr) -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H3 : In r pr)","proofString":"apply OTHER1; auto."},{"statement":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val) (H : eval_expr ge sp e m le a1 v1) (H0 : transl_expr_prop le a1 v1) (H1 : eval_exprlist ge sp e m le al vl) (H2 : transl_exprlist_prop le al vl) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns nd : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r1 : reg) (rl0 : list reg) (n1 : node) (H7 : tr_expr (fn_code f) map pr a1 ns n1 r1 None) (H11 : tr_exprlist (fn_code f) map (r1 :: pr) al n1 nd rl0) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (rs2 : regset) (tm2 : mem) (EX2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (ME2 : match_env map e le rs2) (RES2 : Val.lessdef_list vl rs2 ## rl0) (OTHER2 : forall r : reg, In r (r1 :: pr) -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (TE : tr_condition (fn_code f) map pr (CEcond cond al) ns ntrue nfalse) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if vb then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if vb then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (TE : tr_condition (fn_code f) map pr (CEcond cond al) ns ntrue nfalse) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nexists rs1; exists tm1.\nsplit.\neapply plus_right.\neexact EX1.\neapply exec_Icond.\neauto.\neapply eval_condition_lessdef; eauto.\nauto.\ntraceEq.\nsplit.\nassumption.\nsplit.\nassumption.\nauto."},{"statement":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) : exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if vb then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if vb then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse))","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nexists rs1; exists tm1.\nsplit.\neapply plus_right.\neexact EX1.\neapply exec_Icond.\neauto.\neapply eval_condition_lessdef; eauto.\nauto.\ntraceEq.\nsplit.\nassumption.\nsplit.\nassumption.\nauto."},{"statement":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) : match_env map e le rs1.","conclusion":"match_env map e le rs1","hypotheses":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1)","proofString":"assumption."},{"statement":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) : (forall r : reg, In r pr -> rs1 # r = rs # r) /\\ Mem.extends m tm1.","conclusion":"(forall r : reg, In r pr -> rs1 # r = rs # r) /\\ Mem.extends m tm1","hypotheses":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1)","proofString":"split.\nassumption.\nauto."},{"statement":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) : forall r : reg, In r pr -> rs1 # r = rs # r.","conclusion":"forall r : reg, In r pr -> rs1 # r = rs # r","hypotheses":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1)","proofString":"assumption."},{"statement":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) : Mem.extends m tm1.","conclusion":"Mem.extends m tm1","hypotheses":"(le : letenv) (cond : condition) (al : exprlist) (vl : list val) (vb : bool) (H : eval_exprlist ge sp e m le al vl) (H0 : transl_exprlist_prop le al vl) (H1 : eval_condition cond vl m = Some vb) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (rl : list reg) (H6 : tr_exprlist (fn_code f) map pr al ns n1 rl) (H10 : (fn_code f) ! n1 = Some (Icond cond rl ntrue nfalse)) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map e le rs1) (RES1 : Val.lessdef_list vl rs1 ## rl) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1)","proofString":"auto."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (TE : tr_condition (fn_code f) map pr (CEcondition a b c) ns ntrue nfalse) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (TE : tr_condition (fn_code f) map pr (CEcondition a b c) ns ntrue nfalse) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [OTHER1 EXT1]]]]].\nassert (tr_condition (fn_code f) map pr (if va then b else c) (if va then n2 else n3) ntrue nfalse).\ndestruct va; auto.\nexploit H2; eauto.\nintros [rs2 [tm2 [EX2 [ME2 [OTHER2 EXT2]]]]].\nexists rs2; exists tm2.\nsplit.\neapply plus_trans.\neexact EX1.\neexact EX2.\ntraceEq.\nsplit.\nassumption.\nsplit.\nintros.\nrewrite OTHER2; auto.\nauto."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) : exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [OTHER1 EXT1]]]]].\nassert (tr_condition (fn_code f) map pr (if va then b else c) (if va then n2 else n3) ntrue nfalse).\ndestruct va; auto.\nexploit H2; eauto.\nintros [rs2 [tm2 [EX2 [ME2 [OTHER2 EXT2]]]]].\nexists rs2; exists tm2.\nsplit.\neapply plus_trans.\neexact EX1.\neexact EX2.\ntraceEq.\nsplit.\nassumption.\nsplit.\nintros.\nrewrite OTHER2; auto.\nauto."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : match_env map e le rs2.","conclusion":"match_env map e le rs2","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"assumption."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : (forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2.","conclusion":"(forall r : reg, In r pr -> rs2 # r = rs # r) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"split.\nintros.\nrewrite OTHER2; auto.\nauto."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : forall r : reg, In r pr -> rs2 # r = rs # r.","conclusion":"forall r : reg, In r pr -> rs2 # r = rs # r","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"intros.\nrewrite OTHER2; auto."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H4 : In r pr) : rs2 # r = rs # r.","conclusion":"rs2 # r = rs # r","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) (r : reg) (H4 : In r pr)","proofString":"rewrite OTHER2; auto."},{"statement":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (a b c : condexpr) (va v : bool) (H : eval_condexpr ge sp e m le a va) (H0 : transl_condexpr_prop le a va) (H1 : eval_condexpr ge sp e m le (if va then b else c) v) (H2 : transl_condexpr_prop le (if va then b else c) v) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H8 : tr_condition (fn_code f) map pr a ns n2 n3) (H12 : tr_condition (fn_code f) map pr b n2 ntrue nfalse) (H13 : tr_condition (fn_code f) map pr c n3 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : plus step tge (State cs f sp ns rs tm) E0\n  (State cs f sp (if va then n2 else n3) rs1 tm1)) (ME1 : match_env map e le rs1) (OTHER1 : forall r : reg, In r pr -> rs1 # r = rs # r) (EXT1 : Mem.extends m tm1) (H3 : tr_condition (fn_code f) map pr (if va then b else c) \n  (if va then n2 else n3) ntrue nfalse) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp (if va then n2 else n3) rs1 tm1) E0\n  (State cs f sp (if v then ntrue else nfalse) rs2 tm2)) (ME2 : match_env map e le rs2) (OTHER2 : forall r : reg, In r pr -> rs2 # r = rs1 # r) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (TE : tr_condition (fn_code f) map pr (CElet a b) ns ntrue nfalse) (ME : match_env map e le rs) (EXT : Mem.extends m tm) : exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v2 then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v2 then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r : reg, In r pr -> rs' # r = rs # r) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (TE : tr_condition (fn_code f) map pr (CElet a b) ns ntrue nfalse) (ME : match_env map e le rs) (EXT : Mem.extends m tm)","proofString":"inv TE.\nexploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nassert (map_wf (add_letvar map r)).\neapply add_letvar_wf; eauto.\nexploit H2; eauto.\neapply match_env_bind_letvar; eauto.\nintros [rs2 [tm2 [EX2 [ME3 [OTHER2 EXT2]]]]].\nexists rs2; exists tm2.\nsplit.\neapply star_plus_trans.\neexact EX1.\neexact EX2.\ntraceEq.\nsplit.\neapply match_env_unbind_letvar; eauto.\nsplit.\nintros.\nrewrite OTHER2; auto.\nauto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) : exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v2 then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'.","conclusion":"exists (rs' : regset) (tm' : mem),\n  plus step tge (State cs f sp ns rs tm) E0\n    (State cs f sp (if v2 then ntrue else nfalse) rs' tm') /\\\n  match_env map e le rs' /\\\n  (forall r0 : reg, In r0 pr -> rs' # r0 = rs # r0) /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse)","proofString":"exploit H0; eauto.\nintros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].\nassert (map_wf (add_letvar map r)).\neapply add_letvar_wf; eauto.\nexploit H2; eauto.\neapply match_env_bind_letvar; eauto.\nintros [rs2 [tm2 [EX2 [ME3 [OTHER2 EXT2]]]]].\nexists rs2; exists tm2.\nsplit.\neapply star_plus_trans.\neexact EX1.\neexact EX2.\ntraceEq.\nsplit.\neapply match_env_unbind_letvar; eauto.\nsplit.\nintros.\nrewrite OTHER2; auto.\nauto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : match_env map e le rs2.","conclusion":"match_env map e le rs2","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"eapply match_env_unbind_letvar; eauto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : (forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0) /\\ Mem.extends m tm2.","conclusion":"(forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0) /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"split.\nintros.\nrewrite OTHER2; auto.\nauto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0.","conclusion":"forall r0 : reg, In r0 pr -> rs2 # r0 = rs # r0","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"intros.\nrewrite OTHER2; auto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r1 : reg, In r1 pr -> rs1 # r1 = rs # r1) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r1 : reg, In r1 pr -> rs2 # r1 = rs1 # r1) (EXT2 : Mem.extends m tm2) (r0 : reg) (H4 : In r0 pr) : rs2 # r0 = rs # r0.","conclusion":"rs2 # r0 = rs # r0","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r1 : reg, In r1 pr -> rs1 # r1 = rs # r1) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r1 : reg, In r1 pr -> rs2 # r1 = rs1 # r1) (EXT2 : Mem.extends m tm2) (r0 : reg) (H4 : In r0 pr)","proofString":"rewrite OTHER2; auto."},{"statement":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (a : expr) (b : condexpr) (v1 : val) (v2 : bool) (H : eval_expr ge sp e m le a v1) (H0 : transl_expr_prop le a v1) (H1 : eval_condexpr ge sp e m (v1 :: le) b v2) (H2 : transl_condexpr_prop (v1 :: le) b v2) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (pr : list reg) (ns ntrue nfalse : node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H5 : ~ reg_in_map map r) (H8 : tr_expr (fn_code f) map pr a ns n1 r None) (H12 : tr_condition (fn_code f) (add_letvar map r) pr b n1 ntrue nfalse) (rs1 : regset) (tm1 : mem) (EX1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v1 e) le rs1) (RES1 : Val.lessdef v1 rs1 # r) (OTHER1 : forall r0 : reg, In r0 pr -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H3 : map_wf (add_letvar map r)) (rs2 : regset) (tm2 : mem) (EX2 : plus step tge (State cs f sp n1 rs1 tm1) E0\n  (State cs f sp (if v2 then ntrue else nfalse) rs2 tm2)) (ME3 : match_env (add_letvar map r) e (v1 :: le) rs2) (OTHER2 : forall r0 : reg, In r0 pr -> rs2 # r0 = rs1 # r0) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns) : exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'.","conclusion":"exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns)","proofString":"exists ns, rs, tm.\nsplit.\napply star_refl.\nauto."},{"statement":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns) : star step tge (State cs f sp ns rs tm) E0 (State cs f sp ns rs tm) /\\\nnth_error nexits x = Some ns /\\ match_env map e le rs /\\ Mem.extends m tm.","conclusion":"star step tge (State cs f sp ns rs tm) E0 (State cs f sp ns rs tm) /\\\nnth_error nexits x = Some ns /\\ match_env map e le rs /\\ Mem.extends m tm","hypotheses":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns)","proofString":"split.\napply star_refl.\nauto."},{"statement":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns) : star step tge (State cs f sp ns rs tm) E0 (State cs f sp ns rs tm).","conclusion":"star step tge (State cs f sp ns rs tm) E0 (State cs f sp ns rs tm)","hypotheses":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns)","proofString":"apply star_refl."},{"statement":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns) : nth_error nexits x = Some ns /\\ match_env map e le rs /\\ Mem.extends m tm.","conclusion":"nth_error nexits x = Some ns /\\ match_env map e le rs /\\ Mem.extends m tm","hypotheses":"(le : letenv) (x : nat) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (H1 : nth_error nexits x = Some ns)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl')) : exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'.","conclusion":"exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl'))","proofString":"exploit H3; eauto.\nintros (nd & A & B).\nexploit transl_expr_correct; eauto.\nintros (rs1 & tm1 & EXEC1 & ME1 & RES1 & PRES1 & EXT1).\nexists nd, rs1, tm1.\nsplit.\neapply star_right.\neexact EXEC1.\neapply exec_Ijumptable; eauto.\ninv RES1; auto.\ntraceEq.\nauto."},{"statement":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl')) : (exists n0 : node,\n   list_nth_z tbl' (Int.unsigned n) = Some n0 /\\ nth_error nexits x = Some n0) ->\nexists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'.","conclusion":"(exists n0 : node,\n   list_nth_z tbl' (Int.unsigned n) = Some n0 /\\ nth_error nexits x = Some n0) ->\nexists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl'))","proofString":"intros (nd & A & B).\nexploit transl_expr_correct; eauto.\nintros (rs1 & tm1 & EXEC1 & ME1 & RES1 & PRES1 & EXT1).\nexists nd, rs1, tm1.\nsplit.\neapply star_right.\neexact EXEC1.\neapply exec_Ijumptable; eauto.\ninv RES1; auto.\ntraceEq.\nauto."},{"statement":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl')) (nd : node) (A : list_nth_z tbl' (Int.unsigned n) = Some nd) (B : nth_error nexits x = Some nd) : exists (nd0 : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd0 rs' tm') /\\\n  nth_error nexits x = Some nd0 /\\\n  match_env map e le rs' /\\ Mem.extends m tm'.","conclusion":"exists (nd0 : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd0 rs' tm') /\\\n  nth_error nexits x = Some nd0 /\\\n  match_env map e le rs' /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl')) (nd : node) (A : list_nth_z tbl' (Int.unsigned n) = Some nd) (B : nth_error nexits x = Some nd)","proofString":"exploit transl_expr_correct; eauto.\nintros (rs1 & tm1 & EXEC1 & ME1 & RES1 & PRES1 & EXT1).\nexists nd, rs1, tm1.\nsplit.\neapply star_right.\neexact EXEC1.\neapply exec_Ijumptable; eauto.\ninv RES1; auto.\ntraceEq.\nauto."},{"statement":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl')) (nd : node) (A : list_nth_z tbl' (Int.unsigned n) = Some nd) (B : nth_error nexits x = Some nd) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None (Vint n) e) le rs1) (RES1 : Val.lessdef (Vint n) rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) : rs1 # r = Vint n.","conclusion":"rs1 # r = Vint n","hypotheses":"(le : letenv) (a : expr) (tbl : list nat) (n : int) (x : nat) (H : eval_expr ge sp e m le a (Vint n)) (H0 : list_nth_z tbl (Int.unsigned n) = Some x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n1 : node) (r : reg) (tbl' : list node) (H3 : tr_jumptable nexits tbl tbl') (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : (fn_code f) ! n1 = Some (Ijumptable r tbl')) (nd : node) (A : list_nth_z tbl' (Int.unsigned n) = Some nd) (B : nth_error nexits x = Some nd) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None (Vint n) e) le rs1) (RES1 : Val.lessdef (Vint n) rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1)","proofString":"inv RES1; auto."},{"statement":"(le : letenv) (a : condexpr) (b c : exitexpr) (va : bool) (x : nat) (H : eval_condexpr ge sp e m le a va) (H0 : eval_exitexpr ge sp e m le (if va then b else c) x) (IHeval_exitexpr : transl_exitexpr_prop le (if va then b else c) x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H5 : tr_condition (fn_code f) map nil a ns n2 n3) (H8 : tr_exitexpr (fn_code f) map b n2 nexits) (H9 : tr_exitexpr (fn_code f) map c n3 nexits) : exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'.","conclusion":"exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : condexpr) (b c : exitexpr) (va : bool) (x : nat) (H : eval_condexpr ge sp e m le a va) (H0 : eval_exitexpr ge sp e m le (if va then b else c) x) (IHeval_exitexpr : transl_exitexpr_prop le (if va then b else c) x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (n2 n3 : node) (H5 : tr_condition (fn_code f) map nil a ns n2 n3) (H8 : tr_exitexpr (fn_code f) map b n2 nexits) (H9 : tr_exitexpr (fn_code f) map c n3 nexits)","proofString":"exploit transl_condexpr_correct; eauto.\nintros (rs1 & tm1 & EXEC1 & ME1 & RES1 & EXT1).\nexploit IHeval_exitexpr; eauto.\ninstantiate (2 := if va then n2 else n3).\ndestruct va; eauto.\nintros (nd & rs2 & tm2 & EXEC2 & EXIT2 & ME2 & EXT2).\nexists nd, rs2, tm2.\nsplit.\neapply star_trans.\napply plus_star.\neexact EXEC1.\neexact EXEC2.\ntraceEq.\nauto."},{"statement":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) : exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'.","conclusion":"exists (nd : node) (rs' : regset) (tm' : mem),\n  star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm') /\\\n  nth_error nexits x = Some nd /\\ match_env map e le rs' /\\ Mem.extends m tm'","hypotheses":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits)","proofString":"exploit transl_expr_correct; eauto.\nintros (rs1 & tm1 & EXEC1 & ME1 & RES1 & PRES1 & EXT1).\nassert (map_wf (add_letvar map r)).\neapply add_letvar_wf; eauto.\nexploit IHeval_exitexpr; eauto.\neapply match_env_bind_letvar; eauto.\nintros (nd & rs2 & tm2 & EXEC2 & EXIT2 & ME2 & EXT2).\nexists nd, rs2, tm2.\nsplit.\neapply star_trans.\neexact EXEC1.\neexact EXEC2.\ntraceEq.\nsplit.\nauto.\nsplit.\neapply match_env_unbind_letvar; eauto.\nauto."},{"statement":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2) : nth_error nexits x = Some nd.","conclusion":"nth_error nexits x = Some nd","hypotheses":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2) : match_env map e le rs2 /\\ Mem.extends m tm2.","conclusion":"match_env map e le rs2 /\\ Mem.extends m tm2","hypotheses":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2)","proofString":"split.\neapply match_env_unbind_letvar; eauto.\nauto."},{"statement":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2) : match_env map e le rs2.","conclusion":"match_env map e le rs2","hypotheses":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2)","proofString":"eapply match_env_unbind_letvar; eauto."},{"statement":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2) : Mem.extends m tm2.","conclusion":"Mem.extends m tm2","hypotheses":"(le : letenv) (a : expr) (b : exitexpr) (v : val) (x : nat) (H : eval_expr ge sp e m le a v) (H0 : eval_exitexpr ge sp e m (v :: le) b x) (IHeval_exitexpr : transl_exitexpr_prop (v :: le) b x) (tm : mem) (cs : list stackframe) (f : function) (map : mapping) (ns : node) (nexits : list node) (rs : regset) (MWF : map_wf map) (ME : match_env map e le rs) (EXT : Mem.extends m tm) (r : reg) (n1 : node) (H3 : ~ reg_in_map map r) (H5 : tr_expr (fn_code f) map nil a ns n1 r None) (H8 : tr_exitexpr (fn_code f) (add_letvar map r) b n1 nexits) (rs1 : regset) (tm1 : mem) (EXEC1 : star step tge (State cs f sp ns rs tm) E0 (State cs f sp n1 rs1 tm1)) (ME1 : match_env map (set_optvar None v e) le rs1) (RES1 : Val.lessdef v rs1 # r) (PRES1 : forall r0 : reg, In r0 nil -> rs1 # r0 = rs # r0) (EXT1 : Mem.extends m tm1) (H1 : map_wf (add_letvar map r)) (nd : node) (rs2 : regset) (tm2 : mem) (EXEC2 : star step tge (State cs f sp n1 rs1 tm1) E0 (State cs f sp nd rs2 tm2)) (EXIT2 : nth_error nexits x = Some nd) (ME2 : match_env (add_letvar map r) e (v :: le) rs2) (EXT2 : Mem.extends m tm2)","proofString":"auto."},{"statement":"(le : letenv) (al2 : list expr) (vl2 : list val) (E2 : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2) : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) (nil ++ vl2).","conclusion":"eval_exprlist ge sp e m le (exprlist_of_expr_list al2) (nil ++ vl2)","hypotheses":"(le : letenv) (al2 : list expr) (vl2 : list val) (E2 : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (al1 : list expr) (IHal1 : forall (vl1 : list val) (al0 : list expr) (vl0 : list val),\neval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list al0) vl0 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al0)) (vl1 ++ vl0)) (al2 : list expr) (vl2 : list val) (E2 : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2) (v1 : val) (vl : list val) (H2 : eval_expr ge sp e m le a v1) (H4 : eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl) : eval_exprlist ge sp e m le (Econs a (exprlist_of_expr_list (al1 ++ al2)))\n  ((v1 :: vl) ++ vl2).","conclusion":"eval_exprlist ge sp e m le (Econs a (exprlist_of_expr_list (al1 ++ al2)))\n  ((v1 :: vl) ++ vl2)","hypotheses":"(le : letenv) (a : expr) (al1 : list expr) (IHal1 : forall (vl1 : list val) (al0 : list expr) (vl0 : list val),\neval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list al0) vl0 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al0)) (vl1 ++ vl0)) (al2 : list expr) (vl2 : list val) (E2 : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2) (v1 : val) (vl : list val) (H2 : eval_expr ge sp e m le a v1) (H4 : eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl)","proofString":"simpl.\nconstructor; eauto."},{"statement":"(le : letenv) (a : expr) (al1 : list expr) (IHal1 : forall (vl1 : list val) (al0 : list expr) (vl0 : list val),\neval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list al0) vl0 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al0)) (vl1 ++ vl0)) (al2 : list expr) (vl2 : list val) (E2 : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2) (v1 : val) (vl : list val) (H2 : eval_expr ge sp e m le a v1) (H4 : eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl) : eval_exprlist ge sp e m le (Econs a (exprlist_of_expr_list (al1 ++ al2)))\n  (v1 :: vl ++ vl2).","conclusion":"eval_exprlist ge sp e m le (Econs a (exprlist_of_expr_list (al1 ++ al2)))\n  (v1 :: vl ++ vl2)","hypotheses":"(le : letenv) (a : expr) (al1 : list expr) (IHal1 : forall (vl1 : list val) (al0 : list expr) (vl0 : list val),\neval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list al0) vl0 ->\neval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al0)) (vl1 ++ vl0)) (al2 : list expr) (vl2 : list val) (E2 : eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2) (v1 : val) (vl : list val) (H2 : eval_expr ge sp e m le a v1) (H4 : eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl)","proofString":"constructor; eauto."},{"statement":"exists vl' : list val,\n  eval_exprlist ge sp e m nil Enil vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m nil nil.","conclusion":"exists vl' : list val,\n  eval_exprlist ge sp e m nil Enil vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m nil nil","hypotheses":"","proofString":"exists (@nil val); split; constructor."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl')\n    bl) : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl).","conclusion":"exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl')\n    bl)","proofString":"exploit invert_eval_builtin_arg; eauto.\nintros (vl1 & A & B & C).\ndestruct IHlist_forall2 as (vl2 & D & E).\nexists (vl1 ++ vl2); split.\napply eval_exprlist_append; auto.\nrewrite C; simpl.\nconstructor; auto."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl')\n    bl) : (exists vl : list val,\n   eval_exprlist ge sp e m nil\n     (exprlist_of_expr_list (params_of_builtin_arg a1)) vl /\\\n   Events.eval_builtin_arg ge (fun v : val => v) sp m\n     (fst (convert_builtin_arg a1 vl)) b1 /\\\n   (forall vl' : list val,\n    convert_builtin_arg a1 (vl ++ vl') =\n    (fst (convert_builtin_arg a1 vl), vl'))) ->\nexists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl).","conclusion":"(exists vl : list val,\n   eval_exprlist ge sp e m nil\n     (exprlist_of_expr_list (params_of_builtin_arg a1)) vl /\\\n   Events.eval_builtin_arg ge (fun v : val => v) sp m\n     (fst (convert_builtin_arg a1 vl)) b1 /\\\n   (forall vl' : list val,\n    convert_builtin_arg a1 (vl ++ vl') =\n    (fst (convert_builtin_arg a1 vl), vl'))) ->\nexists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl')\n    bl)","proofString":"intros (vl1 & A & B & C).\ndestruct IHlist_forall2 as (vl2 & D & E).\nexists (vl1 ++ vl2); split.\napply eval_exprlist_append; auto.\nrewrite C; simpl.\nconstructor; auto."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl')\n    bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl')) : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl).","conclusion":"exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl')\n    bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl'))","proofString":"destruct IHlist_forall2 as (vl2 & D & E).\nexists (vl1 ++ vl2); split.\napply eval_exprlist_append; auto.\nrewrite C; simpl.\nconstructor; auto."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl')) : exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl).","conclusion":"exists vl' : list val,\n  eval_exprlist ge sp e m nil\n    (exprlist_of_expr_list\n       (params_of_builtin_arg a1 ++ params_of_builtin_args al)) vl' /\\\n  eval_builtin_args ge (fun v : val => v) sp m\n    (let (a1', rl1) := convert_builtin_arg a1 vl' in\n     a1' :: convert_builtin_args al rl1) (b1 :: bl)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl'))","proofString":"exists (vl1 ++ vl2); split.\napply eval_exprlist_append; auto.\nrewrite C; simpl.\nconstructor; auto."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl')) : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list\n     (params_of_builtin_arg a1 ++ params_of_builtin_args al)) \n  (vl1 ++ vl2).","conclusion":"eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list\n     (params_of_builtin_arg a1 ++ params_of_builtin_args al)) \n  (vl1 ++ vl2)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl'))","proofString":"apply eval_exprlist_append; auto."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl')) : eval_builtin_args ge (fun v : val => v) sp m\n  (let (a1', rl1) := convert_builtin_arg a1 (vl1 ++ vl2) in\n   a1' :: convert_builtin_args al rl1) (b1 :: bl).","conclusion":"eval_builtin_args ge (fun v : val => v) sp m\n  (let (a1', rl1) := convert_builtin_arg a1 (vl1 ++ vl2) in\n   a1' :: convert_builtin_args al rl1) (b1 :: bl)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl'))","proofString":"rewrite C; simpl.\nconstructor; auto."},{"statement":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl')) : eval_builtin_args ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1) :: convert_builtin_args al vl2)\n  (b1 :: bl).","conclusion":"eval_builtin_args ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1) :: convert_builtin_args al vl2)\n  (b1 :: bl)","hypotheses":"(a1 : builtin_arg expr) (al : list (builtin_arg expr)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge sp e m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge sp e m) al bl) (vl2 : list val) (D : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vl2) (E : eval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl2) bl) (vl1 : list val) (A : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_arg a1)) vl1) (B : Events.eval_builtin_arg ge (fun v : val => v) sp m\n  (fst (convert_builtin_arg a1 vl1)) b1) (C : forall vl' : list val,\nconvert_builtin_arg a1 (vl1 ++ vl') = (fst (convert_builtin_arg a1 vl1), vl'))","proofString":"constructor; auto."},{"statement":"(rs : Regmap.t val) (x : expr) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     match vl with\n     | nil => (BA_int Int.zero, nil)\n     | r :: rs0 => (BA r, rs0)\n     end) v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       match rl with\n       | nil => (BA_int Int.zero, nil)\n       | r :: rs0 => (BA r, rs0)\n       end) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       match vl with\n       | nil => (BA_int Int.zero, nil)\n       | r :: rs0 => (BA r, rs0)\n       end)\n    rs\n    ## (snd\n          match rl with\n          | nil => (BA_int Int.zero, nil)\n          | r :: rs0 => (BA r, rs0)\n          end).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       match rl with\n       | nil => (BA_int Int.zero, nil)\n       | r :: rs0 => (BA r, rs0)\n       end) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       match vl with\n       | nil => (BA_int Int.zero, nil)\n       | r :: rs0 => (BA r, rs0)\n       end)\n    rs\n    ## (snd\n          match rl with\n          | nil => (BA_int Int.zero, nil)\n          | r :: rs0 => (BA r, rs0)\n          end)","hypotheses":"(rs : Regmap.t val) (x : expr) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     match vl with\n     | nil => (BA_int Int.zero, nil)\n     | r :: rs0 => (BA r, rs0)\n     end) v)","proofString":"destruct rl; simpl in LD; inv LD; inv EV; simpl.\neconstructor; eauto with barg.\nexists (rs#p); intuition auto.\nconstructor."},{"statement":"(rs : Regmap.t val) (x : expr) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_int Int.zero) v' /\\\n  Val.lessdef (Vint Int.zero) v' /\\ Val.lessdef_list nil nil.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_int Int.zero) v' /\\\n  Val.lessdef (Vint Int.zero) v' /\\ Val.lessdef_list nil nil","hypotheses":"(rs : Regmap.t val) (x : expr)","proofString":"econstructor; eauto with barg."},{"statement":"(rs : Regmap.t val) (x : expr) (p : positive) (rl : list positive) (v : val) (vl1 : list val) (H2 : Val.lessdef v rs # p) (H3 : Val.lessdef_list vl1 rs ## rl) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA p) v' /\\\n  Val.lessdef v v' /\\ Val.lessdef_list vl1 rs ## rl.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA p) v' /\\\n  Val.lessdef v v' /\\ Val.lessdef_list vl1 rs ## rl","hypotheses":"(rs : Regmap.t val) (x : expr) (p : positive) (rl : list positive) (v : val) (vl1 : list val) (H2 : Val.lessdef v rs # p) (H3 : Val.lessdef_list vl1 rs ## rl)","proofString":"exists (rs#p); intuition auto.\nconstructor."},{"statement":"(rs : Regmap.t val) (x : expr) (p : positive) (rl : list positive) (v : val) (vl1 : list val) (H2 : Val.lessdef v rs # p) (H3 : Val.lessdef_list vl1 rs ## rl) : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA p) rs # p.","conclusion":"Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA p) rs # p","hypotheses":"(rs : Regmap.t val) (x : expr) (p : positive) (rl : list positive) (v : val) (vl1 : list val) (H2 : Val.lessdef v rs # p) (H3 : Val.lessdef_list vl1 rs ## rl)","proofString":"constructor."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (hi', rl1) := convert_builtin_arg a1 vl in\n      let (lo', rl2) := convert_builtin_arg a2 rl1 in\n      (BA_splitlong hi' lo', rl2))) v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (hi', rl1) := convert_builtin_arg a1 rl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (hi', rl1) := convert_builtin_arg a1 vl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2)))\n    rs\n    ## (snd\n          (let (hi', rl1) := convert_builtin_arg a1 rl in\n           let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong hi' lo', rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (hi', rl1) := convert_builtin_arg a1 rl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (hi', rl1) := convert_builtin_arg a1 vl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2)))\n    rs\n    ## (snd\n          (let (hi', rl1) := convert_builtin_arg a1 rl in\n           let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong hi' lo', rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (hi', rl1) := convert_builtin_arg a1 vl in\n      let (lo', rl2) := convert_builtin_arg a2 rl1 in\n      (BA_splitlong hi' lo', rl2))) v)","proofString":"destruct (convert_builtin_arg a1 vl) as [a1' vl1] eqn:CV1; simpl in *.\ndestruct (convert_builtin_arg a2 vl1) as [a2' vl2] eqn:CV2; simpl in *.\ndestruct (convert_builtin_arg a1 rl) as [a1'' rl1] eqn:CV3; simpl in *.\ndestruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (lo', rl2) := convert_builtin_arg a2 vl1 in\n      (BA_splitlong a1' lo', rl2))) v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (hi', rl1) := convert_builtin_arg a1 rl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (lo', rl2) := convert_builtin_arg a2 vl1 in\n        (BA_splitlong a1' lo', rl2)))\n    rs\n    ## (snd\n          (let (hi', rl1) := convert_builtin_arg a1 rl in\n           let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong hi' lo', rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (hi', rl1) := convert_builtin_arg a1 rl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (lo', rl2) := convert_builtin_arg a2 vl1 in\n        (BA_splitlong a1' lo', rl2)))\n    rs\n    ## (snd\n          (let (hi', rl1) := convert_builtin_arg a1 rl in\n           let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong hi' lo', rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (lo', rl2) := convert_builtin_arg a2 vl1 in\n      (BA_splitlong a1' lo', rl2))) v)","proofString":"destruct (convert_builtin_arg a2 vl1) as [a2' vl2] eqn:CV2; simpl in *.\ndestruct (convert_builtin_arg a1 rl) as [a1'' rl1] eqn:CV3; simpl in *.\ndestruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_splitlong a1' a2') v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (hi', rl1) := convert_builtin_arg a1 rl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (hi', rl1) := convert_builtin_arg a1 rl in\n           let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong hi' lo', rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (hi', rl1) := convert_builtin_arg a1 rl in\n        let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong hi' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (hi', rl1) := convert_builtin_arg a1 rl in\n           let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong hi' lo', rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_splitlong a1' a2') v)","proofString":"destruct (convert_builtin_arg a1 rl) as [a1'' rl1] eqn:CV3; simpl in *.\ndestruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_splitlong a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong a1'' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong a1'' lo', rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (lo', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_splitlong a1'' lo', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (lo', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_splitlong a1'' lo', rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_splitlong a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1))","proofString":"destruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_splitlong a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef v v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef v v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_splitlong a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2))","proofString":"inv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo)","proofString":"exploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) : (exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v' /\\\n   Val.lessdef vhi v' /\\ Val.lessdef_list vl1 rs ## rl1) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"(exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v' /\\\n   Val.lessdef vhi v' /\\ Val.lessdef_list vl1 rs ## rl1) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo)","proofString":"intros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1)","proofString":"exploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) : (exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v' /\\\n   Val.lessdef vlo v' /\\ Val.lessdef_list vl2 rs ## rl2) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"(exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v' /\\\n   Val.lessdef vlo v' /\\ Val.lessdef_list vl2 rs ## rl2) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1)","proofString":"intros (v2' & A2 & B2 & C2).\nexists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_splitlong a1'' a2'') v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2)","proofString":"exists (Val.longofwords v1' v2'); split.\nconstructor; auto.\nsplit; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2) : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (BA_splitlong a1'' a2'') (Val.longofwords v1' v2').","conclusion":"Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (BA_splitlong a1'' a2'') (Val.longofwords v1' v2')","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2)","proofString":"constructor; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2) : Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1' v2') /\\\nVal.lessdef_list vl2 rs ## rl2.","conclusion":"Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1' v2') /\\\nVal.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2)","proofString":"split; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2) : Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1' v2').","conclusion":"Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1' v2')","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (vhi vlo : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' vhi) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' vlo) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef vhi v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef vlo v2') (C2 : Val.lessdef_list vl2 rs ## rl2)","proofString":"apply Val.longofwords_lessdef; auto."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (a1', rl1) := convert_builtin_arg a1 vl in\n      let (a2', rl2) := convert_builtin_arg a2 rl1 in\n      (BA_addptr a1' a2', rl2))) v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a1', rl1) := convert_builtin_arg a1 rl in\n        let (a2', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1' a2', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (a1', rl1) := convert_builtin_arg a1 vl in\n        let (a2', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1' a2', rl2)))\n    rs\n    ## (snd\n          (let (a1', rl1) := convert_builtin_arg a1 rl in\n           let (a2', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1' a2', rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a1', rl1) := convert_builtin_arg a1 rl in\n        let (a2', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1' a2', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (a1', rl1) := convert_builtin_arg a1 vl in\n        let (a2', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1' a2', rl2)))\n    rs\n    ## (snd\n          (let (a1', rl1) := convert_builtin_arg a1 rl in\n           let (a2', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1' a2', rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (a1', rl1) := convert_builtin_arg a1 vl in\n      let (a2', rl2) := convert_builtin_arg a2 rl1 in\n      (BA_addptr a1' a2', rl2))) v)","proofString":"destruct (convert_builtin_arg a1 vl) as [a1' vl1] eqn:CV1; simpl in *.\ndestruct (convert_builtin_arg a2 vl1) as [a2' vl2] eqn:CV2; simpl in *.\ndestruct (convert_builtin_arg a1 rl) as [a1'' rl1] eqn:CV3; simpl in *.\ndestruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (a2', rl2) := convert_builtin_arg a2 vl1 in\n      (BA_addptr a1' a2', rl2))) v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n        let (a2', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1'0 a2', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (a2', rl2) := convert_builtin_arg a2 vl1 in\n        (BA_addptr a1' a2', rl2)))\n    rs\n    ## (snd\n          (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n           let (a2', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1'0 a2', rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n        let (a2', rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1'0 a2', rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list\n    (snd\n       (let (a2', rl2) := convert_builtin_arg a2 vl1 in\n        (BA_addptr a1' a2', rl2)))\n    rs\n    ## (snd\n          (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n           let (a2', rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1'0 a2', rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst\n     (let (a2', rl2) := convert_builtin_arg a2 vl1 in\n      (BA_addptr a1' a2', rl2))) v)","proofString":"destruct (convert_builtin_arg a2 vl1) as [a2' vl2] eqn:CV2; simpl in *.\ndestruct (convert_builtin_arg a1 rl) as [a1'' rl1] eqn:CV3; simpl in *.\ndestruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_addptr a1' a2') v) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n        let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1'0 a2'0, rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n           let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1'0 a2'0, rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n        let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1'0 a2'0, rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (a1'0, rl1) := convert_builtin_arg a1 rl in\n           let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1'0 a2'0, rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_addptr a1' a2') v)","proofString":"destruct (convert_builtin_arg a1 rl) as [a1'' rl1] eqn:CV3; simpl in *.\ndestruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_addptr a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1'' a2'0, rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1'' a2'0, rl2))).","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst\n       (let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n        (BA_addptr a1'' a2'0, rl2))) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list vl2\n    rs\n    ## (snd\n          (let (a2'0, rl2) := convert_builtin_arg a2 rl1 in\n           (BA_addptr a1'' a2'0, rl2)))","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_addptr a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1))","proofString":"destruct (convert_builtin_arg a2 rl1) as [a2'' rl2] eqn:CV4; simpl in *.\ninv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_addptr a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef v v' /\\ Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef v v' /\\ Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a1 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v0 : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v1 : val => v1) sp m\n  (fst (convert_builtin_arg a2 vl0)) v0 ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v0 v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (v : val) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (EV : Events.eval_builtin_arg ge (fun v0 : val => v0) sp m (BA_addptr a1' a2') v) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2))","proofString":"inv EV.\nexploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2)","proofString":"exploit IHa1; eauto.\nrewrite CV1; simpl; eauto.\nrewrite CV1, CV3; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) : (exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v' /\\\n   Val.lessdef v1 v' /\\ Val.lessdef_list vl1 rs ## rl1) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2.","conclusion":"(exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v' /\\\n   Val.lessdef v1 v' /\\ Val.lessdef_list vl1 rs ## rl1) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2)","proofString":"intros (v1' & A1 & B1 & C1).\nexploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1)","proofString":"exploit IHa2.\neexact C1.\nrewrite CV2; simpl; eauto.\nrewrite CV2, CV4; simpl.\nintros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1) : (exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v' /\\\n   Val.lessdef v2 v' /\\ Val.lessdef_list vl2 rs ## rl2) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2.","conclusion":"(exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v' /\\\n   Val.lessdef v2 v' /\\ Val.lessdef_list vl2 rs ## rl2) ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1)","proofString":"intros (v2' & A2 & B2 & C2).\neconstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef v2 v2') (C2 : Val.lessdef_list vl2 rs ## rl2) : exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2.","conclusion":"exists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (BA_addptr a1'' a2'') v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v' /\\\n  Val.lessdef_list vl2 rs ## rl2","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef v2 v2') (C2 : Val.lessdef_list vl2 rs ## rl2)","proofString":"econstructor; split.\nconstructor; eauto.\nsplit; auto.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef v2 v2') (C2 : Val.lessdef_list vl2 rs ## rl2) : Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)\n  (if Archi.ptr64 then Val.addl v1' v2' else Val.add v1' v2').","conclusion":"Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)\n  (if Archi.ptr64 then Val.addl v1' v2' else Val.add v1' v2')","hypotheses":"(rs : Regmap.t val) (a1 a2 : builtin_arg expr) (IHa1 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a1 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a1 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a1 vl0))\n    rs ## (snd (convert_builtin_arg a1 rl0))) (IHa2 : forall (vl0 : list val) (rl0 : list positive) (v : val),\nVal.lessdef_list vl0 rs ## rl0 ->\nEvents.eval_builtin_arg ge (fun v0 : val => v0) sp m\n  (fst (convert_builtin_arg a2 vl0)) v ->\nexists v' : val,\n  Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n    (fst (convert_builtin_arg a2 rl0)) v' /\\\n  Val.lessdef v v' /\\\n  Val.lessdef_list (snd (convert_builtin_arg a2 vl0))\n    rs ## (snd (convert_builtin_arg a2 rl0))) (vl : list val) (rl : list positive) (LD : Val.lessdef_list vl rs ## rl) (a1' : builtin_arg val) (vl1 : list val) (CV1 : convert_builtin_arg a1 vl = (a1', vl1)) (a2' : builtin_arg val) (vl2 : list val) (CV2 : convert_builtin_arg a2 vl1 = (a2', vl2)) (a1'' : builtin_arg positive) (rl1 : list positive) (CV3 : convert_builtin_arg a1 rl = (a1'', rl1)) (a2'' : builtin_arg positive) (rl2 : list positive) (CV4 : convert_builtin_arg a2 rl1 = (a2'', rl2)) (v1 v2 : val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' v1) (H3 : Events.eval_builtin_arg ge (fun v : val => v) sp m a2' v2) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef v1 v1') (C1 : Val.lessdef_list vl1 rs ## rl1) (v2' : val) (A2 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a2'' v2') (B2 : Val.lessdef v2 v2') (C2 : Val.lessdef_list vl2 rs ## rl2)","proofString":"destruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(rs : Regmap.t val) (vl1 : list val) (rl : list positive) (vl : list val) (LD : Val.lessdef_list vl1 rs ## rl) (EV : eval_builtin_args ge (fun v : val => v) sp m nil vl) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m nil vl' /\\\n  Val.lessdef_list vl vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m nil vl' /\\\n  Val.lessdef_list vl vl'","hypotheses":"(rs : Regmap.t val) (vl1 : list val) (rl : list positive) (vl : list val) (LD : Val.lessdef_list vl1 rs ## rl) (EV : eval_builtin_args ge (fun v : val => v) sp m nil vl)","proofString":"inv EV.\nexists (@nil val); split; constructor."},{"statement":"(rs : Regmap.t val) (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m nil vl' /\\\n  Val.lessdef_list nil vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m nil vl' /\\\n  Val.lessdef_list nil vl'","hypotheses":"(rs : Regmap.t val) (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl)","proofString":"exists (@nil val); split; constructor."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl2 : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0)\n  vl2 ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl2 vl') (vl1 : list val) (rl : list positive) (vl : list val) (LD : Val.lessdef_list vl1 rs ## rl) (EV : eval_builtin_args ge (fun v : val => v) sp m\n  (let (a1', rl1) := convert_builtin_arg a vl1 in\n   a1' :: convert_builtin_args al rl1) vl) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1', rl1) := convert_builtin_arg a rl in\n     a1' :: convert_builtin_args al rl1) vl' /\\ Val.lessdef_list vl vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1', rl1) := convert_builtin_arg a rl in\n     a1' :: convert_builtin_args al rl1) vl' /\\ Val.lessdef_list vl vl'","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl2 : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0)\n  vl2 ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl2 vl') (vl1 : list val) (rl : list positive) (vl : list val) (LD : Val.lessdef_list vl1 rs ## rl) (EV : eval_builtin_args ge (fun v : val => v) sp m\n  (let (a1', rl1) := convert_builtin_arg a vl1 in\n   a1' :: convert_builtin_args al rl1) vl)","proofString":"destruct (convert_builtin_arg a vl1) as [a1' vl2] eqn:CV1; simpl in *.\ninv EV.\nexploit transl_eval_builtin_arg.\neauto.\ninstantiate (2 := a).\nrewrite CV1; simpl; eauto.\nrewrite CV1; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHal.\neexact C1.\neauto.\nintros (vl' & A2 & B2).\ndestruct (convert_builtin_arg a rl) as [a1'' rl2]; simpl in *.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl3 : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0)\n  vl3 ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl3 vl') (vl1 : list val) (rl : list positive) (vl : list val) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (EV : eval_builtin_args ge (fun v : val => v) sp m\n  (a1' :: convert_builtin_args al vl2) vl) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\ Val.lessdef_list vl vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\ Val.lessdef_list vl vl'","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl3 : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0)\n  vl3 ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl3 vl') (vl1 : list val) (rl : list positive) (vl : list val) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (EV : eval_builtin_args ge (fun v : val => v) sp m\n  (a1' :: convert_builtin_args al vl2) vl)","proofString":"inv EV.\nexploit transl_eval_builtin_arg.\neauto.\ninstantiate (2 := a).\nrewrite CV1; simpl; eauto.\nrewrite CV1; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHal.\neexact C1.\neauto.\nintros (vl' & A2 & B2).\ndestruct (convert_builtin_arg a rl) as [a1'' rl2]; simpl in *.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl vl') (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl vl') (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl)","proofString":"exploit transl_eval_builtin_arg.\neauto.\ninstantiate (2 := a).\nrewrite CV1; simpl; eauto.\nrewrite CV1; simpl.\nintros (v1' & A1 & B1 & C1).\nexploit IHal.\neexact C1.\neauto.\nintros (vl' & A2 & B2).\ndestruct (convert_builtin_arg a rl) as [a1'' rl2]; simpl in *.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl vl') (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) : (exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n     (fst (convert_builtin_arg a rl)) v' /\\\n   Val.lessdef b1 v' /\\\n   Val.lessdef_list vl2 rs ## (snd (convert_builtin_arg a rl))) ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"(exists v' : val,\n   Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n     (fst (convert_builtin_arg a rl)) v' /\\\n   Val.lessdef b1 v' /\\\n   Val.lessdef_list vl2 rs ## (snd (convert_builtin_arg a rl))) ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl vl') (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl)","proofString":"intros (v1' & A1 & B1 & C1).\nexploit IHal.\neexact C1.\neauto.\nintros (vl' & A2 & B2).\ndestruct (convert_builtin_arg a rl) as [a1'' rl2]; simpl in *.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl vl') (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (fst (convert_builtin_arg a rl)) v1') (B1 : Val.lessdef b1 v1') (C1 : Val.lessdef_list vl2 rs ## (snd (convert_builtin_arg a rl))) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl' /\\ Val.lessdef_list vl vl') (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (fst (convert_builtin_arg a rl)) v1') (B1 : Val.lessdef b1 v1') (C1 : Val.lessdef_list vl2 rs ## (snd (convert_builtin_arg a rl)))","proofString":"exploit IHal.\neexact C1.\neauto.\nintros (vl' & A2 & B2).\ndestruct (convert_builtin_arg a rl) as [a1'' rl2]; simpl in *.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl'0 /\\ Val.lessdef_list vl vl'0) (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (fst (convert_builtin_arg a rl)) v1') (B1 : Val.lessdef b1 v1') (C1 : Val.lessdef_list vl2 rs ## (snd (convert_builtin_arg a rl))) (vl' : list val) (A2 : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (convert_builtin_args al (snd (convert_builtin_arg a rl))) vl') (B2 : Val.lessdef_list bl vl') : exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (let (a1'0, rl1) := convert_builtin_arg a rl in\n     a1'0 :: convert_builtin_args al rl1) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl'0 /\\ Val.lessdef_list vl vl'0) (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) (v1' : val) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (fst (convert_builtin_arg a rl)) v1') (B1 : Val.lessdef b1 v1') (C1 : Val.lessdef_list vl2 rs ## (snd (convert_builtin_arg a rl))) (vl' : list val) (A2 : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (convert_builtin_args al (snd (convert_builtin_arg a rl))) vl') (B2 : Val.lessdef_list bl vl')","proofString":"destruct (convert_builtin_arg a rl) as [a1'' rl2]; simpl in *.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl'0 /\\ Val.lessdef_list vl vl'0) (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) (v1' : val) (a1'' : builtin_arg positive) (rl2 : list positive) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef b1 v1') (C1 : Val.lessdef_list vl2 rs ## rl2) (vl' : list val) (A2 : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (convert_builtin_args al rl2) vl') (B2 : Val.lessdef_list bl vl') : exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (a1'' :: convert_builtin_args al rl2) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (a1'' :: convert_builtin_args al rl2) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(rs : Regmap.t val) (a : builtin_arg expr) (al : list (builtin_arg expr)) (IHal : forall (vl0 : list val) (rl0 : list positive) (vl : list val),\nVal.lessdef_list vl0 rs ## rl0 ->\neval_builtin_args ge (fun v : val => v) sp m (convert_builtin_args al vl0) vl ->\nexists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (convert_builtin_args al rl0) vl'0 /\\ Val.lessdef_list vl vl'0) (vl1 : list val) (rl : list positive) (LD : Val.lessdef_list vl1 rs ## rl) (a1' : builtin_arg val) (vl2 : list val) (CV1 : convert_builtin_arg a vl1 = (a1', vl2)) (b1 : val) (bl : list val) (H1 : Events.eval_builtin_arg ge (fun v : val => v) sp m a1' b1) (H3 : list_forall2 (Events.eval_builtin_arg ge (fun v : val => v) sp m)\n  (convert_builtin_args al vl2) bl) (v1' : val) (a1'' : builtin_arg positive) (rl2 : list positive) (A1 : Events.eval_builtin_arg ge (fun r : positive => rs # r) sp m a1'' v1') (B1 : Val.lessdef b1 v1') (C1 : Val.lessdef_list vl2 rs ## rl2) (vl' : list val) (A2 : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (convert_builtin_args al rl2) vl') (B2 : Val.lessdef_list bl vl')","proofString":"exists (v1' :: vl'); split; constructor; auto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (H : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/\nsize_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\\nsize_stmt s1 < size_stmt s2) : lt_state (CminorSel.State f1 s1 k1 sp1 e1 m1)\n  (CminorSel.State f2 s2 k2 sp2 e2 m2).","conclusion":"lt_state (CminorSel.State f1 s1 k1 sp1 e1 m1)\n  (CminorSel.State f2 s2 k2 sp2 e2 m2)","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (H : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/\nsize_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\\nsize_stmt s1 < size_stmt s2)","proofString":"unfold lt_state.\nsimpl.\ndestruct H as [A | [A B]].\nleft.\nauto.\nrewrite A.\nright.\nauto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (H : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/\nsize_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\\nsize_stmt s1 < size_stmt s2) : lex_ord lt lt (measure_state (CminorSel.State f1 s1 k1 sp1 e1 m1))\n  (measure_state (CminorSel.State f2 s2 k2 sp2 e2 m2)).","conclusion":"lex_ord lt lt (measure_state (CminorSel.State f1 s1 k1 sp1 e1 m1))\n  (measure_state (CminorSel.State f2 s2 k2 sp2 e2 m2))","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (H : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/\nsize_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\\nsize_stmt s1 < size_stmt s2)","proofString":"simpl.\ndestruct H as [A | [A B]].\nleft.\nauto.\nrewrite A.\nright.\nauto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (H : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/\nsize_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\\nsize_stmt s1 < size_stmt s2) : lex_ord lt lt (size_stmt s1 + size_cont k1, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2).","conclusion":"lex_ord lt lt (size_stmt s1 + size_cont k1, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2)","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (H : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/\nsize_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\\nsize_stmt s1 < size_stmt s2)","proofString":"destruct H as [A | [A B]].\nleft.\nauto.\nrewrite A.\nright.\nauto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2) : lex_ord lt lt (size_stmt s1 + size_cont k1, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2).","conclusion":"lex_ord lt lt (size_stmt s1 + size_cont k1, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2)","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2)","proofString":"left.\nauto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2) : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2.","conclusion":"size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2)","proofString":"auto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2) (B : size_stmt s1 < size_stmt s2) : lex_ord lt lt (size_stmt s1 + size_cont k1, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2).","conclusion":"lex_ord lt lt (size_stmt s1 + size_cont k1, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2)","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2) (B : size_stmt s1 < size_stmt s2)","proofString":"rewrite A.\nright.\nauto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2) (B : size_stmt s1 < size_stmt s2) : lex_ord lt lt (size_stmt s2 + size_cont k2, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2).","conclusion":"lex_ord lt lt (size_stmt s2 + size_cont k2, size_stmt s1)\n  (size_stmt s2 + size_cont k2, size_stmt s2)","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2) (B : size_stmt s1 < size_stmt s2)","proofString":"right.\nauto."},{"statement":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2) (B : size_stmt s1 < size_stmt s2) : size_stmt s1 < size_stmt s2.","conclusion":"size_stmt s1 < size_stmt s2","hypotheses":"(f1 : CminorSel.function) (s1 : stmt) (k1 : cont) (sp1 : val) (e1 : env) (m1 : mem) (f2 : CminorSel.function) (s2 : stmt) (k2 : cont) (sp2 : val) (e2 : env) (m2 : mem) (A : size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2) (B : size_stmt s1 < size_stmt s2)","proofString":"auto."},{"statement":"well_founded\n  (fun S1 S2 : CminorSel.state =>\n   lex_ord lt lt (measure_state S1) (measure_state S2)).","conclusion":"well_founded\n  (fun S1 S2 : CminorSel.state =>\n   lex_ord lt lt (measure_state S1) (measure_state S2))","hypotheses":"","proofString":"apply wf_inverse_image with (f := measure_state).\napply wf_lex_ord.\napply lt_wf.\napply lt_wf."},{"statement":"well_founded (lex_ord lt lt).","conclusion":"well_founded (lex_ord lt lt)","hypotheses":"","proofString":"apply wf_lex_ord.\napply lt_wf.\napply lt_wf."},{"statement":"well_founded lt.","conclusion":"well_founded lt","hypotheses":"","proofString":"apply lt_wf."},{"statement":"well_founded lt.","conclusion":"well_founded lt","hypotheses":"","proofString":"apply lt_wf."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) : match find_label lbl s1 (Kseq s2 k) with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k') ->\ntr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"match find_label lbl s1 (Kseq s2 k) with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k') ->\ntr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node)","proofString":"caseEq (find_label lbl s1 (Kseq s2 k)); intros.\ninv H1.\ninv H2.\neapply IHs1; eauto.\neconstructor; eauto.\ninv H2.\neapply IHs2; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (p : stmt * cont) (H0 : find_label lbl s1 (Kseq s2 k) = Some p) (H1 : Some p = Some (s', k')) (H2 : tr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (p : stmt * cont) (H0 : find_label lbl s1 (Kseq s2 k) = Some p) (H1 : Some p = Some (s', k')) (H2 : tr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H1.\ninv H2.\neapply IHs1; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H2 : tr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H2 : tr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H2.\neapply IHs1; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n0 : node) (H5 : tr_stmt c map s2 n0 nd1 nexits1 ngoto nret rret) (H12 : tr_stmt c map s1 ns1 n0 nexits1 ngoto nret rret) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n0 : node) (H5 : tr_stmt c map s2 n0 nd1 nexits1 ngoto nret rret) (H12 : tr_stmt c map s1 ns1 n0 nexits1 ngoto nret rret)","proofString":"eapply IHs1; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n0 : node) (H5 : tr_stmt c map s2 n0 nd1 nexits1 ngoto nret rret) (H12 : tr_stmt c map s1 ns1 n0 nexits1 ngoto nret rret) : tr_cont c map (Kseq s2 k) n0 nexits1 ngoto nret rret cs.","conclusion":"tr_cont c map (Kseq s2 k) n0 nexits1 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n0 : node) (H5 : tr_stmt c map s2 n0 nd1 nexits1 ngoto nret rret) (H12 : tr_stmt c map s1 ns1 n0 nexits1 ngoto nret rret)","proofString":"econstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = None) (H1 : find_label lbl s2 k = Some (s', k')) (H2 : tr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = None) (H1 : find_label lbl s2 k = Some (s', k')) (H2 : tr_stmt c map (Sseq s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H2.\neapply IHs2; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = None) (H1 : find_label lbl s2 k = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n0 : node) (H6 : tr_stmt c map s2 n0 nd1 nexits1 ngoto nret rret) (H13 : tr_stmt c map s1 ns1 n0 nexits1 ngoto nret rret) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 (Kseq s2 k) = None) (H1 : find_label lbl s2 k = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n0 : node) (H6 : tr_stmt c map s2 n0 nd1 nexits1 ngoto nret rret) (H13 : tr_stmt c map s1 ns1 n0 nexits1 ngoto nret rret)","proofString":"eapply IHs2; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) : match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k') ->\ntr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k') ->\ntr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node)","proofString":"caseEq (find_label lbl s1 k); intros.\ninv H1.\ninv H2.\neapply IHs1; eauto.\ninv H2.\neapply IHs2; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (p : stmt * cont) (H0 : find_label lbl s1 k = Some p) (H1 : Some p = Some (s', k')) (H2 : tr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (p : stmt * cont) (H0 : find_label lbl s1 k = Some p) (H1 : Some p = Some (s', k')) (H2 : tr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H1.\ninv H2.\neapply IHs1; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = Some (s', k')) (H2 : tr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = Some (s', k')) (H2 : tr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H2.\neapply IHs1; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (ntrue nfalse : node) (H6 : tr_stmt c map s1 ntrue nd1 nexits1 ngoto nret rret) (H13 : tr_stmt c map s2 nfalse nd1 nexits1 ngoto nret rret) (H14 : tr_condition c map nil c0 ns1 ntrue nfalse) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (ntrue nfalse : node) (H6 : tr_stmt c map s1 ntrue nd1 nexits1 ngoto nret rret) (H13 : tr_stmt c map s2 nfalse nd1 nexits1 ngoto nret rret) (H14 : tr_condition c map nil c0 ns1 ntrue nfalse)","proofString":"eapply IHs1; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = None) (H1 : find_label lbl s2 k = Some (s', k')) (H2 : tr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = None) (H1 : find_label lbl s2 k = Some (s', k')) (H2 : tr_stmt c map (Sifthenelse c0 s1 s2) ns1 nd1 nexits1 ngoto nret rret) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H2.\neapply IHs2; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = None) (H1 : find_label lbl s2 k = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (ntrue nfalse : node) (H7 : tr_stmt c map s1 ntrue nd1 nexits1 ngoto nret rret) (H14 : tr_stmt c map s2 nfalse nd1 nexits1 ngoto nret rret) (H15 : tr_condition c map nil c0 ns1 ntrue nfalse) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (c0 : condexpr) (s1 s2 : stmt) (IHs1 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s1 k0 = Some (s', k') ->\ntr_stmt c map s1 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (IHs2 : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s2 k0 = Some (s', k') ->\ntr_stmt c map s2 ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s1 k = None) (H1 : find_label lbl s2 k = Some (s', k')) (H3 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (ntrue nfalse : node) (H7 : tr_stmt c map s1 ntrue nd1 nexits1 ngoto nret rret) (H14 : tr_stmt c map s2 nfalse nd1 nexits1 ngoto nret rret) (H15 : tr_condition c map nil c0 ns1 ntrue nfalse)","proofString":"eapply IHs2; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) : find_label lbl s (Kseq (Sloop s) k) = Some (s', k') ->\ntr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"find_label lbl s (Kseq (Sloop s) k) = Some (s', k') ->\ntr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node)","proofString":"intros.\ninversion H1; subst.\neapply IHs; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inversion H1; subst.\neapply IHs; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (nloop nend : node) (H4 : tr_stmt c map s nloop nend nexits1 ngoto nret rret) (H5 : c ! ns1 = Some (Inop nloop)) (H6 : c ! nend = Some (Inop nloop)) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (nloop nend : node) (H4 : tr_stmt c map s nloop nend nexits1 ngoto nret rret) (H5 : c ! ns1 = Some (Inop nloop)) (H6 : c ! nend = Some (Inop nloop))","proofString":"eapply IHs; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (nloop nend : node) (H4 : tr_stmt c map s nloop nend nexits1 ngoto nret rret) (H5 : c ! ns1 = Some (Inop nloop)) (H6 : c ! nend = Some (Inop nloop)) : tr_cont c map (Kseq (Sloop s) k) nend nexits1 ngoto nret rret cs.","conclusion":"tr_cont c map (Kseq (Sloop s) k) nend nexits1 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (nloop nend : node) (H4 : tr_stmt c map s nloop nend nexits1 ngoto nret rret) (H5 : c ! ns1 = Some (Inop nloop)) (H6 : c ! nend = Some (Inop nloop))","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (nloop nend : node) (H4 : tr_stmt c map s nloop nend nexits1 ngoto nret rret) (H5 : c ! ns1 = Some (Inop nloop)) (H6 : c ! nend = Some (Inop nloop)) : tr_stmt c map (Sloop s) nend nd1 nexits1 ngoto nret rret.","conclusion":"tr_stmt c map (Sloop s) nend nd1 nexits1 ngoto nret rret","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kseq (Sloop s) k) = Some (s', k')) (H1 : tr_stmt c map (Sloop s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (nloop nend : node) (H4 : tr_stmt c map s nloop nend nexits1 ngoto nret rret) (H5 : c ! ns1 = Some (Inop nloop)) (H6 : c ! nend = Some (Inop nloop))","proofString":"econstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) : find_label lbl s (Kblock k) = Some (s', k') ->\ntr_stmt c map (Sblock s) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"find_label lbl s (Kblock k) = Some (s', k') ->\ntr_stmt c map (Sblock s) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node)","proofString":"intros.\ninv H1.\neapply IHs; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kblock k) = Some (s', k')) (H1 : tr_stmt c map (Sblock s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kblock k) = Some (s', k')) (H1 : tr_stmt c map (Sblock s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H1.\neapply IHs; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kblock k) = Some (s', k')) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (H4 : tr_stmt c map s ns1 nd1 (nd1 :: nexits1) ngoto nret rret) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kblock k) = Some (s', k')) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (H4 : tr_stmt c map s ns1 nd1 (nd1 :: nexits1) ngoto nret rret)","proofString":"eapply IHs; eauto.\neconstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kblock k) = Some (s', k')) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (H4 : tr_stmt c map s ns1 nd1 (nd1 :: nexits1) ngoto nret rret) : tr_cont c map (Kblock k) nd1 (nd1 :: nexits1) ngoto nret rret cs.","conclusion":"tr_cont c map (Kblock k) nd1 (nd1 :: nexits1) ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (H0 : find_label lbl s (Kblock k) = Some (s', k')) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (H4 : tr_stmt c map s ns1 nd1 (nd1 :: nexits1) ngoto nret rret)","proofString":"econstructor; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) : (if ident_eq lbl l then Some (s, k) else find_label lbl s k) = Some (s', k') ->\ntr_stmt c map (Slabel l s) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"(if ident_eq lbl l then Some (s, k) else find_label lbl s k) = Some (s', k') ->\ntr_stmt c map (Slabel l s) ns1 nd1 nexits1 ngoto nret rret ->\ntr_cont c map k nd1 nexits1 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node)","proofString":"destruct (ident_eq lbl l); intros.\ninv H0.\ninv H1.\nassert (n0 = n).\nchange positive with node in H4.\ncongruence.\nsubst n0.\nexists ns1; exists nd1; exists nexits1; auto.\ninv H1.\neapply IHs; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (e : lbl = l) (H0 : Some (s, k) = Some (s', k')) (H1 : tr_stmt c map (Slabel l s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (e : lbl = l) (H0 : Some (s, k) = Some (s', k')) (H1 : tr_stmt c map (Slabel l s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H0.\ninv H1.\nassert (n0 = n).\nchange positive with node in H4.\ncongruence.\nsubst n0.\nexists ns1; exists nd1; exists nexits1; auto."},{"statement":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H1 : tr_stmt c map (Slabel l s') ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H1 : tr_stmt c map (Slabel l s') ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs)","proofString":"inv H1.\nassert (n0 = n).\nchange positive with node in H4.\ncongruence.\nsubst n0.\nexists ns1; exists nd1; exists nexits1; auto."},{"statement":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret)","proofString":"assert (n0 = n).\nchange positive with node in H4.\ncongruence.\nsubst n0.\nexists ns1; exists nd1; exists nexits1; auto."},{"statement":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret) : n0 = n.","conclusion":"n0 = n","hypotheses":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret)","proofString":"change positive with node in H4.\ncongruence."},{"statement":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret) : n0 = n.","conclusion":"n0 = n","hypotheses":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret)","proofString":"congruence."},{"statement":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret) (H0 : n0 = n) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (n0 : positive) (H4 : ngoto ! l = Some n0) (H5 : c ! n0 = Some (Inop ns1)) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret) (H0 : n0 = n)","proofString":"subst n0.\nexists ns1; exists nd1; exists nexits1; auto."},{"statement":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (H5 : c ! n = Some (Inop ns1)) (H4 : ngoto ! l = Some n) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (l : label) (H : ngoto ! l = Some n) (IHs : forall (k : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label l s' k = Some (s', k') ->\ntr_stmt c map s' ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (ns1 nd1 : node) (nexits1 : list node) (H2 : tr_cont c map k' nd1 nexits1 ngoto nret rret cs) (H5 : c ! n = Some (Inop ns1)) (H4 : ngoto ! l = Some n) (H12 : tr_stmt c map s' ns1 nd1 nexits1 ngoto nret rret)","proofString":"exists ns1; exists nd1; exists nexits1; auto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (n0 : lbl <> l) (H0 : find_label lbl s k = Some (s', k')) (H1 : tr_stmt c map (Slabel l s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (n0 : lbl <> l) (H0 : find_label lbl s k = Some (s', k')) (H1 : tr_stmt c map (Slabel l s) ns1 nd1 nexits1 ngoto nret rret) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs)","proofString":"inv H1.\neapply IHs; eauto."},{"statement":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (n0 : lbl <> l) (H0 : find_label lbl s k = Some (s', k')) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n1 : positive) (H5 : ngoto ! l = Some n1) (H6 : c ! n1 = Some (Inop ns1)) (H13 : tr_stmt c map s ns1 nd1 nexits1 ngoto nret rret) : exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs.","conclusion":"exists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs","hypotheses":"(c : code) (map : mapping) (lbl : positive) (n : node) (ngoto : labelmap) (nret : node) (rret : option reg) (s' : stmt) (k' : cont) (cs : list stackframe) (H : ngoto ! lbl = Some n) (l : label) (s : stmt) (IHs : forall (k0 : cont) (ns0 nd0 : node) (nexits0 : list node),\nfind_label lbl s k0 = Some (s', k') ->\ntr_stmt c map s ns0 nd0 nexits0 ngoto nret rret ->\ntr_cont c map k0 nd0 nexits0 ngoto nret rret cs ->\nexists (ns2 nd2 : node) (nexits2 : list node),\n  c ! n = Some (Inop ns2) /\\\n  tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n  tr_cont c map k' nd2 nexits2 ngoto nret rret cs) (k : cont) (ns1 nd1 : node) (nexits1 : list node) (n0 : lbl <> l) (H0 : find_label lbl s k = Some (s', k')) (H2 : tr_cont c map k nd1 nexits1 ngoto nret rret cs) (n1 : positive) (H5 : ngoto ! l = Some n1) (H6 : c ! n1 = Some (Inop ns1)) (H13 : tr_stmt c map s ns1 nd1 nexits1 ngoto nret rret)","proofString":"eapply IHs; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map Sskip ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f Sskip (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f Sskip (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map Sskip ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\ninv TK.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f Sskip (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f Sskip (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TK.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H3 : tr_stmt (fn_code tf) map s ncont n nexits ngoto nret rret) (H10 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f Sskip (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f Sskip (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H3 : tr_stmt (fn_code tf) map s ncont n nexits ngoto nret rret) (H10 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H3 : tr_stmt (fn_code tf) map s ncont n nexits ngoto nret rret) (H10 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs) : lt_state (CminorSel.State f s k sp e m)\n  (CminorSel.State f Sskip (Kseq s k) sp e m).","conclusion":"lt_state (CminorSel.State f s k sp e m)\n  (CminorSel.State f Sskip (Kseq s k) sp e m)","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H3 : tr_stmt (fn_code tf) map s ncont n nexits ngoto nret rret) (H10 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map Sskip ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f Sskip (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f Sskip (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map Sskip ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\ninv TK.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f Sskip (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f Sskip (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TK.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H2 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f Sskip (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f Sskip (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H2 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H2 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : lt_state (CminorSel.State f Sskip k sp e m)\n  (CminorSel.State f Sskip (Kblock k) sp e m).","conclusion":"lt_state (CminorSel.State f Sskip k sp e m)\n  (CminorSel.State f Sskip (Kblock k) sp e m)","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H2 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H2 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : tr_stmt (fn_code tf) map Sskip ncont ncont nexits0 ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map Sskip ncont ncont nexits0 ngoto nret rret","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H2 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"constructor."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map Sskip ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map Sskip ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nassert ((fn_code tf)!ncont = Some(Ireturn rret)          /\\ match_stacks k cs).\ninv TK; simpl in H; try contradiction; auto.\ndestruct H1.\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF.\nauto.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn.\neauto.\nrewrite H3.\neauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"assert ((fn_code tf)!ncont = Some(Ireturn rret)          /\\ match_stacks k cs).\ninv TK; simpl in H; try contradiction; auto.\ndestruct H1.\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF.\nauto.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn.\neauto.\nrewrite H3.\neauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : (fn_code tf) ! ncont = Some (Ireturn rret) /\\ match_stacks k cs.","conclusion":"(fn_code tf) ! ncont = Some (Ireturn rret) /\\ match_stacks k cs","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TK; simpl in H; try contradiction; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret) /\\ match_stacks k cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret) /\\ match_stacks k cs)","proofString":"destruct H1.\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF.\nauto.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn.\neauto.\nrewrite H3.\neauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs)","proofString":"assert (fn_stacksize tf = fn_stackspace f).\ninv TF.\nauto.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn.\neauto.\nrewrite H3.\neauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs) : fn_stacksize tf = fn_stackspace f.","conclusion":"fn_stacksize tf = fn_stackspace f","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs)","proofString":"inv TF.\nauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (r : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn (ret_reg (CminorSel.fn_sig f) r))) (H2 : match_stacks k cs) (nentry : node) (H4 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (H5 : fn_stacksize tf = fn_stackspace f) : fn_stacksize tf = fn_stackspace f.","conclusion":"fn_stacksize tf = fn_stackspace f","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (r : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn (ret_reg (CminorSel.fn_sig f) r))) (H2 : match_stacks k cs) (nentry : node) (H4 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (H5 : fn_stacksize tf = fn_stackspace f)","proofString":"auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs) (H3 : fn_stacksize tf = fn_stackspace f) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs) (H3 : fn_stacksize tf = fn_stackspace f)","proofString":"edestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn.\neauto.\nrewrite H3.\neauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs) (H3 : fn_stacksize tf = fn_stackspace f) (tm' : mem) (H4 : Mem.free tm sp 0 (fn_stackspace f) = Some tm') (H5 : Mem.extends m' tm') : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ncont rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef k m')\n     (CminorSel.State f Sskip k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef k m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : (fn_code tf) ! ncont = Some (Ireturn rret)) (H2 : match_stacks k cs) (H3 : fn_stacksize tf = fn_stackspace f) (tm' : mem) (H4 : Mem.free tm sp 0 (fn_stackspace f) = Some tm') (H5 : Mem.extends m' tm')","proofString":"econstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn.\neauto.\nrewrite H3.\neauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (id : ident) (a : expr) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (H : eval_expr ge sp e m nil a v) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sassign id a) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (PTree.set id v e) m)\n     (CminorSel.State f (Sassign id a) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (PTree.set id v e) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (PTree.set id v e) m)\n     (CminorSel.State f (Sassign id a) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (PTree.set id v e) m) R2","hypotheses":"(f : CminorSel.function) (id : ident) (a : expr) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (H : eval_expr ge sp e m nil a v) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sassign id a) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D E]]]]]].\neconstructor; split.\nright; split.\neauto.\nLt_state.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (id : ident) (a : expr) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (H : eval_expr ge sp e m nil a v) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (r : reg) (H2 : (map_vars map) ! id = Some r) (H9 : tr_expr (fn_code tf) map nil a ns ncont r (Some id)) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (PTree.set id v e) m)\n     (CminorSel.State f (Sassign id a) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (PTree.set id v e) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (PTree.set id v e) m)\n     (CminorSel.State f (Sassign id a) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (PTree.set id v e) m) R2","hypotheses":"(f : CminorSel.function) (id : ident) (a : expr) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (H : eval_expr ge sp e m nil a v) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (r : reg) (H2 : (map_vars map) ! id = Some r) (H9 : tr_expr (fn_code tf) map nil a ns ncont r (Some id))","proofString":"exploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D E]]]]]].\neconstructor; split.\nright; split.\neauto.\nLt_state.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (id : ident) (a : expr) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (H : eval_expr ge sp e m nil a v) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (r : reg) (H2 : (map_vars map) ! id = Some r) (H9 : tr_expr (fn_code tf) map nil a ns ncont r (Some id)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp ncont rs' tm')) (B : match_env map (set_optvar (Some id) v e) nil rs') (C : Val.lessdef v rs' # r) (D : forall r0 : reg, In r0 nil -> rs' # r0 = rs # r0) (E : Mem.extends m tm') : tr_stmt (fn_code tf) map Sskip ncont ncont nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map Sskip ncont ncont nexits ngoto nret rret","hypotheses":"(f : CminorSel.function) (id : ident) (a : expr) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (H : eval_expr ge sp e m nil a v) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (r : reg) (H2 : (map_vars map) ! id = Some r) (H9 : tr_expr (fn_code tf) map nil a ns ncont r (Some id)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp ncont rs' tm')) (B : match_env map (set_optvar (Some id) v e) nil rs') (C : Val.lessdef v rs' # r) (D : forall r0 : reg, In r0 nil -> rs' # r0 = rs # r0) (E : Mem.extends m tm')","proofString":"constructor."},{"statement":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sstore chunk addr al b) ns ncont nexits ngoto nret\n  rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m')\n     (CminorSel.State f (Sstore chunk addr al b) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m')\n     (CminorSel.State f (Sstore chunk addr al b) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m') R2","hypotheses":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sstore chunk addr al b) ns ncont nexits ngoto nret\n  rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit transl_exprlist_correct; eauto.\nintros [rs' [tm' [A [B [C [D E]]]]]].\nexploit transl_expr_correct; eauto.\nintros [rs'' [tm'' [F [G [J [K L]]]]]].\nassert (Val.lessdef_list vl rs''##rl).\nreplace (rs'' ## rl) with (rs' ## rl).\nauto.\napply list_map_exten.\nintros.\napply K.\nauto.\nedestruct eval_addressing_lessdef as [vaddr' []]; eauto.\nedestruct Mem.storev_extends as [tm''' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neapply star_trans.\neexact A.\neexact F.\nreflexivity.\neapply exec_Istore with (a := vaddr').\neauto.\nrewrite <- H4.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m')\n     (CminorSel.State f (Sstore chunk addr al b) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m')\n     (CminorSel.State f (Sstore chunk addr al b) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m') R2","hypotheses":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont))","proofString":"exploit transl_exprlist_correct; eauto.\nintros [rs' [tm' [A [B [C [D E]]]]]].\nexploit transl_expr_correct; eauto.\nintros [rs'' [tm'' [F [G [J [K L]]]]]].\nassert (Val.lessdef_list vl rs''##rl).\nreplace (rs'' ## rl) with (rs' ## rl).\nauto.\napply list_map_exten.\nintros.\napply K.\nauto.\nedestruct eval_addressing_lessdef as [vaddr' []]; eauto.\nedestruct Mem.storev_extends as [tm''' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neapply star_trans.\neexact A.\neexact F.\nreflexivity.\neapply exec_Istore with (a := vaddr').\neauto.\nrewrite <- H4.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map e nil rs') (C : Val.lessdef_list vl rs' ## rl) (D : forall r : reg, In r nil -> rs' # r = rs # r) (E : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (F : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (G : match_env map (set_optvar None v e) nil rs'') (J : Val.lessdef v rs'' # rd) (K : forall r : reg, In r rl -> rs'' # r = rs' # r) (L : Mem.extends m tm'') (H3 : Val.lessdef_list vl rs'' ## rl) (vaddr' : val) (H4 : eval_addressing ge sp addr rs'' ## rl = Some vaddr') (H5 : Val.lessdef vaddr vaddr') (tm''' : mem) (H6 : Mem.storev chunk tm'' vaddr' rs'' # rd = Some tm''') (H7 : Mem.extends m' tm''') : eval_addressing tge sp addr rs'' ## rl =\neval_addressing ge sp addr rs'' ## rl.","conclusion":"eval_addressing tge sp addr rs'' ## rl =\neval_addressing ge sp addr rs'' ## rl","hypotheses":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map e nil rs') (C : Val.lessdef_list vl rs' ## rl) (D : forall r : reg, In r nil -> rs' # r = rs # r) (E : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (F : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (G : match_env map (set_optvar None v e) nil rs'') (J : Val.lessdef v rs'' # rd) (K : forall r : reg, In r rl -> rs'' # r = rs' # r) (L : Mem.extends m tm'') (H3 : Val.lessdef_list vl rs'' ## rl) (vaddr' : val) (H4 : eval_addressing ge sp addr rs'' ## rl = Some vaddr') (H5 : Val.lessdef vaddr vaddr') (tm''' : mem) (H6 : Mem.storev chunk tm'' vaddr' rs'' # rd = Some tm''') (H7 : Mem.extends m' tm''')","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map e nil rs') (C : Val.lessdef_list vl rs' ## rl) (D : forall r : reg, In r nil -> rs' # r = rs # r) (E : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (F : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (G : match_env map (set_optvar None v e) nil rs'') (J : Val.lessdef v rs'' # rd) (K : forall r : reg, In r rl -> rs'' # r = rs' # r) (L : Mem.extends m tm'') (H3 : Val.lessdef_list vl rs'' ## rl) (vaddr' : val) (H4 : eval_addressing ge sp addr rs'' ## rl = Some vaddr') (H5 : Val.lessdef vaddr vaddr') (tm''' : mem) (H6 : Mem.storev chunk tm'' vaddr' rs'' # rd = Some tm''') (H7 : Mem.extends m' tm''') : forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s.","conclusion":"forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s","hypotheses":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map e nil rs') (C : Val.lessdef_list vl rs' ## rl) (D : forall r : reg, In r nil -> rs' # r = rs # r) (E : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (F : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (G : match_env map (set_optvar None v e) nil rs'') (J : Val.lessdef v rs'' # rd) (K : forall r : reg, In r rl -> rs'' # r = rs' # r) (L : Mem.extends m tm'') (H3 : Val.lessdef_list vl rs'' ## rl) (vaddr' : val) (H4 : eval_addressing ge sp addr rs'' ## rl = Some vaddr') (H5 : Val.lessdef vaddr vaddr') (tm''' : mem) (H6 : Mem.storev chunk tm'' vaddr' rs'' # rd = Some tm''') (H7 : Mem.extends m' tm''')","proofString":"exact symbols_preserved."},{"statement":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map e nil rs') (C : Val.lessdef_list vl rs' ## rl) (D : forall r : reg, In r nil -> rs' # r = rs # r) (E : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (F : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (G : match_env map (set_optvar None v e) nil rs'') (J : Val.lessdef v rs'' # rd) (K : forall r : reg, In r rl -> rs'' # r = rs' # r) (L : Mem.extends m tm'') (H3 : Val.lessdef_list vl rs'' ## rl) (vaddr' : val) (H4 : eval_addressing ge sp addr rs'' ## rl = Some vaddr') (H5 : Val.lessdef vaddr vaddr') (tm''' : mem) (H6 : Mem.storev chunk tm'' vaddr' rs'' # rd = Some tm''') (H7 : Mem.extends m' tm''') : tr_stmt (fn_code tf) map Sskip ncont ncont nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map Sskip ncont ncont nexits ngoto nret rret","hypotheses":"(f : CminorSel.function) (chunk : memory_chunk) (addr : addressing) (al : exprlist) (b : expr) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (v vaddr : val) (m' : mem) (H : eval_exprlist ge sp e m nil al vl) (H0 : eval_expr ge sp e m nil b v) (H1 : eval_addressing ge sp addr vl = Some vaddr) (H2 : Mem.storev chunk m vaddr v = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rl : list reg) (n2 : node) (H13 : tr_exprlist (fn_code tf) map nil al ns n1 rl) (H14 : tr_expr (fn_code tf) map rl b n1 n2 rd None) (H15 : (fn_code tf) ! n2 = Some (Istore chunk addr rl rd ncont)) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map e nil rs') (C : Val.lessdef_list vl rs' ## rl) (D : forall r : reg, In r nil -> rs' # r = rs # r) (E : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (F : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (G : match_env map (set_optvar None v e) nil rs'') (J : Val.lessdef v rs'' # rd) (K : forall r : reg, In r rl -> rs'' # r = rs' # r) (L : Mem.extends m tm'') (H3 : Val.lessdef_list vl rs'' ## rl) (vaddr' : val) (H4 : eval_addressing ge sp addr rs'' ## rl = Some vaddr') (H5 : Val.lessdef vaddr vaddr') (tm''' : mem) (H6 : Mem.storev chunk tm'' vaddr' rs'' # rd = Some tm''') (H7 : Mem.extends m' tm''')","proofString":"constructor."},{"statement":"(f : CminorSel.function) (optid : option ident) (a : expr + ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (H : eval_expr_or_symbol ge sp e m nil a vf) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Scall optid (CminorSel.funsig fd) a bl) ns ncont\n  nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m)\n     (CminorSel.State f (Scall optid (CminorSel.funsig fd) a bl) k sp e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m)\n     (CminorSel.State f (Scall optid (CminorSel.funsig fd) a bl) k sp e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m) R2","hypotheses":"(f : CminorSel.function) (optid : option ident) (a : expr + ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (H : eval_expr_or_symbol ge sp e m nil a vf) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Scall optid (CminorSel.funsig fd) a bl) ns ncont\n  nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS; inv H.\nexploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D X]]]]]].\nexploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\neconstructor; split.\nleft; eapply plus_right.\neapply star_trans.\neexact A.\neexact E.\nreflexivity.\neapply exec_Icall; eauto.\nsimpl.\nrewrite J.\ndestruct C.\neauto.\ndiscriminate P.\nsimpl; auto.\napply sig_transl_function; auto.\ntraceEq.\nconstructor; auto.\neconstructor; eauto.\nexploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\neconstructor; split.\nleft; eapply plus_right.\neexact E.\neapply exec_Icall; eauto.\nsimpl.\nrewrite symbols_preserved.\nrewrite H4.\nrewrite Genv.find_funct_find_funct_ptr in P.\neauto.\napply sig_transl_function; auto.\ntraceEq.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (b : expr) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inl rf) rargs rd ncont)) (H15 : reg_map_ok map rd optid) (H4 : eval_expr ge sp e m nil b vf) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m)\n     (CminorSel.State f (Scall optid (CminorSel.funsig fd) (inl b) bl) k sp e\n        m)) /\\\n  match_states (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m)\n     (CminorSel.State f (Scall optid (CminorSel.funsig fd) (inl b) bl) k sp e\n        m)) /\\\n  match_states (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m) R2","hypotheses":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (b : expr) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inl rf) rargs rd ncont)) (H15 : reg_map_ok map rd optid) (H4 : eval_expr ge sp e m nil b vf)","proofString":"exploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D X]]]]]].\nexploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\neconstructor; split.\nleft; eapply plus_right.\neapply star_trans.\neexact A.\neexact E.\nreflexivity.\neapply exec_Icall; eauto.\nsimpl.\nrewrite J.\ndestruct C.\neauto.\ndiscriminate P.\nsimpl; auto.\napply sig_transl_function; auto.\ntraceEq.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (b : expr) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inl rf) rargs rd ncont)) (H15 : reg_map_ok map rd optid) (H4 : eval_expr ge sp e m nil b vf) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map (set_optvar None vf e) nil rs') (C : Val.lessdef vf rs' # rf) (D : forall r : reg, In r nil -> rs' # r = rs # r) (X : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r (rf :: nil) -> rs'' # r = rs' # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge vf = Some tf') (Q : transl_fundef fd = OK tf') : In rf (rf :: nil).","conclusion":"In rf (rf :: nil)","hypotheses":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (b : expr) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inl rf) rargs rd ncont)) (H15 : reg_map_ok map rd optid) (H4 : eval_expr ge sp e m nil b vf) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map (set_optvar None vf e) nil rs') (C : Val.lessdef vf rs' # rf) (D : forall r : reg, In r nil -> rs' # r = rs # r) (X : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r (rf :: nil) -> rs'' # r = rs' # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge vf = Some tf') (Q : transl_fundef fd = OK tf')","proofString":"simpl; auto."},{"statement":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (b : expr) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inl rf) rargs rd ncont)) (H15 : reg_map_ok map rd optid) (H4 : eval_expr ge sp e m nil b vf) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map (set_optvar None vf e) nil rs') (C : Val.lessdef vf rs' # rf) (D : forall r : reg, In r nil -> rs' # r = rs # r) (X : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r (rf :: nil) -> rs'' # r = rs' # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge vf = Some tf') (Q : transl_fundef fd = OK tf') : match_stacks (Kcall optid f sp e k) (Stackframe rd tf sp ncont rs'' :: cs).","conclusion":"match_stacks (Kcall optid f sp e k) (Stackframe rd tf sp ncont rs'' :: cs)","hypotheses":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (b : expr) (H0 : eval_exprlist ge sp e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inl rf) rargs rd ncont)) (H15 : reg_map_ok map rd optid) (H4 : eval_expr ge sp e m nil b vf) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (B : match_env map (set_optvar None vf e) nil rs') (C : Val.lessdef vf rs' # rf) (D : forall r : reg, In r nil -> rs' # r = rs # r) (X : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf sp n1 rs' tm') E0 (State cs tf sp n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r (rf :: nil) -> rs'' # r = rs' # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge vf = Some tf') (Q : transl_fundef fd = OK tf')","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (fd : CminorSel.fundef) (id : ident) (H0 : eval_exprlist ge sp e m nil bl vargs) (b : block) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n2 : node) (rargs : list reg) (H12 : tr_exprlist (fn_code tf) map nil bl ns n2 rargs) (H13 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inr id) rargs rd ncont)) (H14 : reg_map_ok map rd optid) (H4 : Genv.find_symbol ge id = Some b) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m)\n     (CminorSel.State f (Scall optid (CminorSel.funsig fd) (inr id) bl) k sp\n        e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m)\n     (CminorSel.State f (Scall optid (CminorSel.funsig fd) (inr id) bl) k sp\n        e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (Kcall optid f sp e k) m) R2","hypotheses":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (fd : CminorSel.fundef) (id : ident) (H0 : eval_exprlist ge sp e m nil bl vargs) (b : block) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n2 : node) (rargs : list reg) (H12 : tr_exprlist (fn_code tf) map nil bl ns n2 rargs) (H13 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inr id) rargs rd ncont)) (H14 : reg_map_ok map rd optid) (H4 : Genv.find_symbol ge id = Some b)","proofString":"exploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\neconstructor; split.\nleft; eapply plus_right.\neexact E.\neapply exec_Icall; eauto.\nsimpl.\nrewrite symbols_preserved.\nrewrite H4.\nrewrite Genv.find_funct_find_funct_ptr in P.\neauto.\napply sig_transl_function; auto.\ntraceEq.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (fd : CminorSel.fundef) (id : ident) (H0 : eval_exprlist ge sp e m nil bl vargs) (b : block) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n2 : node) (rargs : list reg) (H12 : tr_exprlist (fn_code tf) map nil bl ns n2 rargs) (H13 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inr id) rargs rd ncont)) (H14 : reg_map_ok map rd optid) (H4 : Genv.find_symbol ge id = Some b) (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r nil -> rs'' # r = rs # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some tf') (Q : transl_fundef fd = OK tf') : match_stacks (Kcall optid f sp e k) (Stackframe rd tf sp ncont rs'' :: cs).","conclusion":"match_stacks (Kcall optid f sp e k) (Stackframe rd tf sp ncont rs'' :: cs)","hypotheses":"(f : CminorSel.function) (optid : option ident) (bl : exprlist) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (fd : CminorSel.fundef) (id : ident) (H0 : eval_exprlist ge sp e m nil bl vargs) (b : block) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (rd : reg) (n2 : node) (rargs : list reg) (H12 : tr_exprlist (fn_code tf) map nil bl ns n2 rargs) (H13 : (fn_code tf) ! n2 =\nSome (Icall (CminorSel.funsig fd) (inr id) rargs rd ncont)) (H14 : reg_map_ok map rd optid) (H4 : Genv.find_symbol ge id = Some b) (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r nil -> rs'' # r = rs # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some tf') (Q : transl_fundef fd = OK tf')","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (a : expr + ident) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (H : eval_expr_or_symbol ge (Vptr sp Ptrofs.zero) e m nil a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Stailcall (CminorSel.funsig fd) a bl) ns ncont\n  nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (call_cont k) m')\n     (CminorSel.State f (Stailcall (CminorSel.funsig fd) a bl) k\n        (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (call_cont k) m')\n     (CminorSel.State f (Stailcall (CminorSel.funsig fd) a bl) k\n        (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (a : expr + ident) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (H : eval_expr_or_symbol ge (Vptr sp Ptrofs.zero) e m nil a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Stailcall (CminorSel.funsig fd) a bl) ns ncont\n  nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS; inv H.\nexploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D X]]]]]].\nexploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\nexploit match_stacks_call_cont; eauto.\nintros [U V].\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF; auto.\nedestruct Mem.free_parallel_extends as [tm''' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neapply star_trans.\neexact A.\neexact E.\nreflexivity.\neapply exec_Itailcall; eauto.\nsimpl.\nrewrite J.\ndestruct C.\neauto.\ndiscriminate P.\nsimpl; auto.\napply sig_transl_function; auto.\nrewrite H; eauto.\ntraceEq.\nconstructor; auto.\nexploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\nexploit match_stacks_call_cont; eauto.\nintros [U V].\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF; auto.\nedestruct Mem.free_parallel_extends as [tm''' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neexact E.\neapply exec_Itailcall; eauto.\nsimpl.\nrewrite symbols_preserved.\nrewrite H5.\nrewrite Genv.find_funct_find_funct_ptr in P.\neauto.\napply sig_transl_function; auto.\nrewrite H; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (b : expr) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 = Some (Itailcall (CminorSel.funsig fd) (inl rf) rargs)) (H5 : eval_expr ge (Vptr sp Ptrofs.zero) e m nil b vf) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (call_cont k) m')\n     (CminorSel.State f (Stailcall (CminorSel.funsig fd) (inl b) bl) k\n        (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (call_cont k) m')\n     (CminorSel.State f (Stailcall (CminorSel.funsig fd) (inl b) bl) k\n        (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (b : expr) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 = Some (Itailcall (CminorSel.funsig fd) (inl rf) rargs)) (H5 : eval_expr ge (Vptr sp Ptrofs.zero) e m nil b vf)","proofString":"exploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D X]]]]]].\nexploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\nexploit match_stacks_call_cont; eauto.\nintros [U V].\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF; auto.\nedestruct Mem.free_parallel_extends as [tm''' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neapply star_trans.\neexact A.\neexact E.\nreflexivity.\neapply exec_Itailcall; eauto.\nsimpl.\nrewrite J.\ndestruct C.\neauto.\ndiscriminate P.\nsimpl; auto.\napply sig_transl_function; auto.\nrewrite H; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (b : expr) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 = Some (Itailcall (CminorSel.funsig fd) (inl rf) rargs)) (H5 : eval_expr ge (Vptr sp Ptrofs.zero) e m nil b vf) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0\n  (State cs tf (Vptr sp Ptrofs.zero) n1 rs' tm')) (B : match_env map (set_optvar None vf e) nil rs') (C : Val.lessdef vf rs' # rf) (D : forall r : reg, In r nil -> rs' # r = rs # r) (X : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf (Vptr sp Ptrofs.zero) n1 rs' tm') E0\n  (State cs tf (Vptr sp Ptrofs.zero) n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r (rf :: nil) -> rs'' # r = rs' # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge vf = Some tf') (Q : transl_fundef fd = OK tf') (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) (H : fn_stacksize tf = fn_stackspace f) (tm''' : mem) (H2 : Mem.free tm'' sp 0 (fn_stackspace f) = Some tm''') (H4 : Mem.extends m' tm''') : In rf (rf :: nil).","conclusion":"In rf (rf :: nil)","hypotheses":"(f : CminorSel.function) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vf : val) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (b : expr) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n1 : node) (rf : reg) (n2 : node) (rargs : list reg) (H6 : tr_expr (fn_code tf) map nil b ns n1 rf None) (H13 : tr_exprlist (fn_code tf) map (rf :: nil) bl n1 n2 rargs) (H14 : (fn_code tf) ! n2 = Some (Itailcall (CminorSel.funsig fd) (inl rf) rargs)) (H5 : eval_expr ge (Vptr sp Ptrofs.zero) e m nil b vf) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0\n  (State cs tf (Vptr sp Ptrofs.zero) n1 rs' tm')) (B : match_env map (set_optvar None vf e) nil rs') (C : Val.lessdef vf rs' # rf) (D : forall r : reg, In r nil -> rs' # r = rs # r) (X : Mem.extends m tm') (rs'' : regset) (tm'' : mem) (E : star step tge (State cs tf (Vptr sp Ptrofs.zero) n1 rs' tm') E0\n  (State cs tf (Vptr sp Ptrofs.zero) n2 rs'' tm'')) (F : match_env map e nil rs'') (G : Val.lessdef_list vargs rs'' ## rargs) (J : forall r : reg, In r (rf :: nil) -> rs'' # r = rs' # r) (Y : Mem.extends m tm'') (tf' : fundef) (P : Genv.find_funct tge vf = Some tf') (Q : transl_fundef fd = OK tf') (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) (H : fn_stacksize tf = fn_stackspace f) (tm''' : mem) (H2 : Mem.free tm'' sp 0 (fn_stackspace f) = Some tm''') (H4 : Mem.extends m' tm''')","proofString":"simpl; auto."},{"statement":"(f : CminorSel.function) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (id : ident) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (b : block) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n2 : node) (rargs : list reg) (H12 : tr_exprlist (fn_code tf) map nil bl ns n2 rargs) (H13 : (fn_code tf) ! n2 = Some (Itailcall (CminorSel.funsig fd) (inr id) rargs)) (H5 : Genv.find_symbol ge id = Some b) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (call_cont k) m')\n     (CminorSel.State f (Stailcall (CminorSel.funsig fd) (inr id) bl) k\n        (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Callstate fd vargs (call_cont k) m')\n     (CminorSel.State f (Stailcall (CminorSel.funsig fd) (inr id) bl) k\n        (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Callstate fd vargs (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (bl : exprlist) (k : cont) (sp : block) (e : env) (m : mem) (vargs : list val) (fd : CminorSel.fundef) (m' : mem) (id : ident) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m nil bl vargs) (b : block) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n2 : node) (rargs : list reg) (H12 : tr_exprlist (fn_code tf) map nil bl ns n2 rargs) (H13 : (fn_code tf) ! n2 = Some (Itailcall (CminorSel.funsig fd) (inr id) rargs)) (H5 : Genv.find_symbol ge id = Some b)","proofString":"exploit transl_exprlist_correct; eauto.\nintros [rs'' [tm'' [E [F [G [J Y]]]]]].\nexploit functions_translated; eauto.\nintros [tf' [P Q]].\nexploit match_stacks_call_cont; eauto.\nintros [U V].\nassert (fn_stacksize tf = fn_stackspace f).\ninv TF; auto.\nedestruct Mem.free_parallel_extends as [tm''' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neexact E.\neapply exec_Itailcall; eauto.\nsimpl.\nrewrite symbols_preserved.\nrewrite H5.\nrewrite Genv.find_funct_find_funct_ptr in P.\neauto.\napply sig_transl_function; auto.\nrewrite H; eauto.\ntraceEq.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sbuiltin res ef al) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sbuiltin res ef al) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit invert_eval_builtin_args; eauto.\nintros (vparams & P & Q).\nexploit transl_exprlist_correct; eauto.\nintros [rs' [tm' [E [F [G [J K]]]]]].\nexploit transl_eval_builtin_args; eauto.\nintros (vargs' & U & V).\nexploit (@eval_builtin_args_lessdef _ ge (fun r => rs'#r) (fun r => rs'#r)); eauto.\nintros (vargs'' & X & Y).\nassert (Z: Val.lessdef_list vl vargs'') by (eapply Val.lessdef_list_trans; eauto).\nedestruct external_call_mem_extends as [tv [tm'' [A [B [C D]]]]]; eauto.\neconstructor; split.\nleft.\neapply plus_right.\neexact E.\neapply exec_Ibuiltin.\neauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\ntraceEq.\neconstructor; eauto.\nconstructor.\neapply match_env_update_res; eauto."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res')","proofString":"exploit invert_eval_builtin_args; eauto.\nintros (vparams & P & Q).\nexploit transl_exprlist_correct; eauto.\nintros [rs' [tm' [E [F [G [J K]]]]]].\nexploit transl_eval_builtin_args; eauto.\nintros (vargs' & U & V).\nexploit (@eval_builtin_args_lessdef _ ge (fun r => rs'#r) (fun r => rs'#r)); eauto.\nintros (vargs'' & X & Y).\nassert (Z: Val.lessdef_list vl vargs'') by (eapply Val.lessdef_list_trans; eauto).\nedestruct external_call_mem_extends as [tv [tm'' [A [B [C D]]]]]; eauto.\neconstructor; split.\nleft.\neapply plus_right.\neexact E.\neapply exec_Ibuiltin.\neauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\ntraceEq.\neconstructor; eauto.\nconstructor.\neapply match_env_update_res; eauto."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') : (exists vl' : list val,\n   eval_exprlist ge sp e m nil\n     (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n   eval_builtin_args ge (fun v0 : val => v0) sp m\n     (convert_builtin_args al vl') vl) ->\nexists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2.","conclusion":"(exists vl' : list val,\n   eval_exprlist ge sp e m nil\n     (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\\n   eval_builtin_args ge (fun v0 : val => v0) sp m\n     (convert_builtin_args al vl') vl) ->\nexists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res')","proofString":"intros (vparams & P & Q).\nexploit transl_exprlist_correct; eauto.\nintros [rs' [tm' [E [F [G [J K]]]]]].\nexploit transl_eval_builtin_args; eauto.\nintros (vargs' & U & V).\nexploit (@eval_builtin_args_lessdef _ ge (fun r => rs'#r) (fun r => rs'#r)); eauto.\nintros (vargs'' & X & Y).\nassert (Z: Val.lessdef_list vl vargs'') by (eapply Val.lessdef_list_trans; eauto).\nedestruct external_call_mem_extends as [tv [tm'' [A [B [C D]]]]]; eauto.\neconstructor; split.\nleft.\neapply plus_right.\neexact E.\neapply exec_Ibuiltin.\neauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\ntraceEq.\neconstructor; eauto.\nconstructor.\neapply match_env_update_res; eauto."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) t R2 \\/\n   star step tge (State cs tf sp ns rs tm) t R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_builtin_res res v e) m')\n     (CminorSel.State f (Sbuiltin res ef al) k sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_builtin_res res v e) m') R2","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl)","proofString":"exploit transl_exprlist_correct; eauto.\nintros [rs' [tm' [E [F [G [J K]]]]]].\nexploit transl_eval_builtin_args; eauto.\nintros (vargs' & U & V).\nexploit (@eval_builtin_args_lessdef _ ge (fun r => rs'#r) (fun r => rs'#r)); eauto.\nintros (vargs'' & X & Y).\nassert (Z: Val.lessdef_list vl vargs'') by (eapply Val.lessdef_list_trans; eauto).\nedestruct external_call_mem_extends as [tv [tm'' [A [B [C D]]]]]; eauto.\neconstructor; split.\nleft.\neapply plus_right.\neexact E.\neapply exec_Ibuiltin.\neauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\ntraceEq.\neconstructor; eauto.\nconstructor.\neapply match_env_update_res; eauto."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) (rs' : regset) (tm' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (F : match_env map e nil rs') (G : Val.lessdef_list vparams rs' ## rargs) (J : forall r : reg, In r nil -> rs' # r = rs # r) (K : Mem.extends m tm') (vargs' : list val) (U : eval_builtin_args ge (fun r : positive => rs' # r) sp m\n  (convert_builtin_args al rargs) vargs') (V : Val.lessdef_list vl vargs') (vargs'' : list val) (X : eval_builtin_args ge (fun r : positive => rs' # r) sp tm'\n  (convert_builtin_args al rargs) vargs'') (Y : Val.lessdef_list vargs' vargs'') (Z : Val.lessdef_list vl vargs'') (tv : val) (tm'' : mem) (A : external_call ef ge vargs'' tm' t tv tm'') (B : Val.lessdef v tv) (C : Mem.extends m' tm'') (D : Mem.unchanged_on (loc_out_of_bounds m) tm' tm'') : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","conclusion":"forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) (rs' : regset) (tm' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (F : match_env map e nil rs') (G : Val.lessdef_list vparams rs' ## rargs) (J : forall r : reg, In r nil -> rs' # r = rs # r) (K : Mem.extends m tm') (vargs' : list val) (U : eval_builtin_args ge (fun r : positive => rs' # r) sp m\n  (convert_builtin_args al rargs) vargs') (V : Val.lessdef_list vl vargs') (vargs'' : list val) (X : eval_builtin_args ge (fun r : positive => rs' # r) sp tm'\n  (convert_builtin_args al rargs) vargs'') (Y : Val.lessdef_list vargs' vargs'') (Z : Val.lessdef_list vl vargs'') (tv : val) (tm'' : mem) (A : external_call ef ge vargs'' tm' t tv tm'') (B : Val.lessdef v tv) (C : Mem.extends m' tm'') (D : Mem.unchanged_on (loc_out_of_bounds m) tm' tm'')","proofString":"exact symbols_preserved."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) (rs' : regset) (tm' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (F : match_env map e nil rs') (G : Val.lessdef_list vparams rs' ## rargs) (J : forall r : reg, In r nil -> rs' # r = rs # r) (K : Mem.extends m tm') (vargs' : list val) (U : eval_builtin_args ge (fun r : positive => rs' # r) sp m\n  (convert_builtin_args al rargs) vargs') (V : Val.lessdef_list vl vargs') (vargs'' : list val) (X : eval_builtin_args ge (fun r : positive => rs' # r) sp tm'\n  (convert_builtin_args al rargs) vargs'') (Y : Val.lessdef_list vargs' vargs'') (Z : Val.lessdef_list vl vargs'') (tv : val) (tm'' : mem) (A : external_call ef ge vargs'' tm' t tv tm'') (B : Val.lessdef v tv) (C : Mem.extends m' tm'') (D : Mem.unchanged_on (loc_out_of_bounds m) tm' tm'') : tr_stmt (fn_code tf) map Sskip ncont ncont nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map Sskip ncont ncont nexits ngoto nret rret","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) (rs' : regset) (tm' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (F : match_env map e nil rs') (G : Val.lessdef_list vparams rs' ## rargs) (J : forall r : reg, In r nil -> rs' # r = rs # r) (K : Mem.extends m tm') (vargs' : list val) (U : eval_builtin_args ge (fun r : positive => rs' # r) sp m\n  (convert_builtin_args al rargs) vargs') (V : Val.lessdef_list vl vargs') (vargs'' : list val) (X : eval_builtin_args ge (fun r : positive => rs' # r) sp tm'\n  (convert_builtin_args al rargs) vargs'') (Y : Val.lessdef_list vargs' vargs'') (Z : Val.lessdef_list vl vargs'') (tv : val) (tm'' : mem) (A : external_call ef ge vargs'' tm' t tv tm'') (B : Val.lessdef v tv) (C : Mem.extends m' tm'') (D : Mem.unchanged_on (loc_out_of_bounds m) tm' tm'')","proofString":"constructor."},{"statement":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) (rs' : regset) (tm' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (F : match_env map e nil rs') (G : Val.lessdef_list vparams rs' ## rargs) (J : forall r : reg, In r nil -> rs' # r = rs # r) (K : Mem.extends m tm') (vargs' : list val) (U : eval_builtin_args ge (fun r : positive => rs' # r) sp m\n  (convert_builtin_args al rargs) vargs') (V : Val.lessdef_list vl vargs') (vargs'' : list val) (X : eval_builtin_args ge (fun r : positive => rs' # r) sp tm'\n  (convert_builtin_args al rargs) vargs'') (Y : Val.lessdef_list vargs' vargs'') (Z : Val.lessdef_list vl vargs'') (tv : val) (tm'' : mem) (A : external_call ef ge vargs'' tm' t tv tm'') (B : Val.lessdef v tv) (C : Mem.extends m' tm'') (D : Mem.unchanged_on (loc_out_of_bounds m) tm' tm'') : match_env map (set_builtin_res res v e) nil (regmap_setres res' tv rs').","conclusion":"match_env map (set_builtin_res res v e) nil (regmap_setres res' tv rs')","hypotheses":"(f : CminorSel.function) (res : builtin_res ident) (ef : external_function) (al : list (builtin_arg expr)) (k : cont) (sp : val) (e : env) (m : mem) (vl : list val) (t : trace) (v : val) (m' : mem) (H : list_forall2 (eval_builtin_arg ge sp e m) al vl) (H0 : external_call ef ge vl m t v m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (res' : builtin_res reg) (n1 : node) (rargs : list reg) (H4 : tr_exprlist (fn_code tf) map nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) ns n1 rargs) (H11 : (fn_code tf) ! n1 =\nSome (Ibuiltin ef (convert_builtin_args al rargs) res' ncont)) (H12 : tr_builtin_res map res res') (vparams : list val) (P : eval_exprlist ge sp e m nil\n  (exprlist_of_expr_list (params_of_builtin_args al)) vparams) (Q : eval_builtin_args ge (fun v0 : val => v0) sp m\n  (convert_builtin_args al vparams) vl) (rs' : regset) (tm' : mem) (E : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp n1 rs' tm')) (F : match_env map e nil rs') (G : Val.lessdef_list vparams rs' ## rargs) (J : forall r : reg, In r nil -> rs' # r = rs # r) (K : Mem.extends m tm') (vargs' : list val) (U : eval_builtin_args ge (fun r : positive => rs' # r) sp m\n  (convert_builtin_args al rargs) vargs') (V : Val.lessdef_list vl vargs') (vargs'' : list val) (X : eval_builtin_args ge (fun r : positive => rs' # r) sp tm'\n  (convert_builtin_args al rargs) vargs'') (Y : Val.lessdef_list vargs' vargs'') (Z : Val.lessdef_list vl vargs'') (tv : val) (tm'' : mem) (A : external_call ef ge vargs'' tm' t tv tm'') (B : Val.lessdef v tv) (C : Mem.extends m' tm'') (D : Mem.unchanged_on (loc_out_of_bounds m) tm' tm'')","proofString":"eapply match_env_update_res; eauto."},{"statement":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sseq s1 s2) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s1 (Kseq s2 k) sp e m)\n     (CminorSel.State f (Sseq s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f s1 (Kseq s2 k) sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s1 (Kseq s2 k) sp e m)\n     (CminorSel.State f (Sseq s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f s1 (Kseq s2 k) sp e m) R2","hypotheses":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sseq s1 s2) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H1 : tr_stmt (fn_code tf) map s2 n ncont nexits ngoto nret rret) (H8 : tr_stmt (fn_code tf) map s1 ns n nexits ngoto nret rret) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s1 (Kseq s2 k) sp e m)\n     (CminorSel.State f (Sseq s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f s1 (Kseq s2 k) sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s1 (Kseq s2 k) sp e m)\n     (CminorSel.State f (Sseq s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f s1 (Kseq s2 k) sp e m) R2","hypotheses":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H1 : tr_stmt (fn_code tf) map s2 n ncont nexits ngoto nret rret) (H8 : tr_stmt (fn_code tf) map s1 ns n nexits ngoto nret rret)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H1 : tr_stmt (fn_code tf) map s2 n ncont nexits ngoto nret rret) (H8 : tr_stmt (fn_code tf) map s1 ns n nexits ngoto nret rret) : lt_state (CminorSel.State f s1 (Kseq s2 k) sp e m)\n  (CminorSel.State f (Sseq s1 s2) k sp e m).","conclusion":"lt_state (CminorSel.State f s1 (Kseq s2 k) sp e m)\n  (CminorSel.State f (Sseq s1 s2) k sp e m)","hypotheses":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H1 : tr_stmt (fn_code tf) map s2 n ncont nexits ngoto nret rret) (H8 : tr_stmt (fn_code tf) map s1 ns n nexits ngoto nret rret)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H1 : tr_stmt (fn_code tf) map s2 n ncont nexits ngoto nret rret) (H8 : tr_stmt (fn_code tf) map s1 ns n nexits ngoto nret rret) : tr_cont (fn_code tf) map (Kseq s2 k) n nexits ngoto nret rret cs.","conclusion":"tr_cont (fn_code tf) map (Kseq s2 k) n nexits ngoto nret rret cs","hypotheses":"(f : CminorSel.function) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : node) (H1 : tr_stmt (fn_code tf) map s2 n ncont nexits ngoto nret rret) (H8 : tr_stmt (fn_code tf) map s1 ns n nexits ngoto nret rret)","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (c : condexpr) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (b : bool) (H : eval_condexpr ge sp e m nil c b) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sifthenelse c s1 s2) ns ncont nexits ngoto nret\n  rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (if b then s1 else s2) k sp e m)\n     (CminorSel.State f (Sifthenelse c s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f (if b then s1 else s2) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (if b then s1 else s2) k sp e m)\n     (CminorSel.State f (Sifthenelse c s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f (if b then s1 else s2) k sp e m) R2","hypotheses":"(f : CminorSel.function) (c : condexpr) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (b : bool) (H : eval_condexpr ge sp e m nil c b) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sifthenelse c s1 s2) ns ncont nexits ngoto nret\n  rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit transl_condexpr_correct; eauto.\nintros [rs' [tm' [A [B [C D]]]]].\neconstructor; split.\nleft.\neexact A.\ndestruct b; econstructor; eauto."},{"statement":"(f : CminorSel.function) (c : condexpr) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (b : bool) (H : eval_condexpr ge sp e m nil c b) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (ntrue nfalse : node) (H3 : tr_stmt (fn_code tf) map s1 ntrue ncont nexits ngoto nret rret) (H10 : tr_stmt (fn_code tf) map s2 nfalse ncont nexits ngoto nret rret) (H11 : tr_condition (fn_code tf) map nil c ns ntrue nfalse) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (if b then s1 else s2) k sp e m)\n     (CminorSel.State f (Sifthenelse c s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f (if b then s1 else s2) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (if b then s1 else s2) k sp e m)\n     (CminorSel.State f (Sifthenelse c s1 s2) k sp e m)) /\\\n  match_states (CminorSel.State f (if b then s1 else s2) k sp e m) R2","hypotheses":"(f : CminorSel.function) (c : condexpr) (s1 s2 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (b : bool) (H : eval_condexpr ge sp e m nil c b) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (ntrue nfalse : node) (H3 : tr_stmt (fn_code tf) map s1 ntrue ncont nexits ngoto nret rret) (H10 : tr_stmt (fn_code tf) map s2 nfalse ncont nexits ngoto nret rret) (H11 : tr_condition (fn_code tf) map nil c ns ntrue nfalse)","proofString":"exploit transl_condexpr_correct; eauto.\nintros [rs' [tm' [A [B [C D]]]]].\neconstructor; split.\nleft.\neexact A.\ndestruct b; econstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kseq (Sloop s) k) sp e m)\n     (CminorSel.State f (Sloop s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kseq (Sloop s) k) sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kseq (Sloop s) k) sp e m)\n     (CminorSel.State f (Sloop s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kseq (Sloop s) k) sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inversion TS; subst.\neconstructor; split.\nleft.\napply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nloop nend : node) (H0 : tr_stmt (fn_code tf) map s nloop nend nexits ngoto nret rret) (H1 : (fn_code tf) ! ns = Some (Inop nloop)) (H2 : (fn_code tf) ! nend = Some (Inop nloop)) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kseq (Sloop s) k) sp e m)\n     (CminorSel.State f (Sloop s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kseq (Sloop s) k) sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kseq (Sloop s) k) sp e m)\n     (CminorSel.State f (Sloop s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kseq (Sloop s) k) sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nloop nend : node) (H0 : tr_stmt (fn_code tf) map s nloop nend nexits ngoto nret rret) (H1 : (fn_code tf) ! ns = Some (Inop nloop)) (H2 : (fn_code tf) ! nend = Some (Inop nloop))","proofString":"econstructor; split.\nleft.\napply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nloop nend : node) (H0 : tr_stmt (fn_code tf) map s nloop nend nexits ngoto nret rret) (H1 : (fn_code tf) ! ns = Some (Inop nloop)) (H2 : (fn_code tf) ! nend = Some (Inop nloop)) : tr_cont (fn_code tf) map (Kseq (Sloop s) k) nend nexits ngoto nret rret cs.","conclusion":"tr_cont (fn_code tf) map (Kseq (Sloop s) k) nend nexits ngoto nret rret cs","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nloop nend : node) (H0 : tr_stmt (fn_code tf) map s nloop nend nexits ngoto nret rret) (H1 : (fn_code tf) ! ns = Some (Inop nloop)) (H2 : (fn_code tf) ! nend = Some (Inop nloop))","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nloop nend : node) (H0 : tr_stmt (fn_code tf) map s nloop nend nexits ngoto nret rret) (H1 : (fn_code tf) ! ns = Some (Inop nloop)) (H2 : (fn_code tf) ! nend = Some (Inop nloop)) : tr_stmt (fn_code tf) map (Sloop s) nend ncont nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map (Sloop s) nend ncont nexits ngoto nret rret","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sloop s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nloop nend : node) (H0 : tr_stmt (fn_code tf) map s nloop nend nexits ngoto nret rret) (H1 : (fn_code tf) ! ns = Some (Inop nloop)) (H2 : (fn_code tf) ! nend = Some (Inop nloop))","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sblock s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kblock k) sp e m)\n     (CminorSel.State f (Sblock s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kblock k) sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kblock k) sp e m)\n     (CminorSel.State f (Sblock s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kblock k) sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sblock s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : tr_stmt (fn_code tf) map s ns ncont (ncont :: nexits) ngoto nret rret) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kblock k) sp e m)\n     (CminorSel.State f (Sblock s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kblock k) sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s (Kblock k) sp e m)\n     (CminorSel.State f (Sblock s) k sp e m)) /\\\n  match_states (CminorSel.State f s (Kblock k) sp e m) R2","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : tr_stmt (fn_code tf) map s ns ncont (ncont :: nexits) ngoto nret rret)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : tr_stmt (fn_code tf) map s ns ncont (ncont :: nexits) ngoto nret rret) : lt_state (CminorSel.State f s (Kblock k) sp e m)\n  (CminorSel.State f (Sblock s) k sp e m).","conclusion":"lt_state (CminorSel.State f s (Kblock k) sp e m)\n  (CminorSel.State f (Sblock s) k sp e m)","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : tr_stmt (fn_code tf) map s ns ncont (ncont :: nexits) ngoto nret rret)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : tr_stmt (fn_code tf) map s ns ncont (ncont :: nexits) ngoto nret rret) : tr_cont (fn_code tf) map (Kblock k) ncont (ncont :: nexits) ngoto nret rret\n  cs.","conclusion":"tr_cont (fn_code tf) map (Kblock k) ncont (ncont :: nexits) ngoto nret rret\n  cs","hypotheses":"(f : CminorSel.function) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : tr_stmt (fn_code tf) map s ns ncont (ncont :: nexits) ngoto nret rret)","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sexit n) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit n) (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit n) (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sexit n) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\ninv TK.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit n) (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit n) (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kseq s k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns)","proofString":"inv TK.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) (n0 : node) (H4 : tr_stmt (fn_code tf) map s ncont n0 nexits ngoto nret rret) (H11 : tr_cont (fn_code tf) map k n0 nexits ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit n) (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit n) (Kseq s k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) (n0 : node) (H4 : tr_stmt (fn_code tf) map s ncont n0 nexits ngoto nret rret) (H11 : tr_cont (fn_code tf) map k n0 nexits ngoto nret rret cs)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) (n0 : node) (H4 : tr_stmt (fn_code tf) map s ncont n0 nexits ngoto nret rret) (H11 : tr_cont (fn_code tf) map k n0 nexits ngoto nret rret cs) : lt_state (CminorSel.State f (Sexit n) k sp e m)\n  (CminorSel.State f (Sexit n) (Kseq s k) sp e m).","conclusion":"lt_state (CminorSel.State f (Sexit n) k sp e m)\n  (CminorSel.State f (Sexit n) (Kseq s k) sp e m)","hypotheses":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) (n0 : node) (H4 : tr_stmt (fn_code tf) map s ncont n0 nexits ngoto nret rret) (H11 : tr_cont (fn_code tf) map k n0 nexits ngoto nret rret cs)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) (n0 : node) (H4 : tr_stmt (fn_code tf) map s ncont n0 nexits ngoto nret rret) (H11 : tr_cont (fn_code tf) map k n0 nexits ngoto nret rret cs) : tr_stmt (fn_code tf) map (Sexit n) ns n0 nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map (Sexit n) ns n0 nexits ngoto nret rret","hypotheses":"(f : CminorSel.function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits n = Some ns) (n0 : node) (H4 : tr_stmt (fn_code tf) map s ncont n0 nexits ngoto nret rret) (H11 : tr_cont (fn_code tf) map k n0 nexits ngoto nret rret cs)","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sexit 0) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sexit 0) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\ninv TK.\nsimpl in H0.\ninv H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits 0 = Some ns) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits 0 = Some ns)","proofString":"inv TK.\nsimpl in H0.\ninv H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error (ncont :: nexits0) 0 = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error (ncont :: nexits0) 0 = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"simpl in H0.\ninv H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : Some ncont = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : Some ncont = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"inv H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H3 : tr_cont (fn_code tf) map k ns nexits0 ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp e m)\n     (CminorSel.State f (Sexit 0) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f Sskip k sp e m) R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H3 : tr_cont (fn_code tf) map k ns nexits0 ngoto nret rret cs)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H3 : tr_cont (fn_code tf) map k ns nexits0 ngoto nret rret cs) : lt_state (CminorSel.State f Sskip k sp e m)\n  (CminorSel.State f (Sexit 0) (Kblock k) sp e m).","conclusion":"lt_state (CminorSel.State f Sskip k sp e m)\n  (CminorSel.State f (Sexit 0) (Kblock k) sp e m)","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H3 : tr_cont (fn_code tf) map k ns nexits0 ngoto nret rret cs)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H3 : tr_cont (fn_code tf) map k ns nexits0 ngoto nret rret cs) : tr_stmt (fn_code tf) map Sskip ns ns nexits0 ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map Sskip ns ns nexits0 ngoto nret rret","hypotheses":"(f : CminorSel.function) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H3 : tr_cont (fn_code tf) map k ns nexits0 ngoto nret rret cs)","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sexit (S n)) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sexit (S n)) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\ninv TK.\nsimpl in H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits (S n) = Some ns) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map (Kblock k) ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H0 : nth_error nexits (S n) = Some ns)","proofString":"inv TK.\nsimpl in H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error (ncont :: nexits0) (S n) = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error (ncont :: nexits0) (S n) = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"simpl in H0.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error nexits0 n = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error nexits0 n = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error nexits0 n = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : lt_state (CminorSel.State f (Sexit n) k sp e m)\n  (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m).","conclusion":"lt_state (CminorSel.State f (Sexit n) k sp e m)\n  (CminorSel.State f (Sexit (S n)) (Kblock k) sp e m)","hypotheses":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error nexits0 n = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error nexits0 n = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs) : tr_stmt (fn_code tf) map (Sexit n) ns ncont nexits0 ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map (Sexit n) ns ncont nexits0 ngoto nret rret","hypotheses":"(f : CminorSel.function) (n : nat) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (nexits0 : list node) (H0 : nth_error nexits0 n = Some ns) (H3 : tr_cont (fn_code tf) map k ncont nexits0 ngoto nret rret cs)","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (a : exitexpr) (k : cont) (sp : val) (e : env) (m : mem) (n : nat) (H : eval_exitexpr ge sp e m nil a n) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sswitch a) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sswitch a) k sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sswitch a) k sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (a : exitexpr) (k : cont) (sp : val) (e : env) (m : mem) (n : nat) (H : eval_exitexpr ge sp e m nil a n) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sswitch a) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit transl_exitexpr_correct; eauto.\nintros (nd & rs' & tm' & A & B & C & D).\neconstructor; split.\nright; split.\neexact A.\nLt_state.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (a : exitexpr) (k : cont) (sp : val) (e : env) (m : mem) (n : nat) (H : eval_exitexpr ge sp e m nil a n) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : tr_exitexpr (fn_code tf) map a ns nexits) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sswitch a) k sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f (Sexit n) k sp e m)\n     (CminorSel.State f (Sswitch a) k sp e m)) /\\\n  match_states (CminorSel.State f (Sexit n) k sp e m) R2","hypotheses":"(f : CminorSel.function) (a : exitexpr) (k : cont) (sp : val) (e : env) (m : mem) (n : nat) (H : eval_exitexpr ge sp e m nil a n) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : tr_exitexpr (fn_code tf) map a ns nexits)","proofString":"exploit transl_exitexpr_correct; eauto.\nintros (nd & rs' & tm' & A & B & C & D).\neconstructor; split.\nright; split.\neexact A.\nLt_state.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (a : exitexpr) (k : cont) (sp : val) (e : env) (m : mem) (n : nat) (H : eval_exitexpr ge sp e m nil a n) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : tr_exitexpr (fn_code tf) map a ns nexits) (nd : node) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp nd rs' tm')) (B : nth_error nexits n = Some nd) (C : match_env map e nil rs') (D : Mem.extends m tm') : tr_stmt (fn_code tf) map (Sexit n) nd ncont nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map (Sexit n) nd ncont nexits ngoto nret rret","hypotheses":"(f : CminorSel.function) (a : exitexpr) (k : cont) (sp : val) (e : env) (m : mem) (n : nat) (H : eval_exitexpr ge sp e m nil a n) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : tr_exitexpr (fn_code tf) map a ns nexits) (nd : node) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf sp ns rs tm) E0 (State cs tf sp nd rs' tm')) (B : nth_error nexits n = Some nd) (C : match_env map e nil rs') (D : Mem.extends m tm')","proofString":"constructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sreturn None) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sreturn None) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit match_stacks_call_cont; eauto.\nintros [U V].\ninversion TF.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn; eauto.\nrewrite H2; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"exploit match_stacks_call_cont; eauto.\nintros [U V].\ninversion TF.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn; eauto.\nrewrite H2; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : match_stacks (call_cont k) cs /\\ (fn_code tf) ! nret = Some (Ireturn rret) ->\nexists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2.","conclusion":"match_stacks (call_cont k) cs /\\ (fn_code tf) ! nret = Some (Ireturn rret) ->\nexists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"intros [U V].\ninversion TF.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn; eauto.\nrewrite H2; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret))","proofString":"inversion TF.\nedestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn; eauto.\nrewrite H2; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) (nentry : node) (r : reg) (H0 : rret = ret_reg (CminorSel.fn_sig f) r) (H1 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret rret) (H2 : fn_stacksize tf = fn_stackspace f) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) (nentry : node) (r : reg) (H0 : rret = ret_reg (CminorSel.fn_sig f) r) (H1 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret rret) (H2 : fn_stacksize tf = fn_stackspace f)","proofString":"edestruct Mem.free_parallel_extends as [tm' []]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn; eauto.\nrewrite H2; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) (nentry : node) (r : reg) (H0 : rret = ret_reg (CminorSel.fn_sig f) r) (H1 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret rret) (H2 : fn_stacksize tf = fn_stackspace f) (tm' : mem) (H3 : Mem.free tm sp 0 (fn_stackspace f) = Some tm') (H4 : Mem.extends m' tm') : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) nret rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate Vundef (call_cont k) m')\n     (CminorSel.State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate Vundef (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (k : cont) (sp : block) (e : env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn rret)) (nentry : node) (r : reg) (H0 : rret = ret_reg (CminorSel.fn_sig f) r) (H1 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret rret) (H2 : fn_stacksize tf = fn_stackspace f) (tm' : mem) (H3 : Mem.free tm sp 0 (fn_stackspace f) = Some tm') (H4 : Mem.extends m' tm')","proofString":"econstructor; split.\nleft; apply plus_one.\neapply exec_Ireturn; eauto.\nrewrite H2; eauto.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (a : expr) (k : cont) (sp : block) (e : env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m nil a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sreturn (Some a)) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate v (call_cont k) m')\n     (CminorSel.State f (Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate v (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate v (call_cont k) m')\n     (CminorSel.State f (Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate v (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (a : expr) (k : cont) (sp : block) (e : env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m nil a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sreturn (Some a)) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\nexploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D E]]]]]].\nexploit match_stacks_call_cont; eauto.\nintros [U V].\ninversion TF.\nedestruct Mem.free_parallel_extends as [tm'' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neexact A.\neapply exec_Ireturn; eauto.\nrewrite H4; eauto.\ntraceEq.\nsimpl.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (a : expr) (k : cont) (sp : block) (e : env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m nil a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (rret0 : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret (Some rret0) cs) (TF : tr_fun tf map f ngoto nret (Some rret0)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H2 : tr_expr (fn_code tf) map nil a ns nret rret0 None) : exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate v (call_cont k) m')\n     (CminorSel.State f (Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate v (call_cont k) m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 \\/\n   star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.Returnstate v (call_cont k) m')\n     (CminorSel.State f (Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) /\\\n  match_states (CminorSel.Returnstate v (call_cont k) m') R2","hypotheses":"(f : CminorSel.function) (a : expr) (k : cont) (sp : block) (e : env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m nil a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (rret0 : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret (Some rret0) cs) (TF : tr_fun tf map f ngoto nret (Some rret0)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H2 : tr_expr (fn_code tf) map nil a ns nret rret0 None)","proofString":"exploit transl_expr_correct; eauto.\nintros [rs' [tm' [A [B [C [D E]]]]]].\nexploit match_stacks_call_cont; eauto.\nintros [U V].\ninversion TF.\nedestruct Mem.free_parallel_extends as [tm'' []]; eauto.\neconstructor; split.\nleft; eapply plus_right.\neexact A.\neapply exec_Ireturn; eauto.\nrewrite H4; eauto.\ntraceEq.\nsimpl.\nconstructor; auto."},{"statement":"(f : CminorSel.function) (a : expr) (k : cont) (sp : block) (e : env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m nil a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (rret0 : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret (Some rret0) cs) (TF : tr_fun tf map f ngoto nret (Some rret0)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H2 : tr_expr (fn_code tf) map nil a ns nret rret0 None) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0\n  (State cs tf (Vptr sp Ptrofs.zero) nret rs' tm')) (B : match_env map (set_optvar None v e) nil rs') (C : Val.lessdef v rs' # rret0) (D : forall r0 : reg, In r0 nil -> rs' # r0 = rs # r0) (E : Mem.extends m tm') (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn (Some rret0))) (nentry : node) (r : reg) (H1 : Some rret0 = ret_reg (CminorSel.fn_sig f) r) (H3 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret (Some rret0)) (H4 : fn_stacksize tf = fn_stackspace f) (tm'' : mem) (H5 : Mem.free tm' sp 0 (fn_stackspace f) = Some tm'') (H6 : Mem.extends m' tm'') : match_states (CminorSel.Returnstate v (call_cont k) m')\n  (Returnstate cs rs' # rret0 tm'').","conclusion":"match_states (CminorSel.Returnstate v (call_cont k) m')\n  (Returnstate cs rs' # rret0 tm'')","hypotheses":"(f : CminorSel.function) (a : expr) (k : cont) (sp : block) (e : env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m nil a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (rret0 : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret (Some rret0) cs) (TF : tr_fun tf map f ngoto nret (Some rret0)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H2 : tr_expr (fn_code tf) map nil a ns nret rret0 None) (rs' : regset) (tm' : mem) (A : star step tge (State cs tf (Vptr sp Ptrofs.zero) ns rs tm) E0\n  (State cs tf (Vptr sp Ptrofs.zero) nret rs' tm')) (B : match_env map (set_optvar None v e) nil rs') (C : Val.lessdef v rs' # rret0) (D : forall r0 : reg, In r0 nil -> rs' # r0 = rs # r0) (E : Mem.extends m tm') (U : match_stacks (call_cont k) cs) (V : (fn_code tf) ! nret = Some (Ireturn (Some rret0))) (nentry : node) (r : reg) (H1 : Some rret0 = ret_reg (CminorSel.fn_sig f) r) (H3 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret (Some rret0)) (H4 : fn_stacksize tf = fn_stackspace f) (tm'' : mem) (H5 : Mem.free tm' sp 0 (fn_stackspace f) = Some tm'') (H6 : Mem.extends m' tm'')","proofString":"constructor; auto."},{"statement":"(f : CminorSel.function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Slabel lbl s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f (Slabel lbl s) k sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f (Slabel lbl s) k sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2","hypotheses":"(f : CminorSel.function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Slabel lbl s) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\neconstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : positive) (H1 : ngoto ! lbl = Some n) (H2 : (fn_code tf) ! n = Some (Inop ns)) (H9 : tr_stmt (fn_code tf) map s ns ncont nexits ngoto nret rret) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f (Slabel lbl s) k sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s k sp e m)\n     (CminorSel.State f (Slabel lbl s) k sp e m)) /\\\n  match_states (CminorSel.State f s k sp e m) R2","hypotheses":"(f : CminorSel.function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : positive) (H1 : ngoto ! lbl = Some n) (H2 : (fn_code tf) ! n = Some (Inop ns)) (H9 : tr_stmt (fn_code tf) map s ns ncont nexits ngoto nret rret)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nLt_state.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : positive) (H1 : ngoto ! lbl = Some n) (H2 : (fn_code tf) ! n = Some (Inop ns)) (H9 : tr_stmt (fn_code tf) map s ns ncont nexits ngoto nret rret) : lt_state (CminorSel.State f s k sp e m)\n  (CminorSel.State f (Slabel lbl s) k sp e m).","conclusion":"lt_state (CminorSel.State f s k sp e m)\n  (CminorSel.State f (Slabel lbl s) k sp e m)","hypotheses":"(f : CminorSel.function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : env) (m tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (n : positive) (H1 : ngoto ! lbl = Some n) (H2 : (fn_code tf) ! n = Some (Inop ns)) (H9 : tr_stmt (fn_code tf) map s ns ncont nexits ngoto nret rret)","proofString":"Lt_state."},{"statement":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sgoto lbl) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2","hypotheses":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TS : tr_stmt (fn_code tf) map (Sgoto lbl) ns ncont nexits ngoto nret rret) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm)","proofString":"inv TS.\ninversion TF; subst.\nexploit tr_find_label; eauto.\neapply tr_cont_call_cont; eauto.\nintros [ns2 [nd2 [nexits2 [A [B C]]]]].\neconstructor; split.\nleft; apply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : ngoto ! lbl = Some ns) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2","hypotheses":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (MWF : map_wf map) (TF : tr_fun tf map f ngoto nret rret) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret rret cs) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : ngoto ! lbl = Some ns)","proofString":"inversion TF; subst.\nexploit tr_find_label; eauto.\neapply tr_cont_call_cont; eauto.\nintros [ns2 [nd2 [nexits2 [A [B C]]]]].\neconstructor; split.\nleft; apply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (r : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) (TF : tr_fun tf map f ngoto nret (ret_reg (CminorSel.fn_sig f) r)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : ngoto ! lbl = Some ns) (nentry : node) (H2 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (H3 : fn_stacksize tf = fn_stackspace f) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2","hypotheses":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (r : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) (TF : tr_fun tf map f ngoto nret (ret_reg (CminorSel.fn_sig f) r)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : ngoto ! lbl = Some ns) (nentry : node) (H2 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (H3 : fn_stacksize tf = fn_stackspace f)","proofString":"exploit tr_find_label; eauto.\neapply tr_cont_call_cont; eauto.\nintros [ns2 [nd2 [nexits2 [A [B C]]]]].\neconstructor; split.\nleft; apply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (r : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) (TF : tr_fun tf map f ngoto nret (ret_reg (CminorSel.fn_sig f) r)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : ngoto ! lbl = Some ns) (nentry : node) (H2 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (H3 : fn_stacksize tf = fn_stackspace f) (ns2 nd2 : node) (nexits2 : list node) (A : (fn_code tf) ! ns = Some (Inop ns2)) (B : tr_stmt (fn_code tf) map s' ns2 nd2 nexits2 ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (C : tr_cont (fn_code tf) map k' nd2 nexits2 ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) : exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (State cs tf sp ns rs tm) E0 R2 \\/\n   star step tge (State cs tf sp ns rs tm) E0 R2 /\\\n   lt_state (CminorSel.State f s' k' sp e m)\n     (CminorSel.State f (Sgoto lbl) k sp e m)) /\\\n  match_states (CminorSel.State f s' k' sp e m) R2","hypotheses":"(f : CminorSel.function) (lbl : label) (k : cont) (sp : val) (e : env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (tm : mem) (cs : list stackframe) (tf : function) (ns : node) (rs : regset) (map : mapping) (ncont : node) (nexits : list node) (ngoto : labelmap) (nret : node) (MWF : map_wf map) (r : reg) (TK : tr_cont (fn_code tf) map k ncont nexits ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs) (TF : tr_fun tf map f ngoto nret (ret_reg (CminorSel.fn_sig f) r)) (ME : match_env map e nil rs) (MEXT : Mem.extends m tm) (H1 : ngoto ! lbl = Some ns) (nentry : node) (H2 : tr_stmt (fn_code tf) map (fn_body f) nentry nret nil ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (H3 : fn_stacksize tf = fn_stackspace f) (ns2 nd2 : node) (nexits2 : list node) (A : (fn_code tf) ! ns = Some (Inop ns2)) (B : tr_stmt (fn_code tf) map s' ns2 nd2 nexits2 ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r)) (C : tr_cont (fn_code tf) map k' nd2 nexits2 ngoto nret\n  (ret_reg (CminorSel.fn_sig f) r) cs)","proofString":"econstructor; split.\nleft; apply plus_one.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (tf : AST.fundef function) (TF : transl_fundef (Internal f) = OK tf) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (Callstate cs tf targs tm) E0 R2 \\/\n   star step tge (Callstate cs tf targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Callstate cs tf targs tm) E0 R2 \\/\n   star step tge (Callstate cs tf targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (tf : AST.fundef function) (TF : transl_fundef (Internal f) = OK tf) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm)","proofString":"monadInv TF.\nexploit transl_function_charact; eauto.\nintro TRF.\ninversion TRF.\nsubst f0.\npose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).\npose (rs := init_regs targs rparams).\nassert (ME: match_env map2 e nil rs).\nunfold rs, e.\neapply match_init_env_init_reg; eauto.\nassert (MWF: map_wf map2).\nassert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\nedestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neconstructor; eauto.\ninversion MS; subst; econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) : exists R2 : RTL.state,\n  (plus step tge (Callstate cs (Internal x) targs tm) E0 R2 \\/\n   star step tge (Callstate cs (Internal x) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Callstate cs (Internal x) targs tm) E0 R2 \\/\n   star step tge (Callstate cs (Internal x) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x)","proofString":"exploit transl_function_charact; eauto.\nintro TRF.\ninversion TRF.\nsubst f0.\npose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).\npose (rs := init_regs targs rparams).\nassert (ME: match_env map2 e nil rs).\nunfold rs, e.\neapply match_init_env_init_reg; eauto.\nassert (MWF: map_wf map2).\nassert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\nedestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neconstructor; eauto.\ninversion MS; subst; econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) : tr_function f x ->\nexists R2 : RTL.state,\n  (plus step tge (Callstate cs (Internal x) targs tm) E0 R2 \\/\n   star step tge (Callstate cs (Internal x) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2.","conclusion":"tr_function f x ->\nexists R2 : RTL.state,\n  (plus step tge (Callstate cs (Internal x) targs tm) E0 R2 \\/\n   star step tge (Callstate cs (Internal x) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x)","proofString":"intro TRF.\ninversion TRF.\nsubst f0.\npose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).\npose (rs := init_regs targs rparams).\nassert (ME: match_env map2 e nil rs).\nunfold rs, e.\neapply match_init_env_init_reg; eauto.\nassert (MWF: map_wf map2).\nassert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\nedestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neconstructor; eauto.\ninversion MS; subst; econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) : exists R2 : RTL.state,\n  (plus step tge (Callstate cs (Internal x) targs tm) E0 R2 \\/\n   star step tge (Callstate cs (Internal x) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Callstate cs (Internal x) targs tm) E0 R2 \\/\n   star step tge (Callstate cs (Internal x) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x)","proofString":"inversion TRF.\nsubst f0.\npose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).\npose (rs := init_regs targs rparams).\nassert (ME: match_env map2 e nil rs).\nunfold rs, e.\neapply match_init_env_init_reg; eauto.\nassert (MWF: map_wf map2).\nassert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\nedestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neconstructor; eauto.\ninversion MS; subst; econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (f0 : CminorSel.function) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H6 : f0 = f) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) : exists R2 : RTL.state,\n  (plus step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 \\/\n   star step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 \\/\n   star step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (f0 : CminorSel.function) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H6 : f0 = f) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x)","proofString":"subst f0.\npose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).\npose (rs := init_regs targs rparams).\nassert (ME: match_env map2 e nil rs).\nunfold rs, e.\neapply match_init_env_init_reg; eauto.\nassert (MWF: map_wf map2).\nassert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\nedestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neconstructor; eauto.\ninversion MS; subst; econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) : exists R2 : RTL.state,\n  (plus step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 \\/\n   star step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 \\/\n   star step tge\n     (Callstate cs\n        (Internal\n           {|\n             fn_sig := CminorSel.fn_sig f;\n             fn_params := rparams;\n             fn_stacksize := fn_stackspace f;\n             fn_code := code;\n             fn_entrypoint := nentry\n           |}) targs tm) E0 R2 /\\\n   lt_state\n     (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f)))\n        m') (CminorSel.Callstate (Internal f) vargs k m)) /\\\n  match_states\n    (CminorSel.State f (fn_body f) k (Vptr sp Ptrofs.zero)\n       (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) m')\n    R2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x)","proofString":"pose (e := set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))).\npose (rs := init_regs targs rparams).\nassert (ME: match_env map2 e nil rs).\nunfold rs, e.\neapply match_init_env_init_reg; eauto.\nassert (MWF: map_wf map2).\nassert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf.\nedestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_internal; simpl; eauto using Val.has_argtype_list_lessdef.\nsimpl.\neconstructor; eauto.\neconstructor; eauto.\ninversion MS; subst; econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) : match_env map2\n  (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) nil\n  (init_regs targs rparams).","conclusion":"match_env map2\n  (set_locals (fn_vars f) (set_params vargs (CminorSel.fn_params f))) nil\n  (init_regs targs rparams)","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset)","proofString":"eapply match_init_env_init_reg; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) : map_wf map2.","conclusion":"map_wf map2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs)","proofString":"assert (map_valid init_mapping s0) by apply init_mapping_valid.\nexploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) : map_wf map2.","conclusion":"map_wf map2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0)","proofString":"exploit (add_vars_valid (CminorSel.fn_params f)); eauto.\nintros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) : regs_valid rparams s1 /\\ map_valid map1 s1 -> map_wf map2.","conclusion":"regs_valid rparams s1 /\\ map_valid map1 s1 -> map_wf map2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0)","proofString":"intros [A B].\neapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) (A : regs_valid rparams s1) (B : map_valid map1 s1) : map_wf map2.","conclusion":"map_wf map2","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) (A : regs_valid rparams s1) (B : map_valid map1 s1)","proofString":"eapply add_vars_wf; eauto.\neapply add_vars_wf; eauto.\napply init_mapping_wf."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) (A : regs_valid rparams s1) (B : map_valid map1 s1) : map_wf map1.","conclusion":"map_wf map1","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) (A : regs_valid rparams s1) (B : map_valid map1 s1)","proofString":"eapply add_vars_wf; eauto.\napply init_mapping_wf."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) (A : regs_valid rparams s1) (B : map_valid map1 s1) : map_wf init_mapping.","conclusion":"map_wf init_mapping","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (H6 : map_valid init_mapping s0) (A : regs_valid rparams s1) (B : map_valid map1 s1)","proofString":"apply init_mapping_wf."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (MWF : map_wf map2) (tm' : Mem.mem') (H6 : Mem.alloc tm 0 (fn_stackspace f) = (tm', sp)) (H8 : Mem.extends m' tm') : tr_fun\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := code;\n    fn_entrypoint := nentry\n  |} map2 f ngoto nret orret.","conclusion":"tr_fun\n  {|\n    fn_sig := CminorSel.fn_sig f;\n    fn_params := rparams;\n    fn_stacksize := fn_stackspace f;\n    fn_code := code;\n    fn_entrypoint := nentry\n  |} map2 f ngoto nret orret","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (MWF : map_wf map2) (tm' : Mem.mem') (H6 : Mem.alloc tm 0 (fn_stackspace f) = (tm', sp)) (H8 : Mem.extends m' tm')","proofString":"econstructor; eauto."},{"statement":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (MWF : map_wf map2) (tm' : Mem.mem') (H6 : Mem.alloc tm 0 (fn_stackspace f) = (tm', sp)) (H8 : Mem.extends m' tm') : tr_cont\n  (fn_code\n     {|\n       fn_sig := CminorSel.fn_sig f;\n       fn_params := rparams;\n       fn_stacksize := fn_stackspace f;\n       fn_code := code;\n       fn_entrypoint := nentry\n     |}) map2 k nret nil ngoto nret orret cs.","conclusion":"tr_cont\n  (fn_code\n     {|\n       fn_sig := CminorSel.fn_sig f;\n       fn_params := rparams;\n       fn_stacksize := fn_stackspace f;\n       fn_code := code;\n       fn_entrypoint := nentry\n     |}) map2 k nret nil ngoto nret orret cs","hypotheses":"(f : CminorSel.function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (CminorSel.fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (x : function) (EQ : transl_function f = OK x) (TRF : tr_function f x) (code : RTL.code) (rparams : list reg) (map1 : mapping) (s0 s1 : state) (i1 : state_incr s0 s1) (rvars : list reg) (map2 : mapping) (s2 : state) (i2 : state_incr s1 s2) (nentry : node) (ngoto : labelmap) (nret : node) (rret : reg) (orret : option reg) (H1 : add_vars init_mapping (CminorSel.fn_params f) s0 =\nRTLgen.OK (rparams, map1) s1 i1) (H2 : add_vars map1 (fn_vars f) s1 = RTLgen.OK (rvars, map2) s2 i2) (H3 : orret = ret_reg (CminorSel.fn_sig f) rret) (H4 : tr_stmt code map2 (fn_body f) nentry nret nil ngoto nret orret) (H5 : code ! nret = Some (Ireturn orret)) (H7 : {|\n  fn_sig := CminorSel.fn_sig f;\n  fn_params := rparams;\n  fn_stacksize := fn_stackspace f;\n  fn_code := code;\n  fn_entrypoint := nentry\n|} = x) (e : env) (rs : regset) (ME : match_env map2 e nil rs) (MWF : map_wf map2) (tm' : Mem.mem') (H6 : Mem.alloc tm 0 (fn_stackspace f) = (tm', sp)) (H8 : Mem.extends m' tm')","proofString":"inversion MS; subst; econstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (tf : AST.fundef function) (TF : transl_fundef (External ef) = OK tf) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (Callstate cs tf targs tm) t R2 \\/\n   star step tge (Callstate cs tf targs tm) t R2 /\\\n   lt_state (CminorSel.Returnstate vres k m')\n     (CminorSel.Callstate (External ef) vargs k m)) /\\\n  match_states (CminorSel.Returnstate vres k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Callstate cs tf targs tm) t R2 \\/\n   star step tge (Callstate cs tf targs tm) t R2 /\\\n   lt_state (CminorSel.Returnstate vres k m')\n     (CminorSel.Callstate (External ef) vargs k m)) /\\\n  match_states (CminorSel.Returnstate vres k m') R2","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (tf : AST.fundef function) (TF : transl_fundef (External ef) = OK tf) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm)","proofString":"monadInv TF.\nedestruct external_call_mem_extends as [tvres [tm' [A [B [C D]]]]]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (Callstate cs (External ef) targs tm) t R2 \\/\n   star step tge (Callstate cs (External ef) targs tm) t R2 /\\\n   lt_state (CminorSel.Returnstate vres k m')\n     (CminorSel.Callstate (External ef) vargs k m)) /\\\n  match_states (CminorSel.Returnstate vres k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Callstate cs (External ef) targs tm) t R2 \\/\n   star step tge (Callstate cs (External ef) targs tm) t R2 /\\\n   lt_state (CminorSel.Returnstate vres k m')\n     (CminorSel.Callstate (External ef) vargs k m)) /\\\n  match_states (CminorSel.Returnstate vres k m') R2","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm)","proofString":"edestruct external_call_mem_extends as [tvres [tm' [A [B [C D]]]]]; eauto.\neconstructor; split.\nleft; apply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge targs tm t tvres tm') (B : Val.lessdef vres tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : exists R2 : RTL.state,\n  (plus step tge (Callstate cs (External ef) targs tm) t R2 \\/\n   star step tge (Callstate cs (External ef) targs tm) t R2 /\\\n   lt_state (CminorSel.Returnstate vres k m')\n     (CminorSel.Callstate (External ef) vargs k m)) /\\\n  match_states (CminorSel.Returnstate vres k m') R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Callstate cs (External ef) targs tm) t R2 \\/\n   star step tge (Callstate cs (External ef) targs tm) t R2 /\\\n   lt_state (CminorSel.Returnstate vres k m')\n     (CminorSel.Callstate (External ef) vargs k m)) /\\\n  match_states (CminorSel.Returnstate vres k m') R2","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge targs tm t tvres tm') (B : Val.lessdef vres tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm')","proofString":"econstructor; split.\nleft; apply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge targs tm t tvres tm') (B : Val.lessdef vres tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm') : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (targs : list val) (tm : mem) (cs : list stackframe) (MS : match_stacks k cs) (LD : Val.lessdef_list vargs targs) (MEXT : Mem.extends m tm) (tvres : val) (tm' : mem) (A : external_call ef ge targs tm t tvres tm') (B : Val.lessdef vres tvres) (C : Mem.extends m' tm') (D : Mem.unchanged_on (loc_out_of_bounds m) tm tm')","proofString":"apply senv_preserved."},{"statement":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (cs : list stackframe) (MS : match_stacks (Kcall optid f sp e k) cs) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) : exists R2 : RTL.state,\n  (plus step tge (Returnstate cs tv tm) E0 R2 \\/\n   star step tge (Returnstate cs tv tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_optvar optid v e) m)\n     (CminorSel.Returnstate v (Kcall optid f sp e k) m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_optvar optid v e) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Returnstate cs tv tm) E0 R2 \\/\n   star step tge (Returnstate cs tv tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_optvar optid v e) m)\n     (CminorSel.Returnstate v (Kcall optid f sp e k) m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_optvar optid v e) m) R2","hypotheses":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (cs : list stackframe) (MS : match_stacks (Kcall optid f sp e k) cs) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm)","proofString":"inv MS.\neconstructor; split.\nleft; apply plus_one; constructor.\neconstructor; eauto.\nconstructor.\neapply match_env_update_dest; eauto."},{"statement":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) (r : reg) (tf : function) (n : node) (rs : regset) (cs0 : list stackframe) (map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (H4 : map_wf map) (H6 : tr_fun tf map f ngoto nret rret) (H7 : match_env map e nil rs) (H8 : reg_map_ok map r optid) (H9 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs0) : exists R2 : RTL.state,\n  (plus step tge (Returnstate (Stackframe r tf sp n rs :: cs0) tv tm) E0 R2 \\/\n   star step tge (Returnstate (Stackframe r tf sp n rs :: cs0) tv tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_optvar optid v e) m)\n     (CminorSel.Returnstate v (Kcall optid f sp e k) m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_optvar optid v e) m) R2.","conclusion":"exists R2 : RTL.state,\n  (plus step tge (Returnstate (Stackframe r tf sp n rs :: cs0) tv tm) E0 R2 \\/\n   star step tge (Returnstate (Stackframe r tf sp n rs :: cs0) tv tm) E0 R2 /\\\n   lt_state (CminorSel.State f Sskip k sp (set_optvar optid v e) m)\n     (CminorSel.Returnstate v (Kcall optid f sp e k) m)) /\\\n  match_states (CminorSel.State f Sskip k sp (set_optvar optid v e) m) R2","hypotheses":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) (r : reg) (tf : function) (n : node) (rs : regset) (cs0 : list stackframe) (map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (H4 : map_wf map) (H6 : tr_fun tf map f ngoto nret rret) (H7 : match_env map e nil rs) (H8 : reg_map_ok map r optid) (H9 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs0)","proofString":"econstructor; split.\nleft; apply plus_one; constructor.\neconstructor; eauto.\nconstructor.\neapply match_env_update_dest; eauto."},{"statement":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) (r : reg) (tf : function) (n : node) (rs : regset) (cs0 : list stackframe) (map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (H4 : map_wf map) (H6 : tr_fun tf map f ngoto nret rret) (H7 : match_env map e nil rs) (H8 : reg_map_ok map r optid) (H9 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs0) : tr_stmt (fn_code tf) map Sskip n n nexits ngoto nret rret.","conclusion":"tr_stmt (fn_code tf) map Sskip n n nexits ngoto nret rret","hypotheses":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) (r : reg) (tf : function) (n : node) (rs : regset) (cs0 : list stackframe) (map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (H4 : map_wf map) (H6 : tr_fun tf map f ngoto nret rret) (H7 : match_env map e nil rs) (H8 : reg_map_ok map r optid) (H9 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs0)","proofString":"constructor."},{"statement":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) (r : reg) (tf : function) (n : node) (rs : regset) (cs0 : list stackframe) (map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (H4 : map_wf map) (H6 : tr_fun tf map f ngoto nret rret) (H7 : match_env map e nil rs) (H8 : reg_map_ok map r optid) (H9 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs0) : match_env map (set_optvar optid v e) nil rs # r <- tv.","conclusion":"match_env map (set_optvar optid v e) nil rs # r <- tv","hypotheses":"(v : val) (optid : option ident) (f : CminorSel.function) (sp : val) (e : env) (k : cont) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef v tv) (MEXT : Mem.extends m tm) (r : reg) (tf : function) (n : node) (rs : regset) (cs0 : list stackframe) (map : mapping) (nexits : list node) (ngoto : labelmap) (nret : node) (rret : option reg) (H4 : map_wf map) (H6 : tr_fun tf map f ngoto nret rret) (H7 : match_env map e nil rs) (H8 : reg_map_ok map r optid) (H9 : tr_cont (fn_code tf) map k n nexits ngoto nret rret cs0)","proofString":"eapply match_env_update_dest; eauto."},{"statement":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf)","proofString":"symmetry; eapply match_program_main; eauto."},{"statement":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf) : funsig tf = CminorSel.funsig f.","conclusion":"funsig tf = CminorSel.funsig f","hypotheses":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf)","proofString":"apply sig_transl_function; auto."},{"statement":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf) : transl_fundef f = OK tf.","conclusion":"transl_fundef f = OK tf","hypotheses":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf)","proofString":"auto."},{"statement":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf) : match_stacks Kstop nil.","conclusion":"match_stacks Kstop nil","hypotheses":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf)","proofString":"constructor."},{"statement":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf) : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf)","proofString":"constructor."},{"statement":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf) : Mem.extends m0 m0.","conclusion":"Mem.extends m0 m0","hypotheses":"(b : block) (f : CminorSel.fundef) (m0 : mem) (ge0 : Genv.t CminorSel.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : CminorSel.funsig f = signature_main) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transl_fundef f = OK tf)","proofString":"apply Mem.extends_refl."},{"statement":"(S : CminorSel.state) (R : RTL.state) (r : int) (H : match_states S R) (H0 : CminorSel.final_state S r) : final_state R r.","conclusion":"final_state R r","hypotheses":"(S : CminorSel.state) (R : RTL.state) (r : int) (H : match_states S R) (H0 : CminorSel.final_state S r)","proofString":"inv H0.\ninv H.\ninv MS.\ninv LD.\nconstructor."},{"statement":"(R : RTL.state) (r : int) (m : mem) (H : match_states (CminorSel.Returnstate (Vint r) Kstop m) R) : final_state R r.","conclusion":"final_state R r","hypotheses":"(R : RTL.state) (r : int) (m : mem) (H : match_states (CminorSel.Returnstate (Vint r) Kstop m) R)","proofString":"inv H.\ninv MS.\ninv LD.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tm : mem) (cs : list stackframe) (MS : match_stacks Kstop cs) (LD : Val.lessdef (Vint r) tv) (MEXT : Mem.extends m tm) : final_state (Returnstate cs tv tm) r.","conclusion":"final_state (Returnstate cs tv tm) r","hypotheses":"(r : int) (m : mem) (tv : val) (tm : mem) (cs : list stackframe) (MS : match_stacks Kstop cs) (LD : Val.lessdef (Vint r) tv) (MEXT : Mem.extends m tm)","proofString":"inv MS.\ninv LD.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef (Vint r) tv) (MEXT : Mem.extends m tm) : final_state (Returnstate nil tv tm) r.","conclusion":"final_state (Returnstate nil tv tm) r","hypotheses":"(r : int) (m : mem) (tv : val) (tm : mem) (LD : Val.lessdef (Vint r) tv) (MEXT : Mem.extends m tm)","proofString":"inv LD.\nconstructor."},{"statement":"(r : int) (m tm : mem) (MEXT : Mem.extends m tm) : final_state (Returnstate nil (Vint r) tm) r.","conclusion":"final_state (Returnstate nil (Vint r) tm) r","hypotheses":"(r : int) (m tm : mem) (MEXT : Mem.extends m tm)","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (CminorSel.semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (CminorSel.semantics prog)) id","hypotheses":"","proofString":"apply senv_preserved."},{"statement":"well_founded lt_state.","conclusion":"well_founded lt_state","hypotheses":"","proofString":"apply lt_state_wf."}]}