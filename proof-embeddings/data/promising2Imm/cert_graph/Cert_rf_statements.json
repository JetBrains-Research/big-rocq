{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/cert_graph/Cert_rf.v","fileSamples":[{"statement":"new_rf ⊆ E × (E \\₁ D).","proofString":"unfold new_rf.\nrewrite (wf_furrE WF WF_SC); basic_solver 21."},{"statement":"Gfurr ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘ \\ cert_co ⨾ Gfurr ⊆ E × (E \\₁ D).","proofString":"rewrite (wf_furrE WF WF_SC); basic_solver 21."},{"statement":"new_rf ⊆ W × R.","proofString":"unfold new_rf.\nunfold furr, urr; basic_solver."},{"statement":"Gfurr ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘ \\ cert_co ⨾ Gfurr ⊆ W × R.","proofString":"unfold furr, urr; basic_solver."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (c : actid) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) c) : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)^? (InitEvent l) c.","proofString":"apply rt_of_trans; try done.\napply transitiveI; unfolder; ins; desf; splits; eauto.\neapply cert_co_trans; eauto."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (c : actid) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) c) : transitive (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘).","proofString":"apply transitiveI; unfolder; ins; desf; splits; eauto.\neapply cert_co_trans; eauto."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x0 : actid, (E \\₁ Init) x0 -> In x0 findom) (c : actid) (REL : (cert_co ⨾ ⦗fun x0 : actid => Gfurr x0 b⦘)＊ (InitEvent l) c) (x y z : actid) (H : cert_co x z) (H0 : Gfurr z b) (H1 : cert_co z y) (H2 : Gfurr y b) : cert_co x y.","proofString":"eapply cert_co_trans; eauto."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) (InitEvent l)) : InitEvent l = InitEvent l \\/ In (InitEvent l) findom.","proofString":"tauto."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (c : actid) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) c) (A0 : Gfurr c b) (A : E (InitEvent l)) (A2 : E c) (A1 : is_w Glab (InitEvent l)) (A3 : Gloc (InitEvent l) = Gloc c) (A4 : is_w Glab c) (H : ~ is_init c) : In c findom.","proofString":"apply FINDOM.\nsplit; auto."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (c : actid) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) c) (A0 : Gfurr c b) (A : E (InitEvent l)) (A2 : E c) (A1 : is_w Glab (InitEvent l)) (A3 : Gloc (InitEvent l) = Gloc c) (A4 : is_w Glab c) (H : ~ is_init c) : (E \\₁ Init) c.","proofString":"split; auto."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (l0 : location) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) (InitEvent l0)) (A0 : Gfurr (InitEvent l0) b) (A : E (InitEvent l)) (A2 : E (InitEvent l0)) (A1 : is_w Glab (InitEvent l)) (A3 : Gloc (InitEvent l) = Gloc (InitEvent l0)) (A4 : is_w Glab (InitEvent l0)) (H : is_init (InitEvent l0)) : InitEvent l = InitEvent l0 \\/ In (InitEvent l0) findom.","proofString":"unfold \"Gloc\" in A3.\nrewrite !wf_init_lab in A3; auto.\nleft.\ncongruence."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (l0 : location) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) (InitEvent l0)) (A0 : Gfurr (InitEvent l0) b) (A : E (InitEvent l)) (A2 : E (InitEvent l0)) (A1 : is_w Glab (InitEvent l)) (A3 : match Glab (InitEvent l) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend =\nmatch Glab (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend) (A4 : is_w Glab (InitEvent l0)) (H : is_init (InitEvent l0)) : InitEvent l = InitEvent l0 \\/ In (InitEvent l0) findom.","proofString":"rewrite !wf_init_lab in A3; auto.\nleft.\ncongruence."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (l0 : location) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) (InitEvent l0)) (A0 : Gfurr (InitEvent l0) b) (A : E (InitEvent l)) (A2 : E (InitEvent l0)) (A1 : is_w Glab (InitEvent l)) (A3 : Some l = Some l0) (A4 : is_w Glab (InitEvent l0)) (H : is_init (InitEvent l0)) : InitEvent l = InitEvent l0 \\/ In (InitEvent l0) findom.","proofString":"left.\ncongruence."},{"statement":"(b : actid) (l : location) (FIN0 : set_finite (E \\₁ Init)) (findom : list actid) (FINDOM : forall x : actid, (E \\₁ Init) x -> In x findom) (l0 : location) (REL : (cert_co ⨾ ⦗fun x : actid => Gfurr x b⦘)＊ (InitEvent l) (InitEvent l0)) (A0 : Gfurr (InitEvent l0) b) (A : E (InitEvent l)) (A2 : E (InitEvent l0)) (A1 : is_w Glab (InitEvent l)) (A3 : Some l = Some l0) (A4 : is_w Glab (InitEvent l0)) (H : is_init (InitEvent l0)) : InitEvent l = InitEvent l0.","proofString":"congruence."},{"statement":"(E \\₁ D) ∩₁ R ⊆₁ codom_rel new_rf.","proofString":"unfolder; ins; desf.\napply new_rf_comp; basic_solver."},{"statement":"(x : actid) (H : E x) (H1 : ~ D x) (H0 : is_r Glab x) : exists x0 : actid, new_rf x0 x.","proofString":"apply new_rf_comp; basic_solver."},{"statement":"codom_rel new_rf ⊆₁ (E \\₁ D) ∩₁ R.","proofString":"unfold new_rf; basic_solver."},{"statement":"irreflexive (Gfurr ⨾ Ghb ⨾ (sc ⨾ Ghb)^?).","proofString":"apply furr_hb_sc_hb_irr; done."},{"statement":"⦗E \\₁ I⦘ ⨾ new_rf ⊆ Gsb.","proofString":"apply non_I_new_rf."},{"statement":"(⦗E⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"arewrite (⦗E⦘ ⊆ ⦗E \\₁ I⦘ ∪ ⦗E ∩₁ I⦘).\nunfolder; ins; desf; tauto.\nrelsf.\nrewrite minus_union_l.\nrelsf; unionL.\nsin_rewrite non_I_new_rf.\nbasic_solver.\nrewrite wf_new_rfD.\narewrite (new_rf ⊆ new_rf ∩ Gsame_loc).\ngeneralize (wf_new_rfl); basic_solver.\nunfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"⦗E⦘ ⊆ ⦗E \\₁ I⦘ ∪ ⦗E ∩₁ I⦘.","proofString":"unfolder; ins; desf; tauto."},{"statement":"((⦗E \\₁ I⦘ ∪ ⦗E ∩₁ I⦘) ⨾ new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"relsf.\nrewrite minus_union_l.\nrelsf; unionL.\nsin_rewrite non_I_new_rf.\nbasic_solver.\nrewrite wf_new_rfD.\narewrite (new_rf ⊆ new_rf ∩ Gsame_loc).\ngeneralize (wf_new_rfl); basic_solver.\nunfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"((⦗E \\₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ ∪ ⦗E ∩₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘) \\ Gsb)\n⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"rewrite minus_union_l.\nrelsf; unionL.\nsin_rewrite non_I_new_rf.\nbasic_solver.\nrewrite wf_new_rfD.\narewrite (new_rf ⊆ new_rf ∩ Gsame_loc).\ngeneralize (wf_new_rfl); basic_solver.\nunfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(⦗E \\₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb ∪ ⦗E ∩₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb)\n⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"relsf; unionL.\nsin_rewrite non_I_new_rf.\nbasic_solver.\nrewrite wf_new_rfD.\narewrite (new_rf ⊆ new_rf ∩ Gsame_loc).\ngeneralize (wf_new_rfl); basic_solver.\nunfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(⦗E \\₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"sin_rewrite non_I_new_rf.\nbasic_solver."},{"statement":"(Gsb ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(⦗E ∩₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"rewrite wf_new_rfD.\narewrite (new_rf ⊆ new_rf ∩ Gsame_loc).\ngeneralize (wf_new_rfl); basic_solver.\nunfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(⦗E ∩₁ I⦘ ⨾ (⦗W⦘ ⨾ new_rf ⨾ ⦗R⦘) ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘ ⊆ ∅₂.","proofString":"arewrite (new_rf ⊆ new_rf ∩ Gsame_loc).\ngeneralize (wf_new_rfl); basic_solver.\nunfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"new_rf ⊆ new_rf ∩ Gsame_loc.","proofString":"generalize (wf_new_rfl); basic_solver."},{"statement":"(⦗E ∩₁ I⦘ ⨾ ⦗W⦘ ⨾ new_rf ∩ Gsame_loc ⨾ ⦗R⦘ ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗R ∩₁ Acq⦘\n⊆ ∅₂.","proofString":"unfolder; ins; desf.\nassert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) : False.","proofString":"assert (Lx:exists l, Gloc x = Some l); desc.\nby apply is_w_loc.\nassert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) : exists l : location, Gloc x = Some l.","proofString":"by apply is_w_loc."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) : False.","proofString":"assert (Ly:Gloc y = Some l).\nunfold same_loc in *; congruence.\nforward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) : Gloc y = Some l.","proofString":"unfold same_loc in *; congruence."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) : False.","proofString":"forward (apply COMP_ACQ).\nby basic_solver.\nins; desc.\napply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (w : actid) (H10 : Grf w y) : False.","proofString":"apply rfi_union_rfe in H10; unfolder in H10; desf; cycle 1.\nby generalize R_Acq_codom_rfe; basic_solver 12.\nie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (w : actid) (H10 : Grfe w y) : False.","proofString":"by generalize R_Acq_codom_rfe; basic_solver 12."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (w : actid) (H10 : Grfi w y) : False.","proofString":"ie_unfolder; unfolder in H10; desf.\nhahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (w : actid) (H10 : Grf w y) (H11 : Gsb w y) : False.","proofString":"hahn_rewrite (wf_rfD WF) in H10.\nhahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (w : actid) (H11 : Gsb w y) (H10 : (⦗W⦘ ⨾ Grf ⨾ ⦗R⦘) w y) : False.","proofString":"hahn_rewrite (wf_rfE WF) in H10.\nunfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (w : actid) (H11 : Gsb w y) (H10 : (⦗W⦘ ⨾ (⦗E⦘ ⨾ Grf ⨾ ⦗E⦘) ⨾ ⦗R⦘) w y) : False.","proofString":"unfolder in H10; desf.\nassert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) : False.","proofString":"assert (Lz:Gloc z = Some l).\nby apply (wf_rfl WF) in H14; unfold same_loc in *; congruence.\nforward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) : Gloc z = Some l.","proofString":"by apply (wf_rfl WF) in H14; unfold same_loc in *; congruence."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) : False.","proofString":"forward (apply ((wf_co_total WF) (Some l) z)).\nbasic_solver.\ninstantiate (1 := x).\nbasic_solver.\nintro; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12.\neapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) : (E ∩₁ W ∩₁ Loc_ l) z.","proofString":"basic_solver."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) : (E ∩₁ W ∩₁ Loc_ l) x.","proofString":"basic_solver."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco z x) : False.","proofString":"eapply eco_furr_irr; try edone.\neexists; splits; [|eby apply new_rf_in_furr].\nunfold eco, fr.\nbasic_solver 12."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco z x) : Geco y x.","proofString":"unfold eco, fr.\nbasic_solver 12."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco z x) : (Grf ∪ Gco ⨾ Grf^? ∪ (Grf⁻¹ ⨾ Gco) ⨾ Grf^?) y x.","proofString":"basic_solver 12."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco x z) : False.","proofString":"eapply H3.\nexists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco x z) : (cert_co ⨾ Gfurr) x y.","proofString":"exists z; split; [| apply furr_alt; basic_solver 12].\neapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco x z) : cert_co x z.","proofString":"eapply I_co_in_cert_co; try edone.\napply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco x z) : (⦗cert_co_base G T thread⦘ ⨾ Gco) x z.","proofString":"apply seq_eqv_l.\nsplit; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco x z) : cert_co_base G T thread x /\\ Gco x z.","proofString":"split; auto.\nby apply I_in_cert_co_base."},{"statement":"(x y : actid) (H : E x) (H9 : I x) (H8 : is_w Glab x) (H3 : new_rf x y) (H7 : Gsame_loc x y) (H4 : true) (H5 : E y) (H6 : ~ D y) (H2 : ~ Gsb x y) (H0 : is_r Glab y) (H1 : is_acq Glab y) (l : location) (Lx : Gloc x = Some l) (Ly : Gloc y = Some l) (z : actid) (H10 : is_w Glab z) (H11 : Gsb z y) (H17 : E z) (H14 : Grf z y) (H16 : E y) (H13 : true) (Lz : Gloc z = Some l) (H12 : Gco x z) : cert_co_base G T thread x.","proofString":"by apply I_in_cert_co_base."},{"statement":"Grfi ⨾ ⦗set_compl D⦘ ⊆ Gfurr ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘ \\ cert_co ⨾ Gfurr.","proofString":"rewrite minus_inter_compl.\napply inclusion_inter_r.\nrewrite furr_alt; [|done].\narewrite (Grfi ⊆ Grf).\nrewrite (dom_r (wf_rfE WF)) at 1.\nrewrite ((wf_rfD WF)) at 1.\narewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21.\narewrite (Grfi ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ Grfi ⨾ ⦗set_compl D⦘).\nforward (eapply dom_Grfi_nD_in_thread with (T:=T) (thread:=thread)); try edone.\nbasic_solver.\narewrite (Grfi ⊆ Grf).\nrewrite cert_co_alt'; try edone.\nunfolder; ins; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\nexists z; splits; eauto.\nred; right.\nunfolder; ins; desf.\nexists z; splits; eauto; red.\nbasic_solver."},{"statement":"Grfi ⨾ ⦗set_compl D⦘\n⊆ (Gfurr ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘) ∩ compl_rel (cert_co ⨾ Gfurr).","proofString":"apply inclusion_inter_r.\nrewrite furr_alt; [|done].\narewrite (Grfi ⊆ Grf).\nrewrite (dom_r (wf_rfE WF)) at 1.\nrewrite ((wf_rfD WF)) at 1.\narewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21.\narewrite (Grfi ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ Grfi ⨾ ⦗set_compl D⦘).\nforward (eapply dom_Grfi_nD_in_thread with (T:=T) (thread:=thread)); try edone.\nbasic_solver.\narewrite (Grfi ⊆ Grf).\nrewrite cert_co_alt'; try edone.\nunfolder; ins; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\nexists z; splits; eauto.\nred; right.\nunfolder; ins; desf.\nexists z; splits; eauto; red.\nbasic_solver."},{"statement":"Grfi ⨾ ⦗set_compl D⦘ ⊆ Gfurr ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"rewrite furr_alt; [|done].\narewrite (Grfi ⊆ Grf).\nrewrite (dom_r (wf_rfE WF)) at 1.\nrewrite ((wf_rfD WF)) at 1.\narewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21."},{"statement":"Grfi ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"arewrite (Grfi ⊆ Grf).\nrewrite (dom_r (wf_rfE WF)) at 1.\nrewrite ((wf_rfD WF)) at 1.\narewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21."},{"statement":"Grf ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"rewrite (dom_r (wf_rfE WF)) at 1.\nrewrite ((wf_rfD WF)) at 1.\narewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21."},{"statement":"(Grf ⨾ ⦗E⦘) ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"rewrite ((wf_rfD WF)) at 1.\narewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21."},{"statement":"((⦗W⦘ ⨾ Grf ⨾ ⦗R⦘) ⨾ ⦗E⦘) ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"arewrite (Grf ⊆ Grf ∩ Grf) at 1.\nrewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21."},{"statement":"⦗W⦘ ⨾ Grf ∩ Grf ⨾ ⦗R⦘ ⨾ ⦗E⦘ ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"rewrite ((wf_rfl WF)) at 1.\nclear.\nbasic_solver 21."},{"statement":"⦗W⦘ ⨾ Gsame_loc ∩ Grf ⨾ ⦗R⦘ ⨾ ⦗E⦘ ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"clear.\nbasic_solver 21."},{"statement":"⦗W⦘ ⨾ Gsame_loc ∩ Grf ⨾ ⦗R⦘ ⨾ ⦗E⦘ ⨾ ⦗set_compl D⦘\n⊆ (⦗W⦘ ⨾ Grf^? ⨾ Ghb^? ⨾ sc^? ⨾ Ghb^?) ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘.","proofString":"basic_solver 21."},{"statement":"Grfi ⨾ ⦗set_compl D⦘ ⊆ compl_rel (cert_co ⨾ Gfurr).","proofString":"arewrite (Grfi ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ Grfi ⨾ ⦗set_compl D⦘).\nforward (eapply dom_Grfi_nD_in_thread with (T:=T) (thread:=thread)); try edone.\nbasic_solver.\narewrite (Grfi ⊆ Grf).\nrewrite cert_co_alt'; try edone.\nunfolder; ins; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\nexists z; splits; eauto.\nred; right.\nunfolder; ins; desf.\nexists z; splits; eauto; red.\nbasic_solver."},{"statement":"Grfi ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ Grfi ⨾ ⦗set_compl D⦘.","proofString":"forward (eapply dom_Grfi_nD_in_thread with (T:=T) (thread:=thread)); try edone.\nbasic_solver."},{"statement":"dom_rel (Grfi ⨾ ⦗set_compl D⦘) ⊆₁ Tid_ thread ->\nGrfi ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ Grfi ⨾ ⦗set_compl D⦘.","proofString":"basic_solver."},{"statement":"⦗Tid_ thread⦘ ⨾ Grfi ⨾ ⦗set_compl D⦘ ⊆ compl_rel (cert_co ⨾ Gfurr).","proofString":"arewrite (Grfi ⊆ Grf).\nrewrite cert_co_alt'; try edone.\nunfolder; ins; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\nexists z; splits; eauto.\nred; right.\nunfolder; ins; desf.\nexists z; splits; eauto; red.\nbasic_solver."},{"statement":"⦗Tid_ thread⦘ ⨾ Grf ⨾ ⦗set_compl D⦘ ⊆ compl_rel (cert_co ⨾ Gfurr).","proofString":"rewrite cert_co_alt'; try edone.\nunfolder; ins; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\nexists z; splits; eauto.\nred; right.\nunfolder; ins; desf.\nexists z; splits; eauto; red.\nbasic_solver."},{"statement":"⦗Tid_ thread⦘ ⨾ Grf ⨾ ⦗set_compl D⦘\n⊆ compl_rel\n    ((Gco ∩ cert_co\n      ∪ ⦗I ∩₁ NTid_ thread⦘ ⨾ cert_co ⨾ ⦗E ∩₁ W ∩₁ Tid_ thread \\₁ I⦘) ⨾ Gfurr).","proofString":"unfolder; ins; desf.\nintro; desf.\neapply eco_furr_irr; try edone.\nexists z; splits; eauto.\nred; right.\nunfolder; ins; desf.\nexists z; splits; eauto; red.\nbasic_solver."},{"statement":"cert_rf ≡ cert_rf ∩ Gsb ∪ cert_rf \\ Gsb.","proofString":"clear.\nunfolder.\nsplit; ins; desf; tauto."},{"statement":"cert_rf ≡ cert_rf ∩ Gsb ∪ cert_rf \\ Gsb.","proofString":"unfolder.\nsplit; ins; desf; tauto."},{"statement":"(forall x y : actid,\n cert_rf x y -> cert_rf x y /\\ Gsb x y \\/ cert_rf x y /\\ ~ Gsb x y) /\\\n(forall x y : actid,\n cert_rf x y /\\ Gsb x y \\/ cert_rf x y /\\ ~ Gsb x y -> cert_rf x y).","proofString":"split; ins; desf; tauto."},{"statement":"cert_rf ⊆ E × E.","proofString":"unfold cert_rf.\nrewrite (wf_new_rfE), (wf_rfE WF), (wf_rmwE WF), wf_cert_coE; eauto.\nclear.\nbasic_solver."},{"statement":"Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘ ⊆ E × E.","proofString":"rewrite (wf_new_rfE), (wf_rfE WF), (wf_rmwE WF), wf_cert_coE; eauto.\nclear.\nbasic_solver."},{"statement":"(⦗E⦘ ⨾ Grf ⨾ ⦗E⦘) ⨾ ⦗D⦘\n∪ (⦗E⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘) ⨾ ⦗set_compl (dom_rel (⦗E⦘ ⨾ Grmw ⨾ ⦗E⦘))⦘\n∪ immediate (⦗E⦘ ⨾ cert_co ⨾ ⦗E⦘) ⨾ (⦗E⦘ ⨾ Grmw ⨾ ⦗E⦘)⁻¹ ⨾ ⦗set_compl D⦘\n⊆ E × E.","proofString":"clear.\nbasic_solver."},{"statement":"(⦗E⦘ ⨾ Grf ⨾ ⦗E⦘) ⨾ ⦗D⦘\n∪ (⦗E⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘) ⨾ ⦗set_compl (dom_rel (⦗E⦘ ⨾ Grmw ⨾ ⦗E⦘))⦘\n∪ immediate (⦗E⦘ ⨾ cert_co ⨾ ⦗E⦘) ⨾ (⦗E⦘ ⨾ Grmw ⨾ ⦗E⦘)⁻¹ ⨾ ⦗set_compl D⦘\n⊆ E × E.","proofString":"basic_solver."},{"statement":"cert_rf ⊆ W × R.","proofString":"unfold cert_rf.\nrewrite (wf_new_rfD), (wf_rfD WF), (wf_rmwD WF), wf_cert_coD; eauto.\nclear.\nbasic_solver."},{"statement":"Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘ ⊆ W × R.","proofString":"rewrite (wf_new_rfD), (wf_rfD WF), (wf_rmwD WF), wf_cert_coD; eauto.\nclear.\nbasic_solver."},{"statement":"(⦗W⦘ ⨾ Grf ⨾ ⦗R⦘) ⨾ ⦗D⦘\n∪ (⦗W⦘ ⨾ new_rf ⨾ ⦗R⦘) ⨾ ⦗set_compl (dom_rel (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘))⦘\n∪ immediate (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘)⁻¹ ⨾ ⦗set_compl D⦘\n⊆ W × R.","proofString":"clear.\nbasic_solver."},{"statement":"(⦗W⦘ ⨾ Grf ⨾ ⦗R⦘) ⨾ ⦗D⦘\n∪ (⦗W⦘ ⨾ new_rf ⨾ ⦗R⦘) ⨾ ⦗set_compl (dom_rel (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘))⦘\n∪ immediate (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘)⁻¹ ⨾ ⦗set_compl D⦘\n⊆ W × R.","proofString":"basic_solver."},{"statement":"Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"rewrite (wf_new_rfl), (wf_rfl WF).\nrewrite (wf_rmwl WF) at 2.\nrewrite immediate_in.\nrewrite wf_cert_col; eauto.\ngeneralize (@same_loc_trans _ Glab).\nrewrite transp_sym_equiv; [|by apply same_loc_sym].\nclear.\nbasic_solver 10."},{"statement":"Gsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"rewrite (wf_rmwl WF) at 2.\nrewrite immediate_in.\nrewrite wf_cert_col; eauto.\ngeneralize (@same_loc_trans _ Glab).\nrewrite transp_sym_equiv; [|by apply same_loc_sym].\nclear.\nbasic_solver 10."},{"statement":"Gsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ immediate cert_co ⨾ Gsame_loc⁻¹ ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"rewrite immediate_in.\nrewrite wf_cert_col; eauto.\ngeneralize (@same_loc_trans _ Glab).\nrewrite transp_sym_equiv; [|by apply same_loc_sym].\nclear.\nbasic_solver 10."},{"statement":"Gsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ cert_co ⨾ Gsame_loc⁻¹ ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"rewrite wf_cert_col; eauto.\ngeneralize (@same_loc_trans _ Glab).\nrewrite transp_sym_equiv; [|by apply same_loc_sym].\nclear.\nbasic_solver 10."},{"statement":"Gsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ Gsame_loc ⨾ Gsame_loc⁻¹ ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"generalize (@same_loc_trans _ Glab).\nrewrite transp_sym_equiv; [|by apply same_loc_sym].\nclear.\nbasic_solver 10."},{"statement":"transitive Gsame_loc ->\nGsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ Gsame_loc ⨾ Gsame_loc⁻¹ ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"rewrite transp_sym_equiv; [|by apply same_loc_sym].\nclear.\nbasic_solver 10."},{"statement":"transitive Gsame_loc ->\nGsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ Gsame_loc ⨾ Gsame_loc ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"clear.\nbasic_solver 10."},{"statement":"transitive Gsame_loc ->\nGsame_loc ⨾ ⦗D⦘ ∪ Gsame_loc ⨾ ⦗set_compl (dom_rel Grmw)⦘\n∪ Gsame_loc ⨾ Gsame_loc ⨾ ⦗set_compl D⦘ ⊆ Gsame_loc.","proofString":"basic_solver 10."},{"statement":"(T' TLS : trav_label -> Prop) (DISJ : TLS ∩₁ T' ⊆₁ ∅) : event ↑₁ (TLS ∩₁ T') ⊆₁ ∅.","proofString":"rewrite DISJ.\nbasic_solver."},{"statement":"(T' TLS : trav_label -> Prop) (DISJ : TLS ∩₁ T' ⊆₁ ∅) : event ↑₁ ∅ ⊆₁ ∅.","proofString":"basic_solver."},{"statement":"Grf ⨾ ⦗D⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"generalize Grfe_E; ie_unfolder; clear; basic_solver 21."},{"statement":"new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"rewrite wf_new_rfE at 1; try edone.\narewrite (⦗E⦘ ⊆ ⦗E ∩₁ I⦘ ∪ ⦗E \\₁ I⦘) at 1.\nunfolder; ins; desf; tauto.\nrelsf; rewrite minus_union_l; unionL.\nclear; basic_solver 21.\nrewrite <- seqA.\nrewrite (non_I_new_rf); try edone.\nclear; basic_solver 21."},{"statement":"(⦗E⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘) ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"arewrite (⦗E⦘ ⊆ ⦗E ∩₁ I⦘ ∪ ⦗E \\₁ I⦘) at 1.\nunfolder; ins; desf; tauto.\nrelsf; rewrite minus_union_l; unionL.\nclear; basic_solver 21.\nrewrite <- seqA.\nrewrite (non_I_new_rf); try edone.\nclear; basic_solver 21."},{"statement":"⦗E⦘ ⊆ ⦗E ∩₁ I⦘ ∪ ⦗E \\₁ I⦘.","proofString":"unfolder; ins; desf; tauto."},{"statement":"(⦗E ∩₁ I⦘ ∪ ⦗E \\₁ I⦘) ⨾ new_rf ⨾ ⦗E \\₁ D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"relsf; rewrite minus_union_l; unionL.\nclear; basic_solver 21.\nrewrite <- seqA.\nrewrite (non_I_new_rf); try edone.\nclear; basic_solver 21."},{"statement":"⦗E ∩₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"clear; basic_solver 21."},{"statement":"⦗E \\₁ I⦘ ⨾ new_rf ⨾ ⦗E \\₁ D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"rewrite <- seqA.\nrewrite (non_I_new_rf); try edone.\nclear; basic_solver 21."},{"statement":"(⦗E \\₁ I⦘ ⨾ new_rf) ⨾ ⦗E \\₁ D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"rewrite (non_I_new_rf); try edone.\nclear; basic_solver 21."},{"statement":"Gsb ⨾ ⦗E \\₁ D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ \\ Gsb\n⊆ ⦗I⦘ ⨾ (Grf \\ Gsb) ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘.","proofString":"clear; basic_solver 21."},{"statement":"⦗E⦘ ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ ⦗E⦘ ⨾ ⦗set_compl D⦘.","proofString":"generalize (@E_minus_D_in_tid G T thread).\nclear; basic_solver 21."},{"statement":"E \\₁ D ⊆₁ Tid_ thread ->\n⦗E⦘ ⨾ ⦗set_compl D⦘ ⊆ ⦗Tid_ thread⦘ ⨾ ⦗E⦘ ⨾ ⦗set_compl D⦘.","proofString":"clear; basic_solver 21."},{"statement":"cert_co ⊆ ⦗E ∩₁ W⦘ ⨾ cert_co.","proofString":"rewrite wf_cert_coD at 1; try edone.\nrewrite wf_cert_coE at 1; try edone.\nclear; basic_solver."},{"statement":"⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘ ⊆ ⦗E ∩₁ W⦘ ⨾ cert_co.","proofString":"rewrite wf_cert_coE at 1; try edone.\nclear; basic_solver."},{"statement":"⦗W⦘ ⨾ (⦗E⦘ ⨾ cert_co ⨾ ⦗E⦘) ⨾ ⦗W⦘ ⊆ ⦗E ∩₁ W⦘ ⨾ cert_co.","proofString":"clear; basic_solver."},{"statement":"⦗E ∩₁ W⦘ ⊆ ⦗E ∩₁ W⦘ ⨾ ⦗set_compl Init⦘ ∪ ⦗Init ∩₁ E⦘.","proofString":"unfolder; ins; desf.\ndestruct (classic (is_init y)); eauto."},{"statement":"(y : actid) (H1 : is_w Glab y) (H0 : E y) : y = y /\\ ((E y /\\ true) /\\ ~ is_init y \\/ is_init y /\\ E y).","proofString":"destruct (classic (is_init y)); eauto."},{"statement":"dom_rel\n  ((⦗I ∩₁ set_compl Init⦘ ⨾ cert_co ⨾ Grmw⁻¹ \\ Gsb)\n   ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"clear.\nbasic_solver."},{"statement":"dom_rel\n  ((⦗I ∩₁ set_compl Init⦘ ⨾ cert_co ⨾ Grmw⁻¹ \\ Gsb)\n   ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"basic_solver."},{"statement":"dom_rel\n  ((⦗I⦘ ⨾ cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"basic_solver."},{"statement":"dom_rel\n  ((⦗E ∩₁ W ∩₁ Tid_ thread ∩₁ set_compl Init⦘\n    ⨾ (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ Grmw⁻¹ \\ Gsb)\n   ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"rewrite (wf_rmwD WF) at 1.\nforward (eapply transp_rmw_sb); try edone; intro AA.\nforward (eapply cert_co_irr); try edone; intro BB.\nforward eapply cert_co_sb_irr' as CC.\nclear - AA BB CC WF.\nunfolder; ins; desf; exfalso.\nassert (A: (y = z \\/ Gsb y z) \\/ Gsb z y).\neapply (@tid_n_init_sb G).\nbasic_solver.\ndesf.\ntype_solver.\nassert (B: z1 = z \\/ Gsb z1 z).\neapply AA; basic_solver.\ndesf; eauto.\neapply CC.\nred.\nexists z1.\nsplit; eauto.\neapply hahn_inclusion_exp; [| apply H4].\nunfold cert_co, cert_co_base.\nerewrite new_co_more; [reflexivity| ..]; auto.\nrewrite reserved_certT, issued_certT.\nbasic_solver 10."},{"statement":"dom_rel\n  ((⦗E ∩₁ W ∩₁ Tid_ thread ∩₁ set_compl Init⦘\n    ⨾ (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘)⁻¹ \\ Gsb)\n   ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"forward (eapply transp_rmw_sb); try edone; intro AA.\nforward (eapply cert_co_irr); try edone; intro BB.\nforward eapply cert_co_sb_irr' as CC.\nclear - AA BB CC WF.\nunfolder; ins; desf; exfalso.\nassert (A: (y = z \\/ Gsb y z) \\/ Gsb z y).\neapply (@tid_n_init_sb G).\nbasic_solver.\ndesf.\ntype_solver.\nassert (B: z1 = z \\/ Gsb z1 z).\neapply AA; basic_solver.\ndesf; eauto.\neapply CC.\nred.\nexists z1.\nsplit; eauto.\neapply hahn_inclusion_exp; [| apply H4].\nunfold cert_co, cert_co_base.\nerewrite new_co_more; [reflexivity| ..]; auto.\nrewrite reserved_certT, issued_certT.\nbasic_solver 10."},{"statement":"(AA : Grmw⁻¹ ⨾ Gsb ⊆ Gsb^?) : dom_rel\n  ((⦗E ∩₁ W ∩₁ Tid_ thread ∩₁ set_compl Init⦘\n    ⨾ (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘)⁻¹ \\ Gsb)\n   ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"forward (eapply cert_co_irr); try edone; intro BB.\nforward eapply cert_co_sb_irr' as CC.\nclear - AA BB CC WF.\nunfolder; ins; desf; exfalso.\nassert (A: (y = z \\/ Gsb y z) \\/ Gsb z y).\neapply (@tid_n_init_sb G).\nbasic_solver.\ndesf.\ntype_solver.\nassert (B: z1 = z \\/ Gsb z1 z).\neapply AA; basic_solver.\ndesf; eauto.\neapply CC.\nred.\nexists z1.\nsplit; eauto.\neapply hahn_inclusion_exp; [| apply H4].\nunfold cert_co, cert_co_base.\nerewrite new_co_more; [reflexivity| ..]; auto.\nrewrite reserved_certT, issued_certT.\nbasic_solver 10."},{"statement":"(AA : Grmw⁻¹ ⨾ Gsb ⊆ Gsb^?) (BB : irreflexive cert_co) : dom_rel\n  ((⦗E ∩₁ W ∩₁ Tid_ thread ∩₁ set_compl Init⦘\n    ⨾ (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ (⦗R⦘ ⨾ Grmw ⨾ ⦗W⦘)⁻¹ \\ Gsb)\n   ⨾ ⦗Tid_ thread ∩₁ (E ∩₁ set_compl D)⦘) ⊆₁ I.","proofString":"forward eapply cert_co_sb_irr' as CC.\nclear - AA BB CC WF.\nunfolder; ins; desf; exfalso.\nassert (A: (y = z \\/ Gsb y z) \\/ Gsb z y).\neapply (@tid_n_init_sb G).\nbasic_solver.\ndesf.\ntype_solver.\nassert (B: z1 = z \\/ Gsb z1 z).\neapply AA; basic_solver.\ndesf; eauto.\neapply CC.\nred.\nexists z1.\nsplit; eauto.\neapply hahn_inclusion_exp; [| apply H4].\nunfold cert_co, cert_co_base.\nerewrite new_co_more; [reflexivity| ..]; auto.\nrewrite reserved_certT, issued_certT.\nbasic_solver 10."},{"statement":"(⦗I⦘ ⨾ Grfe ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘) ⨾ ⦗D⦘\n⊆ ⦗I⦘ ⨾ Grfe.","proofString":"rewrite (dom_r wf_new_rfE).\nbasic_solver 12."},{"statement":"(⦗I⦘ ⨾ Grfe ⨾ ⦗D⦘\n ∪ ⦗I⦘ ⨾ (new_rf ⨾ ⦗E \\₁ D⦘ \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘) ⨾ ⦗D⦘\n⊆ ⦗I⦘ ⨾ Grfe.","proofString":"basic_solver 12."},{"statement":"dom_rel (Grf ⨾ ⦗D⦘) ⊆₁ D -> Grf ⨾ ⦗D⦘ ≡ ⦗D⦘ ⨾ Grf ⨾ ⦗D⦘.","proofString":"basic_solver 12."},{"statement":"(Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ∩ Gsb ⨾ ⦗D⦘ ⊆ \n⦗D⦘ ⨾ Grfi ⨾ ⦗D⦘.","proofString":"rewrite <- seq_eqv_inter_lr.\nseq_rewrite cert_rf_D.\nrewrite dom_rf_D_helper.\nclear.\nbasic_solver 12."},{"statement":"((Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n  ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ⨾ ⦗D⦘) ∩ Gsb\n⊆ ⦗D⦘ ⨾ Grfi ⨾ ⦗D⦘.","proofString":"seq_rewrite cert_rf_D.\nrewrite dom_rf_D_helper.\nclear.\nbasic_solver 12."},{"statement":"(Grf ⨾ ⦗D⦘) ∩ Gsb ⊆ ⦗D⦘ ⨾ Grfi ⨾ ⦗D⦘.","proofString":"rewrite dom_rf_D_helper.\nclear.\nbasic_solver 12."},{"statement":"(⦗D⦘ ⨾ Grf ⨾ ⦗D⦘) ∩ Gsb ⊆ ⦗D⦘ ⨾ Grfi ⨾ ⦗D⦘.","proofString":"clear.\nbasic_solver 12."},{"statement":"(⦗D⦘ ⨾ Grf ⨾ ⦗D⦘) ∩ Gsb ⊆ ⦗D⦘ ⨾ Grfi ⨾ ⦗D⦘.","proofString":"basic_solver 12."},{"statement":"dom_rel\n  (⦗I⦘ ⨾ Grfe ⨾ ⦗D⦘ ∪ ⦗I⦘ ⨾ (new_rf \\ Gsb) ⨾ ⦗set_compl (dom_rel Grmw)⦘\n   ∪ ⦗I⦘ ⨾ (immediate cert_co ⨾ Grmw⁻¹ \\ Gsb) ⨾ ⦗set_compl D⦘) ⊆₁ I.","proofString":"clear; basic_solver."},{"statement":"⦗set_compl I⦘ ⨾ (cert_rfi ∪ cert_rfe) ⊆ Gsb.","proofString":"unfold cert_rfi.\nrewrite (dom_rel_helper dom_cert_rfe_in_I).\nclear.\nbasic_solver 10."},{"statement":"⦗set_compl I⦘ ⨾ (cert_rf ∩ Gsb ∪ cert_rfe) ⊆ Gsb.","proofString":"rewrite (dom_rel_helper dom_cert_rfe_in_I).\nclear.\nbasic_solver 10."},{"statement":"⦗set_compl I⦘ ⨾ (cert_rf ∩ Gsb ∪ ⦗I⦘ ⨾ cert_rfe) ⊆ Gsb.","proofString":"clear.\nbasic_solver 10."},{"statement":"⦗set_compl I⦘ ⨾ (cert_rf ∩ Gsb ∪ ⦗I⦘ ⨾ cert_rfe) ⊆ Gsb.","proofString":"basic_solver 10."},{"statement":"sc_per_loc G.","proofString":"by apply coherence_sc_per_loc."},{"statement":"(GSPL : sc_per_loc G) : Grfi ⊆ Grfi ⨾ ⦗D ∪₁ set_compl D⦘.","proofString":"clear; unfolder; ins; desf; tauto."},{"statement":"(GSPL : sc_per_loc G) : Grfi ⨾ ⦗D⦘ ⊆ cert_rfi.","proofString":"unfold rfi, cert_rfi, cert_rf.\ngeneralize cert_rf_D.\nclear; unfolder; ins; desf; unfolder; eauto 12."},{"statement":"(GSPL : sc_per_loc G) : Grf ∩ Gsb ⨾ ⦗D⦘\n⊆ (Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n   ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ∩ Gsb.","proofString":"generalize cert_rf_D.\nclear; unfolder; ins; desf; unfolder; eauto 12."},{"statement":"(GSPL : sc_per_loc G) : cert_rf ⨾ ⦗D⦘ ≡ Grf ⨾ ⦗D⦘ ->\nGrf ∩ Gsb ⨾ ⦗D⦘\n⊆ (Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n   ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ∩ Gsb.","proofString":"clear; unfolder; ins; desf; unfolder; eauto 12."},{"statement":"(GSPL : sc_per_loc G) : Grfi ⨾ ⦗set_compl D⦘ ⊆ Gsb ∩ (Grfi ⨾ ⦗set_compl D⦘).","proofString":"clear; unfold rfi.\nbasic_solver."},{"statement":"Grf ∩ Gsb ⨾ ⦗set_compl D⦘ ⊆ Gsb ∩ (Grf ∩ Gsb ⨾ ⦗set_compl D⦘).","proofString":"basic_solver."},{"statement":"(GSPL : sc_per_loc G) : ⦗set_compl D⦘\n⊆ ⦗set_compl D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ ∪ ⦗set_compl D⦘ ⨾ ⦗dom_rel Grmw⦘.","proofString":"clear.\nunfolder.\nins.\ndesf.\ntauto."},{"statement":"⦗set_compl D⦘\n⊆ ⦗set_compl D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘ ∪ ⦗set_compl D⦘ ⨾ ⦗dom_rel Grmw⦘.","proofString":"unfolder.\nins.\ndesf.\ntauto."},{"statement":"forall x y : actid,\nx = y /\\ ~ D x ->\nx = y /\\\n(~ D x /\\ ~ (exists y0 : actid, Grmw x y0) \\/\n ~ D x /\\ (exists y0 : actid, Grmw x y0)).","proofString":"ins.\ndesf.\ntauto."},{"statement":"(x y : actid) (H : x = y /\\ ~ D x) : x = y /\\\n(~ D x /\\ ~ (exists y0 : actid, Grmw x y0) \\/\n ~ D x /\\ (exists y0 : actid, Grmw x y0)).","proofString":"desf.\ntauto."},{"statement":"(y : actid) (H0 : ~ D y) : y = y /\\\n(~ D y /\\ ~ (exists y0 : actid, Grmw y y0) \\/\n ~ D y /\\ (exists y0 : actid, Grmw y y0)).","proofString":"tauto."},{"statement":"(GSPL : sc_per_loc G) : Gsb ∩ (Grfi ⨾ ⦗set_compl D⦘ ⨾ ⦗set_compl (dom_rel Grmw)⦘) ⊆ cert_rfi.","proofString":"sin_rewrite Grfi_nD_in_new_rf.\nunfold rfi, cert_rfi, cert_rf.\nclear; simpl.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : Gsb ∩ (new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘) ⊆ cert_rfi.","proofString":"unfold rfi, cert_rfi, cert_rf.\nclear; simpl.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : Gsb ∩ (new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘)\n⊆ (Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n   ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ∩ Gsb.","proofString":"clear; simpl.\nbasic_solver."},{"statement":"Gsb ∩ (new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘)\n⊆ (Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n   ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ∩ Gsb.","proofString":"basic_solver."},{"statement":"(GSPL : sc_per_loc G) : Grfi ⨾ ⦗dom_rel Grmw⦘ ⨾ ⦗set_compl D⦘ ⊆ cert_rf ->\nGsb ∩ (Grfi ⨾ ⦗set_compl D⦘ ⨾ ⦗dom_rel Grmw⦘) ⊆ cert_rf ∩ Gsb.","proofString":"clear.\nbasic_solver 10."},{"statement":"Grfi ⨾ ⦗dom_rel Grmw⦘ ⨾ ⦗set_compl D⦘ ⊆ cert_rf ->\nGsb ∩ (Grfi ⨾ ⦗set_compl D⦘ ⨾ ⦗dom_rel Grmw⦘) ⊆ cert_rf ∩ Gsb.","proofString":"basic_solver 10."},{"statement":"(GSPL : sc_per_loc G) : Grfi ⨾ ⦗set_compl D⦘ ⨾ Grmw ⊆ immediate cert_co ->\nGrfi ⨾ ⦗dom_rel Grmw⦘ ⨾ ⦗set_compl D⦘\n⊆ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘.","proofString":"basic_solver 10."},{"statement":"(GSPL : sc_per_loc G) : Grfi ⨾ ⦗set_compl D⦘ ⨾ Grmw ⊆ (Grfi ⨾ ⦗set_compl D⦘ ⨾ Grmw) ∩ Gco.","proofString":"forward (eapply rf_rmw_in_co); eauto.\nunfold rfi.\nclear.\nbasic_solver 20."},{"statement":"(GSPL : sc_per_loc G) : Grf ⨾ Grmw ⊆ Gco ->\nGrfi ⨾ ⦗set_compl D⦘ ⨾ Grmw ⊆ (Grfi ⨾ ⦗set_compl D⦘ ⨾ Grmw) ∩ Gco.","proofString":"unfold rfi.\nclear.\nbasic_solver 20."},{"statement":"(GSPL : sc_per_loc G) : Grf ⨾ Grmw ⊆ Gco ->\nGrf ∩ Gsb ⨾ ⦗set_compl D⦘ ⨾ Grmw ⊆ (Grf ∩ Gsb ⨾ ⦗set_compl D⦘ ⨾ Grmw) ∩ Gco.","proofString":"clear.\nbasic_solver 20."},{"statement":"Grf ⨾ Grmw ⊆ Gco ->\nGrf ∩ Gsb ⨾ ⦗set_compl D⦘ ⨾ Grmw ⊆ (Grf ∩ Gsb ⨾ ⦗set_compl D⦘ ⨾ Grmw) ∩ Gco.","proofString":"basic_solver 20."},{"statement":"(GSPL : sc_per_loc G) : (Grfi ⨾ ⦗set_compl D⦘ ⨾ Grmw) ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"arewrite_id ⦗set_compl D⦘.\nrewrite seq_id_l.\nrewrite (rfi_rmw_in_sb_loc WF).\nforward (eapply cert_co_irr); try edone; intro BB.\nforward (eapply cert_co_sb_irr with (T:=T)); eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : (Grfi ⨾ ⦗fun _ : actid => True⦘ ⨾ Grmw) ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"rewrite seq_id_l.\nrewrite (rfi_rmw_in_sb_loc WF).\nforward (eapply cert_co_irr); try edone; intro BB.\nforward (eapply cert_co_sb_irr with (T:=T)); eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : (Grfi ⨾ Grmw) ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"rewrite (rfi_rmw_in_sb_loc WF).\nforward (eapply cert_co_irr); try edone; intro BB.\nforward (eapply cert_co_sb_irr with (T:=T)); eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : Gsb ∩ Gsame_loc ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"forward (eapply cert_co_irr); try edone; intro BB.\nforward (eapply cert_co_sb_irr with (T:=T)); eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) (BB : irreflexive cert_co) : Gsb ∩ Gsame_loc ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"forward (eapply cert_co_sb_irr with (T:=T)); eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) (BB : irreflexive cert_co) : irreflexive (cert_co ⨾ Gsb) -> Gsb ∩ Gsame_loc ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"clear.\nbasic_solver."},{"statement":"irreflexive (cert_co ⨾ Gsb) -> Gsb ∩ Gsame_loc ∩ cert_co⁻¹ ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(Grfi ⨾ ∅₂) ∩ cert_co ⊆ immediate cert_co.","proofString":"basic_solver."},{"statement":"(GSPL : sc_per_loc G) : ⦗set_compl D⦘ ⨾ ⦗GR_ex⦘ ⨾ Grmw ⊆ ∅₂.","proofString":"rewrite (dom_l (wf_rmwE WF)).\nseq_rewrite <- !id_inter.\nrewrite set_interA.\nrewrite Rex_in_D; eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : ⦗set_compl D⦘ ⨾ ⦗GR_ex⦘ ⨾ ⦗E⦘ ⨾ Grmw ⊆ ∅₂.","proofString":"seq_rewrite <- !id_inter.\nrewrite set_interA.\nrewrite Rex_in_D; eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : ⦗set_compl D ∩₁ GR_ex ∩₁ E⦘ ⨾ Grmw ⊆ ∅₂.","proofString":"rewrite set_interA.\nrewrite Rex_in_D; eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : ⦗set_compl D ∩₁ (GR_ex ∩₁ E)⦘ ⨾ Grmw ⊆ ∅₂.","proofString":"rewrite Rex_in_D; eauto.\nclear.\nbasic_solver."},{"statement":"(GSPL : sc_per_loc G) : ⦗set_compl D ∩₁ D⦘ ⨾ Grmw ⊆ ∅₂.","proofString":"clear.\nbasic_solver."},{"statement":"⦗set_compl D ∩₁ D⦘ ⨾ Grmw ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(Grf ⨾ ⦗D⦘ ∪ new_rf ⨾ ⦗set_compl (dom_rel Grmw)⦘\n ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ⨾ ⦗\nset_compl (dom_rel Grmw)⦘ ⊆ Gfurr.","proofString":"rewrite new_rf_in_furr.\nrewrite rf_in_furr with (sc := sc); auto.\nunfolder; ins; desf; splits; eauto 20.\nexfalso; eauto."},{"statement":"(Grf ⨾ ⦗D⦘ ∪ Gfurr ⨾ ⦗set_compl (dom_rel Grmw)⦘\n ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ⨾ ⦗\nset_compl (dom_rel Grmw)⦘ ⊆ Gfurr.","proofString":"rewrite rf_in_furr with (sc := sc); auto.\nunfolder; ins; desf; splits; eauto 20.\nexfalso; eauto."},{"statement":"(Gfurr ⨾ ⦗D⦘ ∪ Gfurr ⨾ ⦗set_compl (dom_rel Grmw)⦘\n ∪ immediate cert_co ⨾ Grmw⁻¹ ⨾ ⦗set_compl D⦘) ⨾ ⦗\nset_compl (dom_rel Grmw)⦘ ⊆ Gfurr.","proofString":"unfolder; ins; desf; splits; eauto 20.\nexfalso; eauto."},{"statement":"(x y z : actid) (H : cert_co x z) (H4 : forall c : actid, cert_co x c -> cert_co c z -> False) (H1 : Grmw y z) (H3 : ~ D y) (H0 : ~ (exists y0 : actid, Grmw y y0)) : Gfurr x y.","proofString":"exfalso; eauto."},{"statement":"(X : actid -> Prop) (HeqX : X = dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)) : cert_rf ⨾ ⦗X⦘ ⊆ Grf.","proofString":"arewrite (cert_rf ⨾ ⦗X⦘ ⊆ cert_rf ⨾ ⦗ codom_rel Grf ⦘ ⨾ ⦗X⦘).\nsubst X.\nrewrite (dom_l (@wf_sbE G)), !seqA.\narewrite (⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ R ∩₁ Acq⦘) by basic_solver.\ngeneralize COMP_R_ACQ_SB.\nbasic_solver 21.\nunfolder.\nins.\ndesf.\nassert (x0 = x); subst; auto.\neapply cert_rff; eauto.\nred.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(X : actid -> Prop) (HeqX : X = dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)) : cert_rf ⨾ ⦗X⦘ ⊆ cert_rf ⨾ ⦗codom_rel Grf⦘ ⨾ ⦗X⦘.","proofString":"subst X.\nrewrite (dom_l (@wf_sbE G)), !seqA.\narewrite (⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ R ∩₁ Acq⦘) by basic_solver.\ngeneralize COMP_R_ACQ_SB.\nbasic_solver 21."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n⊆ cert_rf\n  ⨾ ⦗codom_rel Grf⦘ ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘.","proofString":"rewrite (dom_l (@wf_sbE G)), !seqA.\narewrite (⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ R ∩₁ Acq⦘) by basic_solver.\ngeneralize COMP_R_ACQ_SB.\nbasic_solver 21."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n⊆ cert_rf\n  ⨾ ⦗codom_rel Grf⦘\n    ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘.","proofString":"arewrite (⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ R ∩₁ Acq⦘) by basic_solver.\ngeneralize COMP_R_ACQ_SB.\nbasic_solver 21."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗E ∩₁ R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n⊆ cert_rf\n  ⨾ ⦗codom_rel Grf⦘\n    ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘.","proofString":"generalize COMP_R_ACQ_SB.\nbasic_solver 21."},{"statement":"dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗E ∩₁ R ∩₁ Acq⦘) ⊆₁ codom_rel Grf ->\ncert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗E ∩₁ R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n⊆ cert_rf\n  ⨾ ⦗codom_rel Grf⦘\n    ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ ⦗E⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘.","proofString":"basic_solver 21."},{"statement":"(X : actid -> Prop) (HeqX : X = dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)) : cert_rf ⨾ ⦗codom_rel Grf⦘ ⨾ ⦗X⦘ ⊆ Grf.","proofString":"unfolder.\nins.\ndesf.\nassert (x0 = x); subst; auto.\neapply cert_rff; eauto.\nred.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(X : actid -> Prop) (HeqX : X = dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)) : forall x y : actid,\ncert_rf x y /\\ (exists x0 : actid, Grf x0 y) /\\ X y -> Grf x y.","proofString":"ins.\ndesf.\nassert (x0 = x); subst; auto.\neapply cert_rff; eauto.\nred.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(X : actid -> Prop) (HeqX : X = dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)) (x y : actid) (H : cert_rf x y /\\ (exists x0 : actid, Grf x0 y) /\\ X y) : Grf x y.","proofString":"desf.\nassert (x0 = x); subst; auto.\neapply cert_rff; eauto.\nred.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(x y : actid) (H : cert_rf x y) (x0 : actid) (H0 : Grf x0 y) (H1 : dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y) : Grf x y.","proofString":"assert (x0 = x); subst; auto.\neapply cert_rff; eauto.\nred.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(x y : actid) (H : cert_rf x y) (x0 : actid) (H0 : Grf x0 y) (H1 : dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y) : x0 = x.","proofString":"eapply cert_rff; eauto.\nred.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(x y : actid) (H : cert_rf x y) (x0 : actid) (H0 : Grf x0 y) (H1 : dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y) : cert_rf⁻¹ y x0.","proofString":"red.\neapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(x y : actid) (H : cert_rf x y) (x0 : actid) (H0 : Grf x0 y) (H1 : dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y) : cert_rf x0 y.","proofString":"eapply Grf_to_Acq_S_in_cert_rf.\napply seq_eqv_r.\nby splits."},{"statement":"(x y : actid) (H : cert_rf x y) (x0 : actid) (H0 : Grf x0 y) (H1 : dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y) : (Grf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘) x0 y.","proofString":"apply seq_eqv_r.\nby splits."},{"statement":"(x y : actid) (H : cert_rf x y) (x0 : actid) (H0 : Grf x0 y) (H1 : dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y) : Grf x0 y /\\ dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘) y.","proofString":"by splits."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘)⦘\n⊆ Grf.","proofString":"rewrite <- !seqA.\nrewrite dom_rel_eqv_dom_rel.\nrewrite !seqA.\napply cert_rf_to_Acq_S_in_Grf."},{"statement":"cert_rf ⨾ ⦗dom_rel (((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘) ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘)⦘\n⊆ Grf.","proofString":"rewrite dom_rel_eqv_dom_rel.\nrewrite !seqA.\napply cert_rf_to_Acq_S_in_Grf."},{"statement":"cert_rf ⨾ ⦗dom_rel (((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘) ⨾ Gsb ⨾ ⦗S⦘)⦘ ⊆ Grf.","proofString":"rewrite !seqA.\napply cert_rf_to_Acq_S_in_Grf."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⊆ Grf.","proofString":"apply cert_rf_to_Acq_S_in_Grf."},{"statement":"(C ∪₁ dom_rel (Gsb^? ⨾ ⦗S⦘)) ∩₁ R ∩₁ Acq \\₁ C\n⊆₁ R ∩₁ Acq ∩₁ dom_rel (Gsb ⨾ ⦗S⦘).","proofString":"rewrite crE, seq_union_l.\nrewrite S_in_W at 1.\nclear.\ntype_solver 20."},{"statement":"(C ∪₁ dom_rel (⦗fun _ : actid => True⦘ ⨾ ⦗S⦘ ∪ Gsb ⨾ ⦗S⦘)) ∩₁ R ∩₁ Acq \\₁ C\n⊆₁ R ∩₁ Acq ∩₁ dom_rel (Gsb ⨾ ⦗S⦘).","proofString":"rewrite S_in_W at 1.\nclear.\ntype_solver 20."},{"statement":"(C ∪₁ dom_rel (⦗fun _ : actid => True⦘ ⨾ ⦗W⦘ ∪ Gsb ⨾ ⦗S⦘)) ∩₁ R ∩₁ Acq \\₁ C\n⊆₁ R ∩₁ Acq ∩₁ dom_rel (Gsb ⨾ ⦗S⦘).","proofString":"clear.\ntype_solver 20."},{"statement":"(C ∪₁ dom_rel (⦗fun _ : actid => True⦘ ⨾ ⦗W⦘ ∪ Gsb ⨾ ⦗S⦘)) ∩₁ R ∩₁ Acq \\₁ C\n⊆₁ R ∩₁ Acq ∩₁ dom_rel (Gsb ⨾ ⦗S⦘).","proofString":"type_solver 20."},{"statement":"⦗Acq⦘ ⊆ ⦗E ∩₁ R ∩₁ Acq \\₁ C⦘ ∪ ⦗set_compl E ∪₁ set_compl R ∪₁ C⦘.","proofString":"unfolder; ins; desf.\nclear.\nsplits; eauto.\ndestruct (classic (E y)); destruct (classic (is_r Glab y)); destruct (classic (C y)); eauto."},{"statement":"(y : actid) (H0 : is_acq Glab y) : y = y /\\\n(((E y /\\ is_r Glab y) /\\ true) /\\ ~ C y \\/ (~ E y \\/ ~ is_r Glab y) \\/ C y).","proofString":"clear.\nsplits; eauto.\ndestruct (classic (E y)); destruct (classic (is_r Glab y)); destruct (classic (C y)); eauto."},{"statement":"(y : actid) : y = y /\\\n(((E y /\\ is_r Glab y) /\\ true) /\\ ~ C y \\/ (~ E y \\/ ~ is_r Glab y) \\/ C y).","proofString":"splits; eauto.\ndestruct (classic (E y)); destruct (classic (is_r Glab y)); destruct (classic (C y)); eauto."},{"statement":"(y : actid) : ((E y /\\ is_r Glab y) /\\ true) /\\ ~ C y \\/ (~ E y \\/ ~ is_r Glab y) \\/ C y.","proofString":"destruct (classic (E y)); destruct (classic (is_r Glab y)); destruct (classic (C y)); eauto."},{"statement":"cert_rf\n⨾ ⦗dom_rel\n     ((Grmw ⨾ Grfi)＊\n      ⨾ (⦗E ∩₁ R ∩₁ Acq \\₁ C⦘ ∪ ⦗set_compl E ∪₁ set_compl R ∪₁ C⦘))⦘ ⊆ Grf.","proofString":"relsf; rewrite id_union; relsf; unionL.\napply cert_rf_to_Acq_nC_in_Grf.\nrewrite !id_union; relsf.\nrewrite !id_union; relsf; unionL.\nrewrite (dom_r (wf_rfiE WF)).\nrewrite (dom_r (cert_rfE)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver.\nrewrite (dom_r (wf_rfiD WF)).\nrewrite (dom_r (cert_rfD)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver.\narewrite (Grfi ⊆ Gsb).\nrewrite (rmw_in_sb WF).\nins; relsf.\nrewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗E ∩₁ R ∩₁ Acq \\₁ C⦘)⦘ ⊆ Grf.","proofString":"apply cert_rf_to_Acq_nC_in_Grf."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗set_compl E ∪₁ set_compl R ∪₁ C⦘)⦘\n⊆ Grf.","proofString":"rewrite !id_union; relsf.\nrewrite !id_union; relsf; unionL.\nrewrite (dom_r (wf_rfiE WF)).\nrewrite (dom_r (cert_rfE)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver.\nrewrite (dom_r (wf_rfiD WF)).\nrewrite (dom_r (cert_rfD)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver.\narewrite (Grfi ⊆ Gsb).\nrewrite (rmw_in_sb WF).\nins; relsf.\nrewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf\n⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗set_compl E⦘)\n   ∪₁ dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗set_compl R⦘)\n   ∪₁ dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"rewrite !id_union; relsf; unionL.\nrewrite (dom_r (wf_rfiE WF)).\nrewrite (dom_r (cert_rfE)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver.\nrewrite (dom_r (wf_rfiD WF)).\nrewrite (dom_r (cert_rfD)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver.\narewrite (Grfi ⊆ Gsb).\nrewrite (rmw_in_sb WF).\nins; relsf.\nrewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗set_compl E⦘)⦘ ⊆ Grf.","proofString":"rewrite (dom_r (wf_rfiE WF)).\nrewrite (dom_r (cert_rfE)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi ⨾ ⦗E⦘)＊ ⨾ ⦗set_compl E⦘)⦘ ⊆ Grf.","proofString":"rewrite (dom_r (cert_rfE)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(cert_rf ⨾ ⦗E⦘) ⨾ ⦗dom_rel ((Grmw ⨾ Grfi ⨾ ⦗E⦘)＊ ⨾ ⦗set_compl E⦘)⦘ ⊆ Grf.","proofString":"rewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(cert_rf ⨾ ⦗E⦘)\n⨾ ⦗dom_rel ((⦗fun _ : actid => True⦘ ∪ (Grmw ⨾ Grfi ⨾ ⦗E⦘)⁺) ⨾ ⦗set_compl E⦘)⦘\n⊆ Grf.","proofString":"rewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(cert_rf ⨾ ⦗E⦘)\n⨾ ⦗dom_rel ((⦗fun _ : actid => True⦘ ∪ (Grmw ⨾ Grfi)⁺ ⨾ ⦗E⦘) ⨾ ⦗set_compl E⦘)⦘\n⊆ Grf.","proofString":"basic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗set_compl R⦘)⦘ ⊆ Grf.","proofString":"rewrite (dom_r (wf_rfiD WF)).\nrewrite (dom_r (cert_rfD)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi ⨾ ⦗R⦘)＊ ⨾ ⦗set_compl R⦘)⦘ ⊆ Grf.","proofString":"rewrite (dom_r (cert_rfD)).\nrewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(cert_rf ⨾ ⦗R⦘) ⨾ ⦗dom_rel ((Grmw ⨾ Grfi ⨾ ⦗R⦘)＊ ⨾ ⦗set_compl R⦘)⦘ ⊆ Grf.","proofString":"rewrite rtE.\nrewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(cert_rf ⨾ ⦗R⦘)\n⨾ ⦗dom_rel ((⦗fun _ : actid => True⦘ ∪ (Grmw ⨾ Grfi ⨾ ⦗R⦘)⁺) ⨾ ⦗set_compl R⦘)⦘\n⊆ Grf.","proofString":"rewrite <- !seqA, !inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(cert_rf ⨾ ⦗R⦘)\n⨾ ⦗dom_rel ((⦗fun _ : actid => True⦘ ∪ (Grmw ⨾ Grfi)⁺ ⨾ ⦗R⦘) ⨾ ⦗set_compl R⦘)⦘\n⊆ Grf.","proofString":"basic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"arewrite (Grfi ⊆ Gsb).\nrewrite (rmw_in_sb WF).\nins; relsf.\nrewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Gsb)＊ ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"rewrite (rmw_in_sb WF).\nins; relsf.\nrewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Gsb ⨾ Gsb)＊ ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"ins; relsf.\nrewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Gsb ⨾ Gsb)＊ ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"rewrite rewrite_trans, rt_of_trans; auto using sb_trans.\nrewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel (Gsb^? ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"rewrite crE; relsf.\nrewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗C ∪₁ dom_rel (Gsb ⨾ ⦗C⦘)⦘ ⊆ Grf.","proofString":"rewrite dom_sb_C_in_D; eauto.\nrewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗C ∪₁ D⦘ ⊆ Grf.","proofString":"rewrite C_in_D, set_unionK.\nrewrite cert_rf_D.\nbasic_solver."},{"statement":"cert_rf ⨾ ⦗D⦘ ⊆ Grf.","proofString":"rewrite cert_rf_D.\nbasic_solver."},{"statement":"Grf ⨾ ⦗D⦘ ⊆ Grf.","proofString":"basic_solver."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗Acq⦘)⦘ ⊆ Grf -> cert_rf ⨾ ⦗Acq⦘ ⊆ Grf.","proofString":"rewrite rtE; basic_solver 12."},{"statement":"cert_rf ⨾ ⦗Acq⦘ ⊆ Grf -> cert_rfi ⨾ ⦗Acq⦘ ⊆ Grfi.","proofString":"unfold rfi, cert_rfi.\nbasic_solver 12."},{"statement":"cert_rf ⨾ ⦗Acq⦘ ⊆ Grf -> cert_rf ∩ Gsb ⨾ ⦗Acq⦘ ⊆ Grf ∩ Gsb.","proofString":"basic_solver 12."},{"statement":"cert_rf ⨾ ⦗Acq⦘ ⊆ Grf -> cert_rfe ⨾ ⦗Acq⦘ ⊆ Grfe.","proofString":"unfold rfe, cert_rfe.\nbasic_solver 12."},{"statement":"cert_rf ⨾ ⦗Acq⦘ ⊆ Grf -> (cert_rf \\ Gsb) ⨾ ⦗Acq⦘ ⊆ Grf \\ Gsb.","proofString":"basic_solver 12."},{"statement":"⦗R⦘ ⨾ ⦗C ∪₁ dom_rel (Gsb^? ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq \\₁ C⦘\n⊆ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘.","proofString":"generalize S_in_W.\nclear.\nins.\nunfolder.\nins.\ndesf; splits; eauto.\nexfalso.\napply S_in_W in H5.\ntype_solver 10."},{"statement":"⦗R⦘ ⨾ ⦗C ∪₁ dom_rel (Gsb^? ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq \\₁ C⦘\n⊆ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘.","proofString":"unfolder.\nins.\ndesf; splits; eauto.\nexfalso.\napply S_in_W in H5.\ntype_solver 10."},{"statement":"forall x y : actid,\nx = y /\\\nis_r Glab x /\\\n(C x \\/ (exists y0 z : actid, (x = z \\/ Gsb x z) /\\ z = y0 /\\ S z)) /\\\nis_acq Glab x /\\ ~ C x ->\nx = y /\\ (exists y0 z : actid, Gsb x z /\\ z = y0 /\\ S z) /\\ is_acq Glab x.","proofString":"ins.\ndesf; splits; eauto.\nexfalso.\napply S_in_W in H5.\ntype_solver 10."},{"statement":"(x y : actid) (H : x = y /\\\nis_r Glab x /\\\n(C x \\/ (exists y0 z : actid, (x = z \\/ Gsb x z) /\\ z = y0 /\\ S z)) /\\\nis_acq Glab x /\\ ~ C x) : x = y /\\ (exists y0 z : actid, Gsb x z /\\ z = y0 /\\ S z) /\\ is_acq Glab x.","proofString":"desf; splits; eauto.\nexfalso.\napply S_in_W in H5.\ntype_solver 10."},{"statement":"(y0 : actid) (H0 : is_r Glab y0) (H3 : ~ C y0) (H2 : is_acq Glab y0) (H5 : S y0) : exists y z : actid, Gsb y0 z /\\ z = y /\\ S z.","proofString":"exfalso.\napply S_in_W in H5.\ntype_solver 10."},{"statement":"(y0 : actid) (H0 : is_r Glab y0) (H3 : ~ C y0) (H2 : is_acq Glab y0) (H5 : S y0) : False.","proofString":"apply S_in_W in H5.\ntype_solver 10."},{"statement":"(y0 : actid) (H0 : is_r Glab y0) (H3 : ~ C y0) (H2 : is_acq Glab y0) (H5 : is_w Glab y0) : False.","proofString":"type_solver 10."},{"statement":"cert_rfi\n⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ Grmw ⨾ (Grfi ⨾ Grmw)＊\n⊆ Grfi ⨾ Grmw ⨾ (Grfi ⨾ Grmw)＊.","proofString":"unfold cert_rfi, rfi.\ngeneralize cert_rf_to_Acq_S_in_Grf.\nbasic_solver 20."},{"statement":"cert_rf ∩ Gsb\n⨾ ⦗dom_rel ((Grmw ⨾ Grf ∩ Gsb)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n  ⨾ Grmw ⨾ (Grf ∩ Gsb ⨾ Grmw)＊ ⊆ Grf ∩ Gsb ⨾ Grmw ⨾ (Grf ∩ Gsb ⨾ Grmw)＊.","proofString":"generalize cert_rf_to_Acq_S_in_Grf.\nbasic_solver 20."},{"statement":"cert_rf ⨾ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⊆ Grf ->\ncert_rf ∩ Gsb\n⨾ ⦗dom_rel ((Grmw ⨾ Grf ∩ Gsb)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n  ⨾ Grmw ⨾ (Grf ∩ Gsb ⨾ Grmw)＊ ⊆ Grf ∩ Gsb ⨾ Grmw ⨾ (Grf ∩ Gsb ⨾ Grmw)＊.","proofString":"basic_solver 20."},{"statement":"((Grmw ⨾ Grfi)＊ ⨾ Grmw) ⨾ Grfi ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n  ⨾ ((Grmw ⨾ Grfi)＊ ⨾ Grmw) ⨾ Grfi.","proofString":"rewrite !seqA.\nremember (Grmw ⨾ Grfi) as X.\nrewrite (dom_r (wf_rfiD WF)) at 1.\nassert (Grmw ⨾ Grfi ⊆ X) as AA by (by subst X).\nrewrite !seqA.\nsin_rewrite AA.\nseq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(Grmw ⨾ Grfi)＊ ⨾ Grmw ⨾ Grfi ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel ((Grmw ⨾ Grfi)＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘\n  ⨾ (Grmw ⨾ Grfi)＊ ⨾ Grmw ⨾ Grfi.","proofString":"remember (Grmw ⨾ Grfi) as X.\nrewrite (dom_r (wf_rfiD WF)) at 1.\nassert (Grmw ⨾ Grfi ⊆ X) as AA by (by subst X).\nrewrite !seqA.\nsin_rewrite AA.\nseq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) : X＊ ⨾ Grmw ⨾ Grfi ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X＊ ⨾ X.","proofString":"rewrite (dom_r (wf_rfiD WF)) at 1.\nassert (Grmw ⨾ Grfi ⊆ X) as AA by (by subst X).\nrewrite !seqA.\nsin_rewrite AA.\nseq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) : X＊ ⨾ Grmw ⨾ (Grfi ⨾ ⦗R⦘) ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X＊ ⨾ X.","proofString":"assert (Grmw ⨾ Grfi ⊆ X) as AA by (by subst X).\nrewrite !seqA.\nsin_rewrite AA.\nseq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) (AA : Grmw ⨾ Grfi ⊆ X) : X＊ ⨾ Grmw ⨾ (Grfi ⨾ ⦗R⦘) ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X＊ ⨾ X.","proofString":"rewrite !seqA.\nsin_rewrite AA.\nseq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) (AA : Grmw ⨾ Grfi ⊆ X) : X＊ ⨾ Grmw ⨾ Grfi ⨾ ⦗R⦘ ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X＊ ⨾ X.","proofString":"sin_rewrite AA.\nseq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) (AA : Grmw ⨾ Grfi ⊆ X) : X＊ ⨾ X ⨾ ⦗R⦘ ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X＊ ⨾ X.","proofString":"seq_rewrite <- !ct_end.\nrewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) (AA : Grmw ⨾ Grfi ⊆ X) : X⁺ ⨾ ⦗R⦘ ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X＊ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X⁺.","proofString":"rewrite <- inclusion_t_rt.\nbasic_solver 10."},{"statement":"(X : relation actid) (HeqX : X = Grmw ⨾ Grfi) (AA : Grmw ⨾ Grfi ⊆ X) : X⁺ ⨾ ⦗R⦘ ⨾ ⦗dom_rel (Gsb ⨾ ⦗S⦘)⦘ ⨾ ⦗Acq⦘\n⊆ ⦗dom_rel (X⁺ ⨾ ⦗R ∩₁ Acq⦘ ⨾ Gsb ⨾ ⦗S⦘)⦘ ⨾ X⁺.","proofString":"basic_solver 10."},{"statement":"⦗fun _ : actid => True⦘ ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"rewrite rtE.\nbasic_solver 12."},{"statement":"⦗fun _ : actid => True⦘ ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘\n⊆ (⦗fun _ : actid => True⦘ ∪ (Grfi ⨾ Grmw)⁺) ⨾ Grfi.","proofString":"basic_solver 12."},{"statement":"forall k : relation actid,\nk ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi ->\n((cert_rfi ⨾ Grmw) ⨾ k) ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"intros k H.\narewrite (⦗Acq \\₁ C⦘ ⊆ ⦗Acq \\₁ C⦘ ⨾ ⦗Acq \\₁ C⦘) by (clear; basic_solver).\nsin_rewrite H.\nrewrite !seqA.\nrewrite cert_rfi_Grmw_in_Grfi_Grmw.\nrewrite <- !seqA.\nrewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : ((cert_rfi ⨾ Grmw) ⨾ k) ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"arewrite (⦗Acq \\₁ C⦘ ⊆ ⦗Acq \\₁ C⦘ ⨾ ⦗Acq \\₁ C⦘) by (clear; basic_solver).\nsin_rewrite H.\nrewrite !seqA.\nrewrite cert_rfi_Grmw_in_Grfi_Grmw.\nrewrite <- !seqA.\nrewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : cert_rfi ⨾ Grmw ⨾ k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"sin_rewrite H.\nrewrite !seqA.\nrewrite cert_rfi_Grmw_in_Grfi_Grmw.\nrewrite <- !seqA.\nrewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : cert_rfi ⨾ Grmw ⨾ ((Grfi ⨾ Grmw)＊ ⨾ Grfi) ⨾ ⦗Acq \\₁ C⦘\n⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"rewrite !seqA.\nrewrite cert_rfi_Grmw_in_Grfi_Grmw.\nrewrite <- !seqA.\nrewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : cert_rfi ⨾ Grmw ⨾ (Grfi ⨾ Grmw)＊ ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"rewrite cert_rfi_Grmw_in_Grfi_Grmw.\nrewrite <- !seqA.\nrewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : Grfi ⨾ Grmw ⨾ (Grfi ⨾ Grmw)＊ ⨾ Grfi ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"rewrite <- !seqA.\nrewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : ((Grfi ⨾ Grmw) ⨾ (Grfi ⨾ Grmw)＊) ⨾ Grfi ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"rewrite <- ct_begin.\nby rewrite inclusion_t_rt."},{"statement":"(k : relation actid) (H : k ⨾ Grfi ⨾ ⦗Acq \\₁ C⦘ ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi) : (Grfi ⨾ Grmw)⁺ ⨾ Grfi ⊆ (Grfi ⨾ Grmw)＊ ⨾ Grfi.","proofString":"by rewrite inclusion_t_rt."},{"statement":"Grelease\n⨾ ⦗E ∩₁ S⦘ ⨾ (Gfurr ∩ Gsame_loc ⨾ ⦗(E \\₁ D) ∩₁ R⦘ \\ cert_co ⨾ Gfurr) ⨾ ⦗Acq⦘\n⊆ Gsb ∪ (Grelease ⨾ Grf ⨾ ⦗Acq⦘ ∪ Grelease ⨾ Grf ⨾ Gsb ⨾ ⦗F⦘ ⨾ ⦗Acq⦘).","proofString":"unfolder; ins; desf.\nassert (A: exists w : actid, Grf w y); desc.\neapply COMP_ACQ.\nbasic_solver.\ndestruct (classic (w=z)); subst; [eauto 20|].\nexfalso.\nunfold furr in *; desf; eauto.\nassert (Gloc z = Some l).\nhahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf.\neapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (H1 : Gfurr z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ Gfurr z0 y)) (H2 : is_acq Glab y) : Gsb x y \\/\n(exists z0 : actid,\n   Grelease x z0 /\\\n   (exists z1 : actid, Grf z0 z1 /\\ z1 = y /\\ is_acq Glab z1)) \\/\n(exists z0 : actid,\n   Grelease x z0 /\\\n   (exists z1 : actid,\n      Grf z0 z1 /\\\n      (exists z2 : actid,\n         Gsb z1 z2 /\\ z2 = y /\\ is_f Glab z2 /\\ is_acq Glab z2))).","proofString":"assert (A: exists w : actid, Grf w y); desc.\neapply COMP_ACQ.\nbasic_solver.\ndestruct (classic (w=z)); subst; [eauto 20|].\nexfalso.\nunfold furr in *; desf; eauto.\nassert (Gloc z = Some l).\nhahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf.\neapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (H1 : Gfurr z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ Gfurr z0 y)) (H2 : is_acq Glab y) : exists w : actid, Grf w y.","proofString":"eapply COMP_ACQ.\nbasic_solver."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (H1 : Gfurr z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ Gfurr z0 y)) (H2 : is_acq Glab y) : (E ∩₁ R ∩₁ Acq) y.","proofString":"basic_solver."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (H1 : Gfurr z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ Gfurr z0 y)) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) : Gsb x y \\/\n(exists z0 : actid,\n   Grelease x z0 /\\\n   (exists z1 : actid, Grf z0 z1 /\\ z1 = y /\\ is_acq Glab z1)) \\/\n(exists z0 : actid,\n   Grelease x z0 /\\\n   (exists z1 : actid,\n      Grf z0 z1 /\\\n      (exists z2 : actid,\n         Gsb z1 z2 /\\ z2 = y /\\ is_f Glab z2 /\\ is_acq Glab z2))).","proofString":"destruct (classic (w=z)); subst; [eauto 20|].\nexfalso.\nunfold furr in *; desf; eauto.\nassert (Gloc z = Some l).\nhahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf.\neapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (H1 : Gfurr z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ Gfurr z0 y)) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) : Gsb x y \\/\n(exists z0 : actid,\n   Grelease x z0 /\\\n   (exists z1 : actid, Grf z0 z1 /\\ z1 = y /\\ is_acq Glab z1)) \\/\n(exists z0 : actid,\n   Grelease x z0 /\\\n   (exists z1 : actid,\n      Grf z0 z1 /\\\n      (exists z2 : actid,\n         Gsb z1 z2 /\\ z2 = y /\\ is_f Glab z2 /\\ is_acq Glab z2))).","proofString":"exfalso.\nunfold furr in *; desf; eauto.\nassert (Gloc z = Some l).\nhahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf.\neapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (H1 : Gfurr z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ Gfurr z0 y)) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) : False.","proofString":"unfold furr in *; desf; eauto.\nassert (Gloc z = Some l).\nhahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf.\neapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) : False.","proofString":"assert (Gloc z = Some l).\nhahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf.\neapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) : Gloc z = Some l.","proofString":"hahn_rewrite (@wf_urrD G) in H1.\nunfolder in H1.\ndesf."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H1 : (⦗W_ l⦘ ⨾ Gurr l) z y) : Gloc z = Some l.","proofString":"unfolder in H1.\ndesf."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H1 : (is_w Glab z /\\ Gloc z = Some l) /\\ Gurr l z y) : Gloc z = Some l.","proofString":"desf."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) : False.","proofString":"eapply (transp_rf_co_urr_irr WF WF_SC CSC COH).\nassert (W w).\nhahn_rewrite (wf_rfD WF) in A; unfolder in A; desf.\nassert (Loc_ l w).\nhahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence.\nexists w; splits.\nbasic_solver.\nassert (W z) as WZ.\nmatch goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf.\nassert (E w) as EW.\nhahn_rewrite (wf_rfE WF) in A; unfolder in A; desf.\nexists z; split; eauto.\ncut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) : is_w Glab w.","proofString":"hahn_rewrite (wf_rfD WF) in A; unfolder in A; desf."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) : Gloc w = Some l.","proofString":"hahn_rewrite (wf_rfl WF) in A; unfold same_loc in *.\nunfolder in A; desf; congruence."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gloc z = Gloc y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : is_w Glab w) (A : Gloc w = Gloc y) : Gloc w = Some l.","proofString":"unfolder in A; desf; congruence."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) : is_w Glab z.","proofString":"match goal with    | H : Grelease _ _ |- _ => rename H into REL    end.\napply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf."},{"statement":"(x y z : actid) (REL : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) : is_w Glab z.","proofString":"apply (dom_r (wf_releaseD WF)) in REL.\nclear -REL.\nunfolder in REL.\ndesf."},{"statement":"(x y z : actid) (REL : (Grelease ⨾ ⦗W⦘) x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) : is_w Glab z.","proofString":"clear -REL.\nunfolder in REL.\ndesf."},{"statement":"(x z : actid) (REL : (Grelease ⨾ ⦗W⦘) x z) : is_w Glab z.","proofString":"unfolder in REL.\ndesf."},{"statement":"(x z : actid) (REL : Grelease x z /\\ is_w Glab z) : is_w Glab z.","proofString":"desf."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) : E w.","proofString":"hahn_rewrite (wf_rfE WF) in A; unfolder in A; desf."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : Gco w z.","proofString":"cut ((co G ⨾ ⦗cert_co_base G T thread⦘) w z).\nbasic_solver.\neapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : (Gco ⨾ ⦗cert_co_base G T thread⦘) w z -> Gco w z.","proofString":"basic_solver."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : (Gco ⨾ ⦗cert_co_base G T thread⦘) w z.","proofString":"eapply new_co_I; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : (new_co G (cert_co_base G T thread) (E ∩₁ W ∩₁ Tid_ thread)\n ⨾ ⦗cert_co_base G T thread⦘) w z.","proofString":"unfolder; splits; eauto.\neapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto.\neapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) w z.","proofString":"eapply tot_ex.\neapply wf_new_co_total; try eapply IST_new_co; try apply WF; eauto.\nunfolder; splits; eauto.\nbasic_solver 10.\nintro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12.\nintro; subst; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : ~\nnew_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w.","proofString":"intro.\neapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (H13 : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w) : False.","proofString":"eapply H3.\nexists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (H13 : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w) : exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y).","proofString":"exists w.\nsplits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (H13 : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w) : cert_co z w /\\ (exists l0 : location, Gurr l0 w y).","proofString":"splits; eauto.\nexists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (H13 : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w) : exists l0 : location, Gurr l0 w y.","proofString":"exists l; unfold urr.\napply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (H13 : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w) : (⦗W_ l⦘ ⨾ Grf^? ⨾ (Ghb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ Ghb^?) w y.","proofString":"apply (wf_urrE WF WF_SC) in H1.\nbasic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : (⦗W_ l⦘ ∪ ⦗E⦘ ⨾ Gurr l ⨾ ⦗E⦘) z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (H13 : new_co G (cert_co_base G T thread)\n  (fun x0 : actid => (E x0 /\\ is_w Glab x0) /\\ tid x0 = thread) z w) : (⦗W_ l⦘ ⨾ Grf^? ⨾ (Ghb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ Ghb^?) w y.","proofString":"basic_solver 12."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : z <> w.","proofString":"intro; subst; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : cert_co_base G T thread z.","proofString":"eapply IST_in_cert_co_base; try edone.\nassert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : (I ∪₁ S ∩₁ Tid_ thread) z.","proofString":"assert ((E ∩₁ W) z) as AA.\nsplit; auto.\napply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) : (E ∩₁ W) z.","proofString":"split; auto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (AA : (E ∩₁ W) z) : (I ∪₁ S ∩₁ Tid_ thread) z.","proofString":"apply IT_new_co in AA.\nunfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (AA : (I ∪₁ E ∩₁ W ∩₁ Tid_ thread) z) : (I ∪₁ S ∩₁ Tid_ thread) z.","proofString":"unfolder in AA.\nunfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (AA : I z \\/ (E z /\\ is_w Glab z) /\\ tid z = thread) : (I ∪₁ S ∩₁ Tid_ thread) z.","proofString":"unfolder.\ndesf; eauto."},{"statement":"(x y z : actid) (H : Grelease x z) (H0 : E z) (H9 : S z) (H8 : Gsame_loc z y) (l : location) (H1 : Gurr l z y) (H6 : is_r Glab y) (H7 : ~ D y) (H5 : E y) (H3 : ~ (exists z0 : actid, cert_co z z0 /\\ (exists l0 : location, Gurr l0 z0 y))) (H2 : is_acq Glab y) (w : actid) (A : Grf w y) (H4 : w <> z) (H10 : Gloc z = Some l) (H11 : W w) (H12 : Loc_ l w) (WZ : W z) (EW : E w) (AA : I z \\/ (E z /\\ is_w Glab z) /\\ tid z = thread) : I z \\/ S z /\\ tid z = thread.","proofString":"desf; eauto."},{"statement":"Grelease ⨾ ⦗E ∩₁ S⦘ ⨾ new_rf ⨾ ⦗Acq⦘\n⊆ Gsb ∪ (Grelease ⨾ Grf ⨾ ⦗Acq⦘ ∪ Grelease ⨾ Grf ⨾ Gsb ⨾ ⦗F⦘ ⨾ ⦗Acq⦘).","proofString":"apply sw_helper_S."}]}