{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Builtins0.v","fileSamples":[{"statement":"(t : xtype) (x : option (valxty t)) : val_opt_has_rettype (option_map (inj_num t) x) t.","conclusion":"val_opt_has_rettype (option_map (inj_num t) x) t","hypotheses":"(t : xtype) (x : option (valxty t))","proofString":"destruct x; simpl.\napply inj_num_wt.\nauto."},{"statement":"(t : xtype) (v : valxty t) : Val.has_rettype (inj_num t v) t.","conclusion":"Val.has_rettype (inj_num t v) t","hypotheses":"(t : xtype) (v : valxty t)","proofString":"apply inj_num_wt."},{"statement":"(t : xtype) : True.","conclusion":"True","hypotheses":"(t : xtype)","proofString":"auto."},{"statement":"(j : meminj) (t : xtype) (v : valxty t) : Val.inject j (inj_num t v) (inj_num t v).","conclusion":"Val.inject j (inj_num t v) (inj_num t v)","hypotheses":"(j : meminj) (t : xtype) (v : valxty t)","proofString":"apply inj_num_inject."},{"statement":"(j : meminj) (t : xtype) : True.","conclusion":"True","hypotheses":"(j : meminj) (t : xtype)","proofString":"auto."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres) : Val.has_rettype (proj_num t Vundef v k1) tres.","conclusion":"Val.has_rettype (proj_num t Vundef v k1) tres","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres)","proofString":"assert (U: Val.has_rettype Vundef tres).\ndestruct tres; exact I.\nintros.\ndestruct t; simpl; destruct v; auto."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres) : Val.has_rettype Vundef tres.","conclusion":"Val.has_rettype Vundef tres","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres)","proofString":"destruct tres; exact I."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres) (U : Val.has_rettype Vundef tres) : Val.has_rettype (proj_num t Vundef v k1) tres.","conclusion":"Val.has_rettype (proj_num t Vundef v k1) tres","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres) (U : Val.has_rettype Vundef tres)","proofString":"intros.\ndestruct t; simpl; destruct v; auto."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres) (U : Val.has_rettype Vundef tres) : Val.has_rettype (proj_num t Vundef v k1) tres.","conclusion":"Val.has_rettype (proj_num t Vundef v k1) tres","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> val) (v : val) (H : forall x : valty t, Val.has_rettype (k1 x) tres) (U : Val.has_rettype Vundef tres)","proofString":"destruct t; simpl; destruct v; auto."},{"statement":"(j : meminj) (t : typ) (k1 : valty t -> val) (v : val) (k1' : valty t -> val) (v' : val) (H : forall x : valty t, Val.inject j (k1 x) (k1' x)) (H0 : Val.inject j v v') : Val.inject j (proj_num t Vundef v k1) (proj_num t Vundef v' k1').","conclusion":"Val.inject j (proj_num t Vundef v k1) (proj_num t Vundef v' k1')","hypotheses":"(j : meminj) (t : typ) (k1 : valty t -> val) (v : val) (k1' : valty t -> val) (v' : val) (H : forall x : valty t, Val.inject j (k1 x) (k1' x)) (H0 : Val.inject j v v')","proofString":"destruct t; simpl; inv H0; auto."},{"statement":"(tres : xtype) (t : typ) (k0 : option val) (k1 : valty t -> option val) (v : val) (H : k0 = None \\/ k0 = Some Vundef) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) : val_opt_has_rettype (proj_num t k0 v k1) tres.","conclusion":"val_opt_has_rettype (proj_num t k0 v k1) tres","hypotheses":"(tres : xtype) (t : typ) (k0 : option val) (k1 : valty t -> option val) (v : val) (H : k0 = None \\/ k0 = Some Vundef) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres)","proofString":"assert (val_opt_has_rettype k0 tres).\ndestruct H; subst k0.\nexact I.\nhnf.\ndestruct tres; exact I.\ndestruct t; simpl; destruct v; auto."},{"statement":"(tres : xtype) (t : typ) (k0 : option val) (k1 : valty t -> option val) (v : val) (H : k0 = None \\/ k0 = Some Vundef) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) : val_opt_has_rettype k0 tres.","conclusion":"val_opt_has_rettype k0 tres","hypotheses":"(tres : xtype) (t : typ) (k0 : option val) (k1 : valty t -> option val) (v : val) (H : k0 = None \\/ k0 = Some Vundef) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres)","proofString":"destruct H; subst k0.\nexact I.\nhnf.\ndestruct tres; exact I."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> option val) (v : val) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) : val_opt_has_rettype None tres.","conclusion":"val_opt_has_rettype None tres","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> option val) (v : val) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres)","proofString":"exact I."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> option val) (v : val) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) : val_opt_has_rettype (Some Vundef) tres.","conclusion":"val_opt_has_rettype (Some Vundef) tres","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> option val) (v : val) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres)","proofString":"hnf.\ndestruct tres; exact I."},{"statement":"(tres : xtype) (t : typ) (k1 : valty t -> option val) (v : val) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) : match tres with\n| Xbool | _ => True\nend.","conclusion":"match tres with\n| Xbool | _ => True\nend","hypotheses":"(tres : xtype) (t : typ) (k1 : valty t -> option val) (v : val) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres)","proofString":"destruct tres; exact I."},{"statement":"(tres : xtype) (t : typ) (k0 : option val) (k1 : valty t -> option val) (v : val) (H : k0 = None \\/ k0 = Some Vundef) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) (H1 : val_opt_has_rettype k0 tres) : val_opt_has_rettype (proj_num t k0 v k1) tres.","conclusion":"val_opt_has_rettype (proj_num t k0 v k1) tres","hypotheses":"(tres : xtype) (t : typ) (k0 : option val) (k1 : valty t -> option val) (v : val) (H : k0 = None \\/ k0 = Some Vundef) (H0 : forall x : valty t, val_opt_has_rettype (k1 x) tres) (H1 : val_opt_has_rettype k0 tres)","proofString":"destruct t; simpl; destruct v; auto."},{"statement":"(j : meminj) (k0 : option val) (t : typ) (k1 : valty t -> option val) (v : val) (k1' : valty t -> option val) (v' : val) (H : forall ov : option val, val_opt_inject j k0 ov) (H0 : forall x : valty t, val_opt_inject j (k1 x) (k1' x)) (H1 : Val.inject j v v') : val_opt_inject j (proj_num t k0 v k1) (proj_num t k0 v' k1').","conclusion":"val_opt_inject j (proj_num t k0 v k1) (proj_num t k0 v' k1')","hypotheses":"(j : meminj) (k0 : option val) (t : typ) (k1 : valty t -> option val) (v : val) (k1' : valty t -> option val) (v' : val) (H : forall ov : option val, val_opt_inject j k0 ov) (H0 : forall x : valty t, val_opt_inject j (k1 x) (k1' x)) (H1 : Val.inject j v v')","proofString":"destruct t; simpl; inv H1; auto."},{"statement":"(name : string) (sg : signature) (b : A) (H : None = Some b) : sig_of b = sg.","conclusion":"sig_of b = sg","hypotheses":"(name : string) (sg : signature) (b : A) (H : None = Some b)","proofString":"discriminate."},{"statement":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (H : (if string_dec name n && signature_eq sg (sig_of b')\n then Some b'\n else lookup_builtin name sg l) = Some b) : sig_of b = sg.","conclusion":"sig_of b = sg","hypotheses":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (H : (if string_dec name n && signature_eq sg (sig_of b')\n then Some b'\n else lookup_builtin name sg l) = Some b)","proofString":"destruct (string_dec name n && signature_eq sg (sig_of b')) eqn:E.\nInvBooleans.\ncongruence.\nauto."},{"statement":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (E : string_dec name n && signature_eq sg (sig_of b') = true) (H : Some b' = Some b) : sig_of b = sg.","conclusion":"sig_of b = sg","hypotheses":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (E : string_dec name n && signature_eq sg (sig_of b') = true) (H : Some b' = Some b)","proofString":"InvBooleans.\ncongruence."},{"statement":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (H : Some b' = Some b) (H1 : sg = sig_of b') (H0 : name = n) : sig_of b = sg.","conclusion":"sig_of b = sg","hypotheses":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (H : Some b' = Some b) (H1 : sg = sig_of b') (H0 : name = n)","proofString":"congruence."},{"statement":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (E : string_dec name n && signature_eq sg (sig_of b') = false) (H : lookup_builtin name sg l = Some b) : sig_of b = sg.","conclusion":"sig_of b = sg","hypotheses":"(name : string) (sg : signature) (b : A) (n : string) (b' : A) (l : list (string * A)) (IHl : lookup_builtin name sg l = Some b -> sig_of b = sg) (E : string_dec name n && signature_eq sg (sig_of b') = false) (H : lookup_builtin name sg l = Some b)","proofString":"auto."}]}