{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/x86/Asmgenproof1.v","fileSamples":[{"statement":"(v1 v2 : val) : match v1 with\n| Vint n1 =>\n    match v2 with\n    | Vint n2 =>\n        if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None \\/\nmatch v1 with\n| Vint n1 =>\n    match v2 with\n    | Vint n2 =>\n        if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None ->\nexists n d q r : int,\n  v1 = Vint n /\\\n  v2 = Vint d /\\\n  Int.divmodu2 Int.zero n d = Some (q, r) /\\\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 =>\n          if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vint q) /\\\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 =>\n          if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vint r).","proofString":"destruct v1; try (intuition discriminate).\ndestruct v2; try (intuition discriminate).\npredSpec Int.eq Int.eq_spec i0 Int.zero ; try (intuition discriminate).\nintros _.\nexists i, i0, (Int.divu i i0), (Int.modu i i0); intuition auto.\napply Int.divmodu2_divu_modu; auto."},{"statement":"(i : int) (v2 : val) : match v2 with\n| Vint n2 => if Int.eq n2 Int.zero then None else Some (Vint (Int.divu i n2))\n| _ => None\nend <> None \\/\nmatch v2 with\n| Vint n2 => if Int.eq n2 Int.zero then None else Some (Vint (Int.modu i n2))\n| _ => None\nend <> None ->\nexists n d q r : int,\n  Vint i = Vint n /\\\n  v2 = Vint d /\\\n  Int.divmodu2 Int.zero n d = Some (q, r) /\\\n  match v2 with\n  | Vint n2 =>\n      if Int.eq n2 Int.zero then None else Some (Vint (Int.divu i n2))\n  | _ => None\n  end = Some (Vint q) /\\\n  match v2 with\n  | Vint n2 =>\n      if Int.eq n2 Int.zero then None else Some (Vint (Int.modu i n2))\n  | _ => None\n  end = Some (Vint r).","proofString":"destruct v2; try (intuition discriminate).\npredSpec Int.eq Int.eq_spec i0 Int.zero ; try (intuition discriminate).\nintros _.\nexists i, i0, (Int.divu i i0), (Int.modu i i0); intuition auto.\napply Int.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int) : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) <> None \\/\n(if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) <> None ->\nexists n d q r : int,\n  Vint i = Vint n /\\\n  Vint i0 = Vint d /\\\n  Int.divmodu2 Int.zero n d = Some (q, r) /\\\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some (Vint q) /\\\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) =\n  Some (Vint r).","proofString":"predSpec Int.eq Int.eq_spec i0 Int.zero ; try (intuition discriminate).\nintros _.\nexists i, i0, (Int.divu i i0), (Int.modu i i0); intuition auto.\napply Int.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int) (H : i0 <> Int.zero) : Some (Vint (Int.divu i i0)) <> None \\/ Some (Vint (Int.modu i i0)) <> None ->\nexists n d q r : int,\n  Vint i = Vint n /\\\n  Vint i0 = Vint d /\\\n  Int.divmodu2 Int.zero n d = Some (q, r) /\\\n  Some (Vint (Int.divu i i0)) = Some (Vint q) /\\\n  Some (Vint (Int.modu i i0)) = Some (Vint r).","proofString":"intros _.\nexists i, i0, (Int.divu i i0), (Int.modu i i0); intuition auto.\napply Int.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int) (H : i0 <> Int.zero) : exists n d q r : int,\n  Vint i = Vint n /\\\n  Vint i0 = Vint d /\\\n  Int.divmodu2 Int.zero n d = Some (q, r) /\\\n  Some (Vint (Int.divu i i0)) = Some (Vint q) /\\\n  Some (Vint (Int.modu i i0)) = Some (Vint r).","proofString":"exists i, i0, (Int.divu i i0), (Int.modu i i0); intuition auto.\napply Int.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int) (H : i0 = Int.zero -> False) : Int.divmodu2 Int.zero i i0 = Some (Int.divu i i0, Int.modu i i0).","proofString":"apply Int.divmodu2_divu_modu; auto."},{"statement":"(v1 v2 : val) : match v1 with\n| Vint n1 =>\n    match v2 with\n    | Vint n2 =>\n        if\n         Int.eq n2 Int.zero\n         || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n        then None\n        else Some (Vint (Int.divs n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None \\/\nmatch v1 with\n| Vint n1 =>\n    match v2 with\n    | Vint n2 =>\n        if\n         Int.eq n2 Int.zero\n         || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n        then None\n        else Some (Vint (Int.mods n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None ->\nexists nh nl d q r : int,\n  Val.shr v1 (Vint (Int.repr 31)) = Vint nh /\\\n  v1 = Vint nl /\\\n  v2 = Vint d /\\\n  Int.divmods2 nh nl d = Some (q, r) /\\\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 =>\n          if\n           Int.eq n2 Int.zero\n           || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n          then None\n          else Some (Vint (Int.divs n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vint q) /\\\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 =>\n          if\n           Int.eq n2 Int.zero\n           || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n          then None\n          else Some (Vint (Int.mods n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vint r).","proofString":"destruct v1; try (intuition discriminate).\ndestruct v2; try (intuition discriminate).\ndestruct (Int.eq i0 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone) eqn:OK;  try (intuition discriminate).\nintros _.\nInvBooleans.\nexists (Int.shr i (Int.repr 31)), i, i0, (Int.divs i i0), (Int.mods i i0); intuition auto.\nrewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i : int) (v2 : val) : match v2 with\n| Vint n2 =>\n    if\n     Int.eq n2 Int.zero\n     || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n    then None\n    else Some (Vint (Int.divs i n2))\n| _ => None\nend <> None \\/\nmatch v2 with\n| Vint n2 =>\n    if\n     Int.eq n2 Int.zero\n     || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n    then None\n    else Some (Vint (Int.mods i n2))\n| _ => None\nend <> None ->\nexists nh nl d q r : int,\n  Val.shr (Vint i) (Vint (Int.repr 31)) = Vint nh /\\\n  Vint i = Vint nl /\\\n  v2 = Vint d /\\\n  Int.divmods2 nh nl d = Some (q, r) /\\\n  match v2 with\n  | Vint n2 =>\n      if\n       Int.eq n2 Int.zero\n       || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n      then None\n      else Some (Vint (Int.divs i n2))\n  | _ => None\n  end = Some (Vint q) /\\\n  match v2 with\n  | Vint n2 =>\n      if\n       Int.eq n2 Int.zero\n       || Int.eq i (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n      then None\n      else Some (Vint (Int.mods i n2))\n  | _ => None\n  end = Some (Vint r).","proofString":"destruct v2; try (intuition discriminate).\ndestruct (Int.eq i0 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone) eqn:OK;  try (intuition discriminate).\nintros _.\nInvBooleans.\nexists (Int.shr i (Int.repr 31)), i, i0, (Int.divs i i0), (Int.mods i i0); intuition auto.\nrewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) <> None \\/\n(if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) <> None ->\nexists nh nl d q r : int,\n  Val.shr (Vint i) (Vint (Int.repr 31)) = Vint nh /\\\n  Vint i = Vint nl /\\\n  Vint i0 = Vint d /\\\n  Int.divmods2 nh nl d = Some (q, r) /\\\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some (Vint q) /\\\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.mods i i0))) = Some (Vint r).","proofString":"destruct (Int.eq i0 Int.zero            || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone) eqn:OK;  try (intuition discriminate).\nintros _.\nInvBooleans.\nexists (Int.shr i (Int.repr 31)), i, i0, (Int.divs i i0), (Int.mods i i0); intuition auto.\nrewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (OK : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : Some (Vint (Int.divs i i0)) <> None \\/ Some (Vint (Int.mods i i0)) <> None ->\nexists nh nl d q r : int,\n  Val.shr (Vint i) (Vint (Int.repr 31)) = Vint nh /\\\n  Vint i = Vint nl /\\\n  Vint i0 = Vint d /\\\n  Int.divmods2 nh nl d = Some (q, r) /\\\n  Some (Vint (Int.divs i i0)) = Some (Vint q) /\\\n  Some (Vint (Int.mods i i0)) = Some (Vint r).","proofString":"intros _.\nInvBooleans.\nexists (Int.shr i (Int.repr 31)), i, i0, (Int.divs i i0), (Int.mods i i0); intuition auto.\nrewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (OK : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : exists nh nl d q r : int,\n  Val.shr (Vint i) (Vint (Int.repr 31)) = Vint nh /\\\n  Vint i = Vint nl /\\\n  Vint i0 = Vint d /\\\n  Int.divmods2 nh nl d = Some (q, r) /\\\n  Some (Vint (Int.divs i i0)) = Some (Vint q) /\\\n  Some (Vint (Int.mods i i0)) = Some (Vint r).","proofString":"InvBooleans.\nexists (Int.shr i (Int.repr 31)), i, i0, (Int.divs i i0), (Int.mods i i0); intuition auto.\nrewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : exists nh nl d q r : int,\n  Val.shr (Vint i) (Vint (Int.repr 31)) = Vint nh /\\\n  Vint i = Vint nl /\\\n  Vint i0 = Vint d /\\\n  Int.divmods2 nh nl d = Some (q, r) /\\\n  Some (Vint (Int.divs i i0)) = Some (Vint q) /\\\n  Some (Vint (Int.mods i i0)) = Some (Vint r).","proofString":"exists (Int.shr i (Int.repr 31)), i, i0, (Int.divs i i0), (Int.mods i i0); intuition auto.\nrewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : Int.divmods2 (Int.shr i (Int.repr 31)) i i0 =\nSome (Int.divs i i0, Int.mods i i0).","proofString":"rewrite Int.shr_lt_zero.\napply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : Int.divmods2 (if Int.lt i Int.zero then Int.mone else Int.zero) i i0 =\nSome (Int.divs i i0, Int.mods i i0).","proofString":"apply Int.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int.eq_true in H; discriminate.\nrevert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : i0 <> Int.zero.","proofString":"red; intros; subst i0; rewrite Int.eq_true in H; discriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : i <> Int.repr Int.min_signed \\/ i0 <> Int.mone.","proofString":"revert H0.\npredSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) : Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false ->\ni <> Int.repr Int.min_signed \\/ i0 <> Int.mone.","proofString":"predSpec Int.eq Int.eq_spec i (Int.repr Int.min_signed); auto.\npredSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : i = Int.repr Int.min_signed) : true && Int.eq i0 Int.mone = false ->\ni <> Int.repr Int.min_signed \\/ i0 <> Int.mone.","proofString":"predSpec Int.eq Int.eq_spec i0 Int.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int) (H : Int.eq i0 Int.zero = false) (H0 : i = Int.repr Int.min_signed) (H1 : i0 = Int.mone) : true && true = false -> i <> Int.repr Int.min_signed \\/ i0 <> Int.mone.","proofString":"discriminate."},{"statement":"(v1 v2 : val) : match v1 with\n| Vlong n1 =>\n    match v2 with\n    | Vlong n2 =>\n        if Int64.eq n2 Int64.zero\n        then None\n        else Some (Vlong (Int64.divu n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None \\/\nmatch v1 with\n| Vlong n1 =>\n    match v2 with\n    | Vlong n2 =>\n        if Int64.eq n2 Int64.zero\n        then None\n        else Some (Vlong (Int64.modu n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None ->\nexists n d q r : int64,\n  v1 = Vlong n /\\\n  v2 = Vlong d /\\\n  Int64.divmodu2 Int64.zero n d = Some (q, r) /\\\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Int64.eq n2 Int64.zero\n          then None\n          else Some (Vlong (Int64.divu n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vlong q) /\\\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Int64.eq n2 Int64.zero\n          then None\n          else Some (Vlong (Int64.modu n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vlong r).","proofString":"destruct v1; try (intuition discriminate).\ndestruct v2; try (intuition discriminate).\npredSpec Int64.eq Int64.eq_spec i0 Int64.zero ; try (intuition discriminate).\nintros _.\nexists i, i0, (Int64.divu i i0), (Int64.modu i i0); intuition auto.\napply Int64.divmodu2_divu_modu; auto."},{"statement":"(i : int64) (v2 : val) : match v2 with\n| Vlong n2 =>\n    if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu i n2))\n| _ => None\nend <> None \\/\nmatch v2 with\n| Vlong n2 =>\n    if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu i n2))\n| _ => None\nend <> None ->\nexists n d q r : int64,\n  Vlong i = Vlong n /\\\n  v2 = Vlong d /\\\n  Int64.divmodu2 Int64.zero n d = Some (q, r) /\\\n  match v2 with\n  | Vlong n2 =>\n      if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.divu i n2))\n  | _ => None\n  end = Some (Vlong q) /\\\n  match v2 with\n  | Vlong n2 =>\n      if Int64.eq n2 Int64.zero then None else Some (Vlong (Int64.modu i n2))\n  | _ => None\n  end = Some (Vlong r).","proofString":"destruct v2; try (intuition discriminate).\npredSpec Int64.eq Int64.eq_spec i0 Int64.zero ; try (intuition discriminate).\nintros _.\nexists i, i0, (Int64.divu i i0), (Int64.modu i i0); intuition auto.\napply Int64.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int64) : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) <>\nNone \\/\n(if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) <>\nNone ->\nexists n d q r : int64,\n  Vlong i = Vlong n /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmodu2 Int64.zero n d = Some (q, r) /\\\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some (Vlong q) /\\\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\n  Some (Vlong r).","proofString":"predSpec Int64.eq Int64.eq_spec i0 Int64.zero ; try (intuition discriminate).\nintros _.\nexists i, i0, (Int64.divu i i0), (Int64.modu i i0); intuition auto.\napply Int64.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int64) (H : i0 <> Int64.zero) : Some (Vlong (Int64.divu i i0)) <> None \\/\nSome (Vlong (Int64.modu i i0)) <> None ->\nexists n d q r : int64,\n  Vlong i = Vlong n /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmodu2 Int64.zero n d = Some (q, r) /\\\n  Some (Vlong (Int64.divu i i0)) = Some (Vlong q) /\\\n  Some (Vlong (Int64.modu i i0)) = Some (Vlong r).","proofString":"intros _.\nexists i, i0, (Int64.divu i i0), (Int64.modu i i0); intuition auto.\napply Int64.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int64) (H : i0 <> Int64.zero) : exists n d q r : int64,\n  Vlong i = Vlong n /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmodu2 Int64.zero n d = Some (q, r) /\\\n  Some (Vlong (Int64.divu i i0)) = Some (Vlong q) /\\\n  Some (Vlong (Int64.modu i i0)) = Some (Vlong r).","proofString":"exists i, i0, (Int64.divu i i0), (Int64.modu i i0); intuition auto.\napply Int64.divmodu2_divu_modu; auto."},{"statement":"(i i0 : int64) (H : i0 = Int64.zero -> False) : Int64.divmodu2 Int64.zero i i0 = Some (Int64.divu i i0, Int64.modu i i0).","proofString":"apply Int64.divmodu2_divu_modu; auto."},{"statement":"(v1 v2 : val) : match v1 with\n| Vlong n1 =>\n    match v2 with\n    | Vlong n2 =>\n        if\n         Int64.eq n2 Int64.zero\n         || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n            Int64.eq n2 Int64.mone\n        then None\n        else Some (Vlong (Int64.divs n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None \\/\nmatch v1 with\n| Vlong n1 =>\n    match v2 with\n    | Vlong n2 =>\n        if\n         Int64.eq n2 Int64.zero\n         || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n            Int64.eq n2 Int64.mone\n        then None\n        else Some (Vlong (Int64.mods n1 n2))\n    | _ => None\n    end\n| _ => None\nend <> None ->\nexists nh nl d q r : int64,\n  Val.shrl v1 (Vint (Int.repr 63)) = Vlong nh /\\\n  v1 = Vlong nl /\\\n  v2 = Vlong d /\\\n  Int64.divmods2 nh nl d = Some (q, r) /\\\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 =>\n          if\n           Int64.eq n2 Int64.zero\n           || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n              Int64.eq n2 Int64.mone\n          then None\n          else Some (Vlong (Int64.divs n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vlong q) /\\\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 =>\n          if\n           Int64.eq n2 Int64.zero\n           || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n              Int64.eq n2 Int64.mone\n          then None\n          else Some (Vlong (Int64.mods n1 n2))\n      | _ => None\n      end\n  | _ => None\n  end = Some (Vlong r).","proofString":"destruct v1; try (intuition discriminate).\ndestruct v2; try (intuition discriminate).\ndestruct (Int64.eq i0 Int64.zero            || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:OK;  try (intuition discriminate).\nintros _.\nInvBooleans.\nexists (Int64.shr i (Int64.repr 63)), i, i0, (Int64.divs i i0), (Int64.mods i i0); intuition auto.\nrewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i : int64) (v2 : val) : match v2 with\n| Vlong n2 =>\n    if\n     Int64.eq n2 Int64.zero\n     || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n    then None\n    else Some (Vlong (Int64.divs i n2))\n| _ => None\nend <> None \\/\nmatch v2 with\n| Vlong n2 =>\n    if\n     Int64.eq n2 Int64.zero\n     || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n    then None\n    else Some (Vlong (Int64.mods i n2))\n| _ => None\nend <> None ->\nexists nh nl d q r : int64,\n  Val.shrl (Vlong i) (Vint (Int.repr 63)) = Vlong nh /\\\n  Vlong i = Vlong nl /\\\n  v2 = Vlong d /\\\n  Int64.divmods2 nh nl d = Some (q, r) /\\\n  match v2 with\n  | Vlong n2 =>\n      if\n       Int64.eq n2 Int64.zero\n       || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n      then None\n      else Some (Vlong (Int64.divs i n2))\n  | _ => None\n  end = Some (Vlong q) /\\\n  match v2 with\n  | Vlong n2 =>\n      if\n       Int64.eq n2 Int64.zero\n       || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone\n      then None\n      else Some (Vlong (Int64.mods i n2))\n  | _ => None\n  end = Some (Vlong r).","proofString":"destruct v2; try (intuition discriminate).\ndestruct (Int64.eq i0 Int64.zero            || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:OK;  try (intuition discriminate).\nintros _.\nInvBooleans.\nexists (Int64.shr i (Int64.repr 63)), i, i0, (Int64.divs i i0), (Int64.mods i i0); intuition auto.\nrewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) <> None \\/\n(if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) <> None ->\nexists nh nl d q r : int64,\n  Val.shrl (Vlong i) (Vint (Int.repr 63)) = Vlong nh /\\\n  Vlong i = Vlong nl /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmods2 nh nl d = Some (q, r) /\\\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some (Vlong q) /\\\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.mods i i0))) = Some (Vlong r).","proofString":"destruct (Int64.eq i0 Int64.zero            || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:OK;  try (intuition discriminate).\nintros _.\nInvBooleans.\nexists (Int64.shr i (Int64.repr 63)), i, i0, (Int64.divs i i0), (Int64.mods i i0); intuition auto.\nrewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (OK : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : Some (Vlong (Int64.divs i i0)) <> None \\/\nSome (Vlong (Int64.mods i i0)) <> None ->\nexists nh nl d q r : int64,\n  Val.shrl (Vlong i) (Vint (Int.repr 63)) = Vlong nh /\\\n  Vlong i = Vlong nl /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmods2 nh nl d = Some (q, r) /\\\n  Some (Vlong (Int64.divs i i0)) = Some (Vlong q) /\\\n  Some (Vlong (Int64.mods i i0)) = Some (Vlong r).","proofString":"intros _.\nInvBooleans.\nexists (Int64.shr i (Int64.repr 63)), i, i0, (Int64.divs i i0), (Int64.mods i i0); intuition auto.\nrewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (OK : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : exists nh nl d q r : int64,\n  Val.shrl (Vlong i) (Vint (Int.repr 63)) = Vlong nh /\\\n  Vlong i = Vlong nl /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmods2 nh nl d = Some (q, r) /\\\n  Some (Vlong (Int64.divs i i0)) = Some (Vlong q) /\\\n  Some (Vlong (Int64.mods i i0)) = Some (Vlong r).","proofString":"InvBooleans.\nexists (Int64.shr i (Int64.repr 63)), i, i0, (Int64.divs i i0), (Int64.mods i i0); intuition auto.\nrewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : exists nh nl d q r : int64,\n  Val.shrl (Vlong i) (Vint (Int.repr 63)) = Vlong nh /\\\n  Vlong i = Vlong nl /\\\n  Vlong i0 = Vlong d /\\\n  Int64.divmods2 nh nl d = Some (q, r) /\\\n  Some (Vlong (Int64.divs i i0)) = Some (Vlong q) /\\\n  Some (Vlong (Int64.mods i i0)) = Some (Vlong r).","proofString":"exists (Int64.shr i (Int64.repr 63)), i, i0, (Int64.divs i i0), (Int64.mods i i0); intuition auto.\nrewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : Int64.divmods2 (Int64.shr i (Int64.repr 63)) i i0 =\nSome (Int64.divs i i0, Int64.mods i i0).","proofString":"rewrite Int64.shr_lt_zero.\napply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : Int64.divmods2 (if Int64.lt i Int64.zero then Int64.mone else Int64.zero) i\n  i0 = Some (Int64.divs i i0, Int64.mods i i0).","proofString":"apply Int64.divmods2_divs_mods.\nred; intros; subst i0; rewrite Int64.eq_true in H; discriminate.\nrevert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : i0 <> Int64.zero.","proofString":"red; intros; subst i0; rewrite Int64.eq_true in H; discriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : i <> Int64.repr Int64.min_signed \\/ i0 <> Int64.mone.","proofString":"revert H0.\npredSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) : Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false ->\ni <> Int64.repr Int64.min_signed \\/ i0 <> Int64.mone.","proofString":"predSpec Int64.eq Int64.eq_spec i (Int64.repr Int64.min_signed); auto.\npredSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : i = Int64.repr Int64.min_signed) : true && Int64.eq i0 Int64.mone = false ->\ni <> Int64.repr Int64.min_signed \\/ i0 <> Int64.mone.","proofString":"predSpec Int64.eq Int64.eq_spec i0 Int64.mone; auto.\ndiscriminate."},{"statement":"(i i0 : int64) (H : Int64.eq i0 Int64.zero = false) (H0 : i = Int64.repr Int64.min_signed) (H1 : i0 = Int64.mone) : true && true = false -> i <> Int64.repr Int64.min_signed \\/ i0 <> Int64.mone.","proofString":"discriminate."},{"statement":"(x y : int64) : Int.xor (Int.repr (Int64.unsigned (Int64.sub_overflow x y Int64.zero)))\n  (Int.repr (Int64.unsigned (Int64.negative (Int64.sub x y)))) =\n(if Int64.lt x y then Int.one else Int.zero).","proofString":"transitivity (Int.repr (Int64.unsigned (if Int64.lt x y then Int64.one else Int64.zero))).\nrewrite <- (Int64.lt_sub_overflow x y).\nunfold Int64.sub_overflow, Int64.negative.\nset (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto.\ndestruct (Int64.lt x y); auto."},{"statement":"(x y : int64) : Int.xor (Int.repr (Int64.unsigned (Int64.sub_overflow x y Int64.zero)))\n  (Int.repr (Int64.unsigned (Int64.negative (Int64.sub x y)))) =\nInt.repr (Int64.unsigned (if Int64.lt x y then Int64.one else Int64.zero)).","proofString":"rewrite <- (Int64.lt_sub_overflow x y).\nunfold Int64.sub_overflow, Int64.negative.\nset (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) : Int.xor (Int.repr (Int64.unsigned (Int64.sub_overflow x y Int64.zero)))\n  (Int.repr (Int64.unsigned (Int64.negative (Int64.sub x y)))) =\nInt.repr\n  (Int64.unsigned\n     (Int64.xor (Int64.sub_overflow x y Int64.zero)\n        (Int64.negative (Int64.sub x y)))).","proofString":"unfold Int64.sub_overflow, Int64.negative.\nset (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) : Int.xor\n  (Int.repr\n     (Int64.unsigned\n        (if\n          zle Int64.min_signed\n            (Int64.signed x - Int64.signed y - Int64.signed Int64.zero) &&\n          zle (Int64.signed x - Int64.signed y - Int64.signed Int64.zero)\n            Int64.max_signed\n         then Int64.zero\n         else Int64.one)))\n  (Int.repr\n     (Int64.unsigned\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))) =\nInt.repr\n  (Int64.unsigned\n     (Int64.xor\n        (if\n          zle Int64.min_signed\n            (Int64.signed x - Int64.signed y - Int64.signed Int64.zero) &&\n          zle (Int64.signed x - Int64.signed y - Int64.signed Int64.zero)\n            Int64.max_signed\n         then Int64.zero\n         else Int64.one)\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))).","proofString":"set (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) (s : Z) : Int.xor\n  (Int.repr\n     (Int64.unsigned\n        (if zle Int64.min_signed s && zle s Int64.max_signed\n         then Int64.zero\n         else Int64.one)))\n  (Int.repr\n     (Int64.unsigned\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))) =\nInt.repr\n  (Int64.unsigned\n     (Int64.xor\n        (if zle Int64.min_signed s && zle s Int64.max_signed\n         then Int64.zero\n         else Int64.one)\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))).","proofString":"destruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) : Int.repr (Int64.unsigned (if Int64.lt x y then Int64.one else Int64.zero)) =\n(if Int64.lt x y then Int.one else Int.zero).","proofString":"destruct (Int64.lt x y); auto."},{"statement":"(A : Type) (B : Type) (c : comparison) (f : A -> B) (x y : A) : swap_floats c (f x) (f y) = f (swap_floats c x y).","proofString":"destruct c; auto."},{"statement":"(c : testcond) (rs : regset) : eval_testcond c (nextinstr rs) = eval_testcond c rs.","proofString":"unfold eval_testcond.\nrepeat rewrite nextinstr_inv; auto with asmgen."},{"statement":"(c : testcond) (rs : regset) : match c with\n| TCeq =>\n    match nextinstr rs CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match nextinstr rs CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match nextinstr rs CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match nextinstr rs CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match nextinstr rs CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match nextinstr rs CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match nextinstr rs CC with\n    | Vint c0 =>\n        match nextinstr rs CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match nextinstr rs CC with\n    | Vint c0 =>\n        match nextinstr rs CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match nextinstr rs CV with\n    | Vint o =>\n        match nextinstr rs CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match nextinstr rs CV with\n    | Vint o =>\n        match nextinstr rs CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match nextinstr rs CV with\n    | Vint o =>\n        match nextinstr rs CN with\n        | Vint s =>\n            match nextinstr rs CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match nextinstr rs CV with\n    | Vint o =>\n        match nextinstr rs CN with\n        | Vint s =>\n            match nextinstr rs CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend =\nmatch c with\n| TCeq =>\n    match rs CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs CC with\n    | Vint c0 =>\n        match rs CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs CC with\n    | Vint c0 =>\n        match rs CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s =>\n            match rs CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s =>\n            match rs CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend.","proofString":"repeat rewrite nextinstr_inv; auto with asmgen."},{"statement":"(c : testcond) (rs : Pregmap.t val) (r : ireg) (v : val) : eval_testcond c rs # r <- v = eval_testcond c rs.","proofString":"unfold eval_testcond.\nrepeat rewrite Pregmap.gso; auto with asmgen."},{"statement":"(c : testcond) (rs : Pregmap.t val) (r : ireg) (v : val) : match c with\n| TCeq =>\n    match rs # r <- v CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs # r <- v CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs # r <- v CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs # r <- v CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs # r <- v CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs # r <- v CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs # r <- v CC with\n    | Vint c0 =>\n        match rs # r <- v CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs # r <- v CC with\n    | Vint c0 =>\n        match rs # r <- v CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs # r <- v CV with\n    | Vint o =>\n        match rs # r <- v CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs # r <- v CV with\n    | Vint o =>\n        match rs # r <- v CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs # r <- v CV with\n    | Vint o =>\n        match rs # r <- v CN with\n        | Vint s =>\n            match rs # r <- v CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs # r <- v CV with\n    | Vint o =>\n        match rs # r <- v CN with\n        | Vint s =>\n            match rs # r <- v CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend =\nmatch c with\n| TCeq =>\n    match rs CZ with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match rs CZ with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match rs CC with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match rs CC with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match rs CN with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match rs CN with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match rs CC with\n    | Vint c0 =>\n        match rs CZ with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match rs CC with\n    | Vint c0 =>\n        match rs CZ with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s =>\n            match rs CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match rs CV with\n    | Vint o =>\n        match rs CN with\n        | Vint s =>\n            match rs CZ with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend.","proofString":"repeat rewrite Pregmap.gso; auto with asmgen."}]}