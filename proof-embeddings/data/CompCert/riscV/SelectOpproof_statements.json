{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/riscV/SelectOpproof.v","fileSamples":[{"statement":"(le : letenv) (id : ident) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (addrsymbol id ofs) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v.","proofString":"unfold addrsymbol.\neconstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (id : ident) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrsymbol id ofs) Enil) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v.","proofString":"econstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (addrstack ofs) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v.","proofString":"unfold addrstack.\neconstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrstack ofs) Enil) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v.","proofString":"econstructor; split.\nEvalOp.\nsimpl; eauto.\nauto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 t2) v /\\\n  Val.lessdef (Val.add (Vint n1) y) v.","proofString":"rewrite Val.add_commut.\napply eval_addimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 t2) v /\\\n  Val.lessdef (Val.add y (Vint n1)) v.","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm n2 t1) v /\\\n  Val.lessdef (Val.add x (Vint n2)) v.","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Val.add v1 (Vint n1) = x) (H0 : Val.add v0 (Vint n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.add n1 n2) (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add x y) v.","proofString":"subst.\nreplace (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)))       with (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))).\napply eval_addimm.\nEvalOp.\nrepeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.add n1 n2) (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2))) v.","proofString":"replace (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)))       with (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))).\napply eval_addimm.\nEvalOp.\nrepeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.add n1 n2) (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))) v.","proofString":"apply eval_addimm.\nEvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : eval_expr ge sp e m le (Eop Oadd (t1 ::: t2 ::: Enil)) (Val.add v1 v0).","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2)) =\nVal.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)).","proofString":"repeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.add v1 (Val.add v0 (Val.add (Vint n1) (Vint n2))) =\nVal.add v1 (Val.add (Vint n1) (Val.add v0 (Vint n2))).","proofString":"decEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.add v0 (Val.add (Vint n1) (Vint n2)) =\nVal.add (Vint n1) (Val.add v0 (Vint n2)).","proofString":"apply Val.add_permut."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.sub x (Vint n2)) v.","proofString":"rewrite Val.sub_add_opp.\napply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.add x (Vint (Int.neg n2))) v.","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Val.add v1 (Vint n1) = x) (H0 : Val.add v0 (Vint n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v.","proofString":"subst.\nrewrite Val.sub_add_l.\nrewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2))) v.","proofString":"rewrite Val.sub_add_l.\nrewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 (Val.add v0 (Vint n2))) (Vint n1)) v.","proofString":"rewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.add (Val.sub v1 v0) (Vint (Int.neg n2))) (Vint n1)) v.","proofString":"rewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.sub v1 v0) (Val.add (Vint (Int.neg n2)) (Vint n1))) v.","proofString":"simpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add (Int.neg n2) n1))) v.","proofString":"rewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add n1 (Int.neg n2)))) v.","proofString":"rewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.sub n1 n2))) v.","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H : Val.add v1 (Vint n1) = x) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v.","proofString":"subst.\nrewrite Val.sub_add_l.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) y) v.","proofString":"rewrite Val.sub_add_l.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 y) (Vint n1)) v.","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) (H0 : Val.add v1 (Vint n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x y) v.","proofString":"subst.\nrewrite Val.sub_add_r.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x (Val.add v1 (Vint n2))) v.","proofString":"rewrite Val.sub_add_r.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub x v1) (Vint (Int.neg n2))) v.","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (n : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.neg n)) Enil) v /\\\n  Val.lessdef (Val.sub Vzero (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint n)) v.","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shl x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shl i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shl_zero; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.shl n1 n)) Enil) v /\\\n  Val.lessdef (Val.shl (Vint n1) (Vint n)) v.","proofString":"exists (Vint (Int.shl n1 n)); split.\nEvalOp.\nsimpl.\nrewrite LT.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : eval_expr ge sp e m le (Eop (Ointconst (Int.shl n1 n)) Enil)\n  (Vint (Int.shl n1 n)).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (Val.shl (Vint n1) (Vint n)) (Vint (Int.shl n1 n)).","proofString":"simpl.\nrewrite LT.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef)\n  (Vint (Int.shl n1 n)).","proofString":"rewrite LT.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (Vint (Int.shl n1 n)) (Vint (Int.shl n1 n)).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shru x (Vint n)) v.","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shru_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shru x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shru_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shru x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.shru_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shru i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shru_zero; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.shru n1 n)) Enil) v /\\\n  Val.lessdef (Val.shru (Vint n1) (Vint n)) v.","proofString":"exists (Vint (Int.shru n1 n)); split.\nEvalOp.\nsimpl.\nrewrite LT; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : eval_expr ge sp e m le (Eop (Ointconst (Int.shru n1 n)) Enil)\n  (Vint (Int.shru n1 n)).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (Val.shru (Vint n1) (Vint n)) (Vint (Int.shru n1 n)).","proofString":"simpl.\nrewrite LT; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef)\n  (Vint (Int.shru n1 n)).","proofString":"rewrite LT; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint n)) v.","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shr x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shr i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shr_zero; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.shr n1 n)) Enil) v /\\\n  Val.lessdef (Val.shr (Vint n1) (Vint n)) v.","proofString":"exists (Vint (Int.shr n1 n)); split.\nEvalOp.\nsimpl.\nrewrite LT; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : eval_expr ge sp e m le (Eop (Ointconst (Int.shr n1 n)) Enil)\n  (Vint (Int.shr n1 n)).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (Val.shr (Vint n1) (Vint n)) (Vint (Int.shr n1 n)).","proofString":"simpl.\nrewrite LT; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (LT : Int.ltu n Int.iwordsize = true) (n1 : int) : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef)\n  (Vint (Int.shr n1 n)).","proofString":"rewrite LT; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then Eop (Ointconst Int.zero) Enil\n     else\n      if Int.eq n Int.one\n      then a\n      else\n       match mulimm_match a with\n       | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n       | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n       | mulimm_default e2 => mulimm_base n e2\n       end) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto.\ncase (mulimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nsubst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"intros.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mul x (Vint n)) (Vint Int.zero).","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i n)) (Vint Int.zero).","proofString":"subst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint Int.zero) (Vint Int.zero).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.one\n     then a\n     else\n      match mulimm_match a with\n      | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n      | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n      | mulimm_default e2 => mulimm_base n e2\n      end) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto.\ncase (mulimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nsubst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mul x (Vint n)) x.","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i n)) (Vint i).","proofString":"subst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i Int.one)) (Vint i).","proofString":"rewrite Int.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match mulimm_match a with\n    | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n    | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n    | mulimm_default e2 => mulimm_base n e2\n    end v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"case (mulimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nsubst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mul (Vint n2) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : eval_operation ge sp (Ointconst (Int.mul n n2)) nil m =\nSome (Val.mul (Vint n2) (Vint n)).","proofString":"simpl.\nrewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : Some (Vint (Int.mul n n2)) = Some (Vint (Int.mul n2 n)).","proofString":"rewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H1 : Val.add v1 (Vint n2) = x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"subst.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul (Val.add v1 (Vint n2)) (Vint n)) v.","proofString":"rewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"exploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : (exists v : val,\n   eval_expr ge sp e m le (mulimm_base n t2) v /\\\n   Val.lessdef (Val.mul v1 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"intros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : eval_expr ge sp e m le (mulimm_base n t2) v'.","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : (exists v : val,\n   eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n   Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"intros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'') : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"exists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'') : Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v''.","proofString":"eapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (mulimm_base n e2) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"apply eval_mulimm_base; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (mul a b) v /\\ Val.lessdef (Val.mul x y) v.","proofString":"unfold mul; case (mul_match a b); intros; InvEval.\nrewrite Val.mul_commut.\napply eval_mulimm.\nauto.\napply eval_mulimm.\nauto.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul (Vint n1) y) v.","proofString":"rewrite Val.mul_commut.\napply eval_mulimm.\nauto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul y (Vint n1)) v.","proofString":"apply eval_mulimm.\nauto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : eval_expr ge sp e m le t2 y.","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (mulimm n2 t1) v /\\\n  Val.lessdef (Val.mul x (Vint n2)) v.","proofString":"apply eval_mulimm.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : eval_expr ge sp e m le t1 x.","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mul x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and (Vint n1) y) v.","proofString":"rewrite Val.and_commut.\napply eval_andimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and y (Vint n1)) v.","proofString":"apply eval_andimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (andimm n2 t1) v /\\\n  Val.lessdef (Val.and x (Vint n2)) v.","proofString":"apply eval_andimm; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (orimm n a) v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"unfold orimm.\npredSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.eq n Int.mone\n      then Eop (Ointconst Int.mone) Enil\n      else\n       match orimm_match a with\n       | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n       | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n       | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"intros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.or x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i Int.zero)) (Vint i).","proofString":"rewrite Int.or_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.mone\n     then Eop (Ointconst Int.mone) Enil\n     else\n      match orimm_match a with\n      | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n      | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n      | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto.\ndestruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"intros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"exists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) (Vint Int.mone).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.or x (Vint n)) (Vint Int.mone).","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i n)) (Vint Int.mone).","proofString":"subst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i Int.mone)) (Vint Int.mone).","proofString":"rewrite Int.or_mone.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint Int.mone) (Vint Int.mone).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orimm_match a with\n    | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n    | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n    | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"destruct (orimm_match a); intros; InvEval.\nTrivialExists.\nsimpl.\nrewrite Int.or_commut; auto.\nsubst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.or n n2)) Enil) v /\\\n  Val.lessdef (Val.or (Vint n2) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Int.or_commut; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) : eval_operation ge sp (Ointconst (Int.or n n2)) nil m =\nSome (Val.or (Vint n2) (Vint n)).","proofString":"simpl.\nrewrite Int.or_commut; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) : Some (Vint (Int.or n n2)) = Some (Vint (Int.or n2 n)).","proofString":"rewrite Int.or_commut; auto."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H1 : Val.or v1 (Vint n2) = x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"subst.\nrewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.or v1 (Vint n2)) (Vint n)) v.","proofString":"rewrite Val.or_assoc.\nsimpl.\nrewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Val.or (Vint n2) (Vint n))) v.","proofString":"simpl.\nrewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Vint (Int.or n2 n))) v.","proofString":"rewrite Int.or_commut.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n2 n)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or v1 (Vint (Int.or n2 n))) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orimm n1 t2) v /\\\n  Val.lessdef (Val.or (Vint n1) y) v.","proofString":"rewrite Val.or_commut.\napply eval_orimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orimm n1 t2) v /\\\n  Val.lessdef (Val.or y (Vint n1)) v.","proofString":"apply eval_orimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (orimm n2 t1) v /\\\n  Val.lessdef (Val.or x (Vint n2)) v.","proofString":"apply eval_orimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor (Vint n1) y) v.","proofString":"rewrite Val.xor_commut.\napply eval_xorimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor y (Vint n1)) v.","proofString":"apply eval_xorimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (xorimm n2 t1) v /\\\n  Val.lessdef (Val.xor x (Vint n2)) v.","proofString":"apply eval_xorimm; auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : exists v : val, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.","proofString":"unfold divs_base.\nexists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eop Odiv (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"exists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : eval_expr ge sp e m le (Eop Odiv (a ::: b ::: Enil)) z.","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divs x y = Some z) : Val.lessdef z z.","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : exists v : val, eval_expr ge sp e m le (divu_base a b) v /\\ Val.lessdef z v.","proofString":"unfold divu_base.\nexists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivu (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"exists z; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : eval_expr ge sp e m le (Eop Odivu (a ::: b ::: Enil)) z.","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divu x y = Some z) : Val.lessdef z z.","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) : exists v : val, eval_expr ge sp e m le (shrximm a n) v /\\ Val.lessdef z v.","proofString":"unfold shrximm.\npredSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\neconstructor; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto.\neconstructor; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"exists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z) : Val.lessdef z x.","proofString":"destruct x; simpl in H0; try discriminate.\ndestruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (z : val) (H : eval_expr ge sp e m le a (Vint i)) (H0 : (if Int.ltu Int.zero (Int.repr 31)\n then Some (Vint (Int.shrx i Int.zero))\n else None) = Some z) : Val.lessdef z (Vint i).","proofString":"destruct (Int.ltu Int.zero (Int.repr 31)); inv H0.\nreplace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.shrx i Int.zero)) (Vint i).","proofString":"replace (Int.shrx i Int.zero) with i.\nauto.\nunfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.shrx i Int.zero.","proofString":"unfold Int.shrx, Int.divs.\nrewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i  Int.signed (Int.shl Int.one Int.zero)).","proofString":"rewrite Int.shl_zero.\nchange (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i  Int.signed Int.one).","proofString":"change (Int.signed Int.one) with 1.\nrewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i  1).","proofString":"rewrite Z.quot_1_r.\nrewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : i = Int.repr (Int.signed i).","proofString":"rewrite Int.repr_signed; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrximm n) (a ::: Enil)) v /\\ Val.lessdef z v.","proofString":"econstructor; split.\nEvalOp.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\ Val.lessdef (Val.shl x y) v.","proofString":"InvEval.\napply eval_shlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\\n  Val.lessdef (Val.shl x (Vint n2)) v.","proofString":"apply eval_shlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshl (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shl x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\ Val.lessdef (Val.shr x y) v.","proofString":"InvEval.\napply eval_shrimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\\n  Val.lessdef (Val.shr x (Vint n2)) v.","proofString":"apply eval_shrimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshr (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shr x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\ Val.lessdef (Val.shru x y) v.","proofString":"InvEval.\napply eval_shruimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\\n  Val.lessdef (Val.shru x (Vint n2)) v.","proofString":"apply eval_shruimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshru (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shru x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (negf a) v /\\ Val.lessdef (Val.negf x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (absf a) v /\\ Val.lessdef (Val.absf x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (negfs a) v /\\ Val.lessdef (Val.negfs x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (absfs a) v /\\ Val.lessdef (Val.absfs x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (n1 : int) (H : eval_expr ge sp e m le (Eop (Ointconst n1) Enil) x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 x (Vint n2)) v.","proofString":"InvEval.\nrewrite sem_int.\nTrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 (Vint n1) (Vint n2)) v.","proofString":"rewrite sem_int.\nTrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (Val.of_bool (intsem c0 n1 n2)) v.","proofString":"TrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : eval_operation ge sp\n  (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) nil m =\nSome (Val.of_bool (intsem c0 n1 n2)).","proofString":"simpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : Some (Vint (if intsem c0 n1 n2 then Int.one else Int.zero)) =\nSome (Val.of_bool (intsem c0 n1 n2)).","proofString":"destruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"InvEval.\ninv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"inv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"simpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"inv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"simpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"rewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if negb b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.zero)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero)).","proofString":"destruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some Vundef = Some (sem Ceq Vundef (Vint Int.zero)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp c0) el\n     else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v.","proofString":"TrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"simpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.one)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.one)).","proofString":"destruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some Vundef = Some (sem Ceq Vundef (Vint Int.one)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.zero).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Ceq (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.zero).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.zero).","proofString":"destruct b; rewrite sem_eq; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Ceq Vundef (Vint n2)) (Vint Int.zero).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"InvEval.\ninv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"inv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"simpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"inv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v.","proofString":"TrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"simpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.zero)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero)).","proofString":"destruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some Vundef = Some (sem Cne Vundef (Vint Int.zero)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp (negate_condition c0)) el\n     else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"simpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"rewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if negb b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.one)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.one)).","proofString":"destruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some Vundef = Some (sem Cne Vundef (Vint Int.one)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"exists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) (Vint Int.one).","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.one).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Cne (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.one).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.one).","proofString":"destruct b; rewrite sem_ne; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Cne Vundef (Vint n2)) (Vint Int.one).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem c (Vint n2) x) v.","proofString":"rewrite <- sem_swap.\neapply eval_compimm; eauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem (swap_comparison c) x (Vint n2)) v.","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp (swap_comparison c) t2 n1)\n    v /\\ Val.lessdef (Val.cmp c (Vint n1) y) v.","proofString":"eapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : forall (c0 : comparison) (x y0 : val),\nVal.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x.","proofString":"intros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x.","proofString":"unfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.of_optbool (Val.cmp_bool (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmp_bool c0 y0 x).","proofString":"rewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp c t1 n2) v /\\\n  Val.lessdef (Val.cmp c x (Vint n2)) v.","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le\n    (compimm Ccompuimm Int.cmpu (swap_comparison c) t2 n1) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c (Vint n1) y) v.","proofString":"eapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : forall (c0 : comparison) (x y0 : val),\nVal.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x.","proofString":"intros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x.","proofString":"unfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.of_optbool\n  (Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) c0 y0 x).","proofString":"rewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompuimm Int.cmpu c t1 n2) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x (Vint n2)) v.","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (compf c a b) v /\\ Val.lessdef (Val.cmpf c x y) v.","proofString":"unfold compf.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompf c)) (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.cmpf c x y) v.","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (compfs c a b) v /\\ Val.lessdef (Val.cmpfs c x y) v.","proofString":"unfold compfs.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompfs c)) (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.cmpfs c x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intoffloat x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ointoffloat (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intuoffloat x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ointuoffloat (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) : eval_expr ge sp e m le a x ->\nVal.floatofintu x = Some y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match floatofintu_match a with\n    | floatofintu_case1 n => Eop (Ofloatconst (Float.of_intu n)) Enil\n    | floatofintu_default e0 => Eop Ofloatofintu (e0 ::: Enil)\n    end v /\\ Val.lessdef y v.","proofString":"case (floatofintu_match a); intros.\nInvEval.\nsimpl in H0.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) (H0 : Val.floatofintu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"InvEval.\nsimpl in H0.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Val.floatofintu (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"simpl in H0.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Some (Vfloat (Float.of_intu n)) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : Val.floatofintu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofintu (e0 ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) : eval_expr ge sp e m le a x ->\nVal.floatofint x = Some y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match floatofint_match a with\n    | floatofint_case1 n => Eop (Ofloatconst (Float.of_int n)) Enil\n    | floatofint_default e0 => Eop Ofloatofint (e0 ::: Enil)\n    end v /\\ Val.lessdef y v.","proofString":"case (floatofint_match a); intros.\nInvEval.\nsimpl in H0.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) (H0 : Val.floatofint x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"InvEval.\nsimpl in H0.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Val.floatofint (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"simpl in H0.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Some (Vfloat (Float.of_int n)) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : Val.floatofint x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofint (e0 ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intofsingle x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ointofsingle (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.intuofsingle x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ointuofsingle (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (singleoffloat a) v /\\\n  Val.lessdef (Val.singleoffloat x) v.","proofString":"unfold singleoffloat.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleoffloat (a ::: Enil)) v /\\\n  Val.lessdef (Val.singleoffloat x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (floatofsingle a) v /\\\n  Val.lessdef (Val.floatofsingle x) v.","proofString":"unfold floatofsingle.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofsingle (a ::: Enil)) v /\\\n  Val.lessdef (Val.floatofsingle x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le Enil vl /\\\n  eval_addressing ge sp (Ainstack n) vl = Some (Val.offset_ptr sp n).","proofString":"exists (@nil val);  split.\neauto with evalexpr.\nsimpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : eval_exprlist ge sp e m le Enil nil.","proofString":"eauto with evalexpr."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : eval_addressing ge sp (Ainstack n) nil = Some (Val.offset_ptr sp n).","proofString":"simpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : Some (Val.offset_ptr sp n) = Some (Val.offset_ptr sp n).","proofString":"auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le e1 v1) (H : Val.addl v1 (Vlong n) = Vptr b ofs) : eval_exprlist ge sp e m le (e1 ::: Enil) (v1 :: nil).","proofString":"eauto with evalexpr."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le e1 v1) (H : Val.addl v1 (Vlong n) = Vptr b ofs) : eval_addressing ge sp (Aindexed n) (v1 :: nil) = Some (Vptr b ofs).","proofString":"simpl.\ndestruct v1; simpl in H; try discriminate.\ndestruct Archi.ptr64 eqn:SF; inv H.\nsimpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le e1 v1) (H : Val.addl v1 (Vlong n) = Vptr b ofs) : Some (Val.addl v1 (Vlong n)) = Some (Vptr b ofs).","proofString":"destruct v1; simpl in H; try discriminate.\ndestruct Archi.ptr64 eqn:SF; inv H.\nsimpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (H2 : eval_expr ge sp e m le e1 (Vptr b0 i)) (H : (if Archi.ptr64 then Vptr b0 (Ptrofs.add i (Ptrofs.of_int64 n)) else Vundef) =\nVptr b ofs) : Some (Val.addl (Vptr b0 i) (Vlong n)) = Some (Vptr b ofs).","proofString":"destruct Archi.ptr64 eqn:SF; inv H.\nsimpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (i : ptrofs) (H2 : eval_expr ge sp e m le e1 (Vptr b i)) (SF : Archi.ptr64 = true) : Some (Val.addl (Vptr b i) (Vlong n)) =\nSome (Vptr b (Ptrofs.add i (Ptrofs.of_int64 n))).","proofString":"simpl.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (i : ptrofs) (H2 : eval_expr ge sp e m le e1 (Vptr b i)) (SF : Archi.ptr64 = true) : Some\n  (if Archi.ptr64 then Vptr b (Ptrofs.add i (Ptrofs.of_int64 n)) else Vundef) =\nSome (Vptr b (Ptrofs.add i (Ptrofs.of_int64 n))).","proofString":"auto."},{"statement":"(bf : Builtins1.platform_builtin) (al : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (H : platform_builtin bf al = Some a) (H0 : eval_exprlist ge sp e m le al vl) (H1 : platform_builtin_sem bf vl = Some v) : exists v' : val, eval_expr ge sp e m le a v' /\\ Val.lessdef v v'.","proofString":"discriminate."}]}