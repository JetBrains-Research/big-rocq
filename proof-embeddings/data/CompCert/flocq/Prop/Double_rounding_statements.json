{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Prop/Double_rounding.v","fileSamples":[{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) : x < midp fexp1 x - / 2 * ulp beta fexp2 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx2'.\nassert (Hx2 : x - round beta fexp1 Zfloor x              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\nnow apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify.\nset (x'' := round beta fexp2 (Znearest choice2) x).\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/ 2 * ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nreplace x'' with (x'' - x + x) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (bpow _) with (/ 2 * bpow (fexp2 (mag x))                             + (bpow (mag x)                                - / 2 * bpow (fexp2 (mag x)))) by ring.\napply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le].\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nunfold ulp, cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) : x < midp fexp1 x - / 2 * ulp beta fexp2 x ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (x' := round beta fexp1 Zfloor x).\nintro Hx2'.\nassert (Hx2 : x - round beta fexp1 Zfloor x              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\nnow apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify.\nset (x'' := round beta fexp2 (Znearest choice2) x).\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/ 2 * ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nreplace x'' with (x'' - x + x) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (bpow _) with (/ 2 * bpow (fexp2 (mag x))                             + (bpow (mag x)                                - / 2 * bpow (fexp2 (mag x)))) by ring.\napply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le].\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nunfold ulp, cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) : x - round beta fexp1 Zfloor x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x).","proofString":"now apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) : / 2 * ulp beta fexp2 x <= / 2 * bpow (fexp2 (mag x)).","proofString":"rewrite ulp_neq_0;[now right|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x)).","proofString":"exact Hr1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : round beta fexp1 (Znearest choice1) x'' =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : round beta fexp1 (Znearest choice1) 0 = round beta fexp1 (Znearest choice1) x.","proofString":"rewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : 0 = round beta fexp1 (Znearest choice1) x.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : 0 =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"rewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) - 0) < / 2.","proofString":"apply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) - 0) * bpow (fexp1 (mag x)) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) - 0) * Rabs (bpow (fexp1 (mag x))) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs\n  (x * bpow (- fexp1 (mag x)) * bpow (fexp1 (mag x)) -\n   0 * bpow (fexp1 (mag x))) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) * bpow (fexp1 (mag x)) - 0) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"bpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x - 0) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (0 - x) < / 2 * bpow (fexp1 (mag x)).","proofString":"apply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : / 2 * bpow (fexp2 (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"apply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : bpow (fexp2 (mag x)) < bpow (fexp1 (mag x)).","proofString":"apply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : (fexp2 (mag x) < fexp1 (mag x))%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : (mag x'' <= mag x)%Z.","proofString":"apply mag_le_bpow; [exact Nzx''|].\nreplace x'' with (x'' - x + x) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (bpow _) with (/ 2 * bpow (fexp2 (mag x))                             + (bpow (mag x)                                - / 2 * bpow (fexp2 (mag x)))) by ring.\napply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Rabs x'' < bpow (mag x).","proofString":"replace x'' with (x'' - x + x) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (bpow _) with (/ 2 * bpow (fexp2 (mag x))                             + (bpow (mag x)                                - / 2 * bpow (fexp2 (mag x)))) by ring.\napply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Rabs (x'' - x + x) < bpow (mag x).","proofString":"apply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (bpow _) with (/ 2 * bpow (fexp2 (mag x))                             + (bpow (mag x)                                - / 2 * bpow (fexp2 (mag x)))) by ring.\napply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Rabs (x'' - x) + Rabs x < bpow (mag x).","proofString":"replace (bpow _) with (/ 2 * bpow (fexp2 (mag x))                             + (bpow (mag x)                                - / 2 * bpow (fexp2 (mag x)))) by ring.\napply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Rabs (x'' - x) + Rabs x <\n/ 2 * bpow (fexp2 (mag x)) + (bpow (mag x) - / 2 * bpow (fexp2 (mag x))).","proofString":"apply Rplus_le_lt_compat; [exact Hr1|].\nrewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Rabs x < bpow (mag x) - / 2 * bpow (fexp2 (mag x)).","proofString":"rewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].\nnow rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * bpow (cexp beta fexp2 x)) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Rabs x < bpow (mag x) - / 2 * bpow (fexp2 (mag x)).","proofString":"now rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : x < bpow (mag x) - / 2 * ulp beta fexp2 x) (x' : R) (Hx2' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hx2 : x - round beta fexp1 Zfloor x <\n/ 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (x'' : R) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Pxx' : 0 <= x - x') (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : round beta fexp2 (Znearest choice2) x <> 0) : (mag x <= mag (round beta fexp2 (Znearest choice2) x))%Z.","proofString":"now apply mag_round_ge; [|apply valid_rnd_N|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) : x < midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"intro Hx'.\nassert (Hx : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x).\nnow apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify.\nrevert Hx.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx.\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nassert (H : Rabs (x * bpow (- fexp1 (mag x)) -                  IZR (Zfloor (x * bpow (- fexp1 (mag x))))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nchange (IZR _ * _) with x'.\nsplit.\napply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\nrewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption.\nunfold round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hx : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x).\nnow apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify.\nrevert Hx.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx.\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nassert (H : Rabs (x * bpow (- fexp1 (mag x)) -                  IZR (Zfloor (x * bpow (- fexp1 (mag x))))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nchange (IZR _ * _) with x'.\nsplit.\napply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\nrewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption.\nunfold round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x.","proofString":"now apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (Hx : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"revert Hx.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx.\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nassert (H : Rabs (x * bpow (- fexp1 (mag x)) -                  IZR (Zfloor (x * bpow (- fexp1 (mag x))))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nchange (IZR _ * _) with x'.\nsplit.\napply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\nrewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption.\nunfold round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx.\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nassert (H : Rabs (x * bpow (- fexp1 (mag x)) -                  IZR (Zfloor (x * bpow (- fexp1 (mag x))))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nchange (IZR _ * _) with x'.\nsplit.\napply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\nrewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption.\nunfold round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (x' := round beta fexp1 Zfloor x).\nintro Hx.\nassert (Pxx' : 0 <= x - x').\napply Rle_0_minus.\napply round_DN_pt.\nexact Vfexp1.\nassert (H : Rabs (x * bpow (- fexp1 (mag x)) -                  IZR (Zfloor (x * bpow (- fexp1 (mag x))))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nchange (IZR _ * _) with x'.\nsplit.\napply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\nrewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption.\nunfold round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : - (/ 2 * bpow (fexp1 (mag x))) < x - x' < / 2 * bpow (fexp1 (mag x)).","proofString":"split.\napply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\nrewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : - (/ 2 * bpow (fexp1 (mag x))) < x - x'.","proofString":"apply Rlt_le_trans with 0; [|exact Pxx'].\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : - (/ 2 * bpow (fexp1 (mag x))) < 0.","proofString":"rewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : - (/ 2 * bpow (fexp1 (mag x))) < - 0.","proofString":"apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : 0 < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : / 2 * 0 < / 2 * bpow (fexp1 (mag x)).","proofString":"apply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : 0 < bpow (fexp1 (mag x)).","proofString":"apply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') : x - x' < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"unfold round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : round beta fexp1 (Znearest choice1)\n  (IZR (Znearest choice2 (x * bpow (- fexp2 (mag x)))) * bpow (fexp2 (mag x))) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : round beta fexp1 (Znearest choice1)\n  (IZR (Znearest choice2 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x))) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)) H).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : round beta fexp1 (Znearest choice1)\n  (IZR (Zfloor (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x))) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x))))).\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : IZR (Zfloor (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x)) =\nround beta fexp1 (Znearest choice1) x.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x)))))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : IZR (Zfloor (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"now rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (mag x)))))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : Valid_rnd (Znearest choice1).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : generic_format beta fexp1\n  (IZR (Zfloor (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x))).","proofString":"fold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : generic_format beta fexp1\n  (IZR (Zfloor (scaled_mantissa beta fexp1 x)) * bpow (cexp beta fexp1 x)).","proofString":"change (IZR _ * bpow _) with (round beta fexp1 Zfloor x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : generic_format beta fexp1 (round beta fexp1 Zfloor x).","proofString":"apply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : x < midp fexp1 x) (x' : R) (Hx : x - x' < / 2 * ulp beta fexp1 x) (Pxx' : 0 <= x - x') (H : Rabs (x * bpow (- fexp1 (mag x)) - IZR (Zfloor (x * bpow (- fexp1 (mag x))))) <\n/ 2) : Valid_rnd Zfloor.","proofString":"now apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : x < midp fexp1 x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nx < midp fexp1 x - / 2 * ulp beta fexp2 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"destruct (Zle_or_lt (fexp1 (mag x)) (fexp2 (mag x))) as [Hf2'|Hf2'].\nassert (Hf2'' : (fexp2 (mag x) = fexp1 (mag x) :> Z)%Z) by lia.\nnow apply round_round_lt_mid_same_place.\nassert (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\ngeneralize (Hx' Hf2''); intro Hx''.\nnow apply round_round_lt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : x < midp fexp1 x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nx < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hf2' : (fexp1 (mag x) <= fexp2 (mag x))%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hf2'' : (fexp2 (mag x) = fexp1 (mag x) :> Z)%Z) by lia.\nnow apply round_round_lt_mid_same_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : x < midp fexp1 x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nx < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hf2' : (fexp1 (mag x) <= fexp2 (mag x))%Z) (Hf2'' : fexp2 (mag x) = fexp1 (mag x)) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply round_round_lt_mid_same_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : x < midp fexp1 x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nx < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hf2' : (fexp2 (mag x) < fexp1 (mag x))%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\ngeneralize (Hx' Hf2''); intro Hx''.\nnow apply round_round_lt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : x < midp fexp1 x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nx < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hf2' : (fexp2 (mag x) < fexp1 (mag x))%Z) (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"generalize (Hx' Hf2''); intro Hx''.\nnow apply round_round_lt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : x < midp fexp1 x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nx < midp fexp1 x - / 2 * ulp beta fexp2 x) (Hf2' : (fexp2 (mag x) < fexp1 (mag x))%Z) (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx'' : x < midp fexp1 x - / 2 * ulp beta fexp2 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply round_round_lt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) : round beta fexp2 (Znearest choice2) x < bpow (mag x) ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"intros Hx1 Hx2'.\nassert (Hx2 : round beta fexp1 Zceil x - x              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\napply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x                         + / 2 * ulp beta fexp2 x)); ring_simplify.\nnow unfold midp' in Hx2'.\nrevert Hx1 Hx2.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zceil x).\nset (x'' := round beta fexp2 (Znearest choice2) x).\nintros Hx1 Hx2.\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/2* ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Px'x : 0 <= x' - x).\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nrewrite Rabs_right; [exact Hx1|apply Rle_ge].\napply round_ge_generic.\nexact Vfexp2.\nnow apply valid_rnd_N.\napply generic_format_0.\nnow apply Rlt_le.\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_minus_sym.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nrewrite 2!ulp_neq_0; try (apply Rgt_not_eq; assumption).\nunfold cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : round beta fexp2 (Znearest choice2) x < bpow (mag x)) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hx2 : round beta fexp1 Zceil x - x              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\napply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x                         + / 2 * ulp beta fexp2 x)); ring_simplify.\nnow unfold midp' in Hx2'.\nrevert Hx1 Hx2.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zceil x).\nset (x'' := round beta fexp2 (Znearest choice2) x).\nintros Hx1 Hx2.\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/2* ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Px'x : 0 <= x' - x).\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nrewrite Rabs_right; [exact Hx1|apply Rle_ge].\napply round_ge_generic.\nexact Vfexp2.\nnow apply valid_rnd_N.\napply generic_format_0.\nnow apply Rlt_le.\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_minus_sym.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nrewrite 2!ulp_neq_0; try (apply Rgt_not_eq; assumption).\nunfold cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : round beta fexp2 (Znearest choice2) x < bpow (mag x)) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x).","proofString":"apply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x                         + / 2 * ulp beta fexp2 x)); ring_simplify.\nnow unfold midp' in Hx2'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : round beta fexp2 (Znearest choice2) x < bpow (mag x)) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp1 Zceil x - / 2 * ulp beta fexp1 x + / 2 * ulp beta fexp2 x <\nx.","proofString":"now unfold midp' in Hx2'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx1 : round beta fexp2 (Znearest choice2) x < bpow (mag x)) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"revert Hx1 Hx2.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zceil x).\nset (x'' := round beta fexp2 (Znearest choice2) x).\nintros Hx1 Hx2.\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/2* ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Px'x : 0 <= x' - x).\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nrewrite Rabs_right; [exact Hx1|apply Rle_ge].\napply round_ge_generic.\nexact Vfexp2.\nnow apply valid_rnd_N.\napply generic_format_0.\nnow apply Rlt_le.\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_minus_sym.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nrewrite 2!ulp_neq_0; try (apply Rgt_not_eq; assumption).\nunfold cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp2 (Znearest choice2) x < bpow (mag x) ->\nround beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x) ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq.\nset (x' := round beta fexp1 Zceil x).\nset (x'' := round beta fexp2 (Znearest choice2) x).\nintros Hx1 Hx2.\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/2* ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Px'x : 0 <= x' - x).\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nrewrite Rabs_right; [exact Hx1|apply Rle_ge].\napply round_ge_generic.\nexact Vfexp2.\nnow apply valid_rnd_N.\napply generic_format_0.\nnow apply Rlt_le.\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_minus_sym.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nrewrite 2!ulp_neq_0; try (apply Rgt_not_eq; assumption).\nunfold cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp2 (Znearest choice2) x < bpow (mag x) ->\nround beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x) ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (x' := round beta fexp1 Zceil x).\nset (x'' := round beta fexp2 (Znearest choice2) x).\nintros Hx1 Hx2.\nassert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))).\napply Rle_trans with (/2* ulp beta fexp2 x).\nnow unfold x''; apply error_le_half_ulp...\nrewrite ulp_neq_0;[now right|now apply Rgt_not_eq].\nassert (Px'x : 0 <= x' - x).\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nassert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))).\nreplace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2.\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''].\nrewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia.\nassert (Lx'' : mag x'' = mag x :> Z).\napply Zle_antisym.\napply mag_le_bpow; [exact Nzx''|].\nrewrite Rabs_right; [exact Hx1|apply Rle_ge].\napply round_ge_generic.\nexact Vfexp2.\nnow apply valid_rnd_N.\napply generic_format_0.\nnow apply Rlt_le.\nunfold x'' in Nzx'' |- *.\nnow apply mag_round_ge; [|apply valid_rnd_N|].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lx''.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x)));    [reflexivity|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nbpow_simplify.\nrewrite Rabs_minus_sym.\nrewrite Rabs_right; [|now apply Rle_ge].\napply (Rlt_le_trans _ _ _ Hx2).\napply Rmult_le_compat_l; [lra|].\ngeneralize (bpow_ge_0 beta (fexp2 (mag x))).\nrewrite 2!ulp_neq_0; try (apply Rgt_not_eq; assumption).\nunfold cexp; lra.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nfold x'.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) : / 2 * ulp beta fexp2 x <= / 2 * bpow (fexp2 (mag x)).","proofString":"rewrite ulp_neq_0;[now right|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x)).","proofString":"replace (x'' - x') with (x'' - x + (x - x')) by ring.\napply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x'' - x + (x - x')) < / 2 * bpow (fexp1 (mag x)).","proofString":"apply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).\nreplace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x'' - x) + Rabs (x - x') < / 2 * bpow (fexp1 (mag x)).","proofString":"replace (/ 2 * _) with (/ 2 * bpow (fexp2 (mag x))                          + (/ 2 * (bpow (fexp1 (mag x))                                    - bpow (fexp2 (mag x))))) by ring.\napply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x'' - x) + Rabs (x - x') <\n/ 2 * bpow (fexp2 (mag x)) +\n/ 2 * (bpow (fexp1 (mag x)) - bpow (fexp2 (mag x))).","proofString":"apply Rplus_le_lt_compat.\nexact Hr1.\nrewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x)).","proofString":"exact Hr1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x - x') < / 2 * (bpow (fexp1 (mag x)) - bpow (fexp2 (mag x))).","proofString":"rewrite Rabs_minus_sym.\nrewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x' - x) < / 2 * (bpow (fexp1 (mag x)) - bpow (fexp2 (mag x))).","proofString":"rewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).\nnow rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (bpow (cexp beta fexp1 x) - bpow (cexp beta fexp2 x))) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) : Rabs (x' - x) < / 2 * (bpow (fexp1 (mag x)) - bpow (fexp2 (mag x))).","proofString":"now rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : round beta fexp1 (Znearest choice1) x'' =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite Zx'' in Hr1 |- *.\nrewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : round beta fexp1 (Znearest choice1) 0 = round beta fexp1 (Znearest choice1) x.","proofString":"rewrite round_0; [|now apply valid_rnd_N].\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : 0 = round beta fexp1 (Znearest choice1) x.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : 0 =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"rewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) - 0) < / 2.","proofString":"apply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) - 0) * bpow (fexp1 (mag x)) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) - 0) * Rabs (bpow (fexp1 (mag x))) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.\nrewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs\n  (x * bpow (- fexp1 (mag x)) * bpow (fexp1 (mag x)) -\n   0 * bpow (fexp1 (mag x))) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite Rmult_0_l.\nbpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x * bpow (- fexp1 (mag x)) * bpow (fexp1 (mag x)) - 0) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"bpow_simplify.\nrewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (x - 0) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite Rabs_minus_sym.\napply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : Rabs (0 - x) < / 2 * bpow (fexp1 (mag x)).","proofString":"apply (Rle_lt_trans _ _ _ Hr1).\napply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : / 2 * bpow (fexp2 (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"apply Rmult_lt_compat_l; [lra|].\napply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : bpow (fexp2 (mag x)) < bpow (fexp1 (mag x)).","proofString":"apply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (0 - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Zx'' : x'' = 0) : (fexp2 (mag x) < fexp1 (mag x))%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : generic_format beta fexp2 0.","proofString":"apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : x'' <> 0) : 0 <= x.","proofString":"now apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (x'' : R) (Hx1 : x'' < bpow (mag x)) (Hx2 : x' - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (mag x))) (Px'x : 0 <= x' - x) (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (mag x))) (Nzx'' : round beta fexp2 (Znearest choice2) x <> 0) : (mag x <= mag (round beta fexp2 (Znearest choice2) x))%Z.","proofString":"now apply mag_round_ge; [|apply valid_rnd_N|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hx2 : round beta fexp1 Zceil x - x              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\napply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x                         + / 2 * ulp beta fexp2 x)); ring_simplify.\nnow unfold midp' in Hx2'.\nrevert Hx2.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx2.\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Rlt_or_le x'' (bpow (mag x))) as [Hx''|Hx''];  [now apply round_round_gt_mid_further_place'|].\nassert (Hx''pow : x'' = bpow (mag x)).\nassert (H'x'' : x'' < bpow (mag x) + / 2 * ulp beta fexp2 x).\napply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).\napply (Rplus_le_reg_r (- x)); ring_simplify.\napply Rabs_le_inv.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply Rle_antisym; [|exact Hx''].\nunfold x'', round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_le_reg_r (bpow (- fexp2 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)) by lia.\napply IZR_le.\napply Zlt_succ_le; unfold Z.succ.\napply lt_IZR.\nrewrite plus_IZR; rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp2 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r; rewrite Rmult_1_l.\nbpow_simplify.\napply (Rlt_le_trans _ _ _ H'x'').\napply Rplus_le_compat_l.\nrewrite <- (Rmult_1_l (Raux.bpow _ _)).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nlra.\nassert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).\napply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).\nrewrite Rabs_minus_sym.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x).","proofString":"apply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x                         + / 2 * ulp beta fexp2 x)); ring_simplify.\nnow unfold midp' in Hx2'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp1 Zceil x - / 2 * ulp beta fexp1 x + / 2 * ulp beta fexp2 x <\nx.","proofString":"now unfold midp' in Hx2'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"revert Hx2.\nunfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx2.\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Rlt_or_le x'' (bpow (mag x))) as [Hx''|Hx''];  [now apply round_round_gt_mid_further_place'|].\nassert (Hx''pow : x'' = bpow (mag x)).\nassert (H'x'' : x'' < bpow (mag x) + / 2 * ulp beta fexp2 x).\napply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).\napply (Rplus_le_reg_r (- x)); ring_simplify.\napply Rabs_le_inv.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply Rle_antisym; [|exact Hx''].\nunfold x'', round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_le_reg_r (bpow (- fexp2 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)) by lia.\napply IZR_le.\napply Zlt_succ_le; unfold Z.succ.\napply lt_IZR.\nrewrite plus_IZR; rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp2 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r; rewrite Rmult_1_l.\nbpow_simplify.\napply (Rlt_le_trans _ _ _ H'x'').\napply Rplus_le_compat_l.\nrewrite <- (Rmult_1_l (Raux.bpow _ _)).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nlra.\nassert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).\napply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).\nrewrite Rabs_minus_sym.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x) ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq.\nset (x' := round beta fexp1 Zfloor x).\nintro Hx2.\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Rlt_or_le x'' (bpow (mag x))) as [Hx''|Hx''];  [now apply round_round_gt_mid_further_place'|].\nassert (Hx''pow : x'' = bpow (mag x)).\nassert (H'x'' : x'' < bpow (mag x) + / 2 * ulp beta fexp2 x).\napply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).\napply (Rplus_le_reg_r (- x)); ring_simplify.\napply Rabs_le_inv.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply Rle_antisym; [|exact Hx''].\nunfold x'', round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_le_reg_r (bpow (- fexp2 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)) by lia.\napply IZR_le.\napply Zlt_succ_le; unfold Z.succ.\napply lt_IZR.\nrewrite plus_IZR; rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp2 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r; rewrite Rmult_1_l.\nbpow_simplify.\napply (Rlt_le_trans _ _ _ H'x'').\napply Rplus_le_compat_l.\nrewrite <- (Rmult_1_l (Raux.bpow _ _)).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nlra.\nassert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).\napply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).\nrewrite Rabs_minus_sym.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x) ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (x' := round beta fexp1 Zfloor x).\nintro Hx2.\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Rlt_or_le x'' (bpow (mag x))) as [Hx''|Hx''];  [now apply round_round_gt_mid_further_place'|].\nassert (Hx''pow : x'' = bpow (mag x)).\nassert (H'x'' : x'' < bpow (mag x) + / 2 * ulp beta fexp2 x).\napply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).\napply (Rplus_le_reg_r (- x)); ring_simplify.\napply Rabs_le_inv.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply Rle_antisym; [|exact Hx''].\nunfold x'', round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_le_reg_r (bpow (- fexp2 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)) by lia.\napply IZR_le.\napply Zlt_succ_le; unfold Z.succ.\napply lt_IZR.\nrewrite plus_IZR; rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp2 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r; rewrite Rmult_1_l.\nbpow_simplify.\napply (Rlt_le_trans _ _ _ H'x'').\napply Rplus_le_compat_l.\nrewrite <- (Rmult_1_l (Raux.bpow _ _)).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nlra.\nassert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).\napply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).\nrewrite Rabs_minus_sym.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x) ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"intro Hx2.\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Rlt_or_le x'' (bpow (mag x))) as [Hx''|Hx''];  [now apply round_round_gt_mid_further_place'|].\nassert (Hx''pow : x'' = bpow (mag x)).\nassert (H'x'' : x'' < bpow (mag x) + / 2 * ulp beta fexp2 x).\napply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).\napply (Rplus_le_reg_r (- x)); ring_simplify.\napply Rabs_le_inv.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply Rle_antisym; [|exact Hx''].\nunfold x'', round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_le_reg_r (bpow (- fexp2 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)) by lia.\napply IZR_le.\napply Zlt_succ_le; unfold Z.succ.\napply lt_IZR.\nrewrite plus_IZR; rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp2 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r; rewrite Rmult_1_l.\nbpow_simplify.\napply (Rlt_le_trans _ _ _ H'x'').\napply Rplus_le_compat_l.\nrewrite <- (Rmult_1_l (Raux.bpow _ _)).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nlra.\nassert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).\napply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).\nrewrite Rabs_minus_sym.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Rlt_or_le x'' (bpow (mag x))) as [Hx''|Hx''];  [now apply round_round_gt_mid_further_place'|].\nassert (Hx''pow : x'' = bpow (mag x)).\nassert (H'x'' : x'' < bpow (mag x) + / 2 * ulp beta fexp2 x).\napply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).\napply (Rplus_le_reg_r (- x)); ring_simplify.\napply Rabs_le_inv.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply Rle_antisym; [|exact Hx''].\nunfold x'', round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_le_reg_r (bpow (- fexp2 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)) by lia.\napply IZR_le.\napply Zlt_succ_le; unfold Z.succ.\napply lt_IZR.\nrewrite plus_IZR; rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp2 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r; rewrite Rmult_1_l.\nbpow_simplify.\napply (Rlt_le_trans _ _ _ H'x'').\napply Rplus_le_compat_l.\nrewrite <- (Rmult_1_l (Raux.bpow _ _)).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nlra.\nassert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).\napply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).\nrewrite Rabs_minus_sym.\napply error_le_half_ulp.\nexact Vfexp2.\napply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') : x + / 2 * ulp beta fexp2 x < bpow (mag x) + / 2 * ulp beta fexp2 x.","proofString":"apply Rplus_lt_compat_r.\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') : x < bpow (mag x).","proofString":"rewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') : Rabs x < bpow (mag x).","proofString":"apply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) : / 2 * ulp beta fexp2 x < / 2 * ulp beta fexp1 x.","proofString":"apply Rmult_lt_compat_l; [lra|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) : ulp beta fexp2 x < ulp beta fexp1 x.","proofString":"rewrite 2!ulp_neq_0; try now apply Rgt_not_eq.\nunfold cexp; apply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) : bpow (cexp beta fexp2 x) < bpow (cexp beta fexp1 x).","proofString":"unfold cexp; apply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) : (fexp2 (mag x) < fexp1 (mag x))%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : round beta fexp1 (Znearest choice1) x'' =\nround beta fexp1 (Znearest choice1) x.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\nassert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : IZR (Znearest choice1 (x'' * bpow (- fexp1 (mag x'')))) *\nbpow (fexp1 (mag x'')) =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"assert (Hf : (0 <= mag x - fexp1 (mag x''))%Z).\nrewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1.\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : (0 <= mag x - fexp1 (mag x''))%Z.","proofString":"rewrite Hx''pow.\nrewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : (0 <= mag x - fexp1 (mag (bpow (mag x))))%Z.","proofString":"rewrite mag_bpow.\ncut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : (0 <= mag x - fexp1 (mag x + 1))%Z.","proofString":"cut (fexp1 (mag x + 1) <= mag x)%Z.\nlia.\ndestruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : (fexp1 (mag x + 1) <= mag x)%Z -> (0 <= mag x - fexp1 (mag x + 1))%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) : (fexp1 (mag x + 1) <= mag x)%Z.","proofString":"destruct (Zle_or_lt (mag x) (fexp1 (mag x))) as [Hle|Hlt];    [|now apply Vfexp1].\nassert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hle : (mag x <= fexp1 (mag x))%Z) : (fexp1 (mag x + 1) <= mag x)%Z.","proofString":"assert (H : (mag x = fexp1 (mag x) :> Z)%Z);    [now apply Zle_antisym|].\nrewrite H.\nnow apply Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : IZR (Znearest choice1 (x'' * bpow (- fexp1 (mag x'')))) *\nbpow (fexp1 (mag x'')) =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"rewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x'')))%Z).\nrewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr.\nrewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : IZR (beta ^ (mag x - fexp1 (mag x''))) * bpow (fexp1 (mag x'')) =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"rewrite (Znearest_imp _ _ (beta ^ (mag x - fexp1 (mag x)))%Z).\nrewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : IZR (beta ^ (mag x - fexp1 (mag x''))) * bpow (fexp1 (mag x'')) =\nIZR (beta ^ (mag x - fexp1 (mag x))) * bpow (fexp1 (mag x)).","proofString":"rewrite IZR_Zpower by exact Hf.\nrewrite IZR_Zpower by lia.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : bpow (mag x - fexp1 (mag x'')) * bpow (fexp1 (mag x'')) =\nIZR (beta ^ (mag x - fexp1 (mag x))) * bpow (fexp1 (mag x)).","proofString":"rewrite IZR_Zpower by lia.\nnow bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : bpow (mag x - fexp1 (mag x'')) * bpow (fexp1 (mag x'')) =\nbpow (mag x - fexp1 (mag x)) * bpow (fexp1 (mag x)).","proofString":"now bpow_simplify."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x * bpow (- fexp1 (mag x)) - IZR (beta ^ (mag x - fexp1 (mag x)))) <\n/ 2.","proofString":"rewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x * bpow (- fexp1 (mag x)) - bpow (mag x - fexp1 (mag x))) < / 2.","proofString":"apply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x * bpow (- fexp1 (mag x)) - bpow (mag x - fexp1 (mag x))) *\nbpow (fexp1 (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;      [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x * bpow (- fexp1 (mag x)) - bpow (mag x - fexp1 (mag x))) *\nRabs (bpow (fexp1 (mag x))) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs\n  ((x * bpow (- fexp1 (mag x)) - bpow (mag x - fexp1 (mag x))) *\n   bpow (fexp1 (mag x))) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs\n  (x * bpow (- fexp1 (mag x)) * bpow (fexp1 (mag x)) -\n   bpow (mag x - fexp1 (mag x)) * bpow (fexp1 (mag x))) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"bpow_simplify.\nrewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x - bpow (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].\nrewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * bpow (cexp beta fexp1 x)) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x - bpow (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- Hx''pow; exact Hr."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs\n  (x'' * bpow (- fexp1 (mag x'')) - IZR (beta ^ (mag x - fexp1 (mag x'')))) <\n/ 2.","proofString":"rewrite IZR_Zpower; [|exact Hf].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x'' * bpow (- fexp1 (mag x'')) - bpow (mag x - fexp1 (mag x''))) < / 2.","proofString":"apply (Rmult_lt_reg_r (bpow (fexp1 (mag x'')))); [now apply bpow_gt_0|].\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x'' * bpow (- fexp1 (mag x'')) - bpow (mag x - fexp1 (mag x''))) *\nbpow (fexp1 (mag x'')) < / 2 * bpow (fexp1 (mag x'')).","proofString":"rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x'' * bpow (- fexp1 (mag x'')) - bpow (mag x - fexp1 (mag x''))) *\nRabs (bpow (fexp1 (mag x''))) < / 2 * bpow (fexp1 (mag x'')).","proofString":"rewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs\n  ((x'' * bpow (- fexp1 (mag x'')) - bpow (mag x - fexp1 (mag x''))) *\n   bpow (fexp1 (mag x''))) < / 2 * bpow (fexp1 (mag x'')).","proofString":"rewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs\n  (x'' * bpow (- fexp1 (mag x'')) * bpow (fexp1 (mag x'')) -\n   bpow (mag x - fexp1 (mag x'')) * bpow (fexp1 (mag x''))) <\n/ 2 * bpow (fexp1 (mag x'')).","proofString":"bpow_simplify.\nrewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs (x'' - bpow (mag x)) < / 2 * bpow (fexp1 (mag x'')).","proofString":"rewrite Rminus_diag_eq; [|exact Hx''pow].\nrewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : Rabs 0 < / 2 * bpow (fexp1 (mag x'')).","proofString":"rewrite Rabs_R0.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : 0 < / 2 * bpow (fexp1 (mag x'')).","proofString":"rewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx2' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) (x' : R) (Hx2 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) (x'' : R) (Hx'' : bpow (mag x) <= x'') (Hx''pow : x'' = bpow (mag x)) (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x) (Hf : (0 <= mag x - fexp1 (mag x''))%Z) : / 2 * 0 < / 2 * bpow (fexp1 (mag x'')).","proofString":"apply Rmult_lt_compat_l; [lra|apply bpow_gt_0]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x).\napply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x)); ring_simplify.\nnow unfold midp' in Hx'.\nassert (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x))))                  - x * bpow (- fexp1 (mag x))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq].\nunfold round_round_eq, round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym].\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP.\nnow rewrite Rabs_minus_sym."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x.","proofString":"apply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x)); ring_simplify.\nnow unfold midp' in Hx'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) : round beta fexp1 Zceil x - / 2 * ulp beta fexp1 x < x.","proofString":"now unfold midp' in Hx'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x))))                  - x * bpow (- fexp1 (mag x))) < / 2).\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq].\nunfold round_round_eq, round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym].\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP.\nnow rewrite Rabs_minus_sym."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2.","proofString":"apply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nunfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) *\nbpow (fexp1 (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"unfold scaled_mantissa, cexp in Hx.\nrewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) *\nbpow (fexp1 (mag x)) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;    [|now apply Rle_ge; apply bpow_ge_0].\nrewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) *\nRabs (bpow (fexp1 (mag x))) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- Rabs_mult.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs\n  ((IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) *\n   bpow (fexp1 (mag x))) < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs\n  (IZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) -\n   x * bpow (- fexp1 (mag x)) * bpow (fexp1 (mag x))) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"bpow_simplify.\napply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) - x) <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"apply Rabs_lt.\nsplit.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : - (/ 2 * bpow (fexp1 (mag x))) <\nIZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) - x <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"split.\napply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1.\nrewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : - (/ 2 * bpow (fexp1 (mag x))) <\nIZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) - x.","proofString":"apply Rlt_le_trans with 0.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0.\napply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : - (/ 2 * bpow (fexp1 (mag x))) < 0.","proofString":"rewrite <- Ropp_0; apply Ropp_lt_contravar.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : 0 < / 2 * bpow (fexp1 (mag x)).","proofString":"rewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : / 2 * 0 < / 2 * bpow (fexp1 (mag x)).","proofString":"apply Rmult_lt_compat_l; [lra|].\napply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : 0 < bpow (fexp1 (mag x)).","proofString":"apply bpow_gt_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : 0 <= IZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) - x.","proofString":"apply Rle_0_minus.\napply round_UP_pt.\nexact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : x <= IZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"apply round_UP_pt.\nexact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) : IZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) - x <\n/ 2 * bpow (fexp1 (mag x)).","proofString":"rewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq, round at 2.\nunfold F2R, scaled_mantissa, cexp; simpl.\nrewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym].\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP.\nnow rewrite Rabs_minus_sym."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : round beta fexp1 (Znearest choice1)\n  (IZR (Znearest choice2 (x * bpow (- fexp2 (mag x)))) * bpow (fexp2 (mag x))) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite Hf2f1.\nrewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym].\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP.\nnow rewrite Rabs_minus_sym."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : round beta fexp1 (Znearest choice1)\n  (IZR (Znearest choice2 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x))) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).\nrewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym].\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP.\nnow rewrite Rabs_minus_sym."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : round beta fexp1 (Znearest choice1)\n  (IZR (Zceil (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x))) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite round_generic.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym].\nnow apply valid_rnd_N.\nfold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : IZR (Zceil (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x)) =\nround beta fexp1 (Znearest choice1) x.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\nnow rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : IZR (Zceil (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)) =\nIZR (Znearest choice1 (x * bpow (- fexp1 (mag x)))) * bpow (fexp1 (mag x)).","proofString":"now rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (mag x)))));      [|rewrite Rabs_minus_sym]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : Valid_rnd (Znearest choice1).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : generic_format beta fexp1\n  (IZR (Zceil (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x))).","proofString":"fold (cexp beta fexp1 x).\nchange (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : generic_format beta fexp1\n  (IZR (Zceil (scaled_mantissa beta fexp1 x)) * bpow (cexp beta fexp1 x)).","proofString":"change (IZR _ * bpow _) with (round beta fexp1 Zceil x).\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : generic_format beta fexp1 (round beta fexp1 Zceil x).","proofString":"apply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_UP."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : Valid_rnd Zceil.","proofString":"now apply valid_rnd_UP."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : fexp2 (mag x) = fexp1 (mag x)) (Hx' : midp' fexp1 x < x) (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x) (H : Rabs (IZR (Zceil (x * bpow (- fexp1 (mag x)))) - x * bpow (- fexp1 (mag x))) <\n/ 2) : Rabs\n  (x * bpow (- fexp1 (mag x)) - IZR (Zceil (scaled_mantissa beta fexp1 x))) <\n/ 2.","proofString":"now rewrite Rabs_minus_sym."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : midp' fexp1 x < x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"destruct (Zle_or_lt (fexp1 (mag x)) (fexp2 (mag x))) as [Hf2'|Hf2'].\nassert (Hf2'' : (fexp2 (mag x) = fexp1 (mag x) :> Z)%Z) by lia.\nnow apply round_round_gt_mid_same_place.\nassert (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\ngeneralize (Hx' Hf2''); intro Hx''.\nnow apply round_round_gt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : midp' fexp1 x < x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hf2' : (fexp1 (mag x) <= fexp2 (mag x))%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hf2'' : (fexp2 (mag x) = fexp1 (mag x) :> Z)%Z) by lia.\nnow apply round_round_gt_mid_same_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : midp' fexp1 x < x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hf2' : (fexp1 (mag x) <= fexp2 (mag x))%Z) (Hf2'' : fexp2 (mag x) = fexp1 (mag x)) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply round_round_gt_mid_same_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : midp' fexp1 x < x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hf2' : (fexp2 (mag x) < fexp1 (mag x))%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\ngeneralize (Hx' Hf2''); intro Hx''.\nnow apply round_round_gt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : midp' fexp1 x < x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hf2' : (fexp2 (mag x) < fexp1 (mag x))%Z) (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"generalize (Hx' Hf2''); intro Hx''.\nnow apply round_round_gt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (Hx : midp' fexp1 x < x) (Hx' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z ->\nmidp' fexp1 x + / 2 * ulp beta fexp2 x < x) (Hf2' : (fexp2 (mag x) < fexp1 (mag x))%Z) (Hf2'' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hx'' : midp' fexp1 x + / 2 * ulp beta fexp2 x < x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply round_round_gt_mid_further_place."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x * y).","proofString":"destruct (Req_dec x 0) as [Zx|Zx].\nrewrite Zx.\nrewrite Rmult_0_l.\nnow apply generic_format_0.\ndestruct (Req_dec y 0) as [Zy|Zy].\nrewrite Zy.\nrewrite Rmult_0_r.\nnow apply generic_format_0.\nrevert Fx Fy.\nunfold generic_format.\nunfold cexp.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nunfold F2R; simpl.\nintros Fx Fy.\nset (fxy := Float beta (mx * my) (fexp1 (mag x) + fexp1 (mag y))).\nassert (Hxy : x * y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nunfold cexp, fxy; simpl.\ndestruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 (x * y).","proofString":"rewrite Zx.\nrewrite Rmult_0_l.\nnow apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 (0 * y).","proofString":"rewrite Rmult_0_l.\nnow apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 0.","proofString":"now apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x <> 0) : generic_format beta fexp2 (x * y).","proofString":"destruct (Req_dec y 0) as [Zy|Zy].\nrewrite Zy.\nrewrite Rmult_0_r.\nnow apply generic_format_0.\nrevert Fx Fy.\nunfold generic_format.\nunfold cexp.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nunfold F2R; simpl.\nintros Fx Fy.\nset (fxy := Float beta (mx * my) (fexp1 (mag x) + fexp1 (mag y))).\nassert (Hxy : x * y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nunfold cexp, fxy; simpl.\ndestruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 (x * y).","proofString":"rewrite Zy.\nrewrite Rmult_0_r.\nnow apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 (x * 0).","proofString":"rewrite Rmult_0_r.\nnow apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 0.","proofString":"now apply generic_format_0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x <> 0) (Zy : y <> 0) : generic_format beta fexp2 (x * y).","proofString":"revert Fx Fy.\nunfold generic_format.\nunfold cexp.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nunfold F2R; simpl.\nintros Fx Fy.\nset (fxy := Float beta (mx * my) (fexp1 (mag x) + fexp1 (mag y))).\nassert (Hxy : x * y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nunfold cexp, fxy; simpl.\ndestruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) : generic_format beta fexp1 x ->\ngeneric_format beta fexp1 y -> generic_format beta fexp2 (x * y).","proofString":"unfold generic_format.\nunfold cexp.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nunfold F2R; simpl.\nintros Fx Fy.\nset (fxy := Float beta (mx * my) (fexp1 (mag x) + fexp1 (mag y))).\nassert (Hxy : x * y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nunfold cexp, fxy; simpl.\ndestruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) : x = IZR mx * bpow (fexp1 (mag x)) ->\ny = IZR my * bpow (fexp1 (mag y)) ->\nx * y =\nIZR (Ztrunc (scaled_mantissa beta fexp2 (x * y))) *\nbpow (fexp2 (mag (x * y))).","proofString":"intros Fx Fy.\nset (fxy := Float beta (mx * my) (fexp1 (mag x) + fexp1 (mag y))).\nassert (Hxy : x * y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nunfold cexp, fxy; simpl.\ndestruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) : x * y =\nIZR (Ztrunc (scaled_mantissa beta fexp2 (x * y))) *\nbpow (fexp2 (mag (x * y))).","proofString":"set (fxy := Float beta (mx * my) (fexp1 (mag x) + fexp1 (mag y))).\nassert (Hxy : x * y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nunfold cexp, fxy; simpl.\ndestruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x * y = IZR (mx * my) * bpow (fexp1 (mag x) + fexp1 (mag y)).","proofString":"rewrite bpow_plus.\nrewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x * y = IZR (mx * my) * (bpow (fexp1 (mag x)) * bpow (fexp1 (mag y))).","proofString":"rewrite mult_IZR.\nrewrite Fx, Fy at 1.\nring."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x * y = IZR mx * IZR my * (bpow (fexp1 (mag x)) * bpow (fexp1 (mag y))).","proofString":"rewrite Fx, Fy at 1.\nring."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : IZR mx * bpow (fexp1 (mag x)) * (IZR my * bpow (fexp1 (mag y))) =\nIZR mx * IZR my * (bpow (fexp1 (mag x)) * bpow (fexp1 (mag y))).","proofString":"ring."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) (Hxy : x * y = F2R fxy) : (fexp2 (mag (x * y)) <= fexp1 (mag x) + fexp1 (mag y))%Z.","proofString":"destruct Hfexp as (Hfexp1, Hfexp2).\nnow destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp1 : forall ex ey : Z, (fexp2 (ex + ey) <= fexp1 ex + fexp1 ey)%Z) (Hfexp2 : forall ex ey : Z, (fexp2 (ex + ey - 1) <= fexp1 ex + fexp1 ey)%Z) (x y : R) (Zx : x <> 0) (Zy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) (Hxy : x * y = F2R fxy) : (fexp2 (mag (x * y)) <= fexp1 (mag x) + fexp1 (mag y))%Z.","proofString":"now destruct (mag_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 rnd (round beta fexp2 rnd (x * y)) =\nround beta fexp1 rnd (x * y).","proofString":"assert (Hxy : round beta fexp2 rnd (x * y) = x * y).\napply round_generic; [assumption|].\nnow apply (round_round_mult_aux fexp1 fexp2).\nnow rewrite Hxy at 1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp2 rnd (x * y) = x * y.","proofString":"apply round_generic; [assumption|].\nnow apply (round_round_mult_aux fexp1 fexp2)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x * y).","proofString":"now apply (round_round_mult_aux fexp1 fexp2)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hfexp : round_round_mult_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hxy : round beta fexp2 rnd (x * y) = x * y) : round beta fexp1 rnd (round beta fexp2 rnd (x * y)) =\nround beta fexp1 rnd (x * y).","proofString":"now rewrite Hxy at 1."},{"statement":"(Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round beta (FLX_exp prec) rnd (round beta (FLX_exp prec') rnd (x * y)) =\nround beta (FLX_exp prec) rnd (x * y).","proofString":"apply round_round_mult;  [|now apply generic_format_FLX|now apply generic_format_FLX].\nunfold round_round_mult_hyp; split; intros ex ey; unfold FLX_exp;lia."},{"statement":"(Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_mult_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"unfold round_round_mult_hyp; split; intros ex ey; unfold FLX_exp;lia."},{"statement":"(Hemin : (emin' <= 2 * emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round beta (FLT_exp emin prec) rnd\n  (round beta (FLT_exp emin' prec') rnd (x * y)) =\nround beta (FLT_exp emin prec) rnd (x * y).","proofString":"apply round_round_mult;  [|now apply generic_format_FLT|now apply generic_format_FLT].\nunfold round_round_mult_hyp; split; intros ex ey;unfold FLT_exp;generalize (Zmax_spec (ex + ey - prec') emin');generalize (Zmax_spec (ex + ey - 1 - prec') emin');generalize (Zmax_spec (ex - prec) emin);generalize (Zmax_spec (ey - prec) emin);lia."},{"statement":"(Hemin : (emin' <= 2 * emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_mult_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"unfold round_round_mult_hyp; split; intros ex ey;unfold FLT_exp;generalize (Zmax_spec (ex + ey - prec') emin');generalize (Zmax_spec (ex + ey - 1 - prec') emin');generalize (Zmax_spec (ex - prec) emin);generalize (Zmax_spec (ey - prec) emin);lia."},{"statement":"(Hemin : (emin' + prec' <= 2 * emin + prec)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round beta (FTZ_exp emin prec) rnd\n  (round beta (FTZ_exp emin' prec') rnd (x * y)) =\nround beta (FTZ_exp emin prec) rnd (x * y).","proofString":"apply round_round_mult;  [|now apply generic_format_FTZ|now apply generic_format_FTZ].\nunfold round_round_mult_hyp; split; intros ex ey;unfold FTZ_exp;unfold Prec_gt_0 in *;destruct (Z.ltb_spec (ex + ey - prec') emin');destruct (Z.ltb_spec (ex - prec) emin);destruct (Z.ltb_spec (ey - prec) emin);destruct (Z.ltb_spec (ex + ey - 1 - prec') emin');lia."},{"statement":"(Hemin : (emin' + prec' <= 2 * emin + prec)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_mult_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"unfold round_round_mult_hyp; split; intros ex ey;unfold FTZ_exp;unfold Prec_gt_0 in *;destruct (Z.ltb_spec (ex + ey - prec') emin');destruct (Z.ltb_spec (ex - prec) emin);destruct (Z.ltb_spec (ey - prec) emin);destruct (Z.ltb_spec (ex + ey - 1 - prec') emin');lia."},{"statement":"(fexp : Z -> Z) (x y : R) (Px : 0 < x) (Nny : 0 <= y) (Fx : generic_format beta fexp x) (Hsep : (mag y <= fexp (mag x))%Z) : 0 <= y < ulp beta fexp x.","proofString":"apply (conj Nny).\nrewrite <- Rabs_pos_eq with (1 := Nny).\napply Rlt_le_trans with (1 := bpow_mag_gt beta _).\nrewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (x y : R) (Px : 0 < x) (Nny : 0 <= y) (Fx : generic_format beta fexp x) (Hsep : (mag y <= fexp (mag x))%Z) : y < ulp beta fexp x.","proofString":"rewrite <- Rabs_pos_eq with (1 := Nny).\napply Rlt_le_trans with (1 := bpow_mag_gt beta _).\nrewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (x y : R) (Px : 0 < x) (Nny : 0 <= y) (Fx : generic_format beta fexp x) (Hsep : (mag y <= fexp (mag x))%Z) : Rabs y < ulp beta fexp x.","proofString":"apply Rlt_le_trans with (1 := bpow_mag_gt beta _).\nrewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (x y : R) (Px : 0 < x) (Nny : 0 <= y) (Fx : generic_format beta fexp x) (Hsep : (mag y <= fexp (mag x))%Z) : bpow (mag y) <= ulp beta fexp x.","proofString":"rewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (x y : R) (Px : 0 < x) (Nny : 0 <= y) (Fx : generic_format beta fexp x) (Hsep : (mag y <= fexp (mag x))%Z) : bpow (mag y) <= bpow (cexp beta fexp x).","proofString":"now apply bpow_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : bpow (mag x - 1) <= Rabs (x - y) < bpow (mag x).","proofString":"split.\napply Rabs_ge; right.\nassert (Hy : y < ulp beta fexp (bpow (mag x - 1))).\nrewrite ulp_bpow.\nreplace (_ + _)%Z with (mag x : Z) by ring.\nrewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].\napply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le.\napply (Rplus_le_reg_r y); ring_simplify.\napply Rle_trans with (bpow (mag x - 1)                        + ulp beta fexp (bpow (mag x - 1))).\nnow apply Rplus_le_compat_l; apply Rlt_le.\nrewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].\napply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|].\nrewrite Rabs_right.\napply Rlt_trans with x.\nrewrite <- (Rplus_0_r x) at 2.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_lt_contravar.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : bpow (mag x - 1) <= Rabs (x - y).","proofString":"apply Rabs_ge; right.\nassert (Hy : y < ulp beta fexp (bpow (mag x - 1))).\nrewrite ulp_bpow.\nreplace (_ + _)%Z with (mag x : Z) by ring.\nrewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].\napply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le.\napply (Rplus_le_reg_r y); ring_simplify.\napply Rle_trans with (bpow (mag x - 1)                        + ulp beta fexp (bpow (mag x - 1))).\nnow apply Rplus_le_compat_l; apply Rlt_le.\nrewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].\napply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : bpow (mag x - 1) <= x - y.","proofString":"assert (Hy : y < ulp beta fexp (bpow (mag x - 1))).\nrewrite ulp_bpow.\nreplace (_ + _)%Z with (mag x : Z) by ring.\nrewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].\napply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le.\napply (Rplus_le_reg_r y); ring_simplify.\napply Rle_trans with (bpow (mag x - 1)                        + ulp beta fexp (bpow (mag x - 1))).\nnow apply Rplus_le_compat_l; apply Rlt_le.\nrewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].\napply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : y < ulp beta fexp (bpow (mag x - 1)).","proofString":"rewrite ulp_bpow.\nreplace (_ + _)%Z with (mag x : Z) by ring.\nrewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].\napply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : y < bpow (fexp (mag x - 1 + 1)%Z).","proofString":"replace (_ + _)%Z with (mag x : Z) by ring.\nrewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].\napply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : y < bpow (fexp (mag x)).","proofString":"rewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].\napply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : Rabs y < bpow (fexp (mag x)).","proofString":"apply Rlt_le_trans with (bpow (mag y)).\napply bpow_mag_gt.\nnow apply bpow_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : Rabs y < bpow (mag y).","proofString":"apply bpow_mag_gt."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : bpow (mag y) <= bpow (fexp (mag x)).","proofString":"now apply bpow_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : bpow (mag x - 1) <= x - y.","proofString":"apply (Rplus_le_reg_r y); ring_simplify.\napply Rle_trans with (bpow (mag x - 1)                        + ulp beta fexp (bpow (mag x - 1))).\nnow apply Rplus_le_compat_l; apply Rlt_le.\nrewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].\napply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : bpow (mag x - 1) + y <= x.","proofString":"apply Rle_trans with (bpow (mag x - 1)                        + ulp beta fexp (bpow (mag x - 1))).\nnow apply Rplus_le_compat_l; apply Rlt_le.\nrewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].\napply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : bpow (mag x - 1) + y <= bpow (mag x - 1) + ulp beta fexp (bpow (mag x - 1)).","proofString":"now apply Rplus_le_compat_l; apply Rlt_le."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : bpow (mag x - 1) + ulp beta fexp (bpow (mag x - 1)) <= x.","proofString":"rewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].\napply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : succ beta fexp (bpow (mag x - 1)) <= x.","proofString":"apply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].\napply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : generic_format beta fexp (bpow (mag x - 1)).","proofString":"apply (generic_format_bpow beta fexp (mag x - 1)).\nreplace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : (fexp (mag x - 1 + 1) <= mag x - 1)%Z.","proofString":"replace (_ + _)%Z with (mag x : Z) by ring.\ncut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : (fexp (mag x) <= mag x - 1)%Z.","proofString":"cut (fexp (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : (fexp (mag x) < mag x)%Z -> (fexp (mag x) <= mag x - 1)%Z.","proofString":"lia."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) (Hy : y < ulp beta fexp (bpow (mag x - 1))) : (fexp (mag x) < mag x)%Z.","proofString":"now apply mag_generic_gt; [|now apply Rgt_not_eq|]."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : Rabs (x - y) < bpow (mag x).","proofString":"rewrite Rabs_right.\napply Rlt_trans with x.\nrewrite <- (Rplus_0_r x) at 2.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_lt_contravar.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : x - y < bpow (mag x).","proofString":"apply Rlt_trans with x.\nrewrite <- (Rplus_0_r x) at 2.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_lt_contravar.\napply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : x - y < x.","proofString":"rewrite <- (Rplus_0_r x) at 2.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_lt_contravar."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : x - y < x + 0.","proofString":"apply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\nnow apply Ropp_lt_contravar."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : - y < 0.","proofString":"rewrite <- Ropp_0.\nnow apply Ropp_lt_contravar."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : - y < - 0.","proofString":"now apply Ropp_lt_contravar."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : x < bpow (mag x).","proofString":"apply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : Rabs x < bpow (mag x).","proofString":"apply bpow_mag_gt."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Px : 0 < x) (Py : 0 < y) (Yltx : y < x) (Xgtpow : bpow (mag x - 1) < x) (Fx : generic_format beta fexp x) (Ly : (mag y <= fexp (mag x))%Z) : x - y >= 0.","proofString":"lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x + y).","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx, Rplus_0_l in Hlny |- *.\nnow apply (generic_inclusion_mag beta fexp1).\ndestruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy, Rplus_0_r in Hlnx |- *.\nnow apply (generic_inclusion_mag beta fexp1).\nrevert Fx Fy.\nunfold generic_format at -3, cexp, F2R; simpl.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nintros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 (x + y).","proofString":"rewrite Zx, Rplus_0_l in Hlny |- *.\nnow apply (generic_inclusion_mag beta fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag y) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 y.","proofString":"now apply (generic_inclusion_mag beta fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) : generic_format beta fexp2 (x + y).","proofString":"destruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy, Rplus_0_r in Hlnx |- *.\nnow apply (generic_inclusion_mag beta fexp1).\nrevert Fx Fy.\nunfold generic_format at -3, cexp, F2R; simpl.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nintros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 (x + y).","proofString":"rewrite Zy, Rplus_0_r in Hlnx |- *.\nnow apply (generic_inclusion_mag beta fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 x.","proofString":"now apply (generic_inclusion_mag beta fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) : generic_format beta fexp2 (x + y).","proofString":"revert Fx Fy.\nunfold generic_format at -3, cexp, F2R; simpl.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nintros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) : generic_format beta fexp1 x ->\ngeneric_format beta fexp1 y -> generic_format beta fexp2 (x + y).","proofString":"unfold generic_format at -3, cexp, F2R; simpl.\nset (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nintros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) : x = IZR (Ztrunc (scaled_mantissa beta fexp1 x)) * bpow (fexp1 (mag x)) ->\ny = IZR (Ztrunc (scaled_mantissa beta fexp1 y)) * bpow (fexp1 (mag y)) ->\ngeneric_format beta fexp2 (x + y).","proofString":"set (mx := Ztrunc (scaled_mantissa beta fexp1 x)).\nset (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nintros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) : x = IZR mx * bpow (fexp1 (mag x)) ->\ny = IZR (Ztrunc (scaled_mantissa beta fexp1 y)) * bpow (fexp1 (mag y)) ->\ngeneric_format beta fexp2 (x + y).","proofString":"set (my := Ztrunc (scaled_mantissa beta fexp1 y)).\nintros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) : x = IZR mx * bpow (fexp1 (mag x)) ->\ny = IZR my * bpow (fexp1 (mag y)) -> generic_format beta fexp2 (x + y).","proofString":"intros Fx Fy.\nset (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) : generic_format beta fexp2 (x + y).","proofString":"set (fxy := Float beta (mx + my * (beta ^ (fexp1 (mag y)                                               - fexp1 (mag x))))                      (fexp1 (mag x))).\nassert (Hxy : x + y = F2R fxy).\nunfold fxy, F2R; simpl.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy.\napply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].\nintros _.\nnow unfold cexp, fxy; simpl."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y =\nIZR (mx + my * beta ^ (fexp1 (mag y) - fexp1 (mag x))) * bpow (fexp1 (mag x)).","proofString":"rewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y =\n(IZR mx + IZR (my * beta ^ (fexp1 (mag y) - fexp1 (mag x)))) *\nbpow (fexp1 (mag x)).","proofString":"rewrite Rmult_plus_distr_r.\nrewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y =\nIZR mx * bpow (fexp1 (mag x)) +\nIZR (my * beta ^ (fexp1 (mag y) - fexp1 (mag x))) * bpow (fexp1 (mag x)).","proofString":"rewrite <- Fx.\nrewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y =\nx + IZR (my * beta ^ (fexp1 (mag y) - fexp1 (mag x))) * bpow (fexp1 (mag x)).","proofString":"rewrite mult_IZR.\nrewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y =\nx +\nIZR my * IZR (beta ^ (fexp1 (mag y) - fexp1 (mag x))) * bpow (fexp1 (mag x)).","proofString":"rewrite IZR_Zpower by lia.\nbpow_simplify.\nnow rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y =\nx + IZR my * bpow (fexp1 (mag y) - fexp1 (mag x)) * bpow (fexp1 (mag x)).","proofString":"bpow_simplify.\nnow rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Oxy : (fexp1 (mag x) <= fexp1 (mag y))%Z) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Nzx : x <> 0) (Nzy : y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (fxy : float beta) : x + y = x + IZR my * bpow (fexp1 (mag y)).","proofString":"now rewrite <- Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x + y).","proofString":"destruct (Z.le_gt_cases (fexp1 (mag x)) (fexp1 (mag y))) as [Hle|Hgt].\nnow apply (round_round_plus_aux0_aux_aux fexp1).\nrewrite Rplus_comm in Hlnx, Hlny |- *.\nnow apply (round_round_plus_aux0_aux_aux fexp1); [lia| | | |]."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hle : (fexp1 (mag x) <= fexp1 (mag y))%Z) : generic_format beta fexp2 (x + y).","proofString":"now apply (round_round_plus_aux0_aux_aux fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (x + y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hgt : (fexp1 (mag y) < fexp1 (mag x))%Z) : generic_format beta fexp2 (x + y).","proofString":"rewrite Rplus_comm in Hlnx, Hlny |- *.\nnow apply (round_round_plus_aux0_aux_aux fexp1); [lia| | | |]."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (y + x)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (y + x)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hgt : (fexp1 (mag y) < fexp1 (mag x))%Z) : generic_format beta fexp2 (y + x).","proofString":"now apply (round_round_plus_aux0_aux_aux fexp1); [lia| | | |]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x + y).","proofString":"assert (Nny : (0 <= y)%R); [now apply Rlt_le|].\ndestruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).\ndestruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nny : 0 <= y) : generic_format beta fexp2 (x + y).","proofString":"destruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).\ndestruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nny : 0 <= y) : generic_format beta fexp2 (x + y).","proofString":"destruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nny : 0 <= y) (Hle : (mag y <= fexp1 (mag x))%Z) : generic_format beta fexp2 (x + y).","proofString":"assert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nny : 0 <= y) (Hgt : (fexp1 (mag x) < mag y)%Z) : generic_format beta fexp2 (x + y).","proofString":"apply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(2 <= beta)%Z.","proofString":"destruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","proofString":"now apply Zle_bool_imp_le."},{"statement":"(2 <= beta)%Z.","proofString":"destruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","proofString":"now apply Zle_bool_imp_le."},{"statement":"(Hbeta : (2 <= beta)%Z) : forall fexp1 fexp2 : Z -> Z,\nValid_exp fexp1 ->\nValid_exp fexp2 ->\nforall choice1 choice2 : Z -> bool,\nround_round_plus_hyp fexp1 fexp2 ->\nforall x y : R,\n0 < x ->\n0 < y ->\n(mag y <= fexp1 (mag x) - 2)%Z ->\ngeneric_format beta fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Hly Fx.\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1); [|apply Rlt_le| |lia]|].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (P2 : (0 < 2)%Z) by lia.\nunfold round_round_eq.\napply round_round_lt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\nnow rewrite Lxy.\nrewrite Lxy.\ncut (fexp1 (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nunfold midp.\napply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).\napply (Rlt_le_trans _ _ _ (proj2 (round_round_plus_aux1_aux 2 P2 fexp1 x y Px                                                               Py Hly Lxy Fx))).\nring_simplify.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold cexp; rewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\napply (Rle_trans _ _ _ Bpow2).\nrewrite <- (Rmult_1_r (/ 2)) at 3.\napply Rmult_le_compat_l; lra.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold round, F2R, scaled_mantissa, cexp; simpl; rewrite Lxy.\nintro Hf2'.\napply (Rmult_lt_reg_r (bpow (- fexp1 (mag x))));    [now apply bpow_gt_0|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\napply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).\nunfold midp; ring_simplify.\napply (Rlt_le_trans _ _ _ (proj2 (round_round_plus_aux1_aux 2 P2 fexp1 x y Px                                                               Py Hly Lxy Fx))).\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold cexp; rewrite Lxy, Rmult_minus_distr_r; bpow_simplify.\napply (Rle_trans _ _ _ Bpow2).\nrewrite <- (Rmult_1_r (/ 2)) at 3; rewrite <- Rmult_minus_distr_l.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- (/ 2)) by lra.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\napply Rinv_le; [lra|].\napply IZR_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Fx : generic_format beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"assert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1); [|apply Rlt_le| |lia]|].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (P2 : (0 < 2)%Z) by lia.\nunfold round_round_eq.\napply round_round_lt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\nnow rewrite Lxy.\nrewrite Lxy.\ncut (fexp1 (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nunfold midp.\napply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).\napply (Rlt_le_trans _ _ _ (proj2 (round_round_plus_aux1_aux 2 P2 fexp1 x y Px                                                               Py Hly Lxy Fx))).\nring_simplify.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold cexp; rewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\napply (Rle_trans _ _ _ Bpow2).\nrewrite <- (Rmult_1_r (/ 2)) at 3.\napply Rmult_le_compat_l; lra.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold round, F2R, scaled_mantissa, cexp; simpl; rewrite Lxy.\nintro Hf2'.\napply (Rmult_lt_reg_r (bpow (- fexp1 (mag x))));    [now apply bpow_gt_0|].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nbpow_simplify.\napply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).\nunfold midp; ring_simplify.\napply (Rlt_le_trans _ _ _ (proj2 (round_round_plus_aux1_aux 2 P2 fexp1 x y Px                                                               Py Hly Lxy Fx))).\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold cexp; rewrite Lxy, Rmult_minus_distr_r; bpow_simplify.\napply (Rle_trans _ _ _ Bpow2).\nrewrite <- (Rmult_1_r (/ 2)) at 3; rewrite <- Rmult_minus_distr_l.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- (/ 2)) by lra.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\napply Rinv_le; [lra|].\napply IZR_le; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"unfold round_round_eq.\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\nnow apply round_round_plus_aux1.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_plus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\nnow apply round_round_plus_aux1.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_plus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"now apply round_round_plus_aux1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_plus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : round beta fexp1 (Znearest choice1) (x + y) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : generic_format beta fexp2 (x + y).","proofString":"assert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_plus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) : generic_format beta fexp2 (x + y).","proofString":"now apply (round_round_plus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"unfold round_round_eq.\ndestruct (Req_dec x 0) as [Zx|Nzx].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) y) =\nround beta fexp1 (Znearest choice1) y.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1) y = round beta fexp1 (Znearest choice1) y.","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 y.","proofString":"apply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : y <> 0 -> (fexp2 (mag y) <= fexp1 (mag y))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp1 y.","proofString":"exact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Req_dec y 0) as [Zy|Nzy].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) x = round beta fexp1 (Znearest choice1) x.","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 x.","proofString":"apply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : x <> 0 -> (fexp2 (mag x) <= fexp1 (mag x))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp1 x.","proofString":"exact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"assert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"assert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"apply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite Rplus_comm.\nnow apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y + x)) =\nround beta fexp1 (Znearest choice1) (y + x).","proofString":"now apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : y <= x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"now apply round_round_plus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) : (fexp2 (mag (x - y)) <= fexp1 (mag x))%Z ->\n(fexp2 (mag (x - y)) <= fexp1 (mag y))%Z ->\ngeneric_format beta fexp1 x ->\ngeneric_format beta fexp1 y -> generic_format beta fexp2 (x - y).","proofString":"replace (x - y)%R with (x + (- y))%R; [|ring].\nintros Hlnx Hlny Fx Fy.\nrewrite <- (mag_opp beta y) in Hlny.\napply generic_format_opp in Fy.\nnow apply (round_round_plus_aux0_aux fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) : (fexp2 (mag (x + - y)) <= fexp1 (mag x))%Z ->\n(fexp2 (mag (x + - y)) <= fexp1 (mag y))%Z ->\ngeneric_format beta fexp1 x ->\ngeneric_format beta fexp1 y -> generic_format beta fexp2 (x + - y).","proofString":"intros Hlnx Hlny Fx Fy.\nrewrite <- (mag_opp beta y) in Hlny.\napply generic_format_opp in Fy.\nnow apply (round_round_plus_aux0_aux fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (x + - y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + - y)) <= fexp1 (mag y))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x + - y).","proofString":"rewrite <- (mag_opp beta y) in Hlny.\napply generic_format_opp in Fy.\nnow apply (round_round_plus_aux0_aux fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (x + - y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + - y)) <= fexp1 (mag (- y)))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x + - y).","proofString":"apply generic_format_opp in Fy.\nnow apply (round_round_plus_aux0_aux fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (x y : R) (Hlnx : (fexp2 (mag (x + - y)) <= fexp1 (mag x))%Z) (Hlny : (fexp2 (mag (x + - y)) <= fexp1 (mag (- y)))%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 (- y)) : generic_format beta fexp2 (x + - y).","proofString":"now apply (round_round_plus_aux0_aux fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x - y).","proofString":"assert (Px := Rlt_trans 0 y x Py Hyx).\ndestruct Hexp as (Hexp1,(_,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\ndestruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"destruct Hexp as (Hexp1,(_,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\ndestruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"assert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\ndestruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) : generic_format beta fexp2 (x - y).","proofString":"destruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hlt : (mag x - 2 < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hge : (mag y <= mag x - 2)%Z) : generic_format beta fexp2 (x - y).","proofString":"destruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x - y).","proofString":"assert (Px := Rlt_trans 0 y x Py Hyx).\ndestruct Hexp as (Hexp1,(Hexp2,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"destruct Hexp as (Hexp1,(Hexp2,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"assert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"apply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 2)%Z) (Hln' : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)))%Z.","proofString":"apply Hexp4; lia."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fx : generic_format beta fexp x) (Fy : generic_format beta fexp y) : round beta fexp Zceil (x - y) - (x - y) <= y.","proofString":"assert (Px := Rlt_trans 0 y x Py Hxy).\nrevert Fx.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp (mag x)))).\nintro Fx.\nassert (Hfx : (fexp (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\ndestruct (Rlt_or_le (bpow (mag x - 1)) x) as [Hx|Hx].\nassert (Lxy : mag (x - y) = mag x :> Z);    [now apply (mag_minus_separated fexp); [| | | | | |lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) = x).\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply eq_sym; rewrite Fx at 1; apply eq_sym.\napply Rmult_eq_compat_r.\napply f_equal.\nrewrite Fx at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Zceil_imp.\nsplit.\nunfold Zminus; rewrite plus_IZR.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar; simpl.\napply (Rmult_lt_reg_r (bpow (fexp (mag x))));        [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (mag y)).\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply bpow_le.\nlia.\nrewrite <- (Rplus_0_r (IZR _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nrewrite Rxy; ring_simplify.\napply Rle_refl.\nassert (Xpow : x = bpow (mag x - 1)).\napply Rle_antisym; [exact Hx|].\ndestruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nassert (Lxy : (mag (x - y) = mag x - 1 :> Z)%Z).\napply Zle_antisym.\napply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra.\napply (mag_minus_lb beta x y Px Py).\nlia.\nassert (Hfx1 : (fexp (mag x - 1) < mag x - 1)%Z);    [now apply (valid_exp_large fexp (mag y)); [|lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) <= x).\nrewrite Xpow at 2.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp (mag x - 1)%Z)));      [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower beta (_ - _ - _)) by lia.\napply IZR_le.\napply Zceil_glb.\nrewrite IZR_Zpower by lia.\nrewrite Xpow at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite <- (Rplus_0_r (bpow _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fx : generic_format beta fexp x) (Fy : generic_format beta fexp y) (Px : 0 < x) : round beta fexp Zceil (x - y) - (x - y) <= y.","proofString":"revert Fx.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp (mag x)))).\nintro Fx.\nassert (Hfx : (fexp (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\ndestruct (Rlt_or_le (bpow (mag x - 1)) x) as [Hx|Hx].\nassert (Lxy : mag (x - y) = mag x :> Z);    [now apply (mag_minus_separated fexp); [| | | | | |lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) = x).\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply eq_sym; rewrite Fx at 1; apply eq_sym.\napply Rmult_eq_compat_r.\napply f_equal.\nrewrite Fx at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Zceil_imp.\nsplit.\nunfold Zminus; rewrite plus_IZR.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar; simpl.\napply (Rmult_lt_reg_r (bpow (fexp (mag x))));        [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (mag y)).\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply bpow_le.\nlia.\nrewrite <- (Rplus_0_r (IZR _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nrewrite Rxy; ring_simplify.\napply Rle_refl.\nassert (Xpow : x = bpow (mag x - 1)).\napply Rle_antisym; [exact Hx|].\ndestruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nassert (Lxy : (mag (x - y) = mag x - 1 :> Z)%Z).\napply Zle_antisym.\napply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra.\napply (mag_minus_lb beta x y Px Py).\nlia.\nassert (Hfx1 : (fexp (mag x - 1) < mag x - 1)%Z);    [now apply (valid_exp_large fexp (mag y)); [|lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) <= x).\nrewrite Xpow at 2.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp (mag x - 1)%Z)));      [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower beta (_ - _ - _)) by lia.\napply IZR_le.\napply Zceil_glb.\nrewrite IZR_Zpower by lia.\nrewrite Xpow at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite <- (Rplus_0_r (bpow _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) : generic_format beta fexp x -> round beta fexp Zceil (x - y) - (x - y) <= y.","proofString":"unfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp (mag x)))).\nintro Fx.\nassert (Hfx : (fexp (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\ndestruct (Rlt_or_le (bpow (mag x - 1)) x) as [Hx|Hx].\nassert (Lxy : mag (x - y) = mag x :> Z);    [now apply (mag_minus_separated fexp); [| | | | | |lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) = x).\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply eq_sym; rewrite Fx at 1; apply eq_sym.\napply Rmult_eq_compat_r.\napply f_equal.\nrewrite Fx at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Zceil_imp.\nsplit.\nunfold Zminus; rewrite plus_IZR.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar; simpl.\napply (Rmult_lt_reg_r (bpow (fexp (mag x))));        [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (mag y)).\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply bpow_le.\nlia.\nrewrite <- (Rplus_0_r (IZR _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nrewrite Rxy; ring_simplify.\napply Rle_refl.\nassert (Xpow : x = bpow (mag x - 1)).\napply Rle_antisym; [exact Hx|].\ndestruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nassert (Lxy : (mag (x - y) = mag x - 1 :> Z)%Z).\napply Zle_antisym.\napply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra.\napply (mag_minus_lb beta x y Px Py).\nlia.\nassert (Hfx1 : (fexp (mag x - 1) < mag x - 1)%Z);    [now apply (valid_exp_large fexp (mag y)); [|lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) <= x).\nrewrite Xpow at 2.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp (mag x - 1)%Z)));      [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower beta (_ - _ - _)) by lia.\napply IZR_le.\napply Zceil_glb.\nrewrite IZR_Zpower by lia.\nrewrite Xpow at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite <- (Rplus_0_r (bpow _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) : x = IZR (Ztrunc (x * bpow (- fexp (mag x)))) * bpow (fexp (mag x)) ->\nround beta fexp Zceil (x - y) - (x - y) <= y.","proofString":"set (mx := Ztrunc (x * bpow (- fexp (mag x)))).\nintro Fx.\nassert (Hfx : (fexp (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\ndestruct (Rlt_or_le (bpow (mag x - 1)) x) as [Hx|Hx].\nassert (Lxy : mag (x - y) = mag x :> Z);    [now apply (mag_minus_separated fexp); [| | | | | |lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) = x).\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply eq_sym; rewrite Fx at 1; apply eq_sym.\napply Rmult_eq_compat_r.\napply f_equal.\nrewrite Fx at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Zceil_imp.\nsplit.\nunfold Zminus; rewrite plus_IZR.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar; simpl.\napply (Rmult_lt_reg_r (bpow (fexp (mag x))));        [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (mag y)).\nrewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].\napply bpow_mag_gt.\napply bpow_le.\nlia.\nrewrite <- (Rplus_0_r (IZR _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nrewrite Rxy; ring_simplify.\napply Rle_refl.\nassert (Xpow : x = bpow (mag x - 1)).\napply Rle_antisym; [exact Hx|].\ndestruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nassert (Lxy : (mag (x - y) = mag x - 1 :> Z)%Z).\napply Zle_antisym.\napply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra.\napply (mag_minus_lb beta x y Px Py).\nlia.\nassert (Hfx1 : (fexp (mag x - 1) < mag x - 1)%Z);    [now apply (valid_exp_large fexp (mag y)); [|lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) <= x).\nrewrite Xpow at 2.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp (mag x - 1)%Z)));      [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower beta (_ - _ - _)) by lia.\napply IZR_le.\napply Zceil_glb.\nrewrite IZR_Zpower by lia.\nrewrite Xpow at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite <- (Rplus_0_r (bpow _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) : round beta fexp Zceil (x - y) - (x - y) <= y.","proofString":"assert (Xpow : x = bpow (mag x - 1)).\napply Rle_antisym; [exact Hx|].\ndestruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nassert (Lxy : (mag (x - y) = mag x - 1 :> Z)%Z).\napply Zle_antisym.\napply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra.\napply (mag_minus_lb beta x y Px Py).\nlia.\nassert (Hfx1 : (fexp (mag x - 1) < mag x - 1)%Z);    [now apply (valid_exp_large fexp (mag y)); [|lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) <= x).\nrewrite Xpow at 2.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp (mag x - 1)%Z)));      [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower beta (_ - _ - _)) by lia.\napply IZR_le.\napply Zceil_glb.\nrewrite IZR_Zpower by lia.\nrewrite Xpow at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite <- (Rplus_0_r (bpow _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) : x = bpow (mag x - 1).","proofString":"apply Rle_antisym; [exact Hx|].\ndestruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) : bpow (mag x - 1) <= x.","proofString":"destruct (mag x) as (ex, Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hly : (mag y <= fexp (Build_mag_prop beta x ex Hex) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (Build_mag_prop beta x ex Hex))) (Hfx : (fexp (Build_mag_prop beta x ex Hex) < Build_mag_prop beta x ex Hex)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (Build_mag_prop beta x ex Hex - 1)) : bpow (ex - 1) <= x.","proofString":"rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hly : (mag y <= fexp (Build_mag_prop beta x ex Hex) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (Build_mag_prop beta x ex Hex))) (Hfx : (fexp (Build_mag_prop beta x ex Hex) < Build_mag_prop beta x ex Hex)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (Build_mag_prop beta x ex Hex - 1)) : bpow (ex - 1) <= Rabs x.","proofString":"apply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hly : (mag y <= fexp (Build_mag_prop beta x ex Hex) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (Build_mag_prop beta x ex Hex))) (Hfx : (fexp (Build_mag_prop beta x ex Hex) < Build_mag_prop beta x ex Hex)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (Build_mag_prop beta x ex Hex - 1)) : x <> 0.","proofString":"now apply Rgt_not_eq."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) (Xpow : x = bpow (mag x - 1)) : round beta fexp Zceil (x - y) - (x - y) <= y.","proofString":"assert (Lxy : (mag (x - y) = mag x - 1 :> Z)%Z).\napply Zle_antisym.\napply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra.\napply (mag_minus_lb beta x y Px Py).\nlia.\nassert (Hfx1 : (fexp (mag x - 1) < mag x - 1)%Z);    [now apply (valid_exp_large fexp (mag y)); [|lia]|].\nassert (Rxy : round beta fexp Zceil (x - y) <= x).\nrewrite Xpow at 2.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp (mag x - 1)%Z)));      [now apply bpow_gt_0|].\nbpow_simplify.\nrewrite <- (IZR_Zpower beta (_ - _ - _)) by lia.\napply IZR_le.\napply Zceil_glb.\nrewrite IZR_Zpower by lia.\nrewrite Xpow at 1.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\nrewrite <- (Rplus_0_r (bpow _)) at 2.\napply Rplus_le_compat_l.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nrewrite <- (Rmult_0_r y).\napply Rmult_le_compat_l; [now apply Rlt_le|].\nnow apply bpow_ge_0.\nlra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) (Xpow : x = bpow (mag x - 1)) : (mag (x - y) <= mag x - 1)%Z.","proofString":"apply mag_le_bpow.\napply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).\nrewrite Rabs_right; lra."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) (Xpow : x = bpow (mag x - 1)) : x - y <> 0.","proofString":"apply Rminus_eq_contra.\nnow intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y)."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) (Xpow : x = bpow (mag x - 1)) : x <> y.","proofString":"now intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y)."},{"statement":"(fexp : Z -> Z) (Vfexp : Valid_exp fexp) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp (mag x) - 1)%Z) (Fy : generic_format beta fexp y) (Px : 0 < x) (mx : Z) (Fx : x = IZR mx * bpow (fexp (mag x))) (Hfx : (fexp (mag x) < mag x)%Z) (Hfy : (fexp (mag y) < mag y)%Z) (Hx : x <= bpow (mag x - 1)) (Xpow : x = bpow (mag x - 1)) : Rabs (x - y) < bpow (mag x - 1).","proofString":"rewrite Rabs_right; lra."},{"statement":"(2 <= beta)%Z.","proofString":"destruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","proofString":"now apply Zle_bool_imp_le."},{"statement":"(Hbeta : (2 <= beta)%Z) : forall fexp1 fexp2 : Z -> Z,\nValid_exp fexp1 ->\nValid_exp fexp2 ->\nforall choice1 choice2 : Z -> bool,\nround_round_plus_hyp fexp1 fexp2 ->\nforall x y : R,\n0 < y ->\ny < x ->\n(mag y <= fexp1 (mag x) - 2)%Z ->\n(mag y <= fexp1 (mag (x - y)) - 2)%Z ->\ngeneric_format beta fexp1 x ->\ngeneric_format beta fexp1 y ->\nround_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Py Hxy Hly Hly' Fx Fy.\nassert (Px := Rlt_trans 0 y x Py Hxy).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Px := Rlt_trans 0 y x Py Hxy).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Bpow2 : bpow (- 2) <= / 2 * / 2).\nreplace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : bpow (-2) <= / 2 * / 2.","proofString":"replace (/2 * /2) with (/4) by field.\nrewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : bpow (-2) <= / 4.","proofString":"rewrite (bpow_opp _ 2).\napply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : / bpow 2 <= / 4.","proofString":"apply Rinv_le; [lra|].\napply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : 4 <= bpow 2.","proofString":"apply (IZR_le (2 * 2) (beta * (beta * 1))).\nrewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : (2 * 2 <= beta * (beta * 1))%Z.","proofString":"rewrite Zmult_1_r.\nnow apply Zmult_le_compat; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : (2 * 2 <= beta * beta)%Z.","proofString":"now apply Zmult_le_compat; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) : y < bpow (mag y).","proofString":"apply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) : Rabs y < bpow (mag y).","proofString":"apply bpow_mag_gt."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"apply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : 0 < x - y.","proofString":"lra."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)))%Z.","proofString":"apply Hexp4; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : (fexp1 (mag (x - y)) < mag (x - y))%Z ->\n(fexp1 (mag (x - y)) <= mag (x - y))%Z.","proofString":"lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) < x - y.","proofString":"apply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) +\n(/ 2 * ulp beta fexp1 (x - y) - (x - y)) <\nx - y + (/ 2 * ulp beta fexp1 (x - y) - (x - y)).","proofString":"ring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - x + y < / 2 * ulp beta fexp1 (x - y).","proofString":"replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - (x - y) < / 2 * ulp beta fexp1 (x - y).","proofString":"apply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 2)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - (x - y) < bpow (fexp1 (mag (x - y)) - 2).","proofString":"apply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : y < bpow (fexp1 (mag (x - y)) - 2).","proofString":"apply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (mag y) <= bpow (fexp1 (mag (x - y)) - 2).","proofString":"now apply bpow_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 2) <= / 2 * ulp beta fexp1 (x - y).","proofString":"rewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].\nunfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 2) <= / 2 * bpow (cexp beta fexp1 (x - y)).","proofString":"unfold cexp.\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 2) <= / 2 * bpow (fexp1 (mag (x - y))).","proofString":"replace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 1 - 1) <= / 2 * bpow (fexp1 (mag (x - y))).","proofString":"unfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 1) * bpow (- (1)) <=\n/ 2 * bpow (fexp1 (mag (x - y))).","proofString":"rewrite Rmult_comm.\napply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (- (1)) * bpow (fexp1 (mag (x - y)) - 1) <=\n/ 2 * bpow (fexp1 (mag (x - y))).","proofString":"apply Rmult_le_compat.\nnow apply bpow_ge_0.\nnow apply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le.\napply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : 0 <= bpow (- (1)).","proofString":"now apply bpow_ge_0."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : 0 <= bpow (fexp1 (mag (x - y)) - 1).","proofString":"now apply bpow_ge_0."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (- (1)) <= / 2.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : / IZR (beta * 1) <= / 2.","proofString":"rewrite Zmult_1_r; apply Rinv_le.\nlra.\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : 0 < 2.","proofString":"lra."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : 2 <= IZR beta.","proofString":"now apply IZR_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 1) <= bpow (fexp1 (mag (x - y))).","proofString":"apply bpow_le; lia."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : midp' fexp1 (x - y) + / 2 * ulp beta fexp2 (x - y) < x - y.","proofString":"unfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) +\n/ 2 * ulp beta fexp2 (x - y) < x - y.","proofString":"apply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)                         - / 2 * ulp beta fexp2 (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) +\n/ 2 * ulp beta fexp2 (x - y) +\n(/ 2 * ulp beta fexp1 (x - y) - (x - y) - / 2 * ulp beta fexp2 (x - y)) <\nx - y +\n(/ 2 * ulp beta fexp1 (x - y) - (x - y) - / 2 * ulp beta fexp2 (x - y)).","proofString":"ring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - x + y <\n/ 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - (x - y) <\n/ 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"apply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux; try assumption; lia|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : y < / 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"apply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (mag y) <= / 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"apply Rle_trans with (bpow (fexp1 (mag (x - y)) - 2));    [now apply bpow_le|].\nreplace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 2) <=\n/ 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"replace (_ - 2)%Z with (fexp1 (mag (x - y)) - 1 - 1)%Z by ring.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1 - 1) <=\n/ 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"unfold Zminus at 1; rewrite bpow_plus.\nrewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) * bpow (- (1)) <=\n/ 2 * ulp beta fexp1 (x - y) - / 2 * ulp beta fexp2 (x - y).","proofString":"rewrite <- Rmult_minus_distr_l.\nrewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) * bpow (- (1)) <=\n/ 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)).","proofString":"rewrite Rmult_comm; apply Rmult_le_compat.\napply bpow_ge_0.\napply bpow_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 0 <= bpow (- (1)).","proofString":"apply bpow_ge_0."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 0 <= bpow (fexp1 (mag (x - y)) - 1).","proofString":"apply bpow_ge_0."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (- (1)) <= / 2.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR (beta * 1) <= / 2.","proofString":"rewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 2 <= IZR beta.","proofString":"now apply IZR_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) <=\nulp beta fexp1 (x - y) - ulp beta fexp2 (x - y).","proofString":"rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) <=\nbpow (cexp beta fexp1 (x - y)) - bpow (cexp beta fexp2 (x - y)).","proofString":"unfold cexp.\napply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) <=\nbpow (fexp1 (mag (x - y))) - bpow (fexp2 (mag (x - y))).","proofString":"apply (Rplus_le_reg_r (bpow (fexp2 (mag (x - y))))); ring_simplify.\napply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) + bpow (fexp2 (mag (x - y))) <=\nbpow (fexp1 (mag (x - y))).","proofString":"apply Rle_trans with (2 * bpow (fexp1 (mag (x - y)) - 1)).\nrewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) + bpow (fexp2 (mag (x - y))) <=\n2 * bpow (fexp1 (mag (x - y)) - 1).","proofString":"rewrite double.\napply Rplus_le_compat_l.\nnow apply bpow_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) + bpow (fexp2 (mag (x - y))) <=\nbpow (fexp1 (mag (x - y)) - 1) + bpow (fexp1 (mag (x - y)) - 1).","proofString":"apply Rplus_le_compat_l.\nnow apply bpow_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp2 (mag (x - y))) <= bpow (fexp1 (mag (x - y)) - 1).","proofString":"now apply bpow_le."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 2 * bpow (fexp1 (mag (x - y)) - 1) <= bpow (fexp1 (mag (x - y))).","proofString":"unfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 2 * (bpow (fexp1 (mag (x - y))) * bpow (- (1))) <= bpow (fexp1 (mag (x - y))).","proofString":"rewrite Rmult_comm; rewrite Rmult_assoc.\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y))) * (bpow (- (1)) * 2) <= bpow (fexp1 (mag (x - y))).","proofString":"rewrite <- Rmult_1_r.\napply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y))) * (bpow (- (1)) * 2) <=\nbpow (fexp1 (mag (x - y))) * 1.","proofString":"apply Rmult_le_compat_l; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (- (1)) * 2 <= 1.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR (beta * 1) * 2 <= 1.","proofString":"rewrite Zmult_1_r.\napply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : (2 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR beta * 2 <= 1.","proofString":"apply IZR_le, Rinv_le in Hbeta.\nsimpl in Hbeta.\nlra.\napply Rlt_0_2."},{"statement":"(Hbeta : / IZR beta <= / 2) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR beta * 2 <= 1.","proofString":"simpl in Hbeta.\nlra."},{"statement":"(Hbeta : / IZR beta <= / 2) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR beta * 2 <= 1.","proofString":"lra."},{"statement":"(Hbeta : 2 <= IZR beta) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow2 : bpow (-2) <= / 2 * / 2) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 0 < 2.","proofString":"apply Rlt_0_2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Px := Rlt_le_trans 0 y x Py Hyx).\nunfold round_round_eq.\ndestruct (Req_dec y x) as [Hy|Hy].\nrewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 2))      as [Hly'|Hly'].\nnow apply round_round_minus_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold round_round_eq.\ndestruct (Req_dec y x) as [Hy|Hy].\nrewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 2))      as [Hly'|Hly'].\nnow apply round_round_minus_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Req_dec y x) as [Hy|Hy].\nrewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 2))      as [Hly'|Hly'].\nnow apply round_round_minus_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) 0) =\nround beta fexp1 (Znearest choice1) 0.","proofString":"rewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : round beta fexp1 (Znearest choice1) 0 = round beta fexp1 (Znearest choice1) 0.","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"assert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 2))      as [Hly'|Hly'].\nnow apply round_round_minus_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Zle_or_lt (mag y) (fexp1 (mag x) - 2)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 2))      as [Hly'|Hly'].\nnow apply round_round_minus_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 2))      as [Hly'|Hly'].\nnow apply round_round_minus_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 2)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"now apply round_round_minus_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (fexp1 (mag (x - y)) - 2 < mag y)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (fexp1 (mag (x - y)) - 2 < mag y)%Z) : round beta fexp1 (Znearest choice1) (x - y) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (fexp1 (mag (x - y)) - 2 < mag y)%Z) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (fexp1 (mag (x - y)) - 2 < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux1 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 2)%Z) (Hly' : (fexp1 (mag (x - y)) - 2 < mag y)%Z) (Hf1 : (fexp1 (mag (x - y)) - 1 <= mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"now apply (round_round_minus_aux1 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : round beta fexp1 (Znearest choice1) (x - y) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) by lia.\nnow apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 2 < mag y)%Z) (Hf1 : (fexp1 (mag x) - 1 <= mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"now apply (round_round_minus_aux0 fexp1)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold round_round_eq.\ndestruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx; unfold Rminus; rewrite Rplus_0_l.\ndo 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx; unfold Rminus; rewrite Rplus_0_l.\ndo 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite Zx; unfold Rminus; rewrite Rplus_0_l.\ndo 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (- y)) =\nround beta fexp1 (Znearest choice1) (- y).","proofString":"do 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : -\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z))) y) =\n- round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z))) y.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : - round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z))) y =\n- round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z))) y.","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : Valid_rnd (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z))).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 y.","proofString":"apply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : y <> 0 -> (fexp2 (mag y) <= fexp1 (mag y))%Z.","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : y <> 0 -> (fexp2 (mag y) <= fexp1 (mag y))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp1 y.","proofString":"exact Fy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) x = round beta fexp1 (Znearest choice1) x.","proofString":"reflexivity."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 x.","proofString":"apply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : x <> 0 -> (fexp2 (mag x) <= fexp1 (mag x))%Z.","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : x <> 0 -> (fexp2 (mag x) <= fexp1 (mag x))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp1 x.","proofString":"exact Fx."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"assert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"assert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"apply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"replace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (- (y - x))) =\nround beta fexp1 (Znearest choice1) (- (y - x)).","proofString":"do 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : -\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (y - x)) =\n-\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (y - x).","proofString":"apply Ropp_eq_compat.\nnow apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (y - x)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (y - x).","proofString":"now apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : y <= x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"now apply round_round_minus_aux3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"unfold round_round_eq.\ndestruct (Rlt_or_le x 0) as [Sx|Sx]; destruct (Rlt_or_le y 0) as [Sy|Sy].\nreplace (x + y) with (- (- x - y)); [|ring].\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux.\nreplace (x + y) with (y - (- x)); [|ring].\nassert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_aux.\nreplace (x + y) with (x - (- y)); [|ring].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_aux.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Rlt_or_le x 0) as [Sx|Sx]; destruct (Rlt_or_le y 0) as [Sy|Sy].\nreplace (x + y) with (- (- x - y)); [|ring].\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux.\nreplace (x + y) with (y - (- x)); [|ring].\nassert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_aux.\nreplace (x + y) with (x - (- y)); [|ring].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_aux.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"replace (x + y) with (- (- x - y)); [|ring].\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (- (- x - y))) =\nround beta fexp1 (Znearest choice1) (- (- x - y)).","proofString":"do 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : -\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\n-\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"apply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"assert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"assert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) (Py : 0 <= - y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"apply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 (- x)) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) (Py : 0 <= - y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"apply generic_format_opp in Fy.\nnow apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 (- x)) (Fy : generic_format beta fexp1 (- y)) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) (Py : 0 <= - y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"now apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"replace (x + y) with (y - (- x)); [|ring].\nassert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y - - x)) =\nround beta fexp1 (Znearest choice1) (y - - x).","proofString":"assert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) (Px : 0 <= - x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y - - x)) =\nround beta fexp1 (Znearest choice1) (y - - x).","proofString":"apply generic_format_opp in Fx.\nnow apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 (- x)) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) (Px : 0 <= - x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y - - x)) =\nround beta fexp1 (Znearest choice1) (y - - x).","proofString":"now apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"replace (x + y) with (x - (- y)); [|ring].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - - y)) =\nround beta fexp1 (Znearest choice1) (x - - y).","proofString":"assert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : y < 0) (Py : 0 <= - y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - - y)) =\nround beta fexp1 (Znearest choice1) (x - - y).","proofString":"apply generic_format_opp in Fy.\nnow apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 (- y)) (Sx : 0 <= x) (Sy : y < 0) (Py : 0 <= - y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - - y)) =\nround beta fexp1 (Znearest choice1) (x - - y).","proofString":"now apply round_round_minus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : 0 <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"now apply round_round_plus_aux."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold Rminus.\napply generic_format_opp in Fy.\nnow apply round_round_plus."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + - y).","proofString":"apply generic_format_opp in Fy.\nnow apply round_round_plus."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 (- y)) : round_round_eq fexp1 fexp2 choice1 choice2 (x + - y).","proofString":"now apply round_round_plus."},{"statement":"(Hprec : (2 * prec + 1 <= prec')%Z) : round_round_plus_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"unfold FLX_exp.\nunfold round_round_plus_hyp; split; [|split; [|split]];intros ex ey; try lia.\nunfold Prec_gt_0 in prec_gt_0_.\nlia."},{"statement":"(Hprec : (2 * prec + 1 <= prec')%Z) : round_round_plus_hyp (fun e : Z => (e - prec)%Z) (fun e : Z => (e - prec')%Z).","proofString":"unfold round_round_plus_hyp; split; [|split; [|split]];intros ex ey; try lia.\nunfold Prec_gt_0 in prec_gt_0_.\nlia."},{"statement":"(Hprec : (2 * prec + 1 <= prec')%Z) (ex ey : Z) : (ex + 1 - prec - 1 <= ey)%Z -> (ex - prec' <= ey - prec)%Z.","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nlia."},{"statement":"(Hprec : (2 * prec + 1 <= prec')%Z) (ex ey : Z) : (ex + 1 - prec - 1 <= ey)%Z -> (ex - prec' <= ey - prec)%Z.","proofString":"lia."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x + y).","proofString":"apply round_round_plus.\nnow apply FLX_exp_valid.\nnow apply FLX_exp_valid.\nnow apply FLX_round_round_plus_hyp.\nnow apply generic_format_FLX.\nnow apply generic_format_FLX."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec).","proofString":"now apply FLX_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec').","proofString":"now apply FLX_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_plus_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"now apply FLX_round_round_plus_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) x.","proofString":"now apply generic_format_FLX."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) y.","proofString":"now apply generic_format_FLX."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x - y).","proofString":"apply round_round_minus.\nnow apply FLX_exp_valid.\nnow apply FLX_exp_valid.\nnow apply FLX_round_round_plus_hyp.\nnow apply generic_format_FLX.\nnow apply generic_format_FLX."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec).","proofString":"now apply FLX_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec').","proofString":"now apply FLX_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_plus_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"now apply FLX_round_round_plus_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) x.","proofString":"now apply generic_format_FLX."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) y.","proofString":"now apply generic_format_FLX."},{"statement":"(Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_plus_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"unfold FLT_exp.\nunfold round_round_plus_hyp; split; [|split; [|split]]; intros ex ey.\ngeneralize (Zmax_spec (ex + 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\nunfold Prec_gt_0 in prec_gt_0_.\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia."},{"statement":"(Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_plus_hyp (fun e : Z => Z.max (e - prec) emin)\n  (fun e : Z => Z.max (e - prec') emin').","proofString":"unfold round_round_plus_hyp; split; [|split; [|split]]; intros ex ey.\ngeneralize (Zmax_spec (ex + 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\nunfold Prec_gt_0 in prec_gt_0_.\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia."},{"statement":"(Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex ey : Z) : (ey - prec >= emin)%Z /\\ Z.max (ey - prec) emin = (ey - prec)%Z \\/\n(ey - prec < emin)%Z /\\ Z.max (ey - prec) emin = emin ->\n(ex - prec' >= emin')%Z /\\ Z.max (ex - prec') emin' = (ex - prec')%Z \\/\n(ex - prec' < emin')%Z /\\ Z.max (ex - prec') emin' = emin' ->\n(ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin - 1 <= ey)%Z ->\n(Z.max (ex - prec') emin' <= Z.max (ey - prec) emin)%Z.","proofString":"unfold Prec_gt_0 in prec_gt_0_.\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_eq (FLT_exp emin prec) (FLT_exp emin' prec') choice1 choice2\n  (x + y).","proofString":"apply round_round_plus.\nnow apply FLT_exp_valid.\nnow apply FLT_exp_valid.\nnow apply FLT_round_round_plus_hyp.\nnow apply generic_format_FLT.\nnow apply generic_format_FLT."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin prec).","proofString":"now apply FLT_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin' prec').","proofString":"now apply FLT_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_plus_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"now apply FLT_round_round_plus_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) x.","proofString":"now apply generic_format_FLT."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) y.","proofString":"now apply generic_format_FLT."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_eq (FLT_exp emin prec) (FLT_exp emin' prec') choice1 choice2\n  (x - y).","proofString":"apply round_round_minus.\nnow apply FLT_exp_valid.\nnow apply FLT_exp_valid.\nnow apply FLT_round_round_plus_hyp.\nnow apply generic_format_FLT.\nnow apply generic_format_FLT."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin prec).","proofString":"now apply FLT_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin' prec').","proofString":"now apply FLT_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_plus_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"now apply FLT_round_round_plus_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) x.","proofString":"now apply generic_format_FLT."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) y.","proofString":"now apply generic_format_FLT."},{"statement":"(Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_plus_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"unfold FTZ_exp.\nunfold Prec_gt_0 in *.\nunfold round_round_plus_hyp; split; [|split; [|split]]; intros ex ey.\ndestruct (Z.ltb_spec (ex + 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia."},{"statement":"(Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_plus_hyp\n  (fun e : Z =>\n   if (e - prec <? emin)%Z then (emin + prec - 1)%Z else (e - prec)%Z)\n  (fun e : Z =>\n   if (e - prec' <? emin')%Z then (emin' + prec' - 1)%Z else (e - prec')%Z).","proofString":"unfold Prec_gt_0 in *.\nunfold round_round_plus_hyp; split; [|split; [|split]]; intros ex ey.\ndestruct (Z.ltb_spec (ex + 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec') choice1 choice2\n  (x + y).","proofString":"apply round_round_plus.\nnow apply FTZ_exp_valid.\nnow apply FTZ_exp_valid.\nnow apply FTZ_round_round_plus_hyp.\nnow apply generic_format_FTZ.\nnow apply generic_format_FTZ."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin prec).","proofString":"now apply FTZ_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin' prec').","proofString":"now apply FTZ_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_plus_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"now apply FTZ_round_round_plus_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) x.","proofString":"now apply generic_format_FTZ."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) y.","proofString":"now apply generic_format_FTZ."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec') choice1 choice2\n  (x - y).","proofString":"apply round_round_minus.\nnow apply FTZ_exp_valid.\nnow apply FTZ_exp_valid.\nnow apply FTZ_round_round_plus_hyp.\nnow apply generic_format_FTZ.\nnow apply generic_format_FTZ."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin prec).","proofString":"now apply FTZ_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin' prec').","proofString":"now apply FTZ_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_plus_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"now apply FTZ_round_round_plus_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) x.","proofString":"now apply generic_format_FTZ."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) y.","proofString":"now apply generic_format_FTZ."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x + y).","proofString":"assert (Px := Rlt_le_trans 0 y x Py Hyx).\nassert (Nny : (0 <= y)%R); [now apply Rlt_le|].\ndestruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).\ndestruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x + y).","proofString":"assert (Nny : (0 <= y)%R); [now apply Rlt_le|].\ndestruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).\ndestruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Nny : 0 <= y) : generic_format beta fexp2 (x + y).","proofString":"destruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).\ndestruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Nny : 0 <= y) : generic_format beta fexp2 (x + y).","proofString":"destruct (Z.le_gt_cases (mag y) (fexp1 (mag x))) as [Hle|Hgt].\nassert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia.\napply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Nny : 0 <= y) (Hle : (mag y <= fexp1 (mag x))%Z) : generic_format beta fexp2 (x + y).","proofString":"assert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1)|].\napply (round_round_plus_aux0_aux fexp1);    [| |assumption|assumption]; rewrite Lxy.\nnow apply Hexp4; lia.\nnow apply Hexp3; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Nny : 0 <= y) (Hgt : (fexp1 (mag x) < mag y)%Z) : generic_format beta fexp2 (x + y).","proofString":"apply (round_round_plus_aux0_aux fexp1); [| |assumption|assumption].\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp4; lia.\napply Hexp2; apply (mag_le beta y x Py) in Hyx.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia.\ndestruct (mag_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.\nnow apply Hexp3; lia.\napply Hexp2.\nreplace (_ - _)%Z with (mag x : Z) by ring.\nlia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Fx : generic_format beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"assert (Lxy : mag (x + y) = mag x :> Z);  [now apply (mag_plus_separated fexp1); [|apply Rlt_le| |lia]|].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Bpow3 : bpow (- 1) <= / 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nassert (P1 : (0 < 1)%Z) by lia.\nunfold round_round_eq.\napply round_round_lt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\nnow rewrite Lxy.\nrewrite Lxy.\ncut (fexp1 (mag x) < mag x)%Z.\nlia.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nunfold midp.\napply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).\napply (Rlt_le_trans _ _ _ (proj2 (round_round_plus_aux1_aux 1 P1 fexp1 x y Px                                                               Py Hly Lxy Fx))).\nring_simplify.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold cexp; rewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));    [now apply bpow_gt_0|].\nbpow_simplify.\napply (Rle_trans _ _ _ Bpow3); lra.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold round, F2R, scaled_mantissa, cexp; simpl; rewrite Lxy.\nintro Hf2'.\nunfold midp.\napply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))); ring_simplify.\nrewrite <- Rmult_minus_distr_l.\napply (Rlt_le_trans _ _ _ (proj2 (round_round_plus_aux1_aux 1 P1 fexp1 x y Px                                                               Py Hly Lxy Fx))).\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].\nunfold cexp; rewrite Lxy.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));    [now apply bpow_gt_0|].\nrewrite (Rmult_assoc (/ 2)).\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply (Rle_trans _ _ _ Bpow3).\napply Rle_trans with (/ 2 * (2 / 3)); [lra|].\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- (/ 3)) by lra.\napply Ropp_le_contravar.\nnow apply Rle_trans with (bpow (- 1)); [apply bpow_le; lia|]."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"assert (Px := Rlt_le_trans 0 y x Py Hyx).\nunfold round_round_eq.\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\nnow apply round_round_plus_radix_ge_3_aux1.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_plus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"unfold round_round_eq.\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\nnow apply round_round_plus_radix_ge_3_aux1.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_plus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\nnow apply round_round_plus_radix_ge_3_aux1.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_plus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"now apply round_round_plus_radix_ge_3_aux1."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_plus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : round beta fexp1 (Znearest choice1) (x + y) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : generic_format beta fexp2 (x + y).","proofString":"assert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_plus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) (Hf1 : (fexp1 (mag x) <= mag y)%Z) : generic_format beta fexp2 (x + y).","proofString":"now apply (round_round_plus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"unfold round_round_eq.\ndestruct (Req_dec x 0) as [Zx|Nzx].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite Zx; rewrite Rplus_0_l.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) y) =\nround beta fexp1 (Znearest choice1) y.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1) y = round beta fexp1 (Znearest choice1) y.","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 y.","proofString":"apply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : y <> 0 -> (fexp2 (mag y) <= fexp1 (mag y))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp1 y.","proofString":"exact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Req_dec y 0) as [Zy|Nzy].\ndestruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nrewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite Zy; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) x = round beta fexp1 (Znearest choice1) x.","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 x.","proofString":"apply (generic_inclusion_mag beta fexp1).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : x <> 0 -> (fexp2 (mag x) <= fexp1 (mag x))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp1 x.","proofString":"exact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"assert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"assert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"apply Rlt_le in H.\nrewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"rewrite Rplus_comm.\nnow apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y + x)) =\nround beta fexp1 (Znearest choice1) (y + x).","proofString":"now apply round_round_plus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : y <= x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"now apply round_round_plus_radix_ge_3_aux2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x - y).","proofString":"assert (Px := Rlt_trans 0 y x Py Hyx).\ndestruct Hexp as (Hexp1,(_,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\ndestruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"destruct Hexp as (Hexp1,(_,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\ndestruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"assert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\ndestruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) : generic_format beta fexp2 (x - y).","proofString":"destruct (Z.lt_ge_cases (mag x - 2) (mag y)) as [Hlt|Hge].\nassert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus.\ndestruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hlt : (mag x - 2 < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hor : (mag y = mag x :> Z) \\/ (mag y = mag x - 1 :> Z)%Z) by lia.\ndestruct Hor as [Heq|Heqm1].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heq.\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\napply Z.le_trans with (mag (x - y)); [lia|].\nnow apply mag_minus.\nrewrite Heqm1.\napply Hexp4.\napply Zplus_le_compat_r.\nnow apply mag_minus."},{"statement":"(fexp1 fexp2 : Z -> Z) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (fexp1 (mag x) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hge : (mag y <= mag x - 2)%Z) : generic_format beta fexp2 (x - y).","proofString":"destruct (mag_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Hexp4.\nlia.\nnow rewrite Lxmy; apply Hexp3.\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];    rewrite Lxmy.\napply Hexp1.\nreplace (_ + _)%Z with (mag x : Z); [|ring].\nnow apply Z.le_trans with (mag y).\napply Hexp1.\nnow replace (_ + _)%Z with (mag x : Z); [|ring]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : generic_format beta fexp2 (x - y).","proofString":"assert (Px := Rlt_trans 0 y x Py Hyx).\ndestruct Hexp as (Hexp1,(Hexp2,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"destruct Hexp as (Hexp1,(Hexp2,(Hexp3,Hexp4))).\nassert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : generic_format beta fexp2 (x - y).","proofString":"assert (Lyx : (mag y <= mag x)%Z);  [now apply mag_le; [|apply Rlt_le]|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\napply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"apply (round_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].\napply Z.le_trans with (fexp1 (mag (x - y))).\napply Hexp4; lia.\nlia.\nnow apply Hexp3."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp1 : forall ex ey : Z, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp2 : forall ex ey : Z, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp3 : forall ex ey : Z, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hyx : y < x) (Hln : (mag y <= fexp1 (mag x) - 1)%Z) (Hln' : (fexp1 (mag (x - y)) <= mag y)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Lyx : (mag y <= mag x)%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)))%Z.","proofString":"apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Px := Rlt_trans 0 y x Py Hxy).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow3 : bpow (- 1) <= / 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nassert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow3 : bpow (- 1) <= / 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z);  [now apply Hexp4; lia|].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow3 : bpow (- 1) <= / 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Bpow3 : bpow (- 1) <= / 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Bpow3 : bpow (- 1) <= / 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nassert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : bpow (-1) <= / 3.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : / IZR (beta * 1) <= / 3.","proofString":"rewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : / IZR beta <= / 3.","proofString":"apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : 3 <= IZR beta.","proofString":"now apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Ly : y < bpow (mag y)).\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) : y < bpow (mag y).","proofString":"apply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) : Rabs y < bpow (mag y).","proofString":"apply bpow_mag_gt."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold round_round_eq.\napply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"apply round_round_gt_mid.\nexact Vfexp1.\nexact Vfexp2.\nlra.\napply Hexp4; lia.\ncut (fexp1 (mag (x - y)) < mag (x - y))%Z.\nlia.\napply (valid_exp_large fexp1 (mag x - 1)).\napply (valid_exp_large fexp1 (mag y)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nnow apply mag_minus_lb; [| |lia].\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia.\nintro Hf2'.\nunfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : 0 < x - y.","proofString":"lra."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)))%Z.","proofString":"apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : (fexp1 (mag (x - y)) < mag (x - y))%Z ->\n(fexp1 (mag (x - y)) <= mag (x - y))%Z.","proofString":"lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) < x - y.","proofString":"apply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).\nring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) +\n(/ 2 * ulp beta fexp1 (x - y) - (x - y)) <\nx - y + (/ 2 * ulp beta fexp1 (x - y) - (x - y)).","proofString":"ring_simplify.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - x + y < / 2 * ulp beta fexp1 (x - y).","proofString":"replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - (x - y) < / 2 * ulp beta fexp1 (x - y).","proofString":"apply Rlt_le_trans with (bpow (fexp1 (mag (x - y)) - 1)).\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : round beta fexp1 Zceil (x - y) - (x - y) < bpow (fexp1 (mag (x - y)) - 1).","proofString":"apply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : y < bpow (fexp1 (mag (x - y)) - 1).","proofString":"apply (Rlt_le_trans _ _ _ Ly).\nnow apply bpow_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (mag y) <= bpow (fexp1 (mag (x - y)) - 1).","proofString":"now apply bpow_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 1) <= / 2 * ulp beta fexp1 (x - y).","proofString":"rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].\nunfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 1) <= / 2 * bpow (cexp beta fexp1 (x - y)).","proofString":"unfold cexp.\nunfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y)) - 1) <= / 2 * bpow (fexp1 (mag (x - y))).","proofString":"unfold Zminus at 1; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (fexp1 (mag (x - y))) * bpow (- (1)) <= / 2 * bpow (fexp1 (mag (x - y))).","proofString":"rewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (- (1)) * bpow (fexp1 (mag (x - y))) <= / 2 * bpow (fexp1 (mag (x - y))).","proofString":"apply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : bpow (- (1)) <= / 2.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : / IZR (beta * 1) <= / 2.","proofString":"rewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) : 2 <= IZR beta.","proofString":"now apply IZR_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : midp' fexp1 (x - y) + / 2 * ulp beta fexp2 (x - y) < x - y.","proofString":"unfold midp'.\napply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) +\n/ 2 * ulp beta fexp2 (x - y) < x - y.","proofString":"apply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)                                - ulp beta fexp2 (x - y)) - (x - y))).\nring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - / 2 * ulp beta fexp1 (x - y) +\n/ 2 * ulp beta fexp2 (x - y) +\n(/ 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)) - (x - y)) <\nx - y + (/ 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)) - (x - y)).","proofString":"ring_simplify; rewrite <- Rmult_minus_distr_l.\nreplace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - x + y <\n/ 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)).","proofString":"replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.\napply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 Zceil (x - y) - (x - y) <\n/ 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)).","proofString":"apply Rle_lt_trans with y;    [now apply round_round_minus_aux2_aux|].\napply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : y < / 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)).","proofString":"apply (Rlt_le_trans _ _ _ Ly).\napply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (mag y) <= / 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)).","proofString":"apply Rle_trans with (bpow (fexp1 (mag (x - y)) - 1));    [now apply bpow_le|].\nrewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) <=\n/ 2 * (ulp beta fexp1 (x - y) - ulp beta fexp2 (x - y)).","proofString":"rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.\nunfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) <=\n/ 2 * (bpow (cexp beta fexp1 (x - y)) - bpow (cexp beta fexp2 (x - y))).","proofString":"unfold cexp.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) <=\n/ 2 * (bpow (fexp1 (mag (x - y))) - bpow (fexp2 (mag (x - y)))).","proofString":"apply (Rmult_le_reg_r (bpow (- fexp1 (mag (x - y)))));    [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) * bpow (- fexp1 (mag (x - y))) <=\n/ 2 * (bpow (fexp1 (mag (x - y))) - bpow (fexp2 (mag (x - y)))) *\nbpow (- fexp1 (mag (x - y))).","proofString":"rewrite Rmult_assoc.\nrewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) * bpow (- fexp1 (mag (x - y))) <=\n/ 2 *\n((bpow (fexp1 (mag (x - y))) - bpow (fexp2 (mag (x - y)))) *\n bpow (- fexp1 (mag (x - y)))).","proofString":"rewrite Rmult_minus_distr_r.\nbpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp1 (mag (x - y)) - 1) * bpow (- fexp1 (mag (x - y))) <=\n/ 2 *\n(bpow (fexp1 (mag (x - y))) * bpow (- fexp1 (mag (x - y))) -\n bpow (fexp2 (mag (x - y))) * bpow (- fexp1 (mag (x - y)))).","proofString":"bpow_simplify.\napply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (- (1)) <= / 2 * (1 - bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y)))).","proofString":"apply Rle_trans with (/ 3).\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le.\nreplace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (- (1)) <= / 3.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR (beta * 1) <= / 3.","proofString":"rewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 3 <= IZR beta.","proofString":"now apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / 3 <= / 2 * (1 - bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y)))).","proofString":"replace (/ 3) with (/ 2 * (2 / 3)) by field.\napply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / 2 * (2 / 3) <= / 2 * (1 - bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y)))).","proofString":"apply Rmult_le_compat_l; [lra|].\napply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 2 / 3 <= 1 - bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y))).","proofString":"apply (Rplus_le_reg_r (- 1)); ring_simplify.\nreplace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 2 / 3 - 1 <= - bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y))).","proofString":"replace (_ - _) with (- / 3) by field.\napply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : - / 3 <= - bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y))).","proofString":"apply Ropp_le_contravar.\napply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y))) <= / 3.","proofString":"apply Rle_trans with (bpow (- 1)).\napply bpow_le; lia.\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (fexp2 (mag (x - y)) - fexp1 (mag (x - y))) <= bpow (-1).","proofString":"apply bpow_le; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : bpow (-1) <= / 3.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : / IZR (beta * 1) <= / 3.","proofString":"rewrite Zmult_1_r; apply Rinv_le; [lra|].\nnow apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Py : 0 < y) (Hxy : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Bpow3 : bpow (-1) <= / 3) (Ly : y < bpow (mag y)) (Hf2' : (fexp2 (mag (x - y)) <= fexp1 (mag (x - y)) - 1)%Z) : 3 <= IZR beta.","proofString":"now apply IZR_le."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"assert (Px := Rlt_le_trans 0 y x Py Hyx).\nunfold round_round_eq.\ndestruct (Req_dec y x) as [Hy|Hy].\nrewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 1))      as [Hly'|Hly'].\nnow apply round_round_minus_radix_ge_3_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold round_round_eq.\ndestruct (Req_dec y x) as [Hy|Hy].\nrewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 1))      as [Hly'|Hly'].\nnow apply round_round_minus_radix_ge_3_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Req_dec y x) as [Hy|Hy].\nrewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 1))      as [Hly'|Hly'].\nnow apply round_round_minus_radix_ge_3_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite Hy; replace (x - x) with 0 by ring.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) 0) =\nround beta fexp1 (Znearest choice1) 0.","proofString":"rewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : round beta fexp1 (Znearest choice1) 0 = round beta fexp1 (Znearest choice1) 0.","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y = x) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"assert (Hyx' : y < x); [lra|].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 1))      as [Hly'|Hly'].\nnow apply round_round_minus_radix_ge_3_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Zle_or_lt (mag y) (fexp1 (mag x) - 1)) as [Hly|Hly].\ndestruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 1))      as [Hly'|Hly'].\nnow apply round_round_minus_radix_ge_3_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1).\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Zle_or_lt (mag y) (fexp1 (mag (x - y)) - 1))      as [Hly'|Hly'].\nnow apply round_round_minus_radix_ge_3_aux2.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (mag y <= fexp1 (mag (x - y)) - 1)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"now apply round_round_minus_radix_ge_3_aux2."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (fexp1 (mag (x - y)) - 1 < mag y)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (fexp1 (mag (x - y)) - 1 < mag y)%Z) : round beta fexp1 (Znearest choice1) (x - y) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (fexp1 (mag (x - y)) - 1 < mag y)%Z) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (fexp1 (mag (x - y)) - 1 < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux1 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (mag y <= fexp1 (mag x) - 1)%Z) (Hly' : (fexp1 (mag (x - y)) - 1 < mag y)%Z) (Hf1 : (fexp1 (mag (x - y)) <= mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"now apply (round_round_minus_radix_ge_3_aux1 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : round beta fexp1 (Znearest choice1) (x - y) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"assert (Hf1 : (fexp1 (mag x) <= mag y)%Z) by lia.\nnow apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Py : 0 < y) (Hyx : y <= x) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Px : 0 < x) (Hy : y <> x) (Hyx' : y < x) (Hly : (fexp1 (mag x) - 1 < mag y)%Z) (Hf1 : (fexp1 (mag x) <= mag y)%Z) : generic_format beta fexp2 (x - y).","proofString":"now apply (round_round_minus_radix_ge_3_aux0 fexp1)."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold round_round_eq.\ndestruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx; unfold Rminus; rewrite Rplus_0_l.\ndo 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx; unfold Rminus; rewrite Rplus_0_l.\ndo 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy.\ndestruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite Zx; unfold Rminus; rewrite Rplus_0_l.\ndo 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (- y)) =\nround beta fexp1 (Znearest choice1) (- y).","proofString":"do 3 rewrite round_N_opp.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : -\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z))) y) =\n- round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z))) y.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : - round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z))) y =\n- round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z))) y.","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : Valid_rnd (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z))).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp2 y.","proofString":"apply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : y <> 0 -> (fexp2 (mag y) <= fexp1 (mag y))%Z.","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : y <> 0 -> (fexp2 (mag y) <= fexp1 (mag y))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Zx : x = 0) : generic_format beta fexp1 y.","proofString":"exact Fy."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Req_dec y 0) as [Zy|Nzy].\nrewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx.\nassert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"rewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (round_generic beta fexp2).\nreflexivity.\nnow apply valid_rnd_N.\napply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : round beta fexp1 (Znearest choice1) x = round beta fexp1 (Znearest choice1) x.","proofString":"reflexivity."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp2 x.","proofString":"apply (generic_inclusion_mag beta fexp1).\ndestruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia.\nexact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : x <> 0 -> (fexp2 (mag x) <= fexp1 (mag x))%Z.","proofString":"destruct Hexp as (_,(_,(_,Hexp4))).\nnow intros _; apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp4 : forall ex ey : Z, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : x <> 0 -> (fexp2 (mag x) <= fexp1 (mag x))%Z.","proofString":"now intros _; apply Hexp4; lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Zy : y = 0) : generic_format beta fexp1 x.","proofString":"exact Fx."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"assert (Px : 0 < x); [lra|].\nassert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"assert (Py : 0 < y); [lra|].\ndestruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"destruct (Rlt_or_le x y) as [H|H].\napply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x < y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"apply Rlt_le in H.\nreplace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"replace (x - y) with (- (y - x)) by ring.\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (- (y - x))) =\nround beta fexp1 (Znearest choice1) (- (y - x)).","proofString":"do 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : -\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (y - x)) =\n-\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (y - x).","proofString":"apply Ropp_eq_compat.\nnow apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : x <= y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (y - x)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (y - x).","proofString":"now apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Nnx : 0 <= x) (Nny : 0 <= y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Nzx : x <> 0) (Nzy : y <> 0) (Px : 0 < x) (Py : 0 < y) (H : y <= x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - y)) =\nround beta fexp1 (Znearest choice1) (x - y).","proofString":"now apply round_round_minus_radix_ge_3_aux3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + y).","proofString":"unfold round_round_eq.\ndestruct (Rlt_or_le x 0) as [Sx|Sx]; destruct (Rlt_or_le y 0) as [Sy|Sy].\nreplace (x + y) with (- (- x - y)); [|ring].\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux.\nreplace (x + y) with (y - (- x)); [|ring].\nassert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_radix_ge_3_aux.\nreplace (x + y) with (x - (- y)); [|ring].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_radix_ge_3_aux.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"destruct (Rlt_or_le x 0) as [Sx|Sx]; destruct (Rlt_or_le y 0) as [Sy|Sy].\nreplace (x + y) with (- (- x - y)); [|ring].\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux.\nreplace (x + y) with (y - (- x)); [|ring].\nassert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_radix_ge_3_aux.\nreplace (x + y) with (x - (- y)); [|ring].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_radix_ge_3_aux.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"replace (x + y) with (- (- x - y)); [|ring].\ndo 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (- (- x - y))) =\nround beta fexp1 (Znearest choice1) (- (- x - y)).","proofString":"do 3 rewrite round_N_opp.\napply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : -\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\n-\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"apply Ropp_eq_compat.\nassert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"assert (Px : 0 <= - x); [lra|].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"assert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) (Py : 0 <= - y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"apply generic_format_opp in Fx.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 (- x)) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) (Py : 0 <= - y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"apply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 (- x)) (Fy : generic_format beta fexp1 (- y)) (Sx : x < 0) (Sy : y < 0) (Px : 0 <= - x) (Py : 0 <= - y) : round beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (round beta fexp2 (Znearest (fun t : Z => negb (choice2 (- (t + 1))%Z)))\n     (- x - y)) =\nround beta fexp1 (Znearest (fun t : Z => negb (choice1 (- (t + 1))%Z)))\n  (- x - y).","proofString":"now apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"replace (x + y) with (y - (- x)); [|ring].\nassert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y - - x)) =\nround beta fexp1 (Znearest choice1) (y - - x).","proofString":"assert (Px : 0 <= - x); [lra|].\napply generic_format_opp in Fx.\nnow apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) (Px : 0 <= - x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y - - x)) =\nround beta fexp1 (Znearest choice1) (y - - x).","proofString":"apply generic_format_opp in Fx.\nnow apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 (- x)) (Fy : generic_format beta fexp1 y) (Sx : x < 0) (Sy : 0 <= y) (Px : 0 <= - x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (y - - x)) =\nround beta fexp1 (Znearest choice1) (y - - x).","proofString":"now apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"replace (x + y) with (x - (- y)); [|ring].\nassert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : y < 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - - y)) =\nround beta fexp1 (Znearest choice1) (x - - y).","proofString":"assert (Py : 0 <= - y); [lra|].\napply generic_format_opp in Fy.\nnow apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : y < 0) (Py : 0 <= - y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - - y)) =\nround beta fexp1 (Znearest choice1) (x - - y).","proofString":"apply generic_format_opp in Fy.\nnow apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 (- y)) (Sx : 0 <= x) (Sy : y < 0) (Py : 0 <= - y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x - - y)) =\nround beta fexp1 (Znearest choice1) (x - - y).","proofString":"now apply round_round_minus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Sx : 0 <= x) (Sy : 0 <= y) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (x + y)) =\nround beta fexp1 (Znearest choice1) (x + y).","proofString":"now apply round_round_plus_radix_ge_3_aux."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x - y).","proofString":"unfold Rminus.\napply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) : round_round_eq fexp1 fexp2 choice1 choice2 (x + - y).","proofString":"apply generic_format_opp in Fy.\nnow apply round_round_plus_radix_ge_3."},{"statement":"(Hbeta : (3 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_plus_radix_ge_3_hyp fexp1 fexp2) (x y : R) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 (- y)) : round_round_eq fexp1 fexp2 choice1 choice2 (x + - y).","proofString":"now apply round_round_plus_radix_ge_3."},{"statement":"(Hprec : (2 * prec <= prec')%Z) : round_round_plus_radix_ge_3_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"unfold FLX_exp.\nunfold round_round_plus_radix_ge_3_hyp; split; [|split; [|split]];intros ex ey; try lia.\nunfold Prec_gt_0 in prec_gt_0_.\nlia."},{"statement":"(Hprec : (2 * prec <= prec')%Z) : round_round_plus_radix_ge_3_hyp (fun e : Z => (e - prec)%Z)\n  (fun e : Z => (e - prec')%Z).","proofString":"unfold round_round_plus_radix_ge_3_hyp; split; [|split; [|split]];intros ex ey; try lia.\nunfold Prec_gt_0 in prec_gt_0_.\nlia."},{"statement":"(Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ex + 1 - prec <= ey)%Z -> (ex - prec' <= ey - prec)%Z.","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nlia."},{"statement":"(Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ex + 1 - prec <= ey)%Z -> (ex - prec' <= ey - prec)%Z.","proofString":"lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x + y).","proofString":"apply round_round_plus_radix_ge_3.\nexact Hbeta.\nnow apply FLX_exp_valid.\nnow apply FLX_exp_valid.\nnow apply FLX_round_round_plus_radix_ge_3_hyp.\nnow apply generic_format_FLX.\nnow apply generic_format_FLX."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : (3 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec).","proofString":"now apply FLX_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec').","proofString":"now apply FLX_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_plus_radix_ge_3_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"now apply FLX_round_round_plus_radix_ge_3_hyp."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) x.","proofString":"now apply generic_format_FLX."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) y.","proofString":"now apply generic_format_FLX."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x - y).","proofString":"apply round_round_minus_radix_ge_3.\nexact Hbeta.\nnow apply FLX_exp_valid.\nnow apply FLX_exp_valid.\nnow apply FLX_round_round_plus_radix_ge_3_hyp.\nnow apply generic_format_FLX.\nnow apply generic_format_FLX."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : (3 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec).","proofString":"now apply FLX_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : Valid_exp (FLX_exp prec').","proofString":"now apply FLX_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : round_round_plus_radix_ge_3_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"now apply FLX_round_round_plus_radix_ge_3_hyp."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) x.","proofString":"now apply generic_format_FLX."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLX_format beta prec x) (Fy : FLX_format beta prec y) : generic_format beta (FLX_exp prec) y.","proofString":"now apply generic_format_FLX."},{"statement":"(Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_plus_radix_ge_3_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"unfold FLT_exp.\nunfold round_round_plus_radix_ge_3_hyp; split; [|split; [|split]]; intros ex ey.\ngeneralize (Zmax_spec (ex + 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\nunfold Prec_gt_0 in prec_gt_0_.\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia."},{"statement":"(Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_plus_radix_ge_3_hyp (fun e : Z => Z.max (e - prec) emin)\n  (fun e : Z => Z.max (e - prec') emin').","proofString":"unfold round_round_plus_radix_ge_3_hyp; split; [|split; [|split]]; intros ex ey.\ngeneralize (Zmax_spec (ex + 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - 1 - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia.\nunfold Prec_gt_0 in prec_gt_0_.\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia."},{"statement":"(Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ey - prec >= emin)%Z /\\ Z.max (ey - prec) emin = (ey - prec)%Z \\/\n(ey - prec < emin)%Z /\\ Z.max (ey - prec) emin = emin ->\n(ex - prec' >= emin')%Z /\\ Z.max (ex - prec') emin' = (ex - prec')%Z \\/\n(ex - prec' < emin')%Z /\\ Z.max (ex - prec') emin' = emin' ->\n(ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin <= ey)%Z ->\n(Z.max (ex - prec') emin' <= Z.max (ey - prec) emin)%Z.","proofString":"unfold Prec_gt_0 in prec_gt_0_.\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ey - prec) emin).\nlia."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_eq (FLT_exp emin prec) (FLT_exp emin' prec') choice1 choice2\n  (x + y).","proofString":"apply round_round_plus_radix_ge_3.\nexact Hbeta.\nnow apply FLT_exp_valid.\nnow apply FLT_exp_valid.\nnow apply FLT_round_round_plus_radix_ge_3_hyp.\nnow apply generic_format_FLT.\nnow apply generic_format_FLT."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : (3 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin prec).","proofString":"now apply FLT_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin' prec').","proofString":"now apply FLT_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_plus_radix_ge_3_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"now apply FLT_round_round_plus_radix_ge_3_hyp."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) x.","proofString":"now apply generic_format_FLT."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) y.","proofString":"now apply generic_format_FLT."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_eq (FLT_exp emin prec) (FLT_exp emin' prec') choice1 choice2\n  (x - y).","proofString":"apply round_round_minus_radix_ge_3.\nexact Hbeta.\nnow apply FLT_exp_valid.\nnow apply FLT_exp_valid.\nnow apply FLT_round_round_plus_radix_ge_3_hyp.\nnow apply generic_format_FLT.\nnow apply generic_format_FLT."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : (3 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin prec).","proofString":"now apply FLT_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : Valid_exp (FLT_exp emin' prec').","proofString":"now apply FLT_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : round_round_plus_radix_ge_3_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"now apply FLT_round_round_plus_radix_ge_3_hyp."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) x.","proofString":"now apply generic_format_FLT."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' <= emin)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FLT_format beta emin prec x) (Fy : FLT_format beta emin prec y) : generic_format beta (FLT_exp emin prec) y.","proofString":"now apply generic_format_FLT."},{"statement":"(Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_plus_radix_ge_3_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"unfold FTZ_exp.\nunfold Prec_gt_0 in *.\nunfold round_round_plus_radix_ge_3_hyp; split; [|split; [|split]]; intros ex ey.\ndestruct (Z.ltb_spec (ex + 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia."},{"statement":"(Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_plus_radix_ge_3_hyp\n  (fun e : Z =>\n   if (e - prec <? emin)%Z then (emin + prec - 1)%Z else (e - prec)%Z)\n  (fun e : Z =>\n   if (e - prec' <? emin')%Z then (emin' + prec' - 1)%Z else (e - prec')%Z).","proofString":"unfold Prec_gt_0 in *.\nunfold round_round_plus_radix_ge_3_hyp; split; [|split; [|split]]; intros ex ey.\ndestruct (Z.ltb_spec (ex + 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - 1 - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ey - prec) emin);  lia."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec') choice1 choice2\n  (x + y).","proofString":"apply round_round_plus_radix_ge_3.\nexact Hbeta.\nnow apply FTZ_exp_valid.\nnow apply FTZ_exp_valid.\nnow apply FTZ_round_round_plus_radix_ge_3_hyp.\nnow apply generic_format_FTZ.\nnow apply generic_format_FTZ."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : (3 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin prec).","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin' prec').","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_plus_radix_ge_3_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"now apply FTZ_round_round_plus_radix_ge_3_hyp."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) x.","proofString":"now apply generic_format_FTZ."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) y.","proofString":"now apply generic_format_FTZ."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec') choice1 choice2\n  (x - y).","proofString":"apply round_round_minus_radix_ge_3.\nexact Hbeta.\nnow apply FTZ_exp_valid.\nnow apply FTZ_exp_valid.\nnow apply FTZ_round_round_plus_radix_ge_3_hyp.\nnow apply generic_format_FTZ.\nnow apply generic_format_FTZ."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : (3 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin prec).","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : Valid_exp (FTZ_exp emin' prec').","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : round_round_plus_radix_ge_3_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"now apply FTZ_round_round_plus_radix_ge_3_hyp."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) x.","proofString":"now apply generic_format_FTZ."},{"statement":"(Hbeta : (3 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin' + prec' <= emin + 1)%Z) (Hprec : (2 * prec <= prec')%Z) (x y : R) (Fx : FTZ_format beta emin prec x) (Fy : FTZ_format beta emin prec y) : generic_format beta (FTZ_exp emin prec) y.","proofString":"now apply generic_format_FTZ."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) : (Rabs (x - midp fexp1 x) <= / 2 * ulp beta fexp2 x ->\n round_round_eq fexp1 fexp2 choice1 choice2 x) ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq, midp.\nset (rd := round beta fexp1 Zfloor x).\nset (u1 := ulp beta fexp1 x).\nset (u2 := ulp beta fexp2 x).\nintros Cmid.\ndestruct (generic_format_EM beta fexp1 x) as [Fx|Nfx].\nrewrite (round_generic beta fexp2); [reflexivity|now apply valid_rnd_N|].\nnow apply (generic_inclusion_mag beta fexp1); [lia|].\nassert (Hceil : round beta fexp1 Zceil x = rd + u1);  [now apply round_UP_DN_ulp|].\nassert (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\ndestruct (Rlt_or_le (x - rd) (/ 2 * (u1 - u2))).\napply round_round_lt_mid_further_place; try assumption.\nunfold midp.\nfold rd; fold u1; fold u2.\napply (Rplus_lt_reg_r (- rd)); ring_simplify.\nnow rewrite <- Rmult_minus_distr_l.\ndestruct (Rlt_or_le (/ 2 * (u1 + u2)) (x - rd)).\nassert (round beta fexp1 Zceil x - x                < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\nrewrite Hceil; fold u1; fold u2.\nlra.\napply round_round_gt_mid_further_place; try assumption.\nunfold midp'; lra.\napply Cmid, Rabs_le; split; lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) : (Rabs (x - (round beta fexp1 Zfloor x + / 2 * ulp beta fexp1 x)) <=\n / 2 * ulp beta fexp2 x ->\n round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\n round beta fexp1 (Znearest choice1) x) ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (rd := round beta fexp1 Zfloor x).\nset (u1 := ulp beta fexp1 x).\nset (u2 := ulp beta fexp2 x).\nintros Cmid.\ndestruct (generic_format_EM beta fexp1 x) as [Fx|Nfx].\nrewrite (round_generic beta fexp2); [reflexivity|now apply valid_rnd_N|].\nnow apply (generic_inclusion_mag beta fexp1); [lia|].\nassert (Hceil : round beta fexp1 Zceil x = rd + u1);  [now apply round_UP_DN_ulp|].\nassert (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\ndestruct (Rlt_or_le (x - rd) (/ 2 * (u1 - u2))).\napply round_round_lt_mid_further_place; try assumption.\nunfold midp.\nfold rd; fold u1; fold u2.\napply (Rplus_lt_reg_r (- rd)); ring_simplify.\nnow rewrite <- Rmult_minus_distr_l.\ndestruct (Rlt_or_le (/ 2 * (u1 + u2)) (x - rd)).\nassert (round beta fexp1 Zceil x - x                < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).\nrewrite Hceil; fold u1; fold u2.\nlra.\napply round_round_gt_mid_further_place; try assumption.\nunfold midp'; lra.\napply Cmid, Rabs_le; split; lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Fx : generic_format beta fexp1 x) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (round_generic beta fexp2); [reflexivity|now apply valid_rnd_N|].\nnow apply (generic_inclusion_mag beta fexp1); [lia|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Fx : generic_format beta fexp1 x) : generic_format beta fexp2 x.","proofString":"now apply (generic_inclusion_mag beta fexp1); [lia|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = rd + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (H : x - rd < / 2 * (u1 - u2)) : x < rd + / 2 * u1 - / 2 * u2.","proofString":"apply (Rplus_lt_reg_r (- rd)); ring_simplify.\nnow rewrite <- Rmult_minus_distr_l."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = rd + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (H : x - rd < / 2 * (u1 - u2)) : x - rd < / 2 * u1 - / 2 * u2.","proofString":"now rewrite <- Rmult_minus_distr_l."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = rd + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (H : / 2 * (u1 - u2) <= x - rd) (H0 : / 2 * (u1 + u2) < x - rd) : rd + u1 - x < / 2 * (u1 - u2).","proofString":"lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = rd + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (H : / 2 * (u1 - u2) <= x - rd) (H0 : / 2 * (u1 + u2) < x - rd) (H1 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"apply round_round_gt_mid_further_place; try assumption.\nunfold midp'; lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = rd + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (H : / 2 * (u1 - u2) <= x - rd) (H0 : / 2 * (u1 + u2) < x - rd) (H1 : round beta fexp1 Zceil x - x < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)) : midp' fexp1 x + / 2 * ulp beta fexp2 x < x.","proofString":"unfold midp'; lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2f1 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (Hf1 : (fexp1 (mag x) <= mag x)%Z) (rd : R) (u1 : R) (u2 : R) (Cmid : Rabs (x - (rd + / 2 * u1)) <= / 2 * u2 ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = rd + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (H : / 2 * (u1 - u2) <= x - rd) (H0 : x - rd <= / 2 * (u1 + u2)) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"apply Cmid, Rabs_le; split; lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) : / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).","proofString":"assert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le.\nset (a := round beta fexp1 Zfloor (sqrt x)).\nset (u1 := bpow (fexp1 (mag (sqrt x)))).\nset (u2 := bpow (fexp2 (mag (sqrt x)))).\nset (b := / 2 * (u1 - u2)).\nset (b' := / 2 * (u1 + u2)).\nunfold midp; rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, sqrt_lt_R0.\napply Rnot_ge_lt; intro H; apply Rge_le in H.\nassert (Fa : generic_format beta fexp1 a).\nunfold a.\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN.\nrevert Fa; revert Fx.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (ma := Ztrunc (a * bpow (- fexp1 (mag a)))).\nintros Fx Fa.\nassert (Nna : 0 <= a).\nrewrite <- (round_0 beta fexp1 Zfloor).\nunfold a; apply round_le.\nexact Vfexp1.\nnow apply valid_rnd_DN.\napply sqrt_pos.\nassert (Phu1 : 0 < / 2 * u1).\napply Rmult_lt_0_compat; [lra|apply bpow_gt_0].\nassert (Phu2 : 0 < / 2 * u2).\napply Rmult_lt_0_compat; [lra|apply bpow_gt_0].\nassert (Pb : 0 < b).\nunfold b.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply Rlt_Rminus.\nunfold u2, u1.\napply bpow_lt.\nlia.\nassert (Pb' : 0 < b').\nnow unfold b'; rewrite Rmult_plus_distr_l; apply Rplus_lt_0_compat.\nassert (Hr : sqrt x <= a + b').\nunfold b'; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.\nreplace (_ - _) with (sqrt x - (a + / 2 * u1)) by ring.\nnow apply Rabs_le_inv.\nassert (Hl : a + b <= sqrt x).\nunfold b; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.\nreplace (_ + sqrt _) with (sqrt x - (a + / 2 * u1)) by ring.\nrewrite Ropp_mult_distr_l_reverse.\nnow apply Rabs_le_inv in H; destruct H.\nassert (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag (x)))%Z);  [destruct (mag_sqrt_disj x Px) as [H'|H']; rewrite H'; apply Hexp|].\nassert (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nassert (Hsl : a * a + u1 * a - u2 * a + b * b <= x).\nreplace (_ + _) with ((a + b) * (a + b)); [|now unfold b; field].\nrewrite <- sqrt_def; [|now apply Rlt_le].\nassert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat.\nassert (Hsr : x <= a * a + u1 * a + u2 * a + b' * b').\nreplace (_ + _) with ((a + b') * (a + b')); [|now unfold b'; field].\nrewrite <- (sqrt_def x); [|now apply Rlt_le].\nassert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat.\ndestruct (Req_dec a 0) as [Za|Nza].\napply (Rlt_irrefl 0).\napply Rlt_le_trans with (b * b); [now apply Rmult_lt_0_compat|].\napply Rle_trans with x.\nrevert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.\nnow rewrite Ropp_0; do 3 rewrite Rplus_0_l.\nrewrite Fx.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_0_l; bpow_simplify.\nunfold mx.\nrewrite Ztrunc_floor;      [|now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]].\napply Req_le, IZR_eq.\napply Zfloor_imp.\nsplit; [now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]|simpl].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (2 * fexp1 (mag (sqrt x))));      [|now apply bpow_le].\nchange 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.\nrewrite bpow_plus.\nrewrite <- (sqrt_def x) at 1; [|now apply Rlt_le].\nassert (sqrt x < bpow (fexp1 (mag (sqrt x))));      [|now apply Rmult_lt_compat; [apply sqrt_pos|apply sqrt_pos| |]].\napply (Rle_lt_trans _ _ _ Hr); rewrite Za; rewrite Rplus_0_l.\nunfold b'; change (bpow _) with u1.\napply Rlt_le_trans with (/ 2 * (u1 + u1)); [|lra].\napply Rmult_lt_compat_l; [lra|]; apply Rplus_lt_compat_l.\nunfold u2, u1, ulp, cexp; apply bpow_lt; lia.\nassert (Pa : 0 < a); [lra|].\nassert (Hla : (mag a = mag (sqrt x) :> Z)).\nunfold a; apply mag_DN.\nexact Vfexp1.\nnow fold a.\nassert (Hl' : 0 < - (u2 * a) + b * b).\napply (Rplus_lt_reg_r (u2 * a)); ring_simplify.\nunfold b; ring_simplify.\napply (Rplus_lt_reg_r (/ 2 * u2 * u1)); field_simplify.\nreplace (_ / 2) with (u2 * (a + / 2 * u1)) by field.\nreplace (_ / 8) with (/ 4 * (u2 ^ 2 + u1 ^ 2)) by field.\napply Rlt_le_trans with (u2 * bpow (mag (sqrt x))).\napply Rmult_lt_compat_l; [now unfold u2, ulp; apply bpow_gt_0|].\nunfold u1; rewrite <- Hla.\napply Rlt_le_trans with (a + bpow (fexp1 (mag a))).\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l (bpow _)) at 2.\napply Rmult_lt_compat_r; [apply bpow_gt_0|lra].\napply Rle_trans with (a+ ulp beta fexp1 a).\nright; now rewrite ulp_neq_0.\napply (id_p_ulp_le_bpow _ _ _ _ Pa Fa).\napply Rabs_lt_inv, bpow_mag_gt.\napply Rle_trans with (bpow (- 2) * u1 ^ 2).\nunfold pow; rewrite Rmult_1_r.\nunfold u1, u2, ulp, cexp; bpow_simplify; apply bpow_le.\nnow apply Hexp.\napply Rmult_le_compat.\napply bpow_ge_0.\napply pow2_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\napply Rinv_le; [lra|].\nchange 4%Z with (2 * 2)%Z; apply IZR_le, Zmult_le_compat; lia.\nrewrite <- (Rplus_0_l (u1 ^ 2)) at 1; apply Rplus_le_compat_r.\napply pow2_ge_0.\nassert (Hr' : x <= a * a + u1 * a).\nrewrite Hla in Fa.\nrewrite <- Rmult_plus_distr_r.\nunfold u1, ulp, cexp.\nrewrite <- (Rmult_1_l (bpow _)); rewrite Fa; rewrite <- Rmult_plus_distr_r.\nrewrite <- Rmult_assoc; rewrite (Rmult_comm _ (IZR ma)).\nrewrite <- (Rmult_assoc (IZR ma)); bpow_simplify.\napply (Rmult_le_reg_r (bpow (- 2 * fexp1 (mag (sqrt x)))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Fx at 1; bpow_simplify.\nrewrite <- IZR_Zpower by lia.\nrewrite <- plus_IZR, <- 2!mult_IZR.\napply IZR_le, Zlt_succ_le, lt_IZR.\nunfold Z.succ; rewrite plus_IZR; do 2 rewrite mult_IZR; rewrite plus_IZR.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (2 * fexp1 (mag (sqrt x)))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite <- Fx.\nchange 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.\nrewrite bpow_plus; simpl.\nreplace (_ * _) with (a * a + u1 * a + u1 * u1);      [|unfold u1, ulp, cexp; rewrite Fa; ring].\napply (Rle_lt_trans _ _ _ Hsr).\nrewrite Rplus_assoc; apply Rplus_lt_compat_l.\napply (Rplus_lt_reg_r (- b' * b' + / 2 * u1 * u2)); ring_simplify.\nreplace (_ + _) with ((a + / 2 * u1) * u2) by ring.\napply Rlt_le_trans with (bpow (mag (sqrt x)) * u2).\napply Rmult_lt_compat_r; [now unfold u2, ulp; apply bpow_gt_0|].\napply Rlt_le_trans with (a + u1); [lra|].\nunfold u1; fold (cexp beta fexp1 (sqrt x)).\nrewrite <- cexp_DN; [|exact Vfexp1|exact Pa]; fold a.\nrewrite <- ulp_neq_0; trivial.\napply id_p_ulp_le_bpow.\nexact Pa.\nnow apply round_DN_pt.\napply Rle_lt_trans with (sqrt x).\nnow apply round_DN_pt.\napply Rabs_lt_inv.\napply bpow_mag_gt.\napply Rle_trans with (/ 2 * u1 ^ 2).\napply Rle_trans with (bpow (- 2) * u1 ^ 2).\nunfold pow; rewrite Rmult_1_r.\nunfold u2, u1, ulp, cexp.\nbpow_simplify.\napply bpow_le.\nrewrite Zplus_comm.\nnow apply Hexp.\napply Rmult_le_compat_r; [now apply pow2_ge_0|].\nunfold Raux.bpow; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\napply IZR_le.\nrewrite <- (Zmult_1_l 2).\napply Zmult_le_compat; lia.\nassert (u2 ^ 2 < u1 ^ 2); [|unfold b'; lra].\nunfold pow; do 2 rewrite Rmult_1_r.\nassert (H' : 0 <= u2); [unfold u2, ulp; apply bpow_ge_0|].\nassert (u2 < u1); [|now apply Rmult_lt_compat].\nunfold u1, u2, ulp, cexp; apply bpow_lt; lia.\napply (Rlt_irrefl (a * a + u1 * a)).\napply Rlt_le_trans with (a * a + u1 * a - u2 * a + b * b).\nrewrite <- (Rplus_0_r (a * a + _)) at 1.\nunfold Rminus; rewrite (Rplus_assoc _ _ (b * b)).\nnow apply Rplus_lt_compat_l.\nnow apply Rle_trans with x."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) : (2 <= beta)%Z.","proofString":"destruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) (Hf2 : (fexp2\n   (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} (sqrt x)) <=\n fexp1\n   (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} (sqrt x)) -\n 1)%Z) (Fx : generic_format {| radix_val := beta_val; radix_prop := beta_prop |} fexp1 x) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","proofString":"now apply Zle_bool_imp_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Hbeta : (2 <= beta)%Z) : / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).","proofString":"set (a := round beta fexp1 Zfloor (sqrt x)).\nset (u1 := bpow (fexp1 (mag (sqrt x)))).\nset (u2 := bpow (fexp2 (mag (sqrt x)))).\nset (b := / 2 * (u1 - u2)).\nset (b' := / 2 * (u1 + u2)).\nunfold midp; rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, sqrt_lt_R0.\napply Rnot_ge_lt; intro H; apply Rge_le in H.\nassert (Fa : generic_format beta fexp1 a).\nunfold a.\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN.\nrevert Fa; revert Fx.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (ma := Ztrunc (a * bpow (- fexp1 (mag a)))).\nintros Fx Fa.\nassert (Nna : 0 <= a).\nrewrite <- (round_0 beta fexp1 Zfloor).\nunfold a; apply round_le.\nexact Vfexp1.\nnow apply valid_rnd_DN.\napply sqrt_pos.\nassert (Phu1 : 0 < / 2 * u1).\napply Rmult_lt_0_compat; [lra|apply bpow_gt_0].\nassert (Phu2 : 0 < / 2 * u2).\napply Rmult_lt_0_compat; [lra|apply bpow_gt_0].\nassert (Pb : 0 < b).\nunfold b.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply Rlt_Rminus.\nunfold u2, u1.\napply bpow_lt.\nlia.\nassert (Pb' : 0 < b').\nnow unfold b'; rewrite Rmult_plus_distr_l; apply Rplus_lt_0_compat.\nassert (Hr : sqrt x <= a + b').\nunfold b'; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.\nreplace (_ - _) with (sqrt x - (a + / 2 * u1)) by ring.\nnow apply Rabs_le_inv.\nassert (Hl : a + b <= sqrt x).\nunfold b; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.\nreplace (_ + sqrt _) with (sqrt x - (a + / 2 * u1)) by ring.\nrewrite Ropp_mult_distr_l_reverse.\nnow apply Rabs_le_inv in H; destruct H.\nassert (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag (x)))%Z);  [destruct (mag_sqrt_disj x Px) as [H'|H']; rewrite H'; apply Hexp|].\nassert (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nassert (Hsl : a * a + u1 * a - u2 * a + b * b <= x).\nreplace (_ + _) with ((a + b) * (a + b)); [|now unfold b; field].\nrewrite <- sqrt_def; [|now apply Rlt_le].\nassert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat.\nassert (Hsr : x <= a * a + u1 * a + u2 * a + b' * b').\nreplace (_ + _) with ((a + b') * (a + b')); [|now unfold b'; field].\nrewrite <- (sqrt_def x); [|now apply Rlt_le].\nassert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat.\ndestruct (Req_dec a 0) as [Za|Nza].\napply (Rlt_irrefl 0).\napply Rlt_le_trans with (b * b); [now apply Rmult_lt_0_compat|].\napply Rle_trans with x.\nrevert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.\nnow rewrite Ropp_0; do 3 rewrite Rplus_0_l.\nrewrite Fx.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_0_l; bpow_simplify.\nunfold mx.\nrewrite Ztrunc_floor;      [|now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]].\napply Req_le, IZR_eq.\napply Zfloor_imp.\nsplit; [now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]|simpl].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (2 * fexp1 (mag (sqrt x))));      [|now apply bpow_le].\nchange 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.\nrewrite bpow_plus.\nrewrite <- (sqrt_def x) at 1; [|now apply Rlt_le].\nassert (sqrt x < bpow (fexp1 (mag (sqrt x))));      [|now apply Rmult_lt_compat; [apply sqrt_pos|apply sqrt_pos| |]].\napply (Rle_lt_trans _ _ _ Hr); rewrite Za; rewrite Rplus_0_l.\nunfold b'; change (bpow _) with u1.\napply Rlt_le_trans with (/ 2 * (u1 + u1)); [|lra].\napply Rmult_lt_compat_l; [lra|]; apply Rplus_lt_compat_l.\nunfold u2, u1, ulp, cexp; apply bpow_lt; lia.\nassert (Pa : 0 < a); [lra|].\nassert (Hla : (mag a = mag (sqrt x) :> Z)).\nunfold a; apply mag_DN.\nexact Vfexp1.\nnow fold a.\nassert (Hl' : 0 < - (u2 * a) + b * b).\napply (Rplus_lt_reg_r (u2 * a)); ring_simplify.\nunfold b; ring_simplify.\napply (Rplus_lt_reg_r (/ 2 * u2 * u1)); field_simplify.\nreplace (_ / 2) with (u2 * (a + / 2 * u1)) by field.\nreplace (_ / 8) with (/ 4 * (u2 ^ 2 + u1 ^ 2)) by field.\napply Rlt_le_trans with (u2 * bpow (mag (sqrt x))).\napply Rmult_lt_compat_l; [now unfold u2, ulp; apply bpow_gt_0|].\nunfold u1; rewrite <- Hla.\napply Rlt_le_trans with (a + bpow (fexp1 (mag a))).\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l (bpow _)) at 2.\napply Rmult_lt_compat_r; [apply bpow_gt_0|lra].\napply Rle_trans with (a+ ulp beta fexp1 a).\nright; now rewrite ulp_neq_0.\napply (id_p_ulp_le_bpow _ _ _ _ Pa Fa).\napply Rabs_lt_inv, bpow_mag_gt.\napply Rle_trans with (bpow (- 2) * u1 ^ 2).\nunfold pow; rewrite Rmult_1_r.\nunfold u1, u2, ulp, cexp; bpow_simplify; apply bpow_le.\nnow apply Hexp.\napply Rmult_le_compat.\napply bpow_ge_0.\napply pow2_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\napply Rinv_le; [lra|].\nchange 4%Z with (2 * 2)%Z; apply IZR_le, Zmult_le_compat; lia.\nrewrite <- (Rplus_0_l (u1 ^ 2)) at 1; apply Rplus_le_compat_r.\napply pow2_ge_0.\nassert (Hr' : x <= a * a + u1 * a).\nrewrite Hla in Fa.\nrewrite <- Rmult_plus_distr_r.\nunfold u1, ulp, cexp.\nrewrite <- (Rmult_1_l (bpow _)); rewrite Fa; rewrite <- Rmult_plus_distr_r.\nrewrite <- Rmult_assoc; rewrite (Rmult_comm _ (IZR ma)).\nrewrite <- (Rmult_assoc (IZR ma)); bpow_simplify.\napply (Rmult_le_reg_r (bpow (- 2 * fexp1 (mag (sqrt x)))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Fx at 1; bpow_simplify.\nrewrite <- IZR_Zpower by lia.\nrewrite <- plus_IZR, <- 2!mult_IZR.\napply IZR_le, Zlt_succ_le, lt_IZR.\nunfold Z.succ; rewrite plus_IZR; do 2 rewrite mult_IZR; rewrite plus_IZR.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (2 * fexp1 (mag (sqrt x)))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite <- Fx.\nchange 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.\nrewrite bpow_plus; simpl.\nreplace (_ * _) with (a * a + u1 * a + u1 * u1);      [|unfold u1, ulp, cexp; rewrite Fa; ring].\napply (Rle_lt_trans _ _ _ Hsr).\nrewrite Rplus_assoc; apply Rplus_lt_compat_l.\napply (Rplus_lt_reg_r (- b' * b' + / 2 * u1 * u2)); ring_simplify.\nreplace (_ + _) with ((a + / 2 * u1) * u2) by ring.\napply Rlt_le_trans with (bpow (mag (sqrt x)) * u2).\napply Rmult_lt_compat_r; [now unfold u2, ulp; apply bpow_gt_0|].\napply Rlt_le_trans with (a + u1); [lra|].\nunfold u1; fold (cexp beta fexp1 (sqrt x)).\nrewrite <- cexp_DN; [|exact Vfexp1|exact Pa]; fold a.\nrewrite <- ulp_neq_0; trivial.\napply id_p_ulp_le_bpow.\nexact Pa.\nnow apply round_DN_pt.\napply Rle_lt_trans with (sqrt x).\nnow apply round_DN_pt.\napply Rabs_lt_inv.\napply bpow_mag_gt.\napply Rle_trans with (/ 2 * u1 ^ 2).\napply Rle_trans with (bpow (- 2) * u1 ^ 2).\nunfold pow; rewrite Rmult_1_r.\nunfold u2, u1, ulp, cexp.\nbpow_simplify.\napply bpow_le.\nrewrite Zplus_comm.\nnow apply Hexp.\napply Rmult_le_compat_r; [now apply pow2_ge_0|].\nunfold Raux.bpow; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\napply IZR_le.\nrewrite <- (Zmult_1_l 2).\napply Zmult_le_compat; lia.\nassert (u2 ^ 2 < u1 ^ 2); [|unfold b'; lra].\nunfold pow; do 2 rewrite Rmult_1_r.\nassert (H' : 0 <= u2); [unfold u2, ulp; apply bpow_ge_0|].\nassert (u2 < u1); [|now apply Rmult_lt_compat].\nunfold u1, u2, ulp, cexp; apply bpow_lt; lia.\napply (Rlt_irrefl (a * a + u1 * a)).\napply Rlt_le_trans with (a * a + u1 * a - u2 * a + b * b).\nrewrite <- (Rplus_0_r (a * a + _)) at 1.\nunfold Rminus; rewrite (Rplus_assoc _ _ (b * b)).\nnow apply Rplus_lt_compat_l.\nnow apply Rle_trans with x."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) : generic_format beta fexp1 (round beta fexp1 Zfloor (sqrt x)).","proofString":"apply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) : Valid_rnd Zfloor.","proofString":"now apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) : Valid_rnd Zfloor.","proofString":"now apply valid_rnd_DN."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) : 0 <= sqrt x.","proofString":"apply sqrt_pos."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) : bpow (fexp2 (mag (sqrt x))) < bpow (fexp1 (mag (sqrt x))).","proofString":"apply bpow_lt.\nlia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) : (fexp2 (mag (sqrt x)) < fexp1 (mag (sqrt x)))%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) : (a + b) * (a + b) <= x.","proofString":"rewrite <- sqrt_def; [|now apply Rlt_le].\nassert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) : (a + b) * (a + b) <= sqrt x * sqrt x.","proofString":"assert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (H' : 0 <= a + b) : (a + b) * (a + b) <= sqrt x * sqrt x.","proofString":"now apply Rmult_le_compat."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) : x <= (a + b') * (a + b').","proofString":"rewrite <- (sqrt_def x); [|now apply Rlt_le].\nassert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) : sqrt x * sqrt x <= (a + b') * (a + b').","proofString":"assert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) (H' : 0 <= sqrt x) : sqrt x * sqrt x <= (a + b') * (a + b').","proofString":"now apply Rmult_le_compat."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) (Hsr : x <= a * a + u1 * a + u2 * a + b' * b') (Za : a = 0) : b * b <= x.","proofString":"revert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.\nnow rewrite Ropp_0; do 3 rewrite Rplus_0_l."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsr : x <= a * a + u1 * a + u2 * a + b' * b') (Za : a = 0) : 0 + 0 + - 0 + b * b <= x -> b * b <= x.","proofString":"now rewrite Ropp_0; do 3 rewrite Rplus_0_l."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hbeta : (2 <= beta)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) (Hsr : x <= a * a + u1 * a + u2 * a + b' * b') (Nza : a <> 0) (Pa : 0 < a) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 (sqrt x).","proofString":"unfold round_round_eq.\ndestruct (Rle_or_lt x 0) as [Npx|Px].\nrewrite (sqrt_neg _ Npx).\nnow rewrite round_0; [|apply valid_rnd_N].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; try assumption; lra|].\nassert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"destruct (Rle_or_lt x 0) as [Npx|Px].\nrewrite (sqrt_neg _ Npx).\nnow rewrite round_0; [|apply valid_rnd_N].\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; try assumption; lra|].\nassert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"rewrite (sqrt_neg _ Npx).\nnow rewrite round_0; [|apply valid_rnd_N]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) 0) =\nround beta fexp1 (Znearest choice1) 0.","proofString":"now rewrite round_0; [|apply valid_rnd_N]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; try assumption; lra|].\nassert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"destruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"apply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : (mag x <= mag (sqrt x))%Z.","proofString":"apply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : x <= sqrt x.","proofString":"rewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x * sqrt x <= sqrt x.","proofString":"rewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x * sqrt x <= sqrt x * 1.","proofString":"apply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : 0 <= sqrt x.","proofString":"apply sqrt_pos."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x <= 1.","proofString":"rewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x <= sqrt 1.","proofString":"now apply sqrt_le_1_alt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"generalize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) : (2 * fexp1 1 <= fexp1 (2 * 1 - 1))%Z ->\n(fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"replace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) : (2 * fexp1 1 <= fexp1 1)%Z -> (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"intro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hexp10 : (2 * fexp1 1 <= fexp1 1)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"assert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hexp10 : (2 * fexp1 1 <= fexp1 1)%Z) (Hf0 : (fexp1 1 < 1)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"clear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"apply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : (1 <= mag (sqrt x))%Z.","proofString":"apply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : bpow (1 - 1) <= Rabs (sqrt x).","proofString":"rewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : bpow 0 <= Rabs (sqrt x).","proofString":"unfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : 1 <= Rabs (sqrt x).","proofString":"apply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : 1 <= sqrt x.","proofString":"rewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : sqrt 1 <= sqrt x.","proofString":"apply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : 1 <= x.","proofString":"now apply Rlt_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z.","proofString":"destruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : 0 < sqrt x.","proofString":"now apply sqrt_lt_R0."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : (fexp1 (mag (sqrt x)) <= mag (sqrt x))%Z.","proofString":"lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : Rabs (sqrt x - midp fexp1 (sqrt x)) <= / 2 * ulp beta fexp2 (sqrt x) ->\nround_round_eq fexp1 fexp2 choice1 choice2 (sqrt x).","proofString":"intros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hmid : Rabs (sqrt x - midp fexp1 (sqrt x)) <= / 2 * ulp beta fexp2 (sqrt x)) : / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).","proofString":"apply (round_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx)."},{"statement":"(Hprec : (2 * prec + 2 <= prec')%Z) : round_round_sqrt_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"unfold FLX_exp.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_hyp; split; [|split]; intro ex; lia."},{"statement":"(Hprec : (2 * prec + 2 <= prec')%Z) : round_round_sqrt_hyp (fun e : Z => (e - prec)%Z) (fun e : Z => (e - prec')%Z).","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_hyp; split; [|split]; intro ex; lia."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : round_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (sqrt x).","proofString":"apply round_round_sqrt.\nnow apply FLX_exp_valid.\nnow apply FLX_exp_valid.\nnow apply FLX_round_round_sqrt_hyp.\nnow apply generic_format_FLX."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : Valid_exp (FLX_exp prec).","proofString":"now apply FLX_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : Valid_exp (FLX_exp prec').","proofString":"now apply FLX_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : round_round_sqrt_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"now apply FLX_round_round_sqrt_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : generic_format beta (FLX_exp prec) x.","proofString":"now apply generic_format_FLX."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) : round_round_sqrt_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"unfold FLT_exp.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_hyp; split; [|split]; intros ex.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - 1 - prec) emin).\nlia.\ngeneralize (Zmax_spec (2 * ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) : round_round_sqrt_hyp (fun e : Z => Z.max (e - prec) emin)\n  (fun e : Z => Z.max (e - prec') emin').","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_hyp; split; [|split]; intros ex.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - 1 - prec) emin).\nlia.\ngeneralize (Zmax_spec (2 * ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (ex : Z) : (2 * ex - prec >= emin)%Z /\\ Z.max (2 * ex - prec) emin = (2 * ex - prec)%Z \\/\n(2 * ex - prec < emin)%Z /\\ Z.max (2 * ex - prec) emin = emin ->\n(Z.max (2 * ex - prec) emin < 2 * ex)%Z ->\n(Z.max (ex - prec') emin' + ex <= 2 * Z.max (ex - prec) emin - 2)%Z.","proofString":"generalize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (ex : Z) : (ex - prec' >= emin')%Z /\\ Z.max (ex - prec') emin' = (ex - prec')%Z \\/\n(ex - prec' < emin')%Z /\\ Z.max (ex - prec') emin' = emin' ->\n(2 * ex - prec >= emin)%Z /\\ Z.max (2 * ex - prec) emin = (2 * ex - prec)%Z \\/\n(2 * ex - prec < emin)%Z /\\ Z.max (2 * ex - prec) emin = emin ->\n(Z.max (2 * ex - prec) emin < 2 * ex)%Z ->\n(Z.max (ex - prec') emin' + ex <= 2 * Z.max (ex - prec) emin - 2)%Z.","proofString":"generalize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (ex : Z) : (ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(ex - prec' >= emin')%Z /\\ Z.max (ex - prec') emin' = (ex - prec')%Z \\/\n(ex - prec' < emin')%Z /\\ Z.max (ex - prec') emin' = emin' ->\n(2 * ex - prec >= emin)%Z /\\ Z.max (2 * ex - prec) emin = (2 * ex - prec)%Z \\/\n(2 * ex - prec < emin)%Z /\\ Z.max (2 * ex - prec) emin = emin ->\n(Z.max (2 * ex - prec) emin < 2 * ex)%Z ->\n(Z.max (ex - prec') emin' + ex <= 2 * Z.max (ex - prec) emin - 2)%Z.","proofString":"lia."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : round_round_eq (FLT_exp emin prec) (FLT_exp emin' prec') choice1 choice2\n  (sqrt x).","proofString":"apply round_round_sqrt.\nnow apply FLT_exp_valid.\nnow apply FLT_exp_valid.\nnow apply FLT_round_round_sqrt_hyp.\nnow apply generic_format_FLT."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : Valid_exp (FLT_exp emin prec).","proofString":"now apply FLT_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : Valid_exp (FLT_exp emin' prec').","proofString":"now apply FLT_exp_valid."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : round_round_sqrt_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"now apply FLT_round_round_sqrt_hyp."},{"statement":"(choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 2)%Z \\/ (2 * emin' <= emin - 4 * prec - 2)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : generic_format beta (FLT_exp emin prec) x.","proofString":"now apply generic_format_FLT."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) : round_round_sqrt_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"unfold FTZ_exp.\nunfold Prec_gt_0 in *.\nunfold round_round_sqrt_hyp; split; [|split]; intros ex.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - 1 - prec) emin);  lia.\nintro H.\ndestruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].\ndestruct (Z.ltb_spec (ex - prec') emin');    destruct (Z.ltb_spec (ex - prec) emin);    lia.\nexfalso.\nrewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) : round_round_sqrt_hyp\n  (fun e : Z =>\n   if (e - prec <? emin)%Z then (emin + prec - 1)%Z else (e - prec)%Z)\n  (fun e : Z =>\n   if (e - prec' <? emin')%Z then (emin' + prec' - 1)%Z else (e - prec')%Z).","proofString":"unfold Prec_gt_0 in *.\nunfold round_round_sqrt_hyp; split; [|split]; intros ex.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - 1 - prec) emin);  lia.\nintro H.\ndestruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].\ndestruct (Z.ltb_spec (ex - prec') emin');    destruct (Z.ltb_spec (ex - prec) emin);    lia.\nexfalso.\nrewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (ex : Z) (H : ((if 2 * ex - prec <? emin then emin + prec - 1 else 2 * ex - prec) < 2 * ex)%Z) : ((if ex - prec' <? emin' then emin' + prec' - 1 else ex - prec') + ex <=\n 2 * (if ex - prec <? emin then emin + prec - 1 else ex - prec) - 2)%Z.","proofString":"destruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].\ndestruct (Z.ltb_spec (ex - prec') emin');    destruct (Z.ltb_spec (ex - prec) emin);    lia.\nexfalso.\nrewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (ex : Z) (H : ((if 2 * ex - prec <? emin then emin + prec - 1 else 2 * ex - prec) < 2 * ex)%Z) (H' : (2 * ex - prec < emin)%Z) : False.","proofString":"rewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (ex : Z) (H : (emin + prec - 1 < 2 * ex)%Z) (H' : (2 * ex - prec < emin)%Z) : False.","proofString":"lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : round_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec') choice1 choice2\n  (sqrt x).","proofString":"apply round_round_sqrt.\nnow apply FTZ_exp_valid.\nnow apply FTZ_exp_valid.\nnow apply FTZ_round_round_sqrt_hyp.\nnow apply generic_format_FTZ."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : Valid_exp (FTZ_exp emin prec).","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : Valid_exp (FTZ_exp emin' prec').","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : round_round_sqrt_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"now apply FTZ_round_round_sqrt_hyp."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 2 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : generic_format beta (FTZ_exp emin prec) x.","proofString":"now apply generic_format_FTZ."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) : / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).","proofString":"set (a := round beta fexp1 Zfloor (sqrt x)).\nset (u1 := bpow (fexp1 (mag (sqrt x)))).\nset (u2 := bpow (fexp2 (mag (sqrt x)))).\nset (b := / 2 * (u1 - u2)).\nset (b' := / 2 * (u1 + u2)).\nunfold midp; rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, sqrt_lt_R0.\napply Rnot_ge_lt; intro H; apply Rge_le in H.\nassert (Fa : generic_format beta fexp1 a).\nunfold a.\napply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN.\nrevert Fa; revert Fx.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (ma := Ztrunc (a * bpow (- fexp1 (mag a)))).\nintros Fx Fa.\nassert (Nna : 0 <= a).\nrewrite <- (round_0 beta fexp1 Zfloor).\nunfold a; apply round_le.\nexact Vfexp1.\nnow apply valid_rnd_DN.\napply sqrt_pos.\nassert (Phu1 : 0 < / 2 * u1).\napply Rmult_lt_0_compat; [lra|apply bpow_gt_0].\nassert (Phu2 : 0 < / 2 * u2).\napply Rmult_lt_0_compat; [lra|apply bpow_gt_0].\nassert (Pb : 0 < b).\nunfold b.\nrewrite <- (Rmult_0_r (/ 2)).\napply Rmult_lt_compat_l; [lra|].\napply Rlt_Rminus.\nunfold u2, u1, ulp, cexp.\napply bpow_lt.\nlia.\nassert (Pb' : 0 < b').\nnow unfold b'; rewrite Rmult_plus_distr_l; apply Rplus_lt_0_compat.\nassert (Hr : sqrt x <= a + b').\nunfold b'; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.\nreplace (_ - _) with (sqrt x - (a + / 2 * u1)) by ring.\nnow apply Rabs_le_inv.\nassert (Hl : a + b <= sqrt x).\nunfold b; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.\nreplace (_ + sqrt _) with (sqrt x - (a + / 2 * u1)) by ring.\nrewrite Ropp_mult_distr_l_reverse.\nnow apply Rabs_le_inv in H; destruct H.\nassert (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag (x)))%Z);  [destruct (mag_sqrt_disj x Px) as [H'|H']; rewrite H'; apply Hexp|].\nassert (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nassert (Hsl : a * a + u1 * a - u2 * a + b * b <= x).\nreplace (_ + _) with ((a + b) * (a + b)); [|now unfold b; field].\nrewrite <- sqrt_def; [|now apply Rlt_le].\nassert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat.\nassert (Hsr : x <= a * a + u1 * a + u2 * a + b' * b').\nreplace (_ + _) with ((a + b') * (a + b')); [|now unfold b'; field].\nrewrite <- (sqrt_def x); [|now apply Rlt_le].\nassert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat.\ndestruct (Req_dec a 0) as [Za|Nza].\napply (Rlt_irrefl 0).\napply Rlt_le_trans with (b * b); [now apply Rmult_lt_0_compat|].\napply Rle_trans with x.\nrevert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.\nnow rewrite Ropp_0; do 3 rewrite Rplus_0_l.\nrewrite Fx.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_0_l; bpow_simplify.\nunfold mx.\nrewrite Ztrunc_floor;      [|now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]].\napply Req_le, IZR_eq.\napply Zfloor_imp.\nsplit; [now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]|simpl].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x)))); [now apply bpow_gt_0|].\nrewrite Rmult_1_l; bpow_simplify.\napply Rlt_le_trans with (bpow (2 * fexp1 (mag (sqrt x))));      [|now apply bpow_le].\nchange 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.\nrewrite bpow_plus.\nrewrite <- (sqrt_def x) at 1; [|now apply Rlt_le].\nassert (sqrt x < bpow (fexp1 (mag (sqrt x))));      [|now apply Rmult_lt_compat; [apply sqrt_pos|apply sqrt_pos| |]].\napply (Rle_lt_trans _ _ _ Hr); rewrite Za; rewrite Rplus_0_l.\nunfold b'; change (bpow _) with u1.\napply Rlt_le_trans with (/ 2 * (u1 + u1)); [|lra].\napply Rmult_lt_compat_l; [lra|]; apply Rplus_lt_compat_l.\nunfold u2, u1, ulp, cexp; apply bpow_lt; lia.\nassert (Pa : 0 < a); [lra|].\nassert (Hla : (mag a = mag (sqrt x) :> Z)).\nunfold a; apply mag_DN.\nexact Vfexp1.\nnow fold a.\nassert (Hl' : 0 < - (u2 * a) + b * b).\napply (Rplus_lt_reg_r (u2 * a)); ring_simplify.\nunfold b; ring_simplify.\napply (Rplus_lt_reg_r (/ 2 * u2 * u1)); field_simplify.\nreplace (_ / 2) with (u2 * (a + / 2 * u1)) by field.\nreplace (_ / 8) with (/ 4 * (u2 ^ 2 + u1 ^ 2)) by field.\napply Rlt_le_trans with (u2 * bpow (mag (sqrt x))).\napply Rmult_lt_compat_l; [now unfold u2, ulp; apply bpow_gt_0|].\nunfold u1; rewrite <- Hla.\napply Rlt_le_trans with (a + ulp beta fexp1 a).\napply Rplus_lt_compat_l.\nrewrite <- (Rmult_1_l (ulp _ _ _)).\nrewrite ulp_neq_0; trivial.\napply Rmult_lt_compat_r; [apply bpow_gt_0|lra].\napply (id_p_ulp_le_bpow _ _ _ _ Pa Fa).\napply Rabs_lt_inv, bpow_mag_gt.\napply Rle_trans with (bpow (- 1) * u1 ^ 2).\nunfold pow; rewrite Rmult_1_r.\nunfold u1, u2, ulp, cexp; bpow_simplify; apply bpow_le.\nnow apply Hexp.\napply Rmult_le_compat.\napply bpow_ge_0.\napply pow2_ge_0.\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\napply Rinv_le; [lra|].\nnow apply IZR_le.\nrewrite <- (Rplus_0_l (u1 ^ 2)) at 1; apply Rplus_le_compat_r.\napply pow2_ge_0.\nassert (Hr' : x <= a * a + u1 * a).\nrewrite Hla in Fa.\nrewrite <- Rmult_plus_distr_r.\nunfold u1, ulp, cexp.\nrewrite <- (Rmult_1_l (bpow _)); rewrite Fa; rewrite <- Rmult_plus_distr_r.\nrewrite <- Rmult_assoc; rewrite (Rmult_comm _ (IZR ma)).\nrewrite <- (Rmult_assoc (IZR ma)); bpow_simplify.\napply (Rmult_le_reg_r (bpow (- 2 * fexp1 (mag (sqrt x)))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Fx at 1; bpow_simplify.\nrewrite <- IZR_Zpower by lia.\nrewrite <- plus_IZR, <- 2!mult_IZR.\napply IZR_le, Zlt_succ_le, lt_IZR.\nunfold Z.succ; rewrite plus_IZR; do 2 rewrite mult_IZR; rewrite plus_IZR.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (2 * fexp1 (mag (sqrt x)))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite <- Fx.\nchange 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.\nrewrite bpow_plus; simpl.\nreplace (_ * _) with (a * a + u1 * a + u1 * u1);      [|unfold u1, ulp, cexp; rewrite Fa; ring].\napply (Rle_lt_trans _ _ _ Hsr).\nrewrite Rplus_assoc; apply Rplus_lt_compat_l.\napply (Rplus_lt_reg_r (- b' * b' + / 2 * u1 * u2)); ring_simplify.\nreplace (_ + _) with ((a + / 2 * u1) * u2) by ring.\napply Rlt_le_trans with (bpow (mag (sqrt x)) * u2).\napply Rmult_lt_compat_r; [now unfold u2, ulp; apply bpow_gt_0|].\napply Rlt_le_trans with (a + u1); [lra|].\nunfold u1; fold (cexp beta fexp1 (sqrt x)).\nrewrite <- cexp_DN; [|exact Vfexp1|exact Pa]; fold a.\nrewrite <- ulp_neq_0; trivial.\napply id_p_ulp_le_bpow.\nexact Pa.\nnow apply round_DN_pt.\napply Rle_lt_trans with (sqrt x).\nnow apply round_DN_pt.\napply Rabs_lt_inv.\napply bpow_mag_gt.\napply Rle_trans with (/ 2 * u1 ^ 2).\napply Rle_trans with (bpow (- 1) * u1 ^ 2).\nunfold pow; rewrite Rmult_1_r.\nunfold u2, u1, ulp, cexp.\nbpow_simplify.\napply bpow_le.\nrewrite Zplus_comm.\nnow apply Hexp.\napply Rmult_le_compat_r; [now apply pow2_ge_0|].\nunfold Raux.bpow; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [lra|].\napply IZR_le; lia.\nassert (u2 ^ 2 < u1 ^ 2); [|unfold b'; lra].\nunfold pow; do 2 rewrite Rmult_1_r.\nassert (H' : 0 <= u2); [unfold u2, ulp; apply bpow_ge_0|].\nassert (u2 < u1); [|now apply Rmult_lt_compat].\nunfold u1, u2, ulp, cexp; apply bpow_lt; lia.\napply (Rlt_irrefl (a * a + u1 * a)).\napply Rlt_le_trans with (a * a + u1 * a - u2 * a + b * b).\nrewrite <- (Rplus_0_r (a * a + _)) at 1.\nunfold Rminus; rewrite (Rplus_assoc _ _ (b * b)).\nnow apply Rplus_lt_compat_l.\nnow apply Rle_trans with x."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) : generic_format beta fexp1 (round beta fexp1 Zfloor (sqrt x)).","proofString":"apply generic_format_round.\nexact Vfexp1.\nnow apply valid_rnd_DN."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Fx : generic_format beta fexp1 x) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) : Valid_rnd Zfloor.","proofString":"now apply valid_rnd_DN."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) : Valid_rnd Zfloor.","proofString":"now apply valid_rnd_DN."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) : 0 <= sqrt x.","proofString":"apply sqrt_pos."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) : bpow (fexp2 (mag (sqrt x))) < bpow (fexp1 (mag (sqrt x))).","proofString":"apply bpow_lt.\nlia."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) : (fexp2 (mag (sqrt x)) < fexp1 (mag (sqrt x)))%Z.","proofString":"lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) : (a + b) * (a + b) <= x.","proofString":"rewrite <- sqrt_def; [|now apply Rlt_le].\nassert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) : (a + b) * (a + b) <= sqrt x * sqrt x.","proofString":"assert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].\nnow apply Rmult_le_compat."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (H' : 0 <= a + b) : (a + b) * (a + b) <= sqrt x * sqrt x.","proofString":"now apply Rmult_le_compat."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) : x <= (a + b') * (a + b').","proofString":"rewrite <- (sqrt_def x); [|now apply Rlt_le].\nassert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) : sqrt x * sqrt x <= (a + b') * (a + b').","proofString":"assert (H' : 0 <= sqrt x); [now apply sqrt_pos|].\nnow apply Rmult_le_compat."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) (H' : 0 <= sqrt x) : sqrt x * sqrt x <= (a + b') * (a + b').","proofString":"now apply Rmult_le_compat."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) (Hsr : x <= a * a + u1 * a + u2 * a + b' * b') (Za : a = 0) : b * b <= x.","proofString":"revert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.\nnow rewrite Ropp_0; do 3 rewrite Rplus_0_l."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsr : x <= a * a + u1 * a + u2 * a + b' * b') (Za : a = 0) : 0 + 0 + - 0 + b * b <= x -> b * b <= x.","proofString":"now rewrite Ropp_0; do 3 rewrite Rplus_0_l."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (a : R) (u1 : R) (u2 : R) (b : R) (b' : R) (H : Rabs\n  (sqrt x -\n   (round beta fexp1 Zfloor (sqrt x) + / 2 * bpow (cexp beta fexp1 (sqrt x)))) <=\n/ 2 * bpow (cexp beta fexp2 (sqrt x))) (mx : Z) (ma : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fa : a = IZR ma * bpow (fexp1 (mag a))) (Nna : 0 <= a) (Phu1 : 0 < / 2 * u1) (Phu2 : 0 < / 2 * u2) (Pb : 0 < b) (Pb' : 0 < b') (Hr : sqrt x <= a + b') (Hl : a + b <= sqrt x) (Hf1 : (2 * fexp1 (mag (sqrt x)) <= fexp1 (mag x))%Z) (Hlx : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z) (Hsl : a * a + u1 * a - u2 * a + b * b <= x) (Hsr : x <= a * a + u1 * a + u2 * a + b' * b') (Nza : a <> 0) (Pa : 0 < a) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 (sqrt x).","proofString":"unfold round_round_eq.\ndestruct (Rle_or_lt x 0) as [Npx|Px].\nassert (Hs : sqrt x = 0).\ndestruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx.\nexact sqrt_0.\nunfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso; lra.\nrewrite Hs.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);    [now apply mag_generic_gt; try assumption; lra|].\nassert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"destruct (Rle_or_lt x 0) as [Npx|Px].\nassert (Hs : sqrt x = 0).\ndestruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx.\nexact sqrt_0.\nunfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso; lra.\nrewrite Hs.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N.\nassert (Hfx : (fexp1 (mag x) < mag x)%Z);    [now apply mag_generic_gt; try assumption; lra|].\nassert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hs : sqrt x = 0).\ndestruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx.\nexact sqrt_0.\nunfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso; lra.\nrewrite Hs.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) : sqrt x = 0.","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx.\nexact sqrt_0.\nunfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso; lra."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Zx : x = 0) : sqrt x = 0.","proofString":"rewrite Zx.\nexact sqrt_0."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Zx : x = 0) : sqrt 0 = 0.","proofString":"exact sqrt_0."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Nzx : x <> 0) : sqrt x = 0.","proofString":"unfold sqrt.\ndestruct Rcase_abs.\nreflexivity.\nexfalso; lra."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Nzx : x <> 0) : match Rcase_abs x with\n| left _ => 0\n| right a => Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 a |}\nend = 0.","proofString":"destruct Rcase_abs.\nreflexivity.\nexfalso; lra."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Nzx : x <> 0) (r : x < 0) : 0 = 0.","proofString":"reflexivity."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Nzx : x <> 0) (r : x >= 0) : Rsqrt {| nonneg := x; cond_nonneg := Rge_le x 0 r |} = 0.","proofString":"exfalso; lra."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Hs : sqrt x = 0) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"rewrite Hs.\nrewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Hs : sqrt x = 0) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) 0) =\nround beta fexp1 (Znearest choice1) 0.","proofString":"rewrite round_0.\nreflexivity.\nnow apply valid_rnd_N."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Hs : sqrt x = 0) : round beta fexp1 (Znearest choice1) 0 = round beta fexp1 (Znearest choice1) 0.","proofString":"reflexivity."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Npx : x <= 0) (Hs : sqrt x = 0) : Valid_rnd (Znearest choice2).","proofString":"now apply valid_rnd_N."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);    [now apply mag_generic_gt; try assumption; lra|].\nassert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z).\ndestruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le.\nassert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"destruct (Rle_or_lt x 1) as [Hx|Hx].\napply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt.\ngeneralize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"apply (valid_exp_large fexp1 (mag x)); [exact Hfx|].\napply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : (mag x <= mag (sqrt x))%Z.","proofString":"apply mag_le; [exact Px|].\nrewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : x <= sqrt x.","proofString":"rewrite <- (sqrt_def x) at 1; [|lra].\nrewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x * sqrt x <= sqrt x.","proofString":"rewrite <- Rmult_1_r.\napply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x * sqrt x <= sqrt x * 1.","proofString":"apply Rmult_le_compat_l.\napply sqrt_pos.\nrewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : 0 <= sqrt x.","proofString":"apply sqrt_pos."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x <= 1.","proofString":"rewrite <- sqrt_1.\nnow apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : x <= 1) : sqrt x <= sqrt 1.","proofString":"now apply sqrt_le_1_alt."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"generalize ((proj1 (proj2 Hexp)) 1%Z).\nreplace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) : (2 * fexp1 1 <= fexp1 (2 * 1 - 1))%Z ->\n(fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"replace (_ - 1)%Z with 1%Z by ring.\nintro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) : (2 * fexp1 1 <= fexp1 1)%Z -> (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"intro Hexp10.\nassert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hexp10 : (2 * fexp1 1 <= fexp1 1)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"assert (Hf0 : (fexp1 1 < 1)%Z) by lia.\nclear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hexp10 : (2 * fexp1 1 <= fexp1 1)%Z) (Hf0 : (fexp1 1 < 1)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"clear Hexp10.\napply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z.","proofString":"apply (valid_exp_large fexp1 1); [exact Hf0|].\napply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : (1 <= mag (sqrt x))%Z.","proofString":"apply mag_ge_bpow.\nrewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : bpow (1 - 1) <= Rabs (sqrt x).","proofString":"rewrite Zeq_minus; [|reflexivity].\nunfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : bpow 0 <= Rabs (sqrt x).","proofString":"unfold Raux.bpow; simpl.\napply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : 1 <= Rabs (sqrt x).","proofString":"apply Rabs_ge; right.\nrewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : 1 <= sqrt x.","proofString":"rewrite <- sqrt_1.\napply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : sqrt 1 <= sqrt x.","proofString":"apply sqrt_le_1_alt.\nnow apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hx : 1 < x) (Hf0 : (fexp1 1 < 1)%Z) : 1 <= x.","proofString":"now apply Rlt_le."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) : round beta fexp1 (Znearest choice1)\n  (round beta fexp2 (Znearest choice2) (sqrt x)) =\nround beta fexp1 (Znearest choice1) (sqrt x).","proofString":"assert (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z).\nassert (H : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z).\ndestruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\ngeneralize ((proj2 (proj2 Hexp)) (mag (sqrt x)) H).\nlia.\napply round_round_mid_cases.\nexact Vfexp1.\nexact Vfexp2.\nnow apply sqrt_lt_R0.\nlia.\nlia.\nintros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) : (fexp1 (2 * mag (sqrt x)) < 2 * mag (sqrt x))%Z.","proofString":"destruct (mag_sqrt_disj x Px) as [Hlx|Hlx].\napply (valid_exp_large fexp1 (mag x)); [|lia].\nnow apply mag_generic_gt; [|apply Rgt_not_eq|].\nrewrite <- Hlx.\nnow apply mag_generic_gt; [|apply Rgt_not_eq|]."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : Valid_exp fexp1.","proofString":"exact Vfexp1."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : Valid_exp fexp2.","proofString":"exact Vfexp2."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : 0 < sqrt x.","proofString":"now apply sqrt_lt_R0."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z.","proofString":"lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : (fexp1 (mag (sqrt x)) <= mag (sqrt x))%Z.","proofString":"lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) : Rabs (sqrt x - midp fexp1 (sqrt x)) <= / 2 * ulp beta fexp2 (sqrt x) ->\nround_round_eq fexp1 fexp2 choice1 choice2 (sqrt x).","proofString":"intros Hmid; exfalso; apply (Rle_not_lt _ _ Hmid).\napply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hbeta : (4 <= beta)%Z) (fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_sqrt_radix_ge_4_hyp fexp1 fexp2) (x : R) (Fx : generic_format beta fexp1 x) (Px : 0 < x) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfsx : (fexp1 (mag (sqrt x)) < mag (sqrt x))%Z) (Hf2 : (fexp2 (mag (sqrt x)) <= fexp1 (mag (sqrt x)) - 1)%Z) (Hmid : Rabs (sqrt x - midp fexp1 (sqrt x)) <= / 2 * ulp beta fexp2 (sqrt x)) : / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).","proofString":"apply (round_round_sqrt_radix_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2                                           Hexp x Px Hf2 Fx)."},{"statement":"(Hprec : (2 * prec + 1 <= prec')%Z) : round_round_sqrt_radix_ge_4_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"unfold FLX_exp.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_radix_ge_4_hyp; split; [|split]; intro ex; lia."},{"statement":"(Hprec : (2 * prec + 1 <= prec')%Z) : round_round_sqrt_radix_ge_4_hyp (fun e : Z => (e - prec)%Z)\n  (fun e : Z => (e - prec')%Z).","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_radix_ge_4_hyp; split; [|split]; intro ex; lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : round_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (sqrt x).","proofString":"apply round_round_sqrt_radix_ge_4.\nexact Hbeta.\nnow apply FLX_exp_valid.\nnow apply FLX_exp_valid.\nnow apply FLX_round_round_sqrt_radix_ge_4_hyp.\nnow apply generic_format_FLX."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : (4 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : Valid_exp (FLX_exp prec).","proofString":"now apply FLX_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : Valid_exp (FLX_exp prec').","proofString":"now apply FLX_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : round_round_sqrt_radix_ge_4_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"now apply FLX_round_round_sqrt_radix_ge_4_hyp."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLX_format beta prec x) : generic_format beta (FLX_exp prec) x.","proofString":"now apply generic_format_FLX."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_sqrt_radix_ge_4_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"unfold FLT_exp.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_radix_ge_4_hyp; split; [|split]; intros ex.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - 1 - prec) emin).\nlia.\ngeneralize (Zmax_spec (2 * ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_sqrt_radix_ge_4_hyp (fun e : Z => Z.max (e - prec) emin)\n  (fun e : Z => Z.max (e - prec') emin').","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_sqrt_radix_ge_4_hyp; split; [|split]; intros ex.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (2 * ex - 1 - prec) emin).\nlia.\ngeneralize (Zmax_spec (2 * ex - prec) emin).\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex : Z) : (2 * ex - prec >= emin)%Z /\\ Z.max (2 * ex - prec) emin = (2 * ex - prec)%Z \\/\n(2 * ex - prec < emin)%Z /\\ Z.max (2 * ex - prec) emin = emin ->\n(Z.max (2 * ex - prec) emin < 2 * ex)%Z ->\n(Z.max (ex - prec') emin' + ex <= 2 * Z.max (ex - prec) emin - 1)%Z.","proofString":"generalize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex : Z) : (ex - prec' >= emin')%Z /\\ Z.max (ex - prec') emin' = (ex - prec')%Z \\/\n(ex - prec' < emin')%Z /\\ Z.max (ex - prec') emin' = emin' ->\n(2 * ex - prec >= emin)%Z /\\ Z.max (2 * ex - prec) emin = (2 * ex - prec)%Z \\/\n(2 * ex - prec < emin)%Z /\\ Z.max (2 * ex - prec) emin = emin ->\n(Z.max (2 * ex - prec) emin < 2 * ex)%Z ->\n(Z.max (ex - prec') emin' + ex <= 2 * Z.max (ex - prec) emin - 1)%Z.","proofString":"generalize (Zmax_spec (ex - prec) emin).\nlia."},{"statement":"(Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex : Z) : (ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(ex - prec' >= emin')%Z /\\ Z.max (ex - prec') emin' = (ex - prec')%Z \\/\n(ex - prec' < emin')%Z /\\ Z.max (ex - prec') emin' = emin' ->\n(2 * ex - prec >= emin)%Z /\\ Z.max (2 * ex - prec) emin = (2 * ex - prec)%Z \\/\n(2 * ex - prec < emin)%Z /\\ Z.max (2 * ex - prec) emin = emin ->\n(Z.max (2 * ex - prec) emin < 2 * ex)%Z ->\n(Z.max (ex - prec') emin' + ex <= 2 * Z.max (ex - prec) emin - 1)%Z.","proofString":"lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : round_round_eq (FLT_exp emin prec) (FLT_exp emin' prec') choice1 choice2\n  (sqrt x).","proofString":"apply round_round_sqrt_radix_ge_4.\nexact Hbeta.\nnow apply FLT_exp_valid.\nnow apply FLT_exp_valid.\nnow apply FLT_round_round_sqrt_radix_ge_4_hyp.\nnow apply generic_format_FLT."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : (4 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : Valid_exp (FLT_exp emin prec).","proofString":"now apply FLT_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : Valid_exp (FLT_exp emin' prec').","proofString":"now apply FLT_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : round_round_sqrt_radix_ge_4_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"now apply FLT_round_round_sqrt_radix_ge_4_hyp."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (emin <= 0)%Z) (Heminprec : (emin' <= emin - prec - 1)%Z \\/ (2 * emin' <= emin - 4 * prec)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FLT_format beta emin prec x) : generic_format beta (FLT_exp emin prec) x.","proofString":"now apply generic_format_FLT."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_sqrt_radix_ge_4_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"unfold FTZ_exp.\nunfold Prec_gt_0 in *.\nunfold round_round_sqrt_radix_ge_4_hyp; split; [|split]; intros ex.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - 1 - prec) emin);  lia.\nintro H.\ndestruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].\ndestruct (Z.ltb_spec (ex - prec') emin');    destruct (Z.ltb_spec (ex - prec) emin);    lia.\nexfalso.\nrewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) : round_round_sqrt_radix_ge_4_hyp\n  (fun e : Z =>\n   if (e - prec <? emin)%Z then (emin + prec - 1)%Z else (e - prec)%Z)\n  (fun e : Z =>\n   if (e - prec' <? emin')%Z then (emin' + prec' - 1)%Z else (e - prec')%Z).","proofString":"unfold Prec_gt_0 in *.\nunfold round_round_sqrt_radix_ge_4_hyp; split; [|split]; intros ex.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (2 * ex - 1 - prec) emin);  lia.\nintro H.\ndestruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].\ndestruct (Z.ltb_spec (ex - prec') emin');    destruct (Z.ltb_spec (ex - prec) emin);    lia.\nexfalso.\nrewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex : Z) (H : ((if 2 * ex - prec <? emin then emin + prec - 1 else 2 * ex - prec) < 2 * ex)%Z) : ((if ex - prec' <? emin' then emin' + prec' - 1 else ex - prec') + ex <=\n 2 * (if ex - prec <? emin then emin + prec - 1 else ex - prec) - 1)%Z.","proofString":"destruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].\ndestruct (Z.ltb_spec (ex - prec') emin');    destruct (Z.ltb_spec (ex - prec) emin);    lia.\nexfalso.\nrewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex : Z) (H : ((if 2 * ex - prec <? emin then emin + prec - 1 else 2 * ex - prec) < 2 * ex)%Z) (H' : (2 * ex - prec < emin)%Z) : False.","proofString":"rewrite (Zlt_bool_true _ _ H') in H.\nlia."},{"statement":"(Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (ex : Z) (H : (emin + prec - 1 < 2 * ex)%Z) (H' : (2 * ex - prec < emin)%Z) : False.","proofString":"lia."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : round_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec') choice1 choice2\n  (sqrt x).","proofString":"apply round_round_sqrt_radix_ge_4.\nexact Hbeta.\nnow apply FTZ_exp_valid.\nnow apply FTZ_exp_valid.\nnow apply FTZ_round_round_sqrt_radix_ge_4_hyp.\nnow apply generic_format_FTZ."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : (4 <= beta)%Z.","proofString":"exact Hbeta."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : Valid_exp (FTZ_exp emin prec).","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : Valid_exp (FTZ_exp emin' prec').","proofString":"now apply FTZ_exp_valid."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : round_round_sqrt_radix_ge_4_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"now apply FTZ_round_round_sqrt_radix_ge_4_hyp."},{"statement":"(Hbeta : (4 <= beta)%Z) (choice1 choice2 : Z -> bool) (Hemin : (2 * (emin' + prec') <= emin + prec <= 1)%Z) (Hprec : (2 * prec + 1 <= prec')%Z) (x : R) (Fx : FTZ_format beta emin prec x) : generic_format beta (FTZ_exp emin prec) x.","proofString":"now apply generic_format_FTZ."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (Hlx : bpow (mag x - 1) <= x < bpow (mag x)).\ndestruct (mag x) as (ex,Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nunfold round_round_eq.\nrewrite (round_N_small_pos beta fexp1 _ x (mag x)); [|exact Hlx|lia].\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''];  [now rewrite Zx''; rewrite round_0; [|apply valid_rnd_N]|].\ndestruct (Zle_or_lt (fexp2 (mag x)) (mag x)).\ndestruct (Rlt_or_le x'' (bpow (mag x))).\nrewrite (round_N_small_pos beta fexp1 _ _ (mag x));    [reflexivity|split; [|exact H0]|lia].\napply round_large_pos_ge_bpow; [now apply valid_rnd_N| |now apply Hlx].\nfold x''; assert (0 <= x''); [|lra]; unfold x''.\nrewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nassert (Hx'' : x'' = bpow (mag x)).\napply Rle_antisym; [|exact H0].\nrewrite <- (round_generic beta fexp2 (Znearest choice2) (bpow _)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nnow apply generic_format_bpow'.\nrewrite Hx''.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia.\nexfalso; apply Nzx''.\nnow apply (round_N_small_pos beta _ _ _ (mag x))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) : bpow (mag x - 1) <= x < bpow (mag x).","proofString":"destruct (mag x) as (ex,Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hf1 : (Build_mag_prop beta x ex Hex <= fexp1 (Build_mag_prop beta x ex Hex) - 2)%Z) : bpow (ex - 1) <= x < bpow ex.","proofString":"rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hf1 : (Build_mag_prop beta x ex Hex <= fexp1 (Build_mag_prop beta x ex Hex) - 2)%Z) : bpow (ex - 1) <= Rabs x < bpow ex.","proofString":"apply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hf1 : (Build_mag_prop beta x ex Hex <= fexp1 (Build_mag_prop beta x ex Hex) - 2)%Z) : x <> 0.","proofString":"now apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq.\nrewrite (round_N_small_pos beta fexp1 _ x (mag x)); [|exact Hlx|lia].\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''];  [now rewrite Zx''; rewrite round_0; [|apply valid_rnd_N]|].\ndestruct (Zle_or_lt (fexp2 (mag x)) (mag x)).\ndestruct (Rlt_or_le x'' (bpow (mag x))).\nrewrite (round_N_small_pos beta fexp1 _ _ (mag x));    [reflexivity|split; [|exact H0]|lia].\napply round_large_pos_ge_bpow; [now apply valid_rnd_N| |now apply Hlx].\nfold x''; assert (0 <= x''); [|lra]; unfold x''.\nrewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nassert (Hx'' : x'' = bpow (mag x)).\napply Rle_antisym; [|exact H0].\nrewrite <- (round_generic beta fexp2 (Znearest choice2) (bpow _)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nnow apply generic_format_bpow'.\nrewrite Hx''.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia.\nexfalso; apply Nzx''.\nnow apply (round_N_small_pos beta _ _ _ (mag x))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"rewrite (round_N_small_pos beta fexp1 _ x (mag x)); [|exact Hlx|lia].\nset (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''];  [now rewrite Zx''; rewrite round_0; [|apply valid_rnd_N]|].\ndestruct (Zle_or_lt (fexp2 (mag x)) (mag x)).\ndestruct (Rlt_or_le x'' (bpow (mag x))).\nrewrite (round_N_small_pos beta fexp1 _ _ (mag x));    [reflexivity|split; [|exact H0]|lia].\napply round_large_pos_ge_bpow; [now apply valid_rnd_N| |now apply Hlx].\nfold x''; assert (0 <= x''); [|lra]; unfold x''.\nrewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nassert (Hx'' : x'' = bpow (mag x)).\napply Rle_antisym; [|exact H0].\nrewrite <- (round_generic beta fexp2 (Znearest choice2) (bpow _)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nnow apply generic_format_bpow'.\nrewrite Hx''.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia.\nexfalso; apply Nzx''.\nnow apply (round_N_small_pos beta _ _ _ (mag x))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) : round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\n0.","proofString":"set (x'' := round beta fexp2 (Znearest choice2) x).\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''];  [now rewrite Zx''; rewrite round_0; [|apply valid_rnd_N]|].\ndestruct (Zle_or_lt (fexp2 (mag x)) (mag x)).\ndestruct (Rlt_or_le x'' (bpow (mag x))).\nrewrite (round_N_small_pos beta fexp1 _ _ (mag x));    [reflexivity|split; [|exact H0]|lia].\napply round_large_pos_ge_bpow; [now apply valid_rnd_N| |now apply Hlx].\nfold x''; assert (0 <= x''); [|lra]; unfold x''.\nrewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nassert (Hx'' : x'' = bpow (mag x)).\napply Rle_antisym; [|exact H0].\nrewrite <- (round_generic beta fexp2 (Znearest choice2) (bpow _)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\nnow apply generic_format_bpow'.\nrewrite Hx''.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia.\nexfalso; apply Nzx''.\nnow apply (round_N_small_pos beta _ _ _ (mag x))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : x'' < bpow (mag x)) : 0 <= round beta fexp2 (Znearest choice2) x.","proofString":"rewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : x'' < bpow (mag x)) : round beta fexp2 (Znearest choice2) 0 <=\nround beta fexp2 (Znearest choice2) x.","proofString":"now apply round_le; [|apply valid_rnd_N|apply Rlt_le]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') : generic_format beta fexp2 (bpow (mag x)).","proofString":"now apply generic_format_bpow'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) : round beta fexp1 (Znearest choice1) x'' = 0.","proofString":"rewrite Hx''.\nunfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) : round beta fexp1 (Znearest choice1) (bpow (mag x)) = 0.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\nrewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) : IZR (Znearest choice1 (bpow (mag x) * bpow (- fexp1 (mag (bpow (mag x)))))) *\nbpow (fexp1 (mag (bpow (mag x)))) = 0.","proofString":"rewrite mag_bpow.\nassert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) : IZR (Znearest choice1 (bpow (mag x) * bpow (- fexp1 (mag x + 1)%Z))) *\nbpow (fexp1 (mag x + 1)%Z) = 0.","proofString":"assert (Hf11 : (fexp1 (mag x + 1) = fexp1 (mag x) :> Z)%Z);      [apply Vfexp1; lia|].\nrewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : IZR (Znearest choice1 (bpow (mag x) * bpow (- fexp1 (mag x + 1)%Z))) *\nbpow (fexp1 (mag x + 1)%Z) = 0.","proofString":"rewrite Hf11.\napply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : IZR (Znearest choice1 (bpow (mag x) * bpow (- fexp1 (mag x)))) *\nbpow (fexp1 (mag x)) = 0.","proofString":"apply (Rmult_eq_reg_r (bpow (- fexp1 (mag x))));      [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : IZR (Znearest choice1 (bpow (mag x) * bpow (- fexp1 (mag x)))) *\nbpow (fexp1 (mag x)) * bpow (- fexp1 (mag x)) = 0 * bpow (- fexp1 (mag x)).","proofString":"rewrite Rmult_0_l; bpow_simplify.\napply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : IZR (Znearest choice1 (bpow (mag x - fexp1 (mag x)))) = 0.","proofString":"apply IZR_eq.\napply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : Znearest choice1 (bpow (mag x - fexp1 (mag x))) = 0%Z.","proofString":"apply Znearest_imp.\nsimpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : Rabs (bpow (mag x - fexp1 (mag x)) - 0) < / 2.","proofString":"simpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nrewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : Rabs (bpow (mag x - fexp1 (mag x))) < / 2.","proofString":"rewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].\napply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : bpow (mag x - fexp1 (mag x)) < / 2.","proofString":"apply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; lia|].\nunfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : bpow (-2) < / 2.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.\nassert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : / IZR (beta * beta) < / 2.","proofString":"assert (Hbeta : (2 <= beta)%Z).\ndestruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le.\napply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) : (2 <= beta)%Z.","proofString":"destruct beta as (beta_val,beta_prop); simpl.\nnow apply Zle_bool_imp_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) (Hf1 : (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x <=\n fexp1 (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x) - 2)%Z) (Hlx : Raux.bpow {| radix_val := beta_val; radix_prop := beta_prop |}\n  (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x - 1) <=\nx <\nRaux.bpow {| radix_val := beta_val; radix_prop := beta_prop |}\n  (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x) <=\n Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x)%Z) (H0 : Raux.bpow {| radix_val := beta_val; radix_prop := beta_prop |}\n  (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x) <= x'') (Hx'' : x'' =\nRaux.bpow {| radix_val := beta_val; radix_prop := beta_prop |}\n  (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x)) (Hf11 : fexp1 (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x + 1)%Z =\nfexp1 (Raux.mag {| radix_val := beta_val; radix_prop := beta_prop |} x)) : (2 <= beta_val)%Z.","proofString":"now apply Zle_bool_imp_le."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : / IZR (beta * beta) < / 2.","proofString":"apply Rinv_lt_contravar.\napply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia.\napply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : 0 < 2 * IZR (beta * beta).","proofString":"apply Rmult_lt_0_compat; [lra|].\nrewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : 0 < IZR (beta * beta).","proofString":"rewrite mult_IZR; apply Rmult_lt_0_compat;      apply IZR_lt; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : 2 < IZR (beta * beta).","proofString":"apply IZR_lt.\napply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : (2 < beta * beta)%Z.","proofString":"apply (Z.le_lt_trans _ _ _ Hbeta).\nrewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : (beta < beta * beta)%Z.","proofString":"rewrite <- (Zmult_1_r beta) at 1.\napply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : (mag x <= fexp1 (mag x) - 2)%Z) (Hlx : bpow (mag x - 1) <= x < bpow (mag x)) (x'' : R) (Nzx'' : x'' <> 0) (H : (fexp2 (mag x) <= mag x)%Z) (H0 : bpow (mag x) <= x'') (Hx'' : x'' = bpow (mag x)) (Hf11 : fexp1 (mag x + 1)%Z = fexp1 (mag x)) (Hbeta : (2 <= beta)%Z) : (beta * 1 < beta * beta)%Z.","proofString":"apply Zmult_lt_compat_l; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : fexp1 (mag x) = (mag x + 1)%Z) : x < bpow (mag x) - / 2 * ulp beta fexp2 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq.\nset (x'' := round beta fexp2 (Znearest choice2) x).\nset (u1 := ulp beta fexp1 x).\nset (u2 := ulp beta fexp2 x).\nintro Hx.\nassert (Hlx : bpow (mag x - 1) <= x < bpow (mag x)).\ndestruct (mag x) as (ex,Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nrewrite (round_N_small_pos beta fexp1 choice1 x (mag x));  [|exact Hlx|lia].\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''];  [now rewrite Zx''; rewrite round_0; [reflexivity|apply valid_rnd_N]|].\nrewrite (round_N_small_pos beta _ _ x'' (mag x));  [reflexivity| |lia].\nsplit.\napply round_large_pos_ge_bpow.\nnow apply valid_rnd_N.\nassert (0 <= x''); [|now fold x''; lra].\nrewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\napply Rle_trans with (Rabs x);    [|now rewrite Rabs_right; [apply Rle_refl|apply Rle_ge; apply Rlt_le]].\ndestruct (mag x) as (ex,Hex); simpl; apply Hex.\nnow apply Rgt_not_eq.\nreplace x'' with (x + (x'' - x)) by ring.\nreplace (bpow _) with (bpow (mag x) - / 2 * u2 + / 2 * u2) by ring.\napply Rplus_lt_le_compat; [exact Hx|].\napply Rabs_le_inv.\nnow apply error_le_half_ulp."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : fexp1 (mag x) = (mag x + 1)%Z) : x < bpow (mag x) - / 2 * ulp beta fexp2 x ->\nround beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x) =\nround beta fexp1 (Znearest choice1) x.","proofString":"set (x'' := round beta fexp2 (Znearest choice2) x).\nset (u1 := ulp beta fexp1 x).\nset (u2 := ulp beta fexp2 x).\nintro Hx.\nassert (Hlx : bpow (mag x - 1) <= x < bpow (mag x)).\ndestruct (mag x) as (ex,Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq.\nrewrite (round_N_small_pos beta fexp1 choice1 x (mag x));  [|exact Hlx|lia].\ndestruct (Req_dec x'' 0) as [Zx''|Nzx''];  [now rewrite Zx''; rewrite round_0; [reflexivity|apply valid_rnd_N]|].\nrewrite (round_N_small_pos beta _ _ x'' (mag x));  [reflexivity| |lia].\nsplit.\napply round_large_pos_ge_bpow.\nnow apply valid_rnd_N.\nassert (0 <= x''); [|now fold x''; lra].\nrewrite <- (round_0 beta fexp2 (Znearest choice2)).\nnow apply round_le; [|apply valid_rnd_N|apply Rlt_le].\napply Rle_trans with (Rabs x);    [|now rewrite Rabs_right; [apply Rle_refl|apply Rle_ge; apply Rlt_le]].\ndestruct (mag x) as (ex,Hex); simpl; apply Hex.\nnow apply Rgt_not_eq.\nreplace x'' with (x + (x'' - x)) by ring.\nreplace (bpow _) with (bpow (mag x) - / 2 * u2 + / 2 * u2) by ring.\napply Rplus_lt_le_compat; [exact Hx|].\napply Rabs_le_inv.\nnow apply error_le_half_ulp."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf1 : fexp1 (mag x) = (mag x + 1)%Z) (x'' : R) (u1 : R) (u2 : R) (Hx : x < bpow (mag x) - / 2 * u2) : bpow (mag x - 1) <= x < bpow (mag x).","proofString":"destruct (mag x) as (ex,Hex); simpl.\nrewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hf1 : fexp1 (Build_mag_prop beta x ex Hex) = (Build_mag_prop beta x ex Hex + 1)%Z) (x'' : R) (u1 : R) (u2 : R) (Hx : x < bpow (Build_mag_prop beta x ex Hex) - / 2 * u2) : bpow (ex - 1) <= x < bpow ex.","proofString":"rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].\napply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hf1 : fexp1 (Build_mag_prop beta x ex Hex) = (Build_mag_prop beta x ex Hex + 1)%Z) (x'' : R) (u1 : R) (u2 : R) (Hx : x < bpow (Build_mag_prop beta x ex Hex) - / 2 * u2) : bpow (ex - 1) <= Rabs x < bpow ex.","proofString":"apply Hex.\nnow apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (ex : Z) (Hex : x <> 0 -> bpow (ex - 1) <= Rabs x < bpow ex) (Hf1 : fexp1 (Build_mag_prop beta x ex Hex) = (Build_mag_prop beta x ex Hex + 1)%Z) (x'' : R) (u1 : R) (u2 : R) (Hx : x < bpow (Build_mag_prop beta x ex Hex) - / 2 * u2) : x <> 0.","proofString":"now apply Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) : (fexp1 (mag x) = (mag x + 1)%Z ->\n bpow (mag x) - / 2 * ulp beta fexp2 x <= x ->\n round_round_eq fexp1 fexp2 choice1 choice2 x) ->\n((fexp1 (mag x) <= mag x)%Z ->\n midp fexp1 x - / 2 * ulp beta fexp2 x <= x < midp fexp1 x ->\n round_round_eq fexp1 fexp2 choice1 choice2 x) ->\n((fexp1 (mag x) <= mag x)%Z ->\n x = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) ->\n((fexp1 (mag x) <= mag x)%Z ->\n midp fexp1 x < x <= midp fexp1 x + / 2 * ulp beta fexp2 x ->\n round_round_eq fexp1 fexp2 choice1 choice2 x) ->\nround_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"set (x' := round beta fexp1 Zfloor x).\nset (u1 := ulp beta fexp1 x).\nset (u2 := ulp beta fexp2 x).\nintros Cz Clt Ceq Cgt.\ndestruct (Ztrichotomy (mag x) (fexp1 (mag x) - 1)) as [Hlt|[Heq|Hgt]].\nassert (H : (mag x <= fexp1 (mag x) - 2)%Z) by lia.\nnow apply round_round_really_zero.\nassert (H : (fexp1 (mag x) = (mag x + 1))%Z) by lia.\ndestruct (Rlt_or_le x (bpow (mag x) - / 2 * u2)) as [Hlt'|Hge'].\nnow apply round_round_zero.\nnow apply Cz.\nassert (H : (fexp1 (mag x) <= mag x)%Z) by lia.\ndestruct (Rtotal_order x (midp fexp1 x)) as [Hlt'|[Heq'|Hgt']].\ndestruct (Rlt_or_le x (midp fexp1 x - / 2 * u2)) as [Hlt''|Hle''].\nnow apply round_round_lt_mid_further_place; [| | |lia| |].\nnow apply Clt; [|split].\nnow apply Ceq.\ndestruct (Rle_or_lt x (midp fexp1 x + / 2 * u2)) as [Hlt''|Hle''].\nnow apply Cgt; [|split].\ndestruct (generic_format_EM beta fexp1 x) as [Fx|Nfx].\nunfold round_round_eq; rewrite (round_generic beta fexp2);          [reflexivity|now apply valid_rnd_N|].\nnow apply (generic_inclusion_mag beta fexp1); [lia|].\nassert (Hceil : round beta fexp1 Zceil x = x' + u1);          [now apply round_UP_DN_ulp|].\nassert (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) by lia.\nassert (midp' fexp1 x + / 2 * ulp beta fexp2 x < x);            [|now apply round_round_gt_mid_further_place].\nrevert Hle''; unfold midp, midp'; fold x'.\nrewrite Hceil; fold u1; fold u2.\nlra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hlt : (mag x < fexp1 (mag x) - 1)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"assert (H : (mag x <= fexp1 (mag x) - 2)%Z) by lia.\nnow apply round_round_really_zero."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hlt : (mag x < fexp1 (mag x) - 1)%Z) (H : (mag x <= fexp1 (mag x) - 2)%Z) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply round_round_really_zero."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hgt : (mag x > fexp1 (mag x) - 1)%Z) (H : (fexp1 (mag x) <= mag x)%Z) (Hlt' : x < midp fexp1 x) (Hle'' : midp fexp1 x - / 2 * u2 <= x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply Clt; [|split]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hgt : (mag x > fexp1 (mag x) - 1)%Z) (H : (fexp1 (mag x) <= mag x)%Z) (Heq' : x = midp fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply Ceq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hgt : (mag x > fexp1 (mag x) - 1)%Z) (H : (fexp1 (mag x) <= mag x)%Z) (Hgt' : x > midp fexp1 x) (Hlt'' : x <= midp fexp1 x + / 2 * u2) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"now apply Cgt; [|split]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hgt : (mag x > fexp1 (mag x) - 1)%Z) (H : (fexp1 (mag x) <= mag x)%Z) (Hgt' : x > midp fexp1 x) (Hle'' : midp fexp1 x + / 2 * u2 < x) (Fx : generic_format beta fexp1 x) : round_round_eq fexp1 fexp2 choice1 choice2 x.","proofString":"unfold round_round_eq; rewrite (round_generic beta fexp2);          [reflexivity|now apply valid_rnd_N|].\nnow apply (generic_inclusion_mag beta fexp1); [lia|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hgt : (mag x > fexp1 (mag x) - 1)%Z) (H : (fexp1 (mag x) <= mag x)%Z) (Hgt' : x > midp fexp1 x) (Hle'' : midp fexp1 x + / 2 * u2 < x) (Fx : generic_format beta fexp1 x) : generic_format beta fexp2 x.","proofString":"now apply (generic_inclusion_mag beta fexp1); [lia|]."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (x : R) (Px : 0 < x) (Hf2 : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) (x' : R) (u1 : R) (u2 : R) (Cz : fexp1 (mag x) = (mag x + 1)%Z ->\nbpow (mag x) - / 2 * u2 <= x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Clt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x - / 2 * u2 <= x < midp fexp1 x ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Ceq : (fexp1 (mag x) <= mag x)%Z ->\nx = midp fexp1 x -> round_round_eq fexp1 fexp2 choice1 choice2 x) (Cgt : (fexp1 (mag x) <= mag x)%Z ->\nmidp fexp1 x < x <= midp fexp1 x + / 2 * u2 ->\nround_round_eq fexp1 fexp2 choice1 choice2 x) (Hgt : (mag x > fexp1 (mag x) - 1)%Z) (H : (fexp1 (mag x) <= mag x)%Z) (Hgt' : x > midp fexp1 x) (Nfx : ~ generic_format beta fexp1 x) (Hceil : round beta fexp1 Zceil x = x' + u1) (Hf2' : (fexp2 (mag x) <= fexp1 (mag x) - 1)%Z) : x' + / 2 * u1 + / 2 * u2 < x -> x' + u1 - / 2 * u1 + / 2 * u2 < x.","proofString":"lra."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) : ~\nmidp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\ncut (~ (/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y))        <= x / y - round beta fexp1 Zfloor (x / y)        < / 2 * ulp beta fexp1 (x / y))).\nintro H; intro H'; apply H; split.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 - u2))).\napply (Rle_lt_trans _ _ _ (proj1 Hlr)).\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\nrewrite Rmult_minus_distr_r; rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\nrewrite Rmult_minus_distr_l; rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rle_lt_trans with (2 * x' * y + u1 * y                                        - bpow (fexp1 (mag (x / y))                                                + fexp1 (mag y))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (- fexp1 (mag (x / y)))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- IZR_Zpower; [|exact He].\ndo 4 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y))                                 + fexp1 (mag y))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rle_lt_trans with (2 * x' * y + u1 * y - bpow (fexp1 (mag x))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nbpow_simplify.\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : ~\nmidp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y).","proofString":"assert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\ncut (~ (/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y))        <= x / y - round beta fexp1 Zfloor (x / y)        < / 2 * ulp beta fexp1 (x / y))).\nintro H; intro H'; apply H; split.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 - u2))).\napply (Rle_lt_trans _ _ _ (proj1 Hlr)).\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\nrewrite Rmult_minus_distr_r; rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\nrewrite Rmult_minus_distr_l; rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rle_lt_trans with (2 * x' * y + u1 * y                                        - bpow (fexp1 (mag (x / y))                                                + fexp1 (mag y))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (- fexp1 (mag (x / y)))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- IZR_Zpower; [|exact He].\ndo 4 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y))                                 + fexp1 (mag y))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rle_lt_trans with (2 * x' * y + u1 * y - bpow (fexp1 (mag x))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nbpow_simplify.\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : ~\nmidp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y).","proofString":"assert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\ncut (~ (/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y))        <= x / y - round beta fexp1 Zfloor (x / y)        < / 2 * ulp beta fexp1 (x / y))).\nintro H; intro H'; apply H; split.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 - u2))).\napply (Rle_lt_trans _ _ _ (proj1 Hlr)).\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\nrewrite Rmult_minus_distr_r; rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\nrewrite Rmult_minus_distr_l; rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rle_lt_trans with (2 * x' * y + u1 * y                                        - bpow (fexp1 (mag (x / y))                                                + fexp1 (mag y))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (- fexp1 (mag (x / y)))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- IZR_Zpower; [|exact He].\ndo 4 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y))                                 + fexp1 (mag y))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rle_lt_trans with (2 * x' * y + u1 * y - bpow (fexp1 (mag x))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nbpow_simplify.\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : x / y <> 0.","proofString":"apply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : / y <> 0.","proofString":"now apply Rinv_neq_0_compat, Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) : ~\nmidp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y).","proofString":"cut (~ (/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y))        <= x / y - round beta fexp1 Zfloor (x / y)        < / 2 * ulp beta fexp1 (x / y))).\nintro H; intro H'; apply H; split.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 - u2))).\napply (Rle_lt_trans _ _ _ (proj1 Hlr)).\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\nrewrite Rmult_minus_distr_r; rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\nrewrite Rmult_minus_distr_l; rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rle_lt_trans with (2 * x' * y + u1 * y                                        - bpow (fexp1 (mag (x / y))                                                + fexp1 (mag y))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (- fexp1 (mag (x / y)))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- IZR_Zpower; [|exact He].\ndo 4 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y))                                 + fexp1 (mag y))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rle_lt_trans with (2 * x' * y + u1 * y - bpow (fexp1 (mag x))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nbpow_simplify.\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y) ->\n~\nmidp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y).","proofString":"intro H; intro H'; apply H; split.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (H : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y)) (H' : midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y)) : / 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y).","proofString":"apply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (H : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y)) (H' : midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y)) : round beta fexp1 Zfloor (x / y) +\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nround beta fexp1 Zfloor (x / y) + (x / y - round beta fexp1 Zfloor (x / y)).","proofString":"ring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (H : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y)) (H' : midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y)) : round beta fexp1 Zfloor (x / y) + / 2 * ulp beta fexp1 (x / y) -\n/ 2 * ulp beta fexp2 (x / y) <= x / y.","proofString":"apply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (H : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y)) (H' : midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y)) : x / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y).","proofString":"apply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (H : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y)) (H' : midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y)) : round beta fexp1 Zfloor (x / y) + (x / y - round beta fexp1 Zfloor (x / y)) <\nround beta fexp1 Zfloor (x / y) + / 2 * ulp beta fexp1 (x / y).","proofString":"ring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (H : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y)) (H' : midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y) <= \nx / y < midp fexp1 (x / y)) : x / y < round beta fexp1 Zfloor (x / y) + / 2 * ulp beta fexp1 (x / y).","proofString":"apply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) : ~\n/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y)) <=\nx / y - round beta fexp1 Zfloor (x / y) < / 2 * ulp beta fexp1 (x / y).","proofString":"set (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 - u2))).\napply (Rle_lt_trans _ _ _ (proj1 Hlr)).\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\nrewrite Rmult_minus_distr_r; rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\nrewrite Rmult_minus_distr_l; rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rle_lt_trans with (2 * x' * y + u1 * y                                        - bpow (fexp1 (mag (x / y))                                                + fexp1 (mag y))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (- fexp1 (mag (x / y)))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- IZR_Zpower; [|exact He].\ndo 4 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y))                                 + fexp1 (mag y))));      [now apply bpow_gt_0|bpow_simplify].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rle_lt_trans with (2 * x' * y + u1 * y - bpow (fexp1 (mag x))).\nrewrite Fx at 1; rewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- minus_IZR.\napply IZR_le.\napply (Zplus_le_reg_r _ _ 1); ring_simplify.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite Rmult_assoc.\nrewrite <- Fx.\nrewrite (Rmult_plus_distr_r _ _ (Raux.bpow _ _)).\nbpow_simplify.\nrewrite Rmult_assoc.\nrewrite bpow_plus.\nrewrite <- (Rmult_assoc (IZR (Zfloor _))).\nchange (IZR (Zfloor _) * _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_minus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nnow rewrite Rmult_comm.\napply Rplus_lt_compat_l.\napply Ropp_lt_contravar.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : y < bpow (mag y).","proofString":"apply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : Rabs y < bpow (mag y).","proofString":"apply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : (fexp2 (mag (x / y)) + mag y <= fexp1 (mag (x / y)) + fexp1 (mag y))%Z.","proofString":"apply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : (fexp2 (mag (x / y)) <= - mag y + fexp1 (mag (x / y)) + fexp1 (mag y))%Z.","proofString":"rewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : (fexp2 (mag (x / y)) <= fexp1 (mag (x / y)) + fexp1 (mag y) + - mag y)%Z.","proofString":"destruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : y < bpow (mag y).","proofString":"apply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : Rabs y < bpow (mag y).","proofString":"apply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : (fexp2 (mag (x / y)) + mag y <= fexp1 (mag x))%Z.","proofString":"apply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : (fexp2 (mag (x / y)) <= - mag y + fexp1 (mag x))%Z.","proofString":"rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (S : x / y <> 0) (u1 : R) (u2 : R) (x' : R) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * (bpow (fexp1 (mag (x / y))) - bpow (fexp2 (mag (x / y)))) <=\nx / y - x' < / 2 * bpow (fexp1 (mag (x / y)))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : (fexp2 (mag (x / y)) <= fexp1 (mag x) + - mag y)%Z.","proofString":"destruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) : ~\nmidp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y).","proofString":"assert (Hfx : (fexp1 (mag x) < mag x)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\nassert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\ncut (~ (/ 2 * ulp beta fexp1 (x / y)        < x / y - round beta fexp1 Zfloor (x / y)        <= / 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)))).\nintro H; intro H'; apply H; split.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nassert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 + u2))).\napply Rlt_le_trans with (x / y - x'); [|now apply Hlr].\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\ndo 2 rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\ndo 2 rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rlt_le_trans with (u1 * y + bpow (fexp1 (mag (x / y))                                          + fexp1 (mag y))                           + 2 * x' * y).\napply Rplus_lt_compat_r, Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nreplace (u1 * y) with (u1 * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\nreplace (2 * x' * y) with (2 * x' * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm u1).\nunfold u1, ulp, cexp; bpow_simplify.\nrewrite (Rmult_assoc 2).\nrewrite (Rmult_comm x').\nrewrite (Rmult_assoc 2).\nunfold x', round, F2R, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z); [|exact He].\ndo 4 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\nrewrite Zplus_comm, Zplus_assoc.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nrewrite (Rmult_comm _ (IZR _)).\ndo 2 rewrite Rmult_assoc.\nrewrite <- Fy.\nbpow_simplify.\nunfold Zminus; rewrite bpow_plus.\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- (Rmult_assoc (IZR mx)).\nrewrite <- Fx.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y)))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm _ y).\ndo 2 rewrite Rmult_assoc.\nchange (IZR (Zfloor _) * _) with x'.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x')).\napply Rlt_le_trans with (2 * x' * y + u1 * y + bpow (fexp1 (mag x))).\nrewrite Rplus_comm, Rplus_assoc; do 2 apply Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\nnow apply bpow_gt_0.\nnow apply Rabs_lt_inv; apply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nrewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- Fx.\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite bpow_plus.\nrewrite Rmult_assoc.\nrewrite <- (Rmult_assoc (IZR _)).\nchange (IZR _ * bpow _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x'))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) : ~\nmidp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y).","proofString":"assert (Hfy : (fexp1 (mag y) < mag y)%Z);  [now apply mag_generic_gt; [|apply Rgt_not_eq|]|].\ncut (~ (/ 2 * ulp beta fexp1 (x / y)        < x / y - round beta fexp1 Zfloor (x / y)        <= / 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)))).\nintro H; intro H'; apply H; split.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nassert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 + u2))).\napply Rlt_le_trans with (x / y - x'); [|now apply Hlr].\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\ndo 2 rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\ndo 2 rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rlt_le_trans with (u1 * y + bpow (fexp1 (mag (x / y))                                          + fexp1 (mag y))                           + 2 * x' * y).\napply Rplus_lt_compat_r, Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nreplace (u1 * y) with (u1 * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\nreplace (2 * x' * y) with (2 * x' * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm u1).\nunfold u1, ulp, cexp; bpow_simplify.\nrewrite (Rmult_assoc 2).\nrewrite (Rmult_comm x').\nrewrite (Rmult_assoc 2).\nunfold x', round, F2R, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z); [|exact He].\ndo 4 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\nrewrite Zplus_comm, Zplus_assoc.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nrewrite (Rmult_comm _ (IZR _)).\ndo 2 rewrite Rmult_assoc.\nrewrite <- Fy.\nbpow_simplify.\nunfold Zminus; rewrite bpow_plus.\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- (Rmult_assoc (IZR mx)).\nrewrite <- Fx.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y)))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm _ y).\ndo 2 rewrite Rmult_assoc.\nchange (IZR (Zfloor _) * _) with x'.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x')).\napply Rlt_le_trans with (2 * x' * y + u1 * y + bpow (fexp1 (mag x))).\nrewrite Rplus_comm, Rplus_assoc; do 2 apply Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\nnow apply bpow_gt_0.\nnow apply Rabs_lt_inv; apply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nrewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- Fx.\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite bpow_plus.\nrewrite Rmult_assoc.\nrewrite <- (Rmult_assoc (IZR _)).\nchange (IZR _ * bpow _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x'))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : ~\nmidp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y).","proofString":"cut (~ (/ 2 * ulp beta fexp1 (x / y)        < x / y - round beta fexp1 Zfloor (x / y)        <= / 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)))).\nintro H; intro H'; apply H; split.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\nset (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nassert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 + u2))).\napply Rlt_le_trans with (x / y - x'); [|now apply Hlr].\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\ndo 2 rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\ndo 2 rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rlt_le_trans with (u1 * y + bpow (fexp1 (mag (x / y))                                          + fexp1 (mag y))                           + 2 * x' * y).\napply Rplus_lt_compat_r, Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nreplace (u1 * y) with (u1 * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\nreplace (2 * x' * y) with (2 * x' * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm u1).\nunfold u1, ulp, cexp; bpow_simplify.\nrewrite (Rmult_assoc 2).\nrewrite (Rmult_comm x').\nrewrite (Rmult_assoc 2).\nunfold x', round, F2R, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z); [|exact He].\ndo 4 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\nrewrite Zplus_comm, Zplus_assoc.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nrewrite (Rmult_comm _ (IZR _)).\ndo 2 rewrite Rmult_assoc.\nrewrite <- Fy.\nbpow_simplify.\nunfold Zminus; rewrite bpow_plus.\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- (Rmult_assoc (IZR mx)).\nrewrite <- Fx.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y)))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm _ y).\ndo 2 rewrite Rmult_assoc.\nchange (IZR (Zfloor _) * _) with x'.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x')).\napply Rlt_le_trans with (2 * x' * y + u1 * y + bpow (fexp1 (mag x))).\nrewrite Rplus_comm, Rplus_assoc; do 2 apply Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\nnow apply bpow_gt_0.\nnow apply Rabs_lt_inv; apply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nrewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- Fx.\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite bpow_plus.\nrewrite Rmult_assoc.\nrewrite <- (Rmult_assoc (IZR _)).\nchange (IZR _ * bpow _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x'))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)) ->\n~\nmidp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y).","proofString":"intro H; intro H'; apply H; split.\napply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'.\napply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (H : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y))) (H' : midp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)) : / 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y).","proofString":"apply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (H : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y))) (H' : midp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)) : round beta fexp1 Zfloor (x / y) + / 2 * ulp beta fexp1 (x / y) <\nround beta fexp1 Zfloor (x / y) + (x / y - round beta fexp1 Zfloor (x / y)).","proofString":"ring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (H : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y))) (H' : midp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)) : round beta fexp1 Zfloor (x / y) + / 2 * ulp beta fexp1 (x / y) < x / y.","proofString":"apply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (H : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y))) (H' : midp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)) : x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)).","proofString":"apply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).\nring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (H : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y))) (H' : midp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)) : round beta fexp1 Zfloor (x / y) + (x / y - round beta fexp1 Zfloor (x / y)) <=\nround beta fexp1 Zfloor (x / y) +\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)).","proofString":"ring_simplify.\napply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (H : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y))) (H' : midp fexp1 (x / y) < x / y <=\nmidp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)) : x / y <=\nround beta fexp1 Zfloor (x / y) + / 2 * ulp beta fexp1 (x / y) +\n/ 2 * ulp beta fexp2 (x / y).","proofString":"apply H'."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) : ~\n/ 2 * ulp beta fexp1 (x / y) < x / y - round beta fexp1 Zfloor (x / y) <=\n/ 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)).","proofString":"set (u1 := bpow (fexp1 (mag (x / y)))).\nset (u2 := bpow (fexp2 (mag (x / y)))).\nset (x' := round beta fexp1 Zfloor (x / y)).\nassert (S : (x / y <> 0)%R).\napply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq.\nrewrite 2!ulp_neq_0; trivial.\nrevert Fx Fy.\nunfold generic_format, F2R, scaled_mantissa, cexp; simpl.\nset (mx := Ztrunc (x * bpow (- fexp1 (mag x)))).\nset (my := Ztrunc (y * bpow (- fexp1 (mag y)))).\nintros Fx Fy.\nintro Hlr.\napply (Rlt_irrefl (/ 2 * (u1 + u2))).\napply Rlt_le_trans with (x / y - x'); [|now apply Hlr].\napply (Rplus_lt_reg_r x'); ring_simplify.\napply (Rmult_lt_reg_r y _ _ Py).\nunfold Rdiv; rewrite Rmult_assoc.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.\ndo 2 rewrite Rmult_plus_distr_r.\napply (Rmult_lt_reg_l 2); [lra|].\ndo 2 rewrite Rmult_plus_distr_l.\ndo 5 rewrite <- Rmult_assoc.\nrewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.\ndestruct (Zle_or_lt Z0 (fexp1 (mag x) - fexp1 (mag (x / y))                     - fexp1 (mag y))%Z) as [He|He].\napply Rlt_le_trans with (u1 * y + bpow (fexp1 (mag (x / y))                                          + fexp1 (mag y))                           + 2 * x' * y).\napply Rplus_lt_compat_r, Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\napply bpow_gt_0.\napply Rabs_lt_inv.\napply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nreplace (u1 * y) with (u1 * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\nreplace (2 * x' * y) with (2 * x' * (IZR my * bpow (fexp1 (mag y))));      [|now apply eq_sym; rewrite Fy at 1].\napply (Rmult_le_reg_r (bpow (- fexp1 (mag (x / y))                                 - fexp1 (mag y))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm u1).\nunfold u1, ulp, cexp; bpow_simplify.\nrewrite (Rmult_assoc 2).\nrewrite (Rmult_comm x').\nrewrite (Rmult_assoc 2).\nunfold x', round, F2R, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z); [|exact He].\ndo 4 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\nrewrite Zplus_comm, Zplus_assoc.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 4 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower; [|exact He].\napply (Rmult_lt_reg_r (bpow (fexp1 (mag y))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nrewrite (Rmult_comm _ (IZR _)).\ndo 2 rewrite Rmult_assoc.\nrewrite <- Fy.\nbpow_simplify.\nunfold Zminus; rewrite bpow_plus.\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- (Rmult_assoc (IZR mx)).\nrewrite <- Fx.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag (x / y)))));      [now apply bpow_gt_0|].\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite (Rmult_comm _ y).\ndo 2 rewrite Rmult_assoc.\nchange (IZR (Zfloor _) * _) with x'.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x')).\napply Rlt_le_trans with (2 * x' * y + u1 * y + bpow (fexp1 (mag x))).\nrewrite Rplus_comm, Rplus_assoc; do 2 apply Rplus_lt_compat_l.\napply Rlt_le_trans with (u2 * bpow (mag y)).\napply Rmult_lt_compat_l.\nnow apply bpow_gt_0.\nnow apply Rabs_lt_inv; apply bpow_mag_gt.\nunfold u2, ulp, cexp; bpow_simplify; apply bpow_le.\napply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia.\napply Rge_le; rewrite Fx at 1; apply Rle_ge.\nrewrite Fy at 1 2.\napply (Rmult_le_reg_r (bpow (- fexp1 (mag x))));      [now apply bpow_gt_0|].\ndo 2 rewrite Rmult_plus_distr_r.\nbpow_simplify.\nreplace (2 * x' * _ * _)    with (2 * IZR my * x' * bpow (fexp1 (mag y) - fexp1 (mag x))) by ring.\nrewrite (Rmult_comm u1).\nunfold x', u1, round, F2R, ulp, scaled_mantissa, cexp; simpl.\nbpow_simplify.\nrewrite <- (IZR_Zpower _ (_ - _)%Z) by lia.\ndo 5 rewrite <- mult_IZR.\ndo 2 rewrite <- plus_IZR.\napply IZR_le.\napply Zlt_le_succ.\napply lt_IZR.\nrewrite plus_IZR.\ndo 5 rewrite mult_IZR; simpl.\nrewrite IZR_Zpower by lia.\napply (Rmult_lt_reg_r (bpow (fexp1 (mag x))));      [now apply bpow_gt_0|].\nrewrite (Rmult_assoc _ (IZR mx)).\nrewrite <- Fx.\nrewrite Rmult_plus_distr_r.\nbpow_simplify.\nrewrite bpow_plus.\nrewrite Rmult_assoc.\nrewrite <- (Rmult_assoc (IZR _)).\nchange (IZR _ * bpow _) with x'.\ndo 2 rewrite (Rmult_comm _ (bpow (fexp1 (mag y)))).\nrewrite Rmult_assoc.\ndo 2 rewrite <- (Rmult_assoc (IZR my)).\nrewrite <- Fy.\nchange (bpow _) with u1.\napply (Rmult_lt_reg_l (/ 2)); [lra|].\nrewrite Rmult_plus_distr_l.\ndo 4 rewrite <- Rmult_assoc.\nrewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.\napply (Rplus_lt_reg_r (- y * x')); ring_simplify.\napply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].\nrewrite Rmult_plus_distr_l.\ndo 3 rewrite <- Rmult_assoc.\nrewrite Ropp_mult_distr_r_reverse.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.\nrewrite (Rmult_comm (/ y)).\nnow rewrite (Rplus_comm (- x'))."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) : x / y <> 0.","proofString":"apply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].\nnow apply Rinv_neq_0_compat, Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Fx : generic_format beta fexp1 x) (Fy : generic_format beta fexp1 y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) : / y <> 0.","proofString":"now apply Rinv_neq_0_compat, Rgt_not_eq."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : y < bpow (mag y).","proofString":"apply Rabs_lt_inv.\napply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : Rabs y < bpow (mag y).","proofString":"apply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : (fexp2 (mag (x / y)) + mag y <= fexp1 (mag (x / y)) + fexp1 (mag y))%Z.","proofString":"apply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : (fexp2 (mag (x / y)) <= - mag y + fexp1 (mag (x / y)) + fexp1 (mag y))%Z.","proofString":"rewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (0 <= fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y))%Z) : (fexp2 (mag (x / y)) <= fexp1 (mag (x / y)) + fexp1 (mag y) + - mag y)%Z.","proofString":"destruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      [now apply Hexp; [| |rewrite <- Hxy]|].\nreplace (_ - _ + 1)%Z with ((mag x + 1) - mag y)%Z by ring.\napply Hexp.\nnow assert (fexp1 (mag x + 1) <= mag x)%Z;        [apply valid_exp|lia].\nassumption.\nreplace (_ + 1 - _)%Z with (mag x - mag y + 1)%Z by ring.\nnow rewrite <- Hxy."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : y < bpow (mag y).","proofString":"now apply Rabs_lt_inv; apply bpow_mag_gt."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : (fexp2 (mag (x / y)) + mag y <= fexp1 (mag x))%Z.","proofString":"apply (Zplus_le_reg_r _ _ (- mag y)); ring_simplify.\nrewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : (fexp2 (mag (x / y)) <= - mag y + fexp1 (mag x))%Z.","proofString":"rewrite (Zplus_comm (- _)).\ndestruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(fexp1 fexp2 : Z -> Z) (Vfexp1 : Valid_exp fexp1) (Vfexp2 : Valid_exp fexp2) (choice1 choice2 : Z -> bool) (Hexp : round_round_div_hyp fexp1 fexp2) (x y : R) (Px : 0 < x) (Py : 0 < y) (Hf1 : (fexp1 (mag (x / y)) <= mag (x / y))%Z) (Hfx : (fexp1 (mag x) < mag x)%Z) (Hfy : (fexp1 (mag y) < mag y)%Z) (u1 : R) (u2 : R) (x' : R) (S : x / y <> 0) (mx : Z) (my : Z) (Fx : x = IZR mx * bpow (fexp1 (mag x))) (Fy : y = IZR my * bpow (fexp1 (mag y))) (Hlr : / 2 * bpow (fexp1 (mag (x / y))) < x / y - x' <=\n/ 2 * (bpow (fexp1 (mag (x / y))) + bpow (fexp2 (mag (x / y))))) (He : (fexp1 (mag x) - fexp1 (mag (x / y)) - fexp1 (mag y) < 0)%Z) : (fexp2 (mag (x / y)) <= fexp1 (mag x) + - mag y)%Z.","proofString":"destruct (mag_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;      apply Hexp; try assumption; rewrite <- Hxy; lia."},{"statement":"(Hprec : (2 * prec <= prec')%Z) : round_round_div_hyp (FLX_exp prec) (FLX_exp prec').","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold FLX_exp.\nunfold round_round_div_hyp.\nsplit; [now intro ex; lia|].\nsplit; [|split; [|split]]; intros ex ey; lia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_div_hyp (FLT_exp emin prec) (FLT_exp emin' prec').","proofString":"unfold FLT_exp.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_div_hyp.\nsplit; [intro ex|split; [|split; [|split]]; intros ex ey].\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey + 1 - prec) emin).\ngeneralize (Zmax_spec (ex - ey + 1 - prec') emin').\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_div_hyp (fun e : Z => Z.max (e - prec) emin)\n  (fun e : Z => Z.max (e - prec') emin').","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_div_hyp.\nsplit; [intro ex|split; [|split; [|split]]; intros ex ey].\ngeneralize (Zmax_spec (ex - prec') emin').\ngeneralize (Zmax_spec (ex - prec) emin).\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey + 1 - prec) emin).\ngeneralize (Zmax_spec (ex - ey + 1 - prec') emin').\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia.\ngeneralize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ex - ey - prec' >= emin')%Z /\\\nZ.max (ex - ey - prec') emin' = (ex - ey - prec')%Z \\/\n(ex - ey - prec' < emin')%Z /\\ Z.max (ex - ey - prec') emin' = emin' ->\n(ex - ey - prec >= emin)%Z /\\\nZ.max (ex - ey - prec) emin = (ex - ey - prec)%Z \\/\n(ex - ey - prec < emin)%Z /\\ Z.max (ex - ey - prec) emin = emin ->\n(ey - prec >= emin)%Z /\\ Z.max (ey - prec) emin = (ey - prec)%Z \\/\n(ey - prec < emin)%Z /\\ Z.max (ey - prec) emin = emin ->\n(ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin < ex)%Z ->\n(Z.max (ey - prec) emin < ey)%Z ->\n(Z.max (ex - ey - prec) emin <= ex - ey)%Z ->\n(Z.max (ex - ey - prec') emin' <=\n Z.max (ex - ey - prec) emin + Z.max (ey - prec) emin - ey)%Z.","proofString":"generalize (Zmax_spec (ex - prec) emin).\ngeneralize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin < ex)%Z ->\n(Z.max (ey - prec) emin < ey)%Z ->\nZ.max (ex - ey - prec) emin = (ex - ey + 1)%Z ->\n(Z.max (ex - ey - prec') emin' <= ex - ey - ey + Z.max (ey - prec) emin)%Z.","proofString":"generalize (Zmax_spec (ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ey - prec >= emin)%Z /\\ Z.max (ey - prec) emin = (ey - prec)%Z \\/\n(ey - prec < emin)%Z /\\ Z.max (ey - prec) emin = emin ->\n(ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin < ex)%Z ->\n(Z.max (ey - prec) emin < ey)%Z ->\nZ.max (ex - ey - prec) emin = (ex - ey + 1)%Z ->\n(Z.max (ex - ey - prec') emin' <= ex - ey - ey + Z.max (ey - prec) emin)%Z.","proofString":"generalize (Zmax_spec (ex - ey - prec) emin).\ngeneralize (Zmax_spec (ex - ey - prec') emin').\nlia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ex - ey - prec >= emin)%Z /\\\nZ.max (ex - ey - prec) emin = (ex - ey - prec)%Z \\/\n(ex - ey - prec < emin)%Z /\\ Z.max (ex - ey - prec) emin = emin ->\n(ey - prec >= emin)%Z /\\ Z.max (ey - prec) emin = (ey - prec)%Z \\/\n(ey - prec < emin)%Z /\\ Z.max (ey - prec) emin = emin ->\n(ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin < ex)%Z ->\n(Z.max (ey - prec) emin < ey)%Z ->\nZ.max (ex - ey - prec) emin = (ex - ey + 1)%Z ->\n(Z.max (ex - ey - prec') emin' <= ex - ey - ey + Z.max (ey - prec) emin)%Z.","proofString":"generalize (Zmax_spec (ex - ey - prec') emin').\nlia."},{"statement":"(Hemin : (emin' <= emin - prec - 2)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : (ex - ey - prec' >= emin')%Z /\\\nZ.max (ex - ey - prec') emin' = (ex - ey - prec')%Z \\/\n(ex - ey - prec' < emin')%Z /\\ Z.max (ex - ey - prec') emin' = emin' ->\n(ex - ey - prec >= emin)%Z /\\\nZ.max (ex - ey - prec) emin = (ex - ey - prec)%Z \\/\n(ex - ey - prec < emin)%Z /\\ Z.max (ex - ey - prec) emin = emin ->\n(ey - prec >= emin)%Z /\\ Z.max (ey - prec) emin = (ey - prec)%Z \\/\n(ey - prec < emin)%Z /\\ Z.max (ey - prec) emin = emin ->\n(ex - prec >= emin)%Z /\\ Z.max (ex - prec) emin = (ex - prec)%Z \\/\n(ex - prec < emin)%Z /\\ Z.max (ex - prec) emin = emin ->\n(Z.max (ex - prec) emin < ex)%Z ->\n(Z.max (ey - prec) emin < ey)%Z ->\nZ.max (ex - ey - prec) emin = (ex - ey + 1)%Z ->\n(Z.max (ex - ey - prec') emin' <= ex - ey - ey + Z.max (ey - prec) emin)%Z.","proofString":"lia."},{"statement":"(Hemin : (emin' + prec' <= emin - 1)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_div_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').","proofString":"unfold FTZ_exp.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_div_hyp.\nsplit; [intro ex|split; [|split; [|split]]; intros ex ey].\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey + 1 - prec) emin);  destruct (Z.ltb_spec (ex - ey + 1 - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia."},{"statement":"(Hemin : (emin' + prec' <= emin - 1)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_div_hyp\n  (fun e : Z =>\n   if (e - prec <? emin)%Z then (emin + prec - 1)%Z else (e - prec)%Z)\n  (fun e : Z =>\n   if (e - prec' <? emin')%Z then (emin' + prec' - 1)%Z else (e - prec')%Z).","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_div_hyp.\nsplit; [intro ex|split; [|split; [|split]]; intros ex ey].\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey + 1 - prec) emin);  destruct (Z.ltb_spec (ex - ey + 1 - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia."},{"statement":"(Hemin : (emin' + prec' <= emin - 1)%Z) (Hprec : (2 * prec <= prec')%Z) : round_round_div_hyp\n  (fun e : Z =>\n   if (e - prec <? emin)%Z then (emin + prec - 1)%Z else (e - prec)%Z)\n  (fun e : Z =>\n   if (e - prec' <? emin')%Z then (emin' + prec' - 1)%Z else (e - prec')%Z).","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold round_round_div_hyp.\nsplit; [intro ex|split; [|split; [|split]]; intros ex ey].\ndestruct (Z.ltb_spec (ex - prec') emin');  destruct (Z.ltb_spec (ex - prec) emin);  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey + 1 - prec) emin);  destruct (Z.ltb_spec (ex - ey + 1 - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia.\ndestruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia."},{"statement":"(Hemin : (emin' + prec' <= emin - 1)%Z) (Hprec : (2 * prec <= prec')%Z) (ex ey : Z) : ((if ex - prec <? emin then emin + prec - 1 else ex - prec) < ex)%Z ->\n((if ey - prec <? emin then emin + prec - 1 else ey - prec) < ey)%Z ->\n((if ex - ey - prec <? emin then emin + prec - 1 else ex - ey - prec) <=\n ex - ey)%Z ->\n((if ex - ey - prec' <? emin' then emin' + prec' - 1 else ex - ey - prec') <=\n (if ex - ey - prec <? emin then emin + prec - 1 else ex - ey - prec) +\n (if ey - prec <? emin then emin + prec - 1 else ey - prec) - ey)%Z.","proofString":"destruct (Z.ltb_spec (ex - prec) emin);  destruct (Z.ltb_spec (ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec) emin);  destruct (Z.ltb_spec (ex - ey - prec') emin');  lia."}]}