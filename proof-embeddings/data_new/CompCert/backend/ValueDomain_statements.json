{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/ValueDomain.v","fileSamples":[{"statement":"(x y : block_class) (id id0 : ident) : {id = id0} + {id <> id0}.","conclusion":"{id = id0} + {id <> id0}","hypotheses":"(x y : block_class) (id id0 : ident)","proofString":"apply peq."},{"statement":"(b : positive) (bc : block_classification) (bound : positive) (H : ~ Plt b bound) (H0 : bc_below bc bound) : bc b = BCinvalid.","conclusion":"bc b = BCinvalid","hypotheses":"(b : positive) (bc : block_classification) (bound : positive) (H : ~ Plt b bound) (H0 : bc_below bc bound)","proofString":"destruct (block_class_eq (bc b) BCinvalid); auto.\nelim H.\napply H0; auto."},{"statement":"(b : positive) (bc : block_classification) (bound : positive) (H : ~ Plt b bound) (H0 : bc_below bc bound) (n : bc b <> BCinvalid) : bc b = BCinvalid.","conclusion":"bc b = BCinvalid","hypotheses":"(b : positive) (bc : block_classification) (bound : positive) (H : ~ Plt b bound) (H0 : bc_below bc bound) (n : bc b <> BCinvalid)","proofString":"elim H.\napply H0; auto."},{"statement":"(b : positive) (bc : block_classification) (bound : positive) (H : ~ Plt b bound) (H0 : bc_below bc bound) (n : bc b <> BCinvalid) : Plt b bound.","conclusion":"Plt b bound","hypotheses":"(b : positive) (bc : block_classification) (bound : positive) (H : ~ Plt b bound) (H0 : bc_below bc bound) (n : bc b <> BCinvalid)","proofString":"apply H0; auto."},{"statement":"(ob : option bool) (x y : abool) (H : cmatch ob x) : cmatch ob (club x y).","conclusion":"cmatch ob (club x y)","hypotheses":"(ob : option bool) (x y : abool) (H : cmatch ob x)","proofString":"unfold club; inv H; destruct y; try constructor;  destruct (eqb b b0) eqn:EQ; try constructor.\nreplace b0 with b by (apply eqb_prop; auto).\nconstructor."},{"statement":"(b0 b : bool) (EQ : eqb b b0 = true) : cmatch (Some b) (Maybe b0).","conclusion":"cmatch (Some b) (Maybe b0)","hypotheses":"(b0 b : bool) (EQ : eqb b b0 = true)","proofString":"replace b0 with b by (apply eqb_prop; auto).\nconstructor."},{"statement":"(b0 b : bool) (EQ : eqb b b0 = true) : cmatch (Some b) (Maybe b).","conclusion":"cmatch (Some b) (Maybe b)","hypotheses":"(b0 b : bool) (EQ : eqb b b0 = true)","proofString":"constructor."},{"statement":"(ob : option bool) (x y : abool) (H : cmatch ob y) : cmatch ob (club x y).","conclusion":"cmatch ob (club x y)","hypotheses":"(ob : option bool) (x y : abool) (H : cmatch ob y)","proofString":"unfold club; inv H; destruct x; try constructor;  destruct (eqb b0 b) eqn:EQ; try constructor.\nreplace b with b0 by (apply eqb_prop; auto).\nconstructor.\nreplace b with b0 by (apply eqb_prop; auto).\nconstructor.\nreplace b with b0 by (apply eqb_prop; auto).\nconstructor."},{"statement":"(b0 b : bool) (EQ : eqb b0 b = true) : cmatch (Some b) (Just b0).","conclusion":"cmatch (Some b) (Just b0)","hypotheses":"(b0 b : bool) (EQ : eqb b0 b = true)","proofString":"replace b with b0 by (apply eqb_prop; auto).\nconstructor."},{"statement":"(b0 b : bool) (EQ : eqb b0 b = true) : cmatch (Some b0) (Just b0).","conclusion":"cmatch (Some b0) (Just b0)","hypotheses":"(b0 b : bool) (EQ : eqb b0 b = true)","proofString":"constructor."},{"statement":"(b0 b : bool) (EQ : eqb b0 b = true) : cmatch (Some b) (Maybe b0).","conclusion":"cmatch (Some b) (Maybe b0)","hypotheses":"(b0 b : bool) (EQ : eqb b0 b = true)","proofString":"replace b with b0 by (apply eqb_prop; auto).\nconstructor."},{"statement":"(b0 b : bool) (EQ : eqb b0 b = true) : cmatch (Some b0) (Maybe b0).","conclusion":"cmatch (Some b0) (Maybe b0)","hypotheses":"(b0 b : bool) (EQ : eqb b0 b = true)","proofString":"constructor."},{"statement":"(b0 b : bool) (EQ : eqb b0 b = true) : cmatch (Some b) (Maybe b0).","conclusion":"cmatch (Some b) (Maybe b0)","hypotheses":"(b0 b : bool) (EQ : eqb b0 b = true)","proofString":"replace b with b0 by (apply eqb_prop; auto).\nconstructor."},{"statement":"(b0 b : bool) (EQ : eqb b0 b = true) : cmatch (Some b0) (Maybe b0).","conclusion":"cmatch (Some b0) (Maybe b0)","hypotheses":"(b0 b : bool) (EQ : eqb b0 b = true)","proofString":"constructor."},{"statement":"(p1 p2 : aptr) : {p1 = p2} + {p1 <> p2}.","conclusion":"{p1 = p2} + {p1 <> p2}","hypotheses":"(p1 p2 : aptr)","proofString":"generalize ident_eq, Ptrofs.eq_dec; intros.\ndecide equality."},{"statement":"(p1 p2 : aptr) (H : forall x y : positive, {x = y} + {x <> y}) (H0 : forall x y : ptrofs, {x = y} + {x <> y}) : {p1 = p2} + {p1 <> p2}.","conclusion":"{p1 = p2} + {p1 <> p2}","hypotheses":"(p1 p2 : aptr) (H : forall x y : positive, {x = y} + {x <> y}) (H0 : forall x y : ptrofs, {x = y} + {x <> y})","proofString":"decide equality."},{"statement":"(b : block) (ofs : ptrofs) (p : aptr) (H : pmatch b ofs p) : pmatch b ofs Ptop.","conclusion":"pmatch b ofs Ptop","hypotheses":"(b : block) (ofs : ptrofs) (p : aptr) (H : pmatch b ofs p)","proofString":"apply pmatch_ge with p; auto with va."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) : (if ident_eq id id0\n then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n else Glob) =\n(if ident_eq id0 id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id0 ofs0 else Glo id0\n else Glob).","conclusion":"(if ident_eq id id0\n then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n else Glob) =\n(if ident_eq id0 id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id0 ofs0 else Glo id0\n else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs)","proofString":"destruct (ident_eq id id0).\nsubst id0.\nrewrite dec_eq_true.\ndestruct (Ptrofs.eq_dec ofs ofs0).\nsubst ofs0.\nrewrite dec_eq_true.\nauto.\nrewrite dec_eq_false by auto.\nauto.\nrewrite dec_eq_false by auto.\nauto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0) : (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) =\n(if ident_eq id0 id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id0 ofs0 else Glo id0\n else Glob).","conclusion":"(if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) =\n(if ident_eq id0 id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id0 ofs0 else Glo id0\n else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0)","proofString":"subst id0.\nrewrite dec_eq_true.\ndestruct (Ptrofs.eq_dec ofs ofs0).\nsubst ofs0.\nrewrite dec_eq_true.\nauto.\nrewrite dec_eq_false by auto.\nauto."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) : (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) =\n(if ident_eq id id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id\n else Glob).","conclusion":"(if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) =\n(if ident_eq id id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id\n else Glob)","hypotheses":"(id : ident) (ofs ofs0 : ptrofs)","proofString":"rewrite dec_eq_true.\ndestruct (Ptrofs.eq_dec ofs ofs0).\nsubst ofs0.\nrewrite dec_eq_true.\nauto.\nrewrite dec_eq_false by auto.\nauto."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) : (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) =\n(if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id).","conclusion":"(if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) =\n(if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id)","hypotheses":"(id : ident) (ofs ofs0 : ptrofs)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0).\nsubst ofs0.\nrewrite dec_eq_true.\nauto.\nrewrite dec_eq_false by auto.\nauto."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) (e : ofs = ofs0) : Gl id ofs = (if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id).","conclusion":"Gl id ofs = (if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id)","hypotheses":"(id : ident) (ofs ofs0 : ptrofs) (e : ofs = ofs0)","proofString":"subst ofs0.\nrewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (ofs : ptrofs) : Gl id ofs = (if Ptrofs.eq_dec ofs ofs then Gl id ofs else Glo id).","conclusion":"Gl id ofs = (if Ptrofs.eq_dec ofs ofs then Gl id ofs else Glo id)","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"rewrite dec_eq_true.\nauto."},{"statement":"(id : ident) (ofs : ptrofs) : Gl id ofs = Gl id ofs.","conclusion":"Gl id ofs = Gl id ofs","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"auto."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) (n : ofs <> ofs0) : Glo id = (if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id).","conclusion":"Glo id = (if Ptrofs.eq_dec ofs0 ofs then Gl id ofs0 else Glo id)","hypotheses":"(id : ident) (ofs ofs0 : ptrofs) (n : ofs <> ofs0)","proofString":"rewrite dec_eq_false by auto.\nauto."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) (n : ofs <> ofs0) : Glo id = Glo id.","conclusion":"Glo id = Glo id","hypotheses":"(id : ident) (ofs ofs0 : ptrofs) (n : ofs <> ofs0)","proofString":"auto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0) : Glob =\n(if ident_eq id0 id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id0 ofs0 else Glo id0\n else Glob).","conclusion":"Glob =\n(if ident_eq id0 id\n then if Ptrofs.eq_dec ofs0 ofs then Gl id0 ofs0 else Glo id0\n else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0)","proofString":"rewrite dec_eq_false by auto.\nauto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0) : Glob = Glob.","conclusion":"Glob = Glob","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0)","proofString":"auto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) : (if ident_eq id id0 then Glo id0 else Glob) =\n(if ident_eq id0 id then Glo id0 else Glob).","conclusion":"(if ident_eq id id0 then Glo id0 else Glob) =\n(if ident_eq id0 id then Glo id0 else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident)","proofString":"destruct (ident_eq id id0).\nsubst id0.\nrewrite dec_eq_true; auto.\nrewrite dec_eq_false; auto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (e : id = id0) : Glo id0 = (if ident_eq id0 id then Glo id0 else Glob).","conclusion":"Glo id0 = (if ident_eq id0 id then Glo id0 else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (e : id = id0)","proofString":"subst id0.\nrewrite dec_eq_true; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Glo id = (if ident_eq id id then Glo id else Glob).","conclusion":"Glo id = (if ident_eq id id then Glo id else Glob)","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"rewrite dec_eq_true; auto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (n : id <> id0) : Glob = (if ident_eq id0 id then Glo id0 else Glob).","conclusion":"Glob = (if ident_eq id0 id then Glo id0 else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (n : id <> id0)","proofString":"rewrite dec_eq_false; auto."},{"statement":"(id id0 : ident) (ofs : ptrofs) : (if ident_eq id id0 then Glo id else Glob) =\n(if ident_eq id0 id then Glo id else Glob).","conclusion":"(if ident_eq id id0 then Glo id else Glob) =\n(if ident_eq id0 id then Glo id else Glob)","hypotheses":"(id id0 : ident) (ofs : ptrofs)","proofString":"destruct (ident_eq id id0).\nsubst id0.\nrewrite dec_eq_true; auto.\nrewrite dec_eq_false; auto."},{"statement":"(id id0 : ident) (ofs : ptrofs) (e : id = id0) : Glo id = (if ident_eq id0 id then Glo id else Glob).","conclusion":"Glo id = (if ident_eq id0 id then Glo id else Glob)","hypotheses":"(id id0 : ident) (ofs : ptrofs) (e : id = id0)","proofString":"subst id0.\nrewrite dec_eq_true; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Glo id = (if ident_eq id id then Glo id else Glob).","conclusion":"Glo id = (if ident_eq id id then Glo id else Glob)","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"rewrite dec_eq_true; auto."},{"statement":"(id id0 : ident) (ofs : ptrofs) (n : id <> id0) : Glob = (if ident_eq id0 id then Glo id else Glob).","conclusion":"Glob = (if ident_eq id0 id then Glo id else Glob)","hypotheses":"(id id0 : ident) (ofs : ptrofs) (n : id <> id0)","proofString":"rewrite dec_eq_false; auto."},{"statement":"(id id0 : ident) : (if ident_eq id id0 then Glo id else Glob) =\n(if ident_eq id0 id then Glo id0 else Glob).","conclusion":"(if ident_eq id id0 then Glo id else Glob) =\n(if ident_eq id0 id then Glo id0 else Glob)","hypotheses":"(id id0 : ident)","proofString":"destruct (ident_eq id id0).\nsubst id0.\nrewrite dec_eq_true; auto.\nrewrite dec_eq_false; auto."},{"statement":"(id id0 : ident) (e : id = id0) : Glo id = (if ident_eq id0 id then Glo id0 else Glob).","conclusion":"Glo id = (if ident_eq id0 id then Glo id0 else Glob)","hypotheses":"(id id0 : ident) (e : id = id0)","proofString":"subst id0.\nrewrite dec_eq_true; auto."},{"statement":"(id : ident) : Glo id = (if ident_eq id id then Glo id else Glob).","conclusion":"Glo id = (if ident_eq id id then Glo id else Glob)","hypotheses":"(id : ident)","proofString":"rewrite dec_eq_true; auto."},{"statement":"(id id0 : ident) (n : id <> id0) : Glob = (if ident_eq id0 id then Glo id0 else Glob).","conclusion":"Glob = (if ident_eq id0 id then Glo id0 else Glob)","hypotheses":"(id id0 : ident) (n : id <> id0)","proofString":"rewrite dec_eq_false; auto."},{"statement":"(ofs ofs0 : ptrofs) : (if Ptrofs.eq_dec ofs ofs0 then Stk ofs else Stack) =\n(if Ptrofs.eq_dec ofs0 ofs then Stk ofs0 else Stack).","conclusion":"(if Ptrofs.eq_dec ofs ofs0 then Stk ofs else Stack) =\n(if Ptrofs.eq_dec ofs0 ofs then Stk ofs0 else Stack)","hypotheses":"(ofs ofs0 : ptrofs)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0).\nsubst ofs0.\nrewrite dec_eq_true; auto.\nrewrite dec_eq_false; auto."},{"statement":"(ofs ofs0 : ptrofs) (e : ofs = ofs0) : Stk ofs = (if Ptrofs.eq_dec ofs0 ofs then Stk ofs0 else Stack).","conclusion":"Stk ofs = (if Ptrofs.eq_dec ofs0 ofs then Stk ofs0 else Stack)","hypotheses":"(ofs ofs0 : ptrofs) (e : ofs = ofs0)","proofString":"subst ofs0.\nrewrite dec_eq_true; auto."},{"statement":"(ofs : ptrofs) : Stk ofs = (if Ptrofs.eq_dec ofs ofs then Stk ofs else Stack).","conclusion":"Stk ofs = (if Ptrofs.eq_dec ofs ofs then Stk ofs else Stack)","hypotheses":"(ofs : ptrofs)","proofString":"rewrite dec_eq_true; auto."},{"statement":"(ofs ofs0 : ptrofs) (n : ofs <> ofs0) : Stack = (if Ptrofs.eq_dec ofs0 ofs then Stk ofs0 else Stack).","conclusion":"Stack = (if Ptrofs.eq_dec ofs0 ofs then Stk ofs0 else Stack)","hypotheses":"(ofs ofs0 : ptrofs) (n : ofs <> ofs0)","proofString":"rewrite dec_eq_false; auto."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) : pge\n  (if ident_eq id id0\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob) (Gl id ofs).","conclusion":"pge\n  (if ident_eq id id0\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob) (Gl id ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs)","proofString":"destruct (ident_eq id id0).\ndestruct (Ptrofs.eq_dec ofs ofs0); subst; constructor.\nconstructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0) : pge (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) (Gl id ofs).","conclusion":"pge (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id) (Gl id ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0); subst; constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0) : pge Glob (Gl id ofs).","conclusion":"pge Glob (Gl id ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0)","proofString":"constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) : pge (if ident_eq id id0 then Glo id0 else Glob) (Gl id ofs).","conclusion":"pge (if ident_eq id id0 then Glo id0 else Glob) (Gl id ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident)","proofString":"destruct (ident_eq id id0); subst; constructor."},{"statement":"(id id0 : ident) (ofs : ptrofs) : pge (if ident_eq id id0 then Glo id else Glob) (Glo id).","conclusion":"pge (if ident_eq id id0 then Glo id else Glob) (Glo id)","hypotheses":"(id id0 : ident) (ofs : ptrofs)","proofString":"destruct (ident_eq id id0); subst; constructor."},{"statement":"(id id0 : ident) : pge (if ident_eq id id0 then Glo id else Glob) (Glo id).","conclusion":"pge (if ident_eq id id0 then Glo id else Glob) (Glo id)","hypotheses":"(id id0 : ident)","proofString":"destruct (ident_eq id id0); subst; constructor."},{"statement":"(ofs ofs0 : ptrofs) : pge (if Ptrofs.eq_dec ofs ofs0 then Stk ofs else Stack) (Stk ofs).","conclusion":"pge (if Ptrofs.eq_dec ofs ofs0 then Stk ofs else Stack) (Stk ofs)","hypotheses":"(ofs ofs0 : ptrofs)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0); subst; constructor."},{"statement":"(p q : aptr) : pge (plub p q) q.","conclusion":"pge (plub p q) q","hypotheses":"(p q : aptr)","proofString":"rewrite plub_comm.\napply pge_lub_l."},{"statement":"(p q : aptr) : pge (plub q p) q.","conclusion":"pge (plub q p) q","hypotheses":"(p q : aptr)","proofString":"apply pge_lub_l."},{"statement":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs p) : pmatch b ofs (plub p q).","conclusion":"pmatch b ofs (plub p q)","hypotheses":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs p)","proofString":"eapply pmatch_ge; eauto.\napply pge_lub_l."},{"statement":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs p) : pge (plub p q) p.","conclusion":"pge (plub p q) p","hypotheses":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs p)","proofString":"apply pge_lub_l."},{"statement":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs q) : pmatch b ofs (plub p q).","conclusion":"pmatch b ofs (plub p q)","hypotheses":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs q)","proofString":"eapply pmatch_ge; eauto.\napply pge_lub_r."},{"statement":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs q) : pge (plub p q) q.","conclusion":"pge (plub p q) q","hypotheses":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pmatch b ofs q)","proofString":"apply pge_lub_r."},{"statement":"(r p q : aptr) (H : pge r p) (H0 : pge r q) : pge r (plub p q).","conclusion":"pge r (plub p q)","hypotheses":"(r p q : aptr) (H : pge r p) (H0 : pge r q)","proofString":"inv H; inv H0; simpl; try constructor.\ndestruct p; constructor.\nunfold plub; destruct q; repeat rewrite dec_eq_true; constructor.\nrewrite dec_eq_true; constructor.\nrewrite dec_eq_true; constructor.\nrewrite dec_eq_true.\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor.\ndestruct (ident_eq id id0).\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor.\nconstructor.\ndestruct (ident_eq id id0); constructor.\ndestruct (ident_eq id id0); constructor.\ndestruct (ident_eq id id0); constructor.\ndestruct (ident_eq id id0).\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor.\nconstructor.\ndestruct (ident_eq id id0); constructor.\ndestruct (ident_eq id id0); constructor.\ndestruct (ident_eq id id0); constructor.\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor."},{"statement":"(p : aptr) : pge p (plub p Pbot).","conclusion":"pge p (plub p Pbot)","hypotheses":"(p : aptr)","proofString":"destruct p; constructor."},{"statement":"(q : aptr) : pge q (plub q q).","conclusion":"pge q (plub q q)","hypotheses":"(q : aptr)","proofString":"unfold plub; destruct q; repeat rewrite dec_eq_true; constructor."},{"statement":"(id : ident) (ofs : ptrofs) : pge (Glo id) (if ident_eq id id then Glo id else Glob).","conclusion":"pge (Glo id) (if ident_eq id id then Glo id else Glob)","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"rewrite dec_eq_true; constructor."},{"statement":"(id : ident) (ofs : ptrofs) : pge (Glo id) (if ident_eq id id then Glo id else Glob).","conclusion":"pge (Glo id) (if ident_eq id id then Glo id else Glob)","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"rewrite dec_eq_true; constructor."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) : pge (Glo id)\n  (if ident_eq id id\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob).","conclusion":"pge (Glo id)\n  (if ident_eq id id\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob)","hypotheses":"(id : ident) (ofs ofs0 : ptrofs)","proofString":"rewrite dec_eq_true.\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor."},{"statement":"(id : ident) (ofs ofs0 : ptrofs) : pge (Glo id) (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id).","conclusion":"pge (Glo id) (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id)","hypotheses":"(id : ident) (ofs ofs0 : ptrofs)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0); constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) : pge Glob\n  (if ident_eq id id0\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob).","conclusion":"pge Glob\n  (if ident_eq id id0\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs)","proofString":"destruct (ident_eq id id0).\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor.\nconstructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0) : pge Glob (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id).","conclusion":"pge Glob (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0); constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0) : pge Glob Glob.","conclusion":"pge Glob Glob","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0)","proofString":"constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) : pge Glob (if ident_eq id id0 then Glo id0 else Glob).","conclusion":"pge Glob (if ident_eq id id0 then Glo id0 else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident)","proofString":"destruct (ident_eq id id0); constructor."},{"statement":"(id id0 : ident) (ofs : ptrofs) : pge Glob (if ident_eq id id0 then Glo id else Glob).","conclusion":"pge Glob (if ident_eq id id0 then Glo id else Glob)","hypotheses":"(id id0 : ident) (ofs : ptrofs)","proofString":"destruct (ident_eq id id0); constructor."},{"statement":"(id id0 : ident) : pge Glob (if ident_eq id id0 then Glo id else Glob).","conclusion":"pge Glob (if ident_eq id id0 then Glo id else Glob)","hypotheses":"(id id0 : ident)","proofString":"destruct (ident_eq id id0); constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) : pge Nonstack\n  (if ident_eq id id0\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob).","conclusion":"pge Nonstack\n  (if ident_eq id id0\n   then if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id\n   else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs)","proofString":"destruct (ident_eq id id0).\ndestruct (Ptrofs.eq_dec ofs ofs0); constructor.\nconstructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0) : pge Nonstack (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id).","conclusion":"pge Nonstack (if Ptrofs.eq_dec ofs ofs0 then Gl id ofs else Glo id)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (e : id = id0)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0); constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0) : pge Nonstack Glob.","conclusion":"pge Nonstack Glob","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident) (ofs0 : ptrofs) (n : id <> id0)","proofString":"constructor."},{"statement":"(id : ident) (ofs : ptrofs) (id0 : ident) : pge Nonstack (if ident_eq id id0 then Glo id0 else Glob).","conclusion":"pge Nonstack (if ident_eq id id0 then Glo id0 else Glob)","hypotheses":"(id : ident) (ofs : ptrofs) (id0 : ident)","proofString":"destruct (ident_eq id id0); constructor."},{"statement":"(id id0 : ident) (ofs : ptrofs) : pge Nonstack (if ident_eq id id0 then Glo id else Glob).","conclusion":"pge Nonstack (if ident_eq id id0 then Glo id else Glob)","hypotheses":"(id id0 : ident) (ofs : ptrofs)","proofString":"destruct (ident_eq id id0); constructor."},{"statement":"(id id0 : ident) : pge Nonstack (if ident_eq id id0 then Glo id else Glob).","conclusion":"pge Nonstack (if ident_eq id id0 then Glo id else Glob)","hypotheses":"(id id0 : ident)","proofString":"destruct (ident_eq id id0); constructor."},{"statement":"(ofs ofs0 : ptrofs) : pge Stack (if Ptrofs.eq_dec ofs ofs0 then Stk ofs else Stack).","conclusion":"pge Stack (if Ptrofs.eq_dec ofs ofs0 then Stk ofs else Stack)","hypotheses":"(ofs ofs0 : ptrofs)","proofString":"destruct (Ptrofs.eq_dec ofs ofs0); constructor."},{"statement":"(p : aptr) : pincl p Ptop = true.","conclusion":"pincl p Ptop = true","hypotheses":"(p : aptr)","proofString":"destruct p; auto."},{"statement":"(p : aptr) : pincl p p = true.","conclusion":"pincl p p = true","hypotheses":"(p : aptr)","proofString":"destruct p; simpl; auto; rewrite ! proj_sumbool_is_true; auto."},{"statement":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pincl p q = true) (H0 : pmatch b ofs p) : pmatch b ofs q.","conclusion":"pmatch b ofs q","hypotheses":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pincl p q = true) (H0 : pmatch b ofs p)","proofString":"eapply pmatch_ge; eauto.\napply pincl_ge; auto."},{"statement":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pincl p q = true) (H0 : pmatch b ofs p) : pge q p.","conclusion":"pge q p","hypotheses":"(b : block) (ofs : ptrofs) (p q : aptr) (H : pincl p q = true) (H0 : pmatch b ofs p)","proofString":"apply pincl_ge; auto."},{"statement":"(b : block) (ofs : ptrofs) (p : aptr) (delta : ptrofs) (H : pmatch b ofs p) : pmatch b (Ptrofs.add ofs delta) (padd p delta).","conclusion":"pmatch b (Ptrofs.add ofs delta) (padd p delta)","hypotheses":"(b : block) (ofs : ptrofs) (p : aptr) (delta : ptrofs) (H : pmatch b ofs p)","proofString":"inv H; simpl padd; eauto with va."},{"statement":"(b : block) (ofs : ptrofs) (p : aptr) (delta : ptrofs) (H : pmatch b ofs p) : pmatch b (Ptrofs.sub ofs delta) (psub p delta).","conclusion":"pmatch b (Ptrofs.sub ofs delta) (psub p delta)","hypotheses":"(b : block) (ofs : ptrofs) (p : aptr) (delta : ptrofs) (H : pmatch b ofs p)","proofString":"inv H; simpl psub; eauto with va."},{"statement":"(b : block) (ofs1 ofs2 : ptrofs) (p : aptr) (H : pmatch b ofs1 p) : pmatch b ofs2 (poffset p).","conclusion":"pmatch b ofs2 (poffset p)","hypotheses":"(b : block) (ofs1 ofs2 : ptrofs) (p : aptr) (H : pmatch b ofs1 p)","proofString":"inv H; simpl poffset; eauto with va."},{"statement":"forall c : comparison,\ncmatch None\n  match c with\n  | Ceq => Maybe false\n  | Cne => Maybe true\n  | _ => if va_strict tt then Bnone else Btop\n  end.","conclusion":"forall c : comparison,\ncmatch None\n  match c with\n  | Ceq => Maybe false\n  | Cne => Maybe true\n  | _ => if va_strict tt then Bnone else Btop\n  end","hypotheses":"","proofString":"destruct c, (va_strict tt); constructor."},{"statement":"forall c : comparison,\ncmatch (Val.cmp_different_blocks c)\n  match c with\n  | Ceq => Maybe false\n  | Cne => Maybe true\n  | _ => if va_strict tt then Bnone else Btop\n  end.","conclusion":"forall c : comparison,\ncmatch (Val.cmp_different_blocks c)\n  match c with\n  | Ceq => Maybe false\n  | Cne => Maybe true\n  | _ => if va_strict tt then Bnone else Btop\n  end","hypotheses":"","proofString":"destruct c, (va_strict tt); constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2)","proofString":"assert (DIFF: b1 <> b2 ->            cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))                   (cmp_different_blocks c)).\nintros.\nsimpl.\nrewrite dec_eq_false by assumption.\ndestruct Archi.ptr64.\napply cmp_different_blocks_none.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\nassert (SAME: b1 = b2 ->            cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))                   (Maybe (Ptrofs.cmpu c ofs1 ofs2))).\nintros.\nsubst b2.\nsimpl.\ndestruct Archi.ptr64.\nconstructor.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nunfold pcmp; inv H; inv H0; (apply cmatch_top || (apply DIFF; congruence) || idtac).\ndestruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va.\napply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c).","conclusion":"b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2)","proofString":"intros.\nsimpl.\nrewrite dec_eq_false by assumption.\ndestruct Archi.ptr64.\napply cmp_different_blocks_none.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"simpl.\nrewrite dec_eq_false by assumption.\ndestruct Archi.ptr64.\napply cmp_different_blocks_none.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if eq_block b1 b2\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b2 (Ptrofs.unsigned ofs2) || valid b2 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if eq_block b1 b2\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b2 (Ptrofs.unsigned ofs2) || valid b2 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"rewrite dec_eq_false by assumption.\ndestruct Archi.ptr64.\napply cmp_different_blocks_none.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"destruct Archi.ptr64.\napply cmp_different_blocks_none.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch\n  (if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"destruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c).","conclusion":"cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"apply cmp_different_blocks_sound."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c))","proofString":"assert (SAME: b1 = b2 ->            cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))                   (Maybe (Ptrofs.cmpu c ofs1 ofs2))).\nintros.\nsubst b2.\nsimpl.\ndestruct Archi.ptr64.\nconstructor.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nunfold pcmp; inv H; inv H0; (apply cmatch_top || (apply DIFF; congruence) || idtac).\ndestruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va.\napply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c))","proofString":"intros.\nsubst b2.\nsimpl.\ndestruct Archi.ptr64.\nconstructor.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (H1 : b1 = b2) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (H1 : b1 = b2)","proofString":"subst b2.\nsimpl.\ndestruct Archi.ptr64.\nconstructor.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"simpl.\ndestruct Archi.ptr64.\nconstructor.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"destruct Archi.ptr64.\nconstructor.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch None (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch None (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if eq_block b1 b1\n   then\n    if\n     (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n     (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n    then Some (Ptrofs.cmpu c ofs1 ofs2)\n    else None\n   else\n    if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n    then Val.cmp_different_blocks c\n    else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if eq_block b1 b1\n   then\n    if\n     (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n     (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n    then Some (Ptrofs.cmpu c ofs1 ofs2)\n    else None\n   else\n    if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n    then Val.cmp_different_blocks c\n    else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"rewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if\n    (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n    (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n   then Some (Ptrofs.cmpu c ofs1 ofs2)\n   else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if\n    (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n    (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n   then Some (Ptrofs.cmpu c ofs1 ofs2)\n   else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"destruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch (Some (Ptrofs.cmpu c ofs1 ofs2)) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Some (Ptrofs.cmpu c ofs1 ofs2)) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch None (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch None (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)))","proofString":"unfold pcmp; inv H; inv H0; (apply cmatch_top || (apply DIFF; congruence) || idtac).\ndestruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va.\napply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (if peq id id0 then Maybe (Ptrofs.cmpu c ofs1 ofs2) else Btop).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (if peq id id0 then Maybe (Ptrofs.cmpu c ofs1 ofs2) else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (e : id = id0) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (e : id = id0)","proofString":"subst id0.\napply SAME.\neapply bc_glob; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id)","proofString":"apply SAME.\neapply bc_glob; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id)","proofString":"eapply bc_glob; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (n : id <> id0) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) Btop.","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) Btop","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (n : id <> id0)","proofString":"auto with va."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack) : cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack)","proofString":"apply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack)","proofString":"eapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2)","proofString":"assert (DIFF: b1 <> b2 ->            cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))                   (cmp_different_blocks c)).\nintros.\nsimpl.\nrewrite dec_eq_false by assumption.\ndestruct Archi.ptr64; simpl.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none.\nassert (SAME: b1 = b2 ->            cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))                   (Maybe (Ptrofs.cmpu c ofs1 ofs2))).\nintros.\nsubst b2.\nsimpl.\ndestruct Archi.ptr64.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nconstructor.\nunfold pcmp; inv H; inv H0; (apply cmatch_top || (apply DIFF; congruence) || idtac).\ndestruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va.\napply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c).","conclusion":"b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2)","proofString":"intros.\nsimpl.\nrewrite dec_eq_false by assumption.\ndestruct Archi.ptr64; simpl.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"simpl.\nrewrite dec_eq_false by assumption.\ndestruct Archi.ptr64; simpl.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if eq_block b1 b2\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b2 (Ptrofs.unsigned ofs2) || valid b2 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if eq_block b1 b2\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b2 (Ptrofs.unsigned ofs2) || valid b2 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"rewrite dec_eq_false by assumption.\ndestruct Archi.ptr64; simpl.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"destruct Archi.ptr64; simpl.\ndestruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch\n  (if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"destruct (valid b1 (Ptrofs.unsigned ofs1) && valid b2 (Ptrofs.unsigned ofs2)); simpl.\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c).","conclusion":"cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"apply cmp_different_blocks_sound."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (H1 : b1 <> b2)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c))","proofString":"assert (SAME: b1 = b2 ->            cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))                   (Maybe (Ptrofs.cmpu c ofs1 ofs2))).\nintros.\nsubst b2.\nsimpl.\ndestruct Archi.ptr64.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nconstructor.\nunfold pcmp; inv H; inv H0; (apply cmatch_top || (apply DIFF; congruence) || idtac).\ndestruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va.\napply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c))","proofString":"intros.\nsubst b2.\nsimpl.\ndestruct Archi.ptr64.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (H1 : b1 = b2) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (H1 : b1 = b2)","proofString":"subst b2.\nsimpl.\ndestruct Archi.ptr64.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"simpl.\ndestruct Archi.ptr64.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"destruct Archi.ptr64.\nrewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if negb true\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if negb true\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"rewrite dec_eq_true.\ndestruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if negb true\n   then None\n   else\n    if\n     (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n     (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n    then Some (Ptrofs.cmpu c ofs1 ofs2)\n    else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if negb true\n   then None\n   else\n    if\n     (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n     (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n    then Some (Ptrofs.cmpu c ofs1 ofs2)\n    else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"destruct ((valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&         (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))); simpl.\nconstructor.\nconstructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch (Some (Ptrofs.cmpu c ofs1 ofs2)) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Some (Ptrofs.cmpu c ofs1 ofs2)) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch None (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch None (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2) : cmatch\n  (if negb false\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch\n  (if negb false\n   then None\n   else\n    if eq_block b1 b1\n    then\n     if\n      (valid b1 (Ptrofs.unsigned ofs1) || valid b1 (Ptrofs.unsigned ofs1 - 1)) &&\n      (valid b1 (Ptrofs.unsigned ofs2) || valid b1 (Ptrofs.unsigned ofs2 - 1))\n     then Some (Ptrofs.cmpu c ofs1 ofs2)\n     else None\n    else\n     if valid b1 (Ptrofs.unsigned ofs1) && valid b1 (Ptrofs.unsigned ofs2)\n     then Val.cmp_different_blocks c\n     else None) (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (DIFF : b1 <> b1 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b1 ofs2))\n  (cmp_different_blocks c)) (H0 : pmatch b1 ofs2 p2)","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pmatch b1 ofs1 p1) (H0 : pmatch b2 ofs2 p2) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)))","proofString":"unfold pcmp; inv H; inv H0; (apply cmatch_top || (apply DIFF; congruence) || idtac).\ndestruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va.\napply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (if peq id id0 then Maybe (Ptrofs.cmpu c ofs1 ofs2) else Btop).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (if peq id id0 then Maybe (Ptrofs.cmpu c ofs1 ofs2) else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0.\napply SAME.\neapply bc_glob; eauto.\nauto with va."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (e : id = id0) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (e : id = id0)","proofString":"subst id0.\napply SAME.\neapply bc_glob; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id)","proofString":"apply SAME.\neapply bc_glob; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (H : bc b2 = BCglob id)","proofString":"eapply bc_glob; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (n : id <> id0) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) Btop.","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) Btop","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (id : ident) (H1 : bc b1 = BCglob id) (id0 : ident) (H : bc b2 = BCglob id0) (n : id <> id0)","proofString":"auto with va."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack) : cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2)).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack)","proofString":"apply SAME.\neapply bc_stack; eauto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack) : b1 = b2.","conclusion":"b1 = b2","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (DIFF : b1 <> b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (cmp_different_blocks c)) (SAME : b1 = b2 ->\ncmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2))\n  (Maybe (Ptrofs.cmpu c ofs1 ofs2))) (H1 : bc b1 = BCstack) (H : bc b2 = BCstack)","proofString":"eapply bc_stack; eauto."},{"statement":"(c : comparison) (p1 p2 : aptr) : cmatch None (pcmp c p1 p2).","conclusion":"cmatch None (pcmp c p1 p2)","hypotheses":"(c : comparison) (p1 p2 : aptr)","proofString":"unfold pcmp; destruct p1; try constructor; destruct p2;  try (destruct (peq id id0));  try constructor; try (apply cmp_different_blocks_none)."},{"statement":"(v1 v2 : aval) : {v1 = v2} + {v1 <> v2}.","conclusion":"{v1 = v2} + {v1 <> v2}","hypotheses":"(v1 v2 : aval)","proofString":"generalize zeq Int.eq_dec Int64.eq_dec Float.eq_dec Float32.eq_dec eq_aptr; intros.\ndecide equality."},{"statement":"(v1 v2 : aval) (H : forall x y : Z, {x = y} + {x <> y}) (H0 : forall x y : int, {x = y} + {x <> y}) (H1 : forall x y : int64, {x = y} + {x <> y}) (H2 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H3 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H4 : forall p1 p2 : aptr, {p1 = p2} + {p1 <> p2}) : {v1 = v2} + {v1 <> v2}.","conclusion":"{v1 = v2} + {v1 <> v2}","hypotheses":"(v1 v2 : aval) (H : forall x y : Z, {x = y} + {x <> y}) (H0 : forall x y : int, {x = y} + {x <> y}) (H1 : forall x y : int64, {x = y} + {x <> y}) (H2 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H3 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H4 : forall p1 p2 : aptr, {p1 = p2} + {p1 <> p2})","proofString":"decide equality."},{"statement":"(v : val) (p : aptr) (H : match v with\n| Vptr _ _ => False\n| _ => True\nend) : vmatch v (Num p).","conclusion":"vmatch v (Num p)","hypotheses":"(v : val) (p : aptr) (H : match v with\n| Vptr _ _ => False\n| _ => True\nend)","proofString":"destruct v; auto with va; contradiction."},{"statement":"(v : val) (p : aptr) (H : forall (b : block) (ofs : ptrofs), v = Vptr b ofs -> pmatch b ofs p) : vmatch v (Ifptr p).","conclusion":"vmatch v (Ifptr p)","hypotheses":"(v : val) (p : aptr) (H : forall (b : block) (ofs : ptrofs), v = Vptr b ofs -> pmatch b ofs p)","proofString":"destruct v; constructor; auto."},{"statement":"(v : val) (x : aval) (H : vmatch v x) : vmatch v Vtop.","conclusion":"vmatch v Vtop","hypotheses":"(v : val) (x : aval) (H : vmatch v x)","proofString":"apply vmatch_ifptr.\nintros.\nsubst v.\ninv H; eapply pmatch_top'; eauto."},{"statement":"(v : val) (x : aval) (H : vmatch v x) : forall (b : block) (ofs : ptrofs), v = Vptr b ofs -> pmatch b ofs Ptop.","conclusion":"forall (b : block) (ofs : ptrofs), v = Vptr b ofs -> pmatch b ofs Ptop","hypotheses":"(v : val) (x : aval) (H : vmatch v x)","proofString":"intros.\nsubst v.\ninv H; eapply pmatch_top'; eauto."},{"statement":"(v : val) (x : aval) (H : vmatch v x) (b : block) (ofs : ptrofs) (H0 : v = Vptr b ofs) : pmatch b ofs Ptop.","conclusion":"pmatch b ofs Ptop","hypotheses":"(v : val) (x : aval) (H : vmatch v x) (b : block) (ofs : ptrofs) (H0 : v = Vptr b ofs)","proofString":"subst v.\ninv H; eapply pmatch_top'; eauto."},{"statement":"(x : aval) (b : block) (ofs : ptrofs) (H : vmatch (Vptr b ofs) x) : pmatch b ofs Ptop.","conclusion":"pmatch b ofs Ptop","hypotheses":"(x : aval) (b : block) (ofs : ptrofs) (H : vmatch (Vptr b ofs) x)","proofString":"inv H; eapply pmatch_top'; eauto."},{"statement":"(n1 n2 : Z) (i : int) (H : is_uns n1 i) (H0 : n1 <= n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2) : Int.testbit i m = false.","conclusion":"Int.testbit i m = false","hypotheses":"(n1 n2 : Z) (i : int) (H : is_uns n1 i) (H0 : n1 <= n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2)","proofString":"apply H; lia."},{"statement":"(n1 n2 : Z) (i : int) (H : is_sgn n1 i) (H0 : n1 <= n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2 - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(n1 n2 : Z) (i : int) (H : is_sgn n1 i) (H0 : n1 <= n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2 - 1)","proofString":"apply H; lia."},{"statement":"(n1 n2 : Z) (i : int) (H : is_uns n1 i) (H0 : n1 < n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2 - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(n1 n2 : Z) (i : int) (H : is_uns n1 i) (H0 : n1 < n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2 - 1)","proofString":"rewrite ! H by lia.\nauto."},{"statement":"(n1 n2 : Z) (i : int) (H : is_uns n1 i) (H0 : n1 < n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2 - 1) : false = false.","conclusion":"false = false","hypotheses":"(n1 n2 : Z) (i : int) (H : is_uns n1 i) (H0 : n1 < n2) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n2 - 1)","proofString":"auto."},{"statement":"(n : int) : 0 <= Int.size n.","conclusion":"0 <= Int.size n","hypotheses":"(n : int)","proofString":"generalize (Int.size_range n); lia."},{"statement":"(n : int) : 0 < Int.size (if Int.lt n Int.zero then Int.not n else n) + 1.","conclusion":"0 < Int.size (if Int.lt n Int.zero then Int.not n else n) + 1","hypotheses":"(n : int)","proofString":"generalize (Int.size_range (if Int.lt n Int.zero then Int.not n else n)); lia."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.size i) : Int.testbit i m = false.","conclusion":"Int.testbit i m = false","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.size i)","proofString":"apply Int.bits_size_2.\nlia."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.size i) : Int.size i <= m.","conclusion":"Int.size i <= m","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.size i)","proofString":"lia."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.size (if Int.lt i Int.zero then Int.not i else i) + 1 - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.size (if Int.lt i Int.zero then Int.not i else i) + 1 - 1)","proofString":"destruct (Int.lt i Int.zero) eqn:LT.\nrewrite <- (negb_involutive (Int.testbit i m)).\nrewrite <- (negb_involutive (Int.testbit i (Int.zwordsize - 1))).\nf_equal.\ngeneralize (Int.size_range (Int.not i)); intros RANGE.\nrewrite <- ! Int.bits_not by lia.\nrewrite ! Int.bits_size_2 by lia.\nauto.\nrewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1)","proofString":"rewrite <- (negb_involutive (Int.testbit i m)).\nrewrite <- (negb_involutive (Int.testbit i (Int.zwordsize - 1))).\nf_equal.\ngeneralize (Int.size_range (Int.not i)); intros RANGE.\nrewrite <- ! Int.bits_not by lia.\nrewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) : negb (negb (Int.testbit i m)) = Int.testbit i (Int.zwordsize - 1).","conclusion":"negb (negb (Int.testbit i m)) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1)","proofString":"rewrite <- (negb_involutive (Int.testbit i (Int.zwordsize - 1))).\nf_equal.\ngeneralize (Int.size_range (Int.not i)); intros RANGE.\nrewrite <- ! Int.bits_not by lia.\nrewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) : negb (negb (Int.testbit i m)) =\nnegb (negb (Int.testbit i (Int.zwordsize - 1))).","conclusion":"negb (negb (Int.testbit i m)) =\nnegb (negb (Int.testbit i (Int.zwordsize - 1)))","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1)","proofString":"f_equal.\ngeneralize (Int.size_range (Int.not i)); intros RANGE.\nrewrite <- ! Int.bits_not by lia.\nrewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) : negb (Int.testbit i m) = negb (Int.testbit i (Int.zwordsize - 1)).","conclusion":"negb (Int.testbit i m) = negb (Int.testbit i (Int.zwordsize - 1))","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1)","proofString":"generalize (Int.size_range (Int.not i)); intros RANGE.\nrewrite <- ! Int.bits_not by lia.\nrewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) (RANGE : 0 <= Int.size (Int.not i) <= Int.zwordsize) : negb (Int.testbit i m) = negb (Int.testbit i (Int.zwordsize - 1)).","conclusion":"negb (Int.testbit i m) = negb (Int.testbit i (Int.zwordsize - 1))","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) (RANGE : 0 <= Int.size (Int.not i) <= Int.zwordsize)","proofString":"rewrite <- ! Int.bits_not by lia.\nrewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) (RANGE : 0 <= Int.size (Int.not i) <= Int.zwordsize) : Int.testbit (Int.not i) m = Int.testbit (Int.not i) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.not i) m = Int.testbit (Int.not i) (Int.zwordsize - 1)","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) (RANGE : 0 <= Int.size (Int.not i) <= Int.zwordsize)","proofString":"rewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) (RANGE : 0 <= Int.size (Int.not i) <= Int.zwordsize) : false = false.","conclusion":"false = false","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = true) (H0 : m >= Int.size (Int.not i) + 1 - 1) (RANGE : 0 <= Int.size (Int.not i) <= Int.zwordsize)","proofString":"auto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = false) (H0 : m >= Int.size i + 1 - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = false) (H0 : m >= Int.size i + 1 - 1)","proofString":"rewrite ! Int.bits_size_2 by lia.\nauto."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = false) (H0 : m >= Int.size i + 1 - 1) : false = false.","conclusion":"false = false","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (LT : Int.lt i Int.zero = false) (H0 : m >= Int.size i + 1 - 1)","proofString":"auto."},{"statement":"(n : Z) (i : int) (H : is_uns n i) : Int.zero_ext n i = i.","conclusion":"Int.zero_ext n i = i","hypotheses":"(n : Z) (i : int) (H : is_uns n i)","proofString":"Int.bit_solve.\ndestruct (zlt i0 n); auto.\nsymmetry; apply H; auto.\nlia."},{"statement":"(n : Z) (i : int) (H : is_uns n i) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) : (if zlt i0 n then Int.testbit i i0 else false) = Int.testbit i i0.","conclusion":"(if zlt i0 n then Int.testbit i i0 else false) = Int.testbit i i0","hypotheses":"(n : Z) (i : int) (H : is_uns n i) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize)","proofString":"destruct (zlt i0 n); auto.\nsymmetry; apply H; auto."},{"statement":"(n : Z) (i : int) (H : is_uns n i) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (g : i0 >= n) : false = Int.testbit i i0.","conclusion":"false = Int.testbit i i0","hypotheses":"(n : Z) (i : int) (H : is_uns n i) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (g : i0 >= n)","proofString":"symmetry; apply H; auto."},{"statement":"(n : Z) (i : int) (H : is_uns n i) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) : 0 <= i0.","conclusion":"0 <= i0","hypotheses":"(n : Z) (i : int) (H : is_uns n i) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize)","proofString":"lia."},{"statement":"(n : Z) (i : int) (H : Int.zero_ext n i = i) : is_uns n i.","conclusion":"is_uns n i","hypotheses":"(n : Z) (i : int) (H : Int.zero_ext n i = i)","proofString":"rewrite <- H.\nred; intros.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(n : Z) (i : int) (H : Int.zero_ext n i = i) : is_uns n (Int.zero_ext n i).","conclusion":"is_uns n (Int.zero_ext n i)","hypotheses":"(n : Z) (i : int) (H : Int.zero_ext n i = i)","proofString":"red; intros.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(n : Z) (i : int) (H : Int.zero_ext n i = i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n) : Int.testbit (Int.zero_ext n i) m = false.","conclusion":"Int.testbit (Int.zero_ext n i) m = false","hypotheses":"(n : Z) (i : int) (H : Int.zero_ext n i = i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n)","proofString":"rewrite Int.bits_zero_ext by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(n : Z) (i : int) (H : Int.zero_ext n i = i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n) : (if zlt m n then Int.testbit i m else false) = false.","conclusion":"(if zlt m n then Int.testbit i m else false) = false","hypotheses":"(n : Z) (i : int) (H : Int.zero_ext n i = i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n)","proofString":"rewrite zlt_false by lia.\nauto."},{"statement":"(n : Z) (i : int) (H : Int.zero_ext n i = i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n) : false = false.","conclusion":"false = false","hypotheses":"(n : Z) (i : int) (H : Int.zero_ext n i = i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n)","proofString":"auto."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : Int.sign_ext n i = i.","conclusion":"Int.sign_ext n i = i","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"Int.bit_solve.\ndestruct (zlt i0 n); auto.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\napply H0; lia.\nsymmetry; apply H0; lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) : Int.testbit i (if zlt i0 n then i0 else n - 1) = Int.testbit i i0.","conclusion":"Int.testbit i (if zlt i0 n then i0 else n - 1) = Int.testbit i i0","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize)","proofString":"destruct (zlt i0 n); auto.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\napply H0; lia.\nsymmetry; apply H0; lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) (g : i0 >= n) : Int.testbit i (n - 1) = Int.testbit i i0.","conclusion":"Int.testbit i (n - 1) = Int.testbit i i0","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) (g : i0 >= n)","proofString":"transitivity (Int.testbit i (Int.zwordsize - 1)).\napply H0; lia.\nsymmetry; apply H0; lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) (g : i0 >= n) : Int.testbit i (n - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (n - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) (g : i0 >= n)","proofString":"apply H0; lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) (g : i0 >= n) : Int.testbit i (Int.zwordsize - 1) = Int.testbit i i0.","conclusion":"Int.testbit i (Int.zwordsize - 1) = Int.testbit i i0","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) (i0 : Z) (H1 : 0 <= i0 < Int.zwordsize) (g : i0 >= n)","proofString":"symmetry; apply H0; lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) : is_sgn n i.","conclusion":"is_sgn n i","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i)","proofString":"rewrite <- H0.\nred; intros.\nrewrite ! Int.bits_sign_ext by lia.\nf_equal.\ntransitivity (n-1).\ndestruct (zlt m n); lia.\ndestruct (zlt (Int.zwordsize - 1) n); lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) : is_sgn n (Int.sign_ext n i).","conclusion":"is_sgn n (Int.sign_ext n i)","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i)","proofString":"red; intros.\nrewrite ! Int.bits_sign_ext by lia.\nf_equal.\ntransitivity (n-1).\ndestruct (zlt m n); lia.\ndestruct (zlt (Int.zwordsize - 1) n); lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : Int.testbit (Int.sign_ext n i) m =\nInt.testbit (Int.sign_ext n i) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.sign_ext n i) m =\nInt.testbit (Int.sign_ext n i) (Int.zwordsize - 1)","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"rewrite ! Int.bits_sign_ext by lia.\nf_equal.\ntransitivity (n-1).\ndestruct (zlt m n); lia.\ndestruct (zlt (Int.zwordsize - 1) n); lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : Int.testbit i (if zlt m n then m else n - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1) n then Int.zwordsize - 1 else n - 1).","conclusion":"Int.testbit i (if zlt m n then m else n - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1) n then Int.zwordsize - 1 else n - 1)","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"f_equal.\ntransitivity (n-1).\ndestruct (zlt m n); lia.\ndestruct (zlt (Int.zwordsize - 1) n); lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : (if zlt m n then m else n - 1) =\n(if zlt (Int.zwordsize - 1) n then Int.zwordsize - 1 else n - 1).","conclusion":"(if zlt m n then m else n - 1) =\n(if zlt (Int.zwordsize - 1) n then Int.zwordsize - 1 else n - 1)","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"transitivity (n-1).\ndestruct (zlt m n); lia.\ndestruct (zlt (Int.zwordsize - 1) n); lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : (if zlt m n then m else n - 1) = n - 1.","conclusion":"(if zlt m n then m else n - 1) = n - 1","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"destruct (zlt m n); lia."},{"statement":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : n - 1 = (if zlt (Int.zwordsize - 1) n then Int.zwordsize - 1 else n - 1).","conclusion":"n - 1 = (if zlt (Int.zwordsize - 1) n then Int.zwordsize - 1 else n - 1)","hypotheses":"(n : Z) (i : int) (H : 0 < n) (H0 : Int.sign_ext n i = i) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"destruct (zlt (Int.zwordsize - 1) n); lia."},{"statement":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) : is_uns m (Int.zero_ext n i).","conclusion":"is_uns m (Int.zero_ext n i)","hypotheses":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m)","proofString":"red; intros.\nrewrite Int.bits_zero_ext by lia.\ndestruct (zlt m0 n); auto.\ndestruct H.\napply H; lia.\nextlia."},{"statement":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) : Int.testbit (Int.zero_ext n i) m0 = false.","conclusion":"Int.testbit (Int.zero_ext n i) m0 = false","hypotheses":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m)","proofString":"rewrite Int.bits_zero_ext by lia.\ndestruct (zlt m0 n); auto.\ndestruct H.\napply H; lia.\nextlia."},{"statement":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) : (if zlt m0 n then Int.testbit i m0 else false) = false.","conclusion":"(if zlt m0 n then Int.testbit i m0 else false) = false","hypotheses":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m)","proofString":"destruct (zlt m0 n); auto.\ndestruct H.\napply H; lia.\nextlia."},{"statement":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) (l : m0 < n) : Int.testbit i m0 = false.","conclusion":"Int.testbit i m0 = false","hypotheses":"(i : int) (n m : Z) (H : is_uns m i \\/ n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) (l : m0 < n)","proofString":"destruct H.\napply H; lia.\nextlia."},{"statement":"(i : int) (n m : Z) (H : is_uns m i) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) (l : m0 < n) : Int.testbit i m0 = false.","conclusion":"Int.testbit i m0 = false","hypotheses":"(i : int) (n m : Z) (H : is_uns m i) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) (l : m0 < n)","proofString":"apply H; lia."},{"statement":"(i : int) (n m : Z) (H : n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) (l : m0 < n) : Int.testbit i m0 = false.","conclusion":"Int.testbit i m0 = false","hypotheses":"(i : int) (n m : Z) (H : n <= m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m) (l : m0 < n)","proofString":"extlia."},{"statement":"(i : int) (n m : Z) (H : n < m) : is_sgn m (Int.zero_ext n i).","conclusion":"is_sgn m (Int.zero_ext n i)","hypotheses":"(i : int) (n m : Z) (H : n < m)","proofString":"red; intros.\nrewrite ! Int.bits_zero_ext by lia.\ntransitivity false.\napply zlt_false; lia.\nsymmetry; apply zlt_false; lia."},{"statement":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1) : Int.testbit (Int.zero_ext n i) m0 =\nInt.testbit (Int.zero_ext n i) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.zero_ext n i) m0 =\nInt.testbit (Int.zero_ext n i) (Int.zwordsize - 1)","hypotheses":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1)","proofString":"rewrite ! Int.bits_zero_ext by lia.\ntransitivity false.\napply zlt_false; lia.\nsymmetry; apply zlt_false; lia."},{"statement":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1) : (if zlt m0 n then Int.testbit i m0 else false) =\n(if zlt (Int.zwordsize - 1) n\n then Int.testbit i (Int.zwordsize - 1)\n else false).","conclusion":"(if zlt m0 n then Int.testbit i m0 else false) =\n(if zlt (Int.zwordsize - 1) n\n then Int.testbit i (Int.zwordsize - 1)\n else false)","hypotheses":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1)","proofString":"transitivity false.\napply zlt_false; lia.\nsymmetry; apply zlt_false; lia."},{"statement":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1) : (if zlt m0 n then Int.testbit i m0 else false) = false.","conclusion":"(if zlt m0 n then Int.testbit i m0 else false) = false","hypotheses":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1)","proofString":"apply zlt_false; lia."},{"statement":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1) : false =\n(if zlt (Int.zwordsize - 1) n\n then Int.testbit i (Int.zwordsize - 1)\n else false).","conclusion":"false =\n(if zlt (Int.zwordsize - 1) n\n then Int.testbit i (Int.zwordsize - 1)\n else false)","hypotheses":"(i : int) (n m : Z) (H : n < m) (m0 : Z) (H0 : 0 <= m0 < Int.zwordsize) (H1 : m0 >= m - 1)","proofString":"symmetry; apply zlt_false; lia."},{"statement":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m) : Int.testbit (Int.sign_ext n i) m0 = false.","conclusion":"Int.testbit (Int.sign_ext n i) m0 = false","hypotheses":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m)","proofString":"rewrite Int.bits_sign_ext by lia.\napply H0.\ndestruct (zlt m0 n); lia.\ndestruct (zlt m0 n); lia."},{"statement":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m) : Int.testbit i (if zlt m0 n then m0 else n - 1) = false.","conclusion":"Int.testbit i (if zlt m0 n then m0 else n - 1) = false","hypotheses":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m)","proofString":"apply H0.\ndestruct (zlt m0 n); lia.\ndestruct (zlt m0 n); lia."},{"statement":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m) : 0 <= (if zlt m0 n then m0 else n - 1) < Int.zwordsize.","conclusion":"0 <= (if zlt m0 n then m0 else n - 1) < Int.zwordsize","hypotheses":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m)","proofString":"destruct (zlt m0 n); lia."},{"statement":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m) : (if zlt m0 n then m0 else n - 1) >= m.","conclusion":"(if zlt m0 n then m0 else n - 1) >= m","hypotheses":"(i : int) (n m : Z) (H : 0 <= m < n) (H0 : is_uns m i) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= m)","proofString":"destruct (zlt m0 n); lia."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m) : is_sgn m (Int.sign_ext n i).","conclusion":"is_sgn m (Int.sign_ext n i)","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m)","proofString":"apply is_sgn_sign_ext; auto.\ndestruct (zlt m n).\ndestruct H1.\napply is_sgn_sign_ext in H1; auto.\nrewrite <- H1.\nrewrite (Int.sign_ext_widen i) by lia.\napply Int.sign_ext_idem; auto.\nextlia.\napply Int.sign_ext_widen; lia."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m) : Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i.","conclusion":"Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m)","proofString":"destruct (zlt m n).\ndestruct H1.\napply is_sgn_sign_ext in H1; auto.\nrewrite <- H1.\nrewrite (Int.sign_ext_widen i) by lia.\napply Int.sign_ext_idem; auto.\nextlia.\napply Int.sign_ext_widen; lia."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m) (l : m < n) : Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i.","conclusion":"Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m) (l : m < n)","proofString":"destruct H1.\napply is_sgn_sign_ext in H1; auto.\nrewrite <- H1.\nrewrite (Int.sign_ext_widen i) by lia.\napply Int.sign_ext_idem; auto.\nextlia."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i) (l : m < n) : Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i.","conclusion":"Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i) (l : m < n)","proofString":"apply is_sgn_sign_ext in H1; auto.\nrewrite <- H1.\nrewrite (Int.sign_ext_widen i) by lia.\napply Int.sign_ext_idem; auto."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : Int.sign_ext m i = i) (l : m < n) : Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i.","conclusion":"Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : Int.sign_ext m i = i) (l : m < n)","proofString":"rewrite <- H1.\nrewrite (Int.sign_ext_widen i) by lia.\napply Int.sign_ext_idem; auto."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : Int.sign_ext m i = i) (l : m < n) : Int.sign_ext m (Int.sign_ext n (Int.sign_ext m i)) =\nInt.sign_ext n (Int.sign_ext m i).","conclusion":"Int.sign_ext m (Int.sign_ext n (Int.sign_ext m i)) =\nInt.sign_ext n (Int.sign_ext m i)","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : Int.sign_ext m i = i) (l : m < n)","proofString":"rewrite (Int.sign_ext_widen i) by lia.\napply Int.sign_ext_idem; auto."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : Int.sign_ext m i = i) (l : m < n) : Int.sign_ext m (Int.sign_ext m i) = Int.sign_ext m i.","conclusion":"Int.sign_ext m (Int.sign_ext m i) = Int.sign_ext m i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : Int.sign_ext m i = i) (l : m < n)","proofString":"apply Int.sign_ext_idem; auto."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : n <= m) (l : m < n) : Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i.","conclusion":"Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : n <= m) (l : m < n)","proofString":"extlia."},{"statement":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m) (g : m >= n) : Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i.","conclusion":"Int.sign_ext m (Int.sign_ext n i) = Int.sign_ext n i","hypotheses":"(i : int) (n m : Z) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn m i \\/ n <= m) (g : m >= n)","proofString":"apply Int.sign_ext_widen; lia."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.zwordsize) : Int.testbit i m = false.","conclusion":"Int.testbit i m = false","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.zwordsize)","proofString":"lia."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.zwordsize - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.zwordsize - 1)","proofString":"f_equal.\nlia."},{"statement":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.zwordsize - 1) : m = Int.zwordsize - 1.","conclusion":"m = Int.zwordsize - 1","hypotheses":"(i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= Int.zwordsize - 1)","proofString":"lia."},{"statement":"(n : int) (H : is_uns 0 n) : n = Int.zero.","conclusion":"n = Int.zero","hypotheses":"(n : int) (H : is_uns 0 n)","proofString":"apply Int.same_bits_eq; intros.\nrewrite Int.bits_zero.\napply H; lia."},{"statement":"(n : int) (H : is_uns 0 n) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit n i = Int.testbit Int.zero i.","conclusion":"Int.testbit n i = Int.testbit Int.zero i","hypotheses":"(n : int) (H : is_uns 0 n) (i : Z) (H0 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int.bits_zero.\napply H; lia."},{"statement":"(n : int) (H : is_uns 0 n) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit n i = false.","conclusion":"Int.testbit n i = false","hypotheses":"(n : int) (H : is_uns 0 n) (i : Z) (H0 : 0 <= i < Int.zwordsize)","proofString":"apply H; lia."},{"statement":"(n : int) (H : is_uns 1 n) : n = Int.zero \\/ n = Int.one.","conclusion":"n = Int.zero \\/ n = Int.one","hypotheses":"(n : int) (H : is_uns 1 n)","proofString":"destruct (Int.testbit n 0) eqn:B0; [right|left]; apply Int.same_bits_eq; intros.\nrewrite Int.bits_one.\ndestruct (zeq i 0).\nsubst i; auto.\napply H; lia.\nrewrite Int.bits_zero.\ndestruct (zeq i 0).\nsubst i; auto.\napply H; lia."},{"statement":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = true) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit n i = Int.testbit Int.one i.","conclusion":"Int.testbit n i = Int.testbit Int.one i","hypotheses":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = true) (i : Z) (H0 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int.bits_one.\ndestruct (zeq i 0).\nsubst i; auto.\napply H; lia."},{"statement":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = true) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit n i = zeq i 0.","conclusion":"Int.testbit n i = zeq i 0","hypotheses":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = true) (i : Z) (H0 : 0 <= i < Int.zwordsize)","proofString":"destruct (zeq i 0).\nsubst i; auto.\napply H; lia."},{"statement":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit n i = Int.testbit Int.zero i.","conclusion":"Int.testbit n i = Int.testbit Int.zero i","hypotheses":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int.bits_zero.\ndestruct (zeq i 0).\nsubst i; auto.\napply H; lia."},{"statement":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit n i = false.","conclusion":"Int.testbit n i = false","hypotheses":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize)","proofString":"destruct (zeq i 0).\nsubst i; auto.\napply H; lia."},{"statement":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize) (e : i = 0) : Int.testbit n i = false.","conclusion":"Int.testbit n i = false","hypotheses":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize) (e : i = 0)","proofString":"subst i; auto."},{"statement":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize) (n0 : i <> 0) : Int.testbit n i = false.","conclusion":"Int.testbit n i = false","hypotheses":"(n : int) (H : is_uns 1 n) (B0 : Int.testbit n 0 = false) (i : Z) (H0 : 0 <= i < Int.zwordsize) (n0 : i <> 0)","proofString":"apply H; lia."},{"statement":"(z n : Z) (H : 0 <= n) (H0 : 0 <= z < two_p n) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n) : Int.testbit (Int.repr z) m = false.","conclusion":"Int.testbit (Int.repr z) m = false","hypotheses":"(z n : Z) (H : 0 <= n) (H0 : 0 <= z < two_p n) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n)","proofString":"rewrite Int.testbit_repr by auto.\napply (Zbits_unsigned_range n); auto."},{"statement":"(z n : Z) (H : 0 <= n) (H0 : 0 <= z < two_p n) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n) : Z.testbit z m = false.","conclusion":"Z.testbit z m = false","hypotheses":"(z n : Z) (H : 0 <= n) (H0 : 0 <= z < two_p n) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n)","proofString":"apply (Zbits_unsigned_range n); auto."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : 0 <= Int.unsigned i < two_p n.","conclusion":"0 <= Int.unsigned i < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"destruct (zlt n Int.zwordsize).\napply is_uns_zero_ext in H0; auto.\nrewrite <- H0.\nrewrite Int.zero_ext_mod by lia.\nauto using Z_mod_lt, two_p_gt_ZERO.\nassert (Int.modulus <= two_p n).\nrewrite Int.modulus_power.\napply two_p_monotone.\ngeneralize Int.wordsize_pos; lia.\ngeneralize (Int.unsigned_range i).\nlia."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (l : n < Int.zwordsize) : 0 <= Int.unsigned i < two_p n.","conclusion":"0 <= Int.unsigned i < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (l : n < Int.zwordsize)","proofString":"apply is_uns_zero_ext in H0; auto.\nrewrite <- H0.\nrewrite Int.zero_ext_mod by lia.\nauto using Z_mod_lt, two_p_gt_ZERO."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : Int.zero_ext n i = i) (l : n < Int.zwordsize) : 0 <= Int.unsigned i < two_p n.","conclusion":"0 <= Int.unsigned i < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : Int.zero_ext n i = i) (l : n < Int.zwordsize)","proofString":"rewrite <- H0.\nrewrite Int.zero_ext_mod by lia.\nauto using Z_mod_lt, two_p_gt_ZERO."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : Int.zero_ext n i = i) (l : n < Int.zwordsize) : 0 <= Int.unsigned (Int.zero_ext n i) < two_p n.","conclusion":"0 <= Int.unsigned (Int.zero_ext n i) < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : Int.zero_ext n i = i) (l : n < Int.zwordsize)","proofString":"rewrite Int.zero_ext_mod by lia.\nauto using Z_mod_lt, two_p_gt_ZERO."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : Int.zero_ext n i = i) (l : n < Int.zwordsize) : 0 <= Int.unsigned i mod two_p n < two_p n.","conclusion":"0 <= Int.unsigned i mod two_p n < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : Int.zero_ext n i = i) (l : n < Int.zwordsize)","proofString":"auto using Z_mod_lt, two_p_gt_ZERO."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) : 0 <= Int.unsigned i < two_p n.","conclusion":"0 <= Int.unsigned i < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize)","proofString":"assert (Int.modulus <= two_p n).\nrewrite Int.modulus_power.\napply two_p_monotone.\ngeneralize Int.wordsize_pos; lia.\ngeneralize (Int.unsigned_range i).\nlia."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) : Int.modulus <= two_p n.","conclusion":"Int.modulus <= two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize)","proofString":"rewrite Int.modulus_power.\napply two_p_monotone.\ngeneralize Int.wordsize_pos; lia."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) : two_p Int.zwordsize <= two_p n.","conclusion":"two_p Int.zwordsize <= two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize)","proofString":"apply two_p_monotone.\ngeneralize Int.wordsize_pos; lia."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) : 0 <= Int.zwordsize <= n.","conclusion":"0 <= Int.zwordsize <= n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize)","proofString":"generalize Int.wordsize_pos; lia."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) (H1 : Int.modulus <= two_p n) : 0 <= Int.unsigned i < two_p n.","conclusion":"0 <= Int.unsigned i < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) (H1 : Int.modulus <= two_p n)","proofString":"generalize (Int.unsigned_range i).\nlia."},{"statement":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) (H1 : Int.modulus <= two_p n) : 0 <= Int.unsigned i < Int.modulus -> 0 <= Int.unsigned i < two_p n.","conclusion":"0 <= Int.unsigned i < Int.modulus -> 0 <= Int.unsigned i < two_p n","hypotheses":"(i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= Int.zwordsize) (H1 : Int.modulus <= two_p n)","proofString":"lia."},{"statement":"(z n : Z) (H : 0 < n) (H0 : - two_p (n - 1) <= z < two_p (n - 1)) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : Int.testbit (Int.repr z) m = Int.testbit (Int.repr z) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.repr z) m = Int.testbit (Int.repr z) (Int.zwordsize - 1)","hypotheses":"(z n : Z) (H : 0 < n) (H0 : - two_p (n - 1) <= z < two_p (n - 1)) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"rewrite ! Int.testbit_repr by lia.\napply (Zbits_signed_range (n - 1)); lia."},{"statement":"(z n : Z) (H : 0 < n) (H0 : - two_p (n - 1) <= z < two_p (n - 1)) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1) : Z.testbit z m = Z.testbit z (Int.zwordsize - 1).","conclusion":"Z.testbit z m = Z.testbit z (Int.zwordsize - 1)","hypotheses":"(z n : Z) (H : 0 < n) (H0 : - two_p (n - 1) <= z < two_p (n - 1)) (m : Z) (H1 : 0 <= m < Int.zwordsize) (H2 : m >= n - 1)","proofString":"apply (Zbits_signed_range (n - 1)); lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : - two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"destruct (zlt n Int.zwordsize).\napply is_sgn_sign_ext in H0; auto.\nrewrite <- H0.\napply Int.sign_ext_range; lia.\nassert (Int.half_modulus <= two_p (n - 1)).\nrewrite Int.half_modulus_power.\napply two_p_monotone.\ngeneralize Int.wordsize_pos; lia.\ngeneralize (Int.signed_range i).\nunfold Int.min_signed, Int.max_signed.\nlia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (l : n < Int.zwordsize) : - two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (l : n < Int.zwordsize)","proofString":"apply is_sgn_sign_ext in H0; auto.\nrewrite <- H0.\napply Int.sign_ext_range; lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : Int.sign_ext n i = i) (l : n < Int.zwordsize) : - two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : Int.sign_ext n i = i) (l : n < Int.zwordsize)","proofString":"rewrite <- H0.\napply Int.sign_ext_range; lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : Int.sign_ext n i = i) (l : n < Int.zwordsize) : - two_p (n - 1) <= Int.signed (Int.sign_ext n i) < two_p (n - 1).","conclusion":"- two_p (n - 1) <= Int.signed (Int.sign_ext n i) < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : Int.sign_ext n i = i) (l : n < Int.zwordsize)","proofString":"apply Int.sign_ext_range; lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) : - two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize)","proofString":"assert (Int.half_modulus <= two_p (n - 1)).\nrewrite Int.half_modulus_power.\napply two_p_monotone.\ngeneralize Int.wordsize_pos; lia.\ngeneralize (Int.signed_range i).\nunfold Int.min_signed, Int.max_signed.\nlia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) : Int.half_modulus <= two_p (n - 1).","conclusion":"Int.half_modulus <= two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize)","proofString":"rewrite Int.half_modulus_power.\napply two_p_monotone.\ngeneralize Int.wordsize_pos; lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) : two_p (Int.zwordsize - 1) <= two_p (n - 1).","conclusion":"two_p (Int.zwordsize - 1) <= two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize)","proofString":"apply two_p_monotone.\ngeneralize Int.wordsize_pos; lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) : 0 <= Int.zwordsize - 1 <= n - 1.","conclusion":"0 <= Int.zwordsize - 1 <= n - 1","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize)","proofString":"generalize Int.wordsize_pos; lia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) (H1 : Int.half_modulus <= two_p (n - 1)) : - two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) (H1 : Int.half_modulus <= two_p (n - 1))","proofString":"generalize (Int.signed_range i).\nunfold Int.min_signed, Int.max_signed.\nlia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) (H1 : Int.half_modulus <= two_p (n - 1)) : Int.min_signed <= Int.signed i <= Int.max_signed ->\n- two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"Int.min_signed <= Int.signed i <= Int.max_signed ->\n- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) (H1 : Int.half_modulus <= two_p (n - 1))","proofString":"unfold Int.min_signed, Int.max_signed.\nlia."},{"statement":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) (H1 : Int.half_modulus <= two_p (n - 1)) : - Int.half_modulus <= Int.signed i <= Int.half_modulus - 1 ->\n- two_p (n - 1) <= Int.signed i < two_p (n - 1).","conclusion":"- Int.half_modulus <= Int.signed i <= Int.half_modulus - 1 ->\n- two_p (n - 1) <= Int.signed i < two_p (n - 1)","hypotheses":"(i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (g : n >= Int.zwordsize) (H1 : Int.half_modulus <= two_p (n - 1))","proofString":"lia."},{"statement":"(i : int) (a : aval) (H : vmatch (Vint i) a) : 0 <= urange a /\\ is_uns (urange a) i.","conclusion":"0 <= urange a /\\ is_uns (urange a) i","hypotheses":"(i : int) (a : aval) (H : vmatch (Vint i) a)","proofString":"pose proof Int.wordsize_pos.\ninv H; simpl; auto with va."},{"statement":"(i : int) (a : aval) (H : vmatch (Vint i) a) (H0 : Int.zwordsize > 0) : 0 <= urange a /\\ is_uns (urange a) i.","conclusion":"0 <= urange a /\\ is_uns (urange a) i","hypotheses":"(i : int) (a : aval) (H : vmatch (Vint i) a) (H0 : Int.zwordsize > 0)","proofString":"inv H; simpl; auto with va."},{"statement":"(i : int) (a : aval) (H : vmatch (Vint i) a) : 0 < srange a /\\ is_sgn (srange a) i.","conclusion":"0 < srange a /\\ is_sgn (srange a) i","hypotheses":"(i : int) (a : aval) (H : vmatch (Vint i) a)","proofString":"pose proof Int.wordsize_pos.\ninv H; simpl; eauto with va."},{"statement":"(i : int) (a : aval) (H : vmatch (Vint i) a) (H0 : Int.zwordsize > 0) : 0 < srange a /\\ is_sgn (srange a) i.","conclusion":"0 < srange a /\\ is_sgn (srange a) i","hypotheses":"(i : int) (a : aval) (H : vmatch (Vint i) a) (H0 : Int.zwordsize > 0)","proofString":"inv H; simpl; eauto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) : vmatch (Vint i) (uns p n).","conclusion":"vmatch (Vint i) (uns p n)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i)","proofString":"assert (A: forall n', n' >= 0 -> n' >= n -> is_uns n' i) by (eauto with va).\nunfold uns.\nrepeat destruct zle; auto with va.\nreplace (Z.max 0 n) with 0 in H by lia.\napply is_uns_0 in H.\nsubst i; constructor."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) : vmatch (Vint i) (uns p n).","conclusion":"vmatch (Vint i) (uns p n)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i)","proofString":"unfold uns.\nrepeat destruct zle; auto with va.\nreplace (Z.max 0 n) with 0 in H by lia.\napply is_uns_0 in H.\nsubst i; constructor."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) : vmatch (Vint i)\n  (if zle n 0\n   then IU Int.zero\n   else\n    if zle n 1\n    then Uns p 1\n    else\n     if zle n 7\n     then Uns p 7\n     else\n      if zle n 8\n      then Uns p 8\n      else\n       if zle n 15 then Uns p 15 else if zle n 16 then Uns p 16 else Num p).","conclusion":"vmatch (Vint i)\n  (if zle n 0\n   then IU Int.zero\n   else\n    if zle n 1\n    then Uns p 1\n    else\n     if zle n 7\n     then Uns p 7\n     else\n      if zle n 8\n      then Uns p 8\n      else\n       if zle n 15 then Uns p 15 else if zle n 16 then Uns p 16 else Num p)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i)","proofString":"repeat destruct zle; auto with va.\nreplace (Z.max 0 n) with 0 in H by lia.\napply is_uns_0 in H.\nsubst i; constructor."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) (l : n <= 0) : vmatch (Vint i) (IU Int.zero).","conclusion":"vmatch (Vint i) (IU Int.zero)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns (Z.max 0 n) i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) (l : n <= 0)","proofString":"replace (Z.max 0 n) with 0 in H by lia.\napply is_uns_0 in H.\nsubst i; constructor."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns 0 i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) (l : n <= 0) : vmatch (Vint i) (IU Int.zero).","conclusion":"vmatch (Vint i) (IU Int.zero)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns 0 i) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) (l : n <= 0)","proofString":"apply is_uns_0 in H.\nsubst i; constructor."},{"statement":"(p : aptr) (i : int) (n : Z) (H : i = Int.zero) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) (l : n <= 0) : vmatch (Vint i) (IU Int.zero).","conclusion":"vmatch (Vint i) (IU Int.zero)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : i = Int.zero) (A : forall n' : Z, n' >= 0 -> n' >= n -> is_uns n' i) (l : n <= 0)","proofString":"subst i; constructor."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns n i) : vmatch (Vint i) (uns p n).","conclusion":"vmatch (Vint i) (uns p n)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns n i)","proofString":"apply vmatch_uns'.\neauto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_uns n i) : is_uns (Z.max 0 n) i.","conclusion":"is_uns (Z.max 0 n) i","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_uns n i)","proofString":"eauto with va."},{"statement":"(p : aptr) (n : Z) : vmatch Vundef (uns p n).","conclusion":"vmatch Vundef (uns p n)","hypotheses":"(p : aptr) (n : Z)","proofString":"unfold uns.\nrepeat destruct zle; auto with va."},{"statement":"(p : aptr) (n : Z) : vmatch Vundef\n  (if zle n 0\n   then IU Int.zero\n   else\n    if zle n 1\n    then Uns p 1\n    else\n     if zle n 7\n     then Uns p 7\n     else\n      if zle n 8\n      then Uns p 8\n      else\n       if zle n 15 then Uns p 15 else if zle n 16 then Uns p 16 else Num p).","conclusion":"vmatch Vundef\n  (if zle n 0\n   then IU Int.zero\n   else\n    if zle n 1\n    then Uns p 1\n    else\n     if zle n 7\n     then Uns p 7\n     else\n      if zle n 8\n      then Uns p 8\n      else\n       if zle n 15 then Uns p 15 else if zle n 16 then Uns p 16 else Num p)","hypotheses":"(p : aptr) (n : Z)","proofString":"repeat destruct zle; auto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_sgn (Z.max 1 n) i) : vmatch (Vint i) (sgn p n).","conclusion":"vmatch (Vint i) (sgn p n)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_sgn (Z.max 1 n) i)","proofString":"assert (A: forall n', n' >= 1 -> n' >= n -> is_sgn n' i) by (eauto with va).\nunfold sgn.\nrepeat destruct zle; auto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_sgn (Z.max 1 n) i) (A : forall n' : Z, n' >= 1 -> n' >= n -> is_sgn n' i) : vmatch (Vint i) (sgn p n).","conclusion":"vmatch (Vint i) (sgn p n)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_sgn (Z.max 1 n) i) (A : forall n' : Z, n' >= 1 -> n' >= n -> is_sgn n' i)","proofString":"unfold sgn.\nrepeat destruct zle; auto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_sgn (Z.max 1 n) i) (A : forall n' : Z, n' >= 1 -> n' >= n -> is_sgn n' i) : vmatch (Vint i)\n  (if zle n 8 then Sgn p 8 else if zle n 16 then Sgn p 16 else Num p).","conclusion":"vmatch (Vint i)\n  (if zle n 8 then Sgn p 8 else if zle n 16 then Sgn p 16 else Num p)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_sgn (Z.max 1 n) i) (A : forall n' : Z, n' >= 1 -> n' >= n -> is_sgn n' i)","proofString":"repeat destruct zle; auto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_sgn n i) : vmatch (Vint i) (sgn p n).","conclusion":"vmatch (Vint i) (sgn p n)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_sgn n i)","proofString":"apply vmatch_sgn'.\neauto with va."},{"statement":"(p : aptr) (i : int) (n : Z) (H : is_sgn n i) : is_sgn (Z.max 1 n) i.","conclusion":"is_sgn (Z.max 1 n) i","hypotheses":"(p : aptr) (i : int) (n : Z) (H : is_sgn n i)","proofString":"eauto with va."},{"statement":"(p : aptr) (n : Z) : vmatch Vundef (sgn p n).","conclusion":"vmatch Vundef (sgn p n)","hypotheses":"(p : aptr) (n : Z)","proofString":"unfold sgn.\nrepeat destruct zle; auto with va."},{"statement":"(p : aptr) (n : Z) : vmatch Vundef\n  (if zle n 8 then Sgn p 8 else if zle n 16 then Sgn p 16 else Num p).","conclusion":"vmatch Vundef\n  (if zle n 8 then Sgn p 8 else if zle n 16 then Sgn p 16 else Num p)","hypotheses":"(p : aptr) (n : Z)","proofString":"repeat destruct zle; auto with va."},{"statement":"(v : val) (p : aptr) : vmatch (Val.norm_bool v) (Uns p 1).","conclusion":"vmatch (Val.norm_bool v) (Uns p 1)","hypotheses":"(v : val) (p : aptr)","proofString":"destruct (Val.norm_bool_cases v) as [A | [A | A]]; rewrite A; constructor.\nlia.\napply is_uns_zero_ext; auto.\nlia.\napply is_uns_zero_ext; auto."},{"statement":"(v : val) (p : aptr) (A : Val.norm_bool v = Vfalse) : 0 <= 1.","conclusion":"0 <= 1","hypotheses":"(v : val) (p : aptr) (A : Val.norm_bool v = Vfalse)","proofString":"lia."},{"statement":"(v : val) (p : aptr) (A : Val.norm_bool v = Vfalse) : is_uns 1 Int.zero.","conclusion":"is_uns 1 Int.zero","hypotheses":"(v : val) (p : aptr) (A : Val.norm_bool v = Vfalse)","proofString":"apply is_uns_zero_ext; auto."},{"statement":"(v : val) (p : aptr) (A : Val.norm_bool v = Vtrue) : 0 <= 1.","conclusion":"0 <= 1","hypotheses":"(v : val) (p : aptr) (A : Val.norm_bool v = Vtrue)","proofString":"lia."},{"statement":"(v : val) (p : aptr) (A : Val.norm_bool v = Vtrue) : is_uns 1 Int.one.","conclusion":"is_uns 1 Int.one","hypotheses":"(v : val) (p : aptr) (A : Val.norm_bool v = Vtrue)","proofString":"apply is_uns_zero_ext; auto."},{"statement":"(p : aptr) (v : val) (H : vmatch v (Uns p 1)) : v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one.","conclusion":"v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one","hypotheses":"(p : aptr) (v : val) (H : vmatch v (Uns p 1))","proofString":"inv H; auto.\nright.\nexploit is_uns_1; eauto.\nintuition congruence."},{"statement":"(p : aptr) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i) : Vint i = Vundef \\/ Vint i = Vint Int.zero \\/ Vint i = Vint Int.one.","conclusion":"Vint i = Vundef \\/ Vint i = Vint Int.zero \\/ Vint i = Vint Int.one","hypotheses":"(p : aptr) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i)","proofString":"right.\nexploit is_uns_1; eauto.\nintuition congruence."},{"statement":"(p : aptr) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i) : Vint i = Vint Int.zero \\/ Vint i = Vint Int.one.","conclusion":"Vint i = Vint Int.zero \\/ Vint i = Vint Int.one","hypotheses":"(p : aptr) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i)","proofString":"exploit is_uns_1; eauto.\nintuition congruence."},{"statement":"(p : aptr) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i) : i = Int.zero \\/ i = Int.one ->\nVint i = Vint Int.zero \\/ Vint i = Vint Int.one.","conclusion":"i = Int.zero \\/ i = Int.one ->\nVint i = Vint Int.zero \\/ Vint i = Vint Int.one","hypotheses":"(p : aptr) (i : int) (H3 : 0 <= 1) (H4 : is_uns 1 i)","proofString":"intuition congruence."},{"statement":"(p : aptr) (v : val) (H : vmatch v (Uns p 0)) : v = Vundef \\/ v = Vint Int.zero.","conclusion":"v = Vundef \\/ v = Vint Int.zero","hypotheses":"(p : aptr) (v : val) (H : vmatch v (Uns p 0))","proofString":"inv H; auto.\nright.\nexploit is_uns_0; eauto.\nintuition congruence."},{"statement":"(p : aptr) (i : int) (H3 : 0 <= 0) (H4 : is_uns 0 i) : Vint i = Vundef \\/ Vint i = Vint Int.zero.","conclusion":"Vint i = Vundef \\/ Vint i = Vint Int.zero","hypotheses":"(p : aptr) (i : int) (H3 : 0 <= 0) (H4 : is_uns 0 i)","proofString":"right.\nexploit is_uns_0; eauto.\nintuition congruence."},{"statement":"(p : aptr) (i : int) (H3 : 0 <= 0) (H4 : is_uns 0 i) : Vint i = Vint Int.zero.","conclusion":"Vint i = Vint Int.zero","hypotheses":"(p : aptr) (i : int) (H3 : 0 <= 0) (H4 : is_uns 0 i)","proofString":"exploit is_uns_0; eauto.\nintuition congruence."},{"statement":"(p : aptr) (i : int) (H3 : 0 <= 0) (H4 : is_uns 0 i) : i = Int.zero -> Vint i = Vint Int.zero.","conclusion":"i = Int.zero -> Vint i = Vint Int.zero","hypotheses":"(p : aptr) (i : int) (H3 : 0 <= 0) (H4 : is_uns 0 i)","proofString":"intuition congruence."},{"statement":"forall y z : aval, vge y z -> forall x : aval, vge x y -> vge x z.","conclusion":"forall y z : aval, vge y z -> forall x : aval, vge x y -> vge x z","hypotheses":"","proofString":"destruct 1; intros x V; auto with va; inv V; eauto using pge_trans with va."},{"statement":"forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i.","conclusion":"forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i","hypotheses":"","proofString":"intros.\nunfold vlub_int.\nrewrite Int.eq_sym, orb_comm.\npredSpec Int.eq Int.eq_spec j i.\ncongruence.\ndestruct orb; f_equal; apply Z.max_comm."},{"statement":"(cstr : int -> aval) (i j : int) : vlub_int cstr i j = vlub_int cstr j i.","conclusion":"vlub_int cstr i j = vlub_int cstr j i","hypotheses":"(cstr : int -> aval) (i j : int)","proofString":"unfold vlub_int.\nrewrite Int.eq_sym, orb_comm.\npredSpec Int.eq Int.eq_spec j i.\ncongruence.\ndestruct orb; f_equal; apply Z.max_comm."},{"statement":"(cstr : int -> aval) (i j : int) : (if Int.eq i j\n then cstr i\n else\n  if Int.lt i Int.zero || Int.lt j Int.zero\n  then sgn Pbot (Z.max (ssize i) (ssize j))\n  else uns1 Pbot (Z.max (usize i) (usize j))) =\n(if Int.eq j i\n then cstr j\n else\n  if Int.lt j Int.zero || Int.lt i Int.zero\n  then sgn Pbot (Z.max (ssize j) (ssize i))\n  else uns1 Pbot (Z.max (usize j) (usize i))).","conclusion":"(if Int.eq i j\n then cstr i\n else\n  if Int.lt i Int.zero || Int.lt j Int.zero\n  then sgn Pbot (Z.max (ssize i) (ssize j))\n  else uns1 Pbot (Z.max (usize i) (usize j))) =\n(if Int.eq j i\n then cstr j\n else\n  if Int.lt j Int.zero || Int.lt i Int.zero\n  then sgn Pbot (Z.max (ssize j) (ssize i))\n  else uns1 Pbot (Z.max (usize j) (usize i)))","hypotheses":"(cstr : int -> aval) (i j : int)","proofString":"rewrite Int.eq_sym, orb_comm.\npredSpec Int.eq Int.eq_spec j i.\ncongruence.\ndestruct orb; f_equal; apply Z.max_comm."},{"statement":"(cstr : int -> aval) (i j : int) : (if Int.eq j i\n then cstr i\n else\n  if Int.lt j Int.zero || Int.lt i Int.zero\n  then sgn Pbot (Z.max (ssize i) (ssize j))\n  else uns1 Pbot (Z.max (usize i) (usize j))) =\n(if Int.eq j i\n then cstr j\n else\n  if Int.lt j Int.zero || Int.lt i Int.zero\n  then sgn Pbot (Z.max (ssize j) (ssize i))\n  else uns1 Pbot (Z.max (usize j) (usize i))).","conclusion":"(if Int.eq j i\n then cstr i\n else\n  if Int.lt j Int.zero || Int.lt i Int.zero\n  then sgn Pbot (Z.max (ssize i) (ssize j))\n  else uns1 Pbot (Z.max (usize i) (usize j))) =\n(if Int.eq j i\n then cstr j\n else\n  if Int.lt j Int.zero || Int.lt i Int.zero\n  then sgn Pbot (Z.max (ssize j) (ssize i))\n  else uns1 Pbot (Z.max (usize j) (usize i)))","hypotheses":"(cstr : int -> aval) (i j : int)","proofString":"predSpec Int.eq Int.eq_spec j i.\ncongruence.\ndestruct orb; f_equal; apply Z.max_comm."},{"statement":"(cstr : int -> aval) (i j : int) (H : j = i) : cstr i = cstr j.","conclusion":"cstr i = cstr j","hypotheses":"(cstr : int -> aval) (i j : int) (H : j = i)","proofString":"congruence."},{"statement":"(cstr : int -> aval) (i j : int) (H : j <> i) : (if Int.lt j Int.zero || Int.lt i Int.zero\n then sgn Pbot (Z.max (ssize i) (ssize j))\n else uns1 Pbot (Z.max (usize i) (usize j))) =\n(if Int.lt j Int.zero || Int.lt i Int.zero\n then sgn Pbot (Z.max (ssize j) (ssize i))\n else uns1 Pbot (Z.max (usize j) (usize i))).","conclusion":"(if Int.lt j Int.zero || Int.lt i Int.zero\n then sgn Pbot (Z.max (ssize i) (ssize j))\n else uns1 Pbot (Z.max (usize i) (usize j))) =\n(if Int.lt j Int.zero || Int.lt i Int.zero\n then sgn Pbot (Z.max (ssize j) (ssize i))\n else uns1 Pbot (Z.max (usize j) (usize i)))","hypotheses":"(cstr : int -> aval) (i j : int) (H : j <> i)","proofString":"destruct orb; f_equal; apply Z.max_comm."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) : forall v w : aval, vlub v w = vlub w v.","conclusion":"forall v w : aval, vlub v w = vlub w v","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i)","proofString":"intros.\nunfold vlub; destruct v; destruct w; auto; f_equal; auto using Z.max_comm, plub_comm.\nrewrite Int64.eq_sym.\npredSpec Int64.eq Int64.eq_spec n0 n; congruence.\nrewrite dec_eq_sym.\ndestruct (Float.eq_dec f0 f); congruence.\nrewrite dec_eq_sym.\ndestruct (Float32.eq_dec f0 f); congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (v w : aval) : vlub v w = vlub w v.","conclusion":"vlub v w = vlub w v","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (v w : aval)","proofString":"unfold vlub; destruct v; destruct w; auto; f_equal; auto using Z.max_comm, plub_comm.\nrewrite Int64.eq_sym.\npredSpec Int64.eq Int64.eq_spec n0 n; congruence.\nrewrite dec_eq_sym.\ndestruct (Float.eq_dec f0 f); congruence.\nrewrite dec_eq_sym.\ndestruct (Float32.eq_dec f0 f); congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (n n0 : int64) : (if Int64.eq n n0 then L n else ntop) =\n(if Int64.eq n0 n then L n0 else ntop).","conclusion":"(if Int64.eq n n0 then L n else ntop) =\n(if Int64.eq n0 n then L n0 else ntop)","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (n n0 : int64)","proofString":"rewrite Int64.eq_sym.\npredSpec Int64.eq Int64.eq_spec n0 n; congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (n n0 : int64) : (if Int64.eq n0 n then L n else ntop) =\n(if Int64.eq n0 n then L n0 else ntop).","conclusion":"(if Int64.eq n0 n then L n else ntop) =\n(if Int64.eq n0 n then L n0 else ntop)","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (n n0 : int64)","proofString":"predSpec Int64.eq Int64.eq_spec n0 n; congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float) : (if Float.eq_dec f f0 then F f else ntop) =\n(if Float.eq_dec f0 f then F f0 else ntop).","conclusion":"(if Float.eq_dec f f0 then F f else ntop) =\n(if Float.eq_dec f0 f then F f0 else ntop)","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float)","proofString":"rewrite dec_eq_sym.\ndestruct (Float.eq_dec f0 f); congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float) : (if Float.eq_dec f0 f then F f else ntop) =\n(if Float.eq_dec f0 f then F f0 else ntop).","conclusion":"(if Float.eq_dec f0 f then F f else ntop) =\n(if Float.eq_dec f0 f then F f0 else ntop)","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float)","proofString":"destruct (Float.eq_dec f0 f); congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float32) : (if Float32.eq_dec f f0 then FS f else ntop) =\n(if Float32.eq_dec f0 f then FS f0 else ntop).","conclusion":"(if Float32.eq_dec f f0 then FS f else ntop) =\n(if Float32.eq_dec f0 f then FS f0 else ntop)","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float32)","proofString":"rewrite dec_eq_sym.\ndestruct (Float32.eq_dec f0 f); congruence."},{"statement":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float32) : (if Float32.eq_dec f0 f then FS f else ntop) =\n(if Float32.eq_dec f0 f then FS f0 else ntop).","conclusion":"(if Float32.eq_dec f0 f then FS f else ntop) =\n(if Float32.eq_dec f0 f then FS f0 else ntop)","hypotheses":"(INT : forall (cstr : int -> aval) (i j : int),\nvlub_int cstr i j = vlub_int cstr j i) (f f0 : float32)","proofString":"destruct (Float32.eq_dec f0 f); congruence."},{"statement":"(p : aptr) (n : Z) : vge\n  (if zle n 1\n   then Uns p 1\n   else\n    if zle n 7\n    then Uns p 7\n    else\n     if zle n 8\n     then Uns p 8\n     else if zle n 15 then Uns p 15 else if zle n 16 then Uns p 16 else Num p)\n  (Uns p n).","conclusion":"vge\n  (if zle n 1\n   then Uns p 1\n   else\n    if zle n 7\n    then Uns p 7\n    else\n     if zle n 8\n     then Uns p 8\n     else if zle n 15 then Uns p 15 else if zle n 16 then Uns p 16 else Num p)\n  (Uns p n)","hypotheses":"(p : aptr) (n : Z)","proofString":"repeat (destruct zle); eauto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i) : vge (uns1 p n) (I i).","conclusion":"vge (uns1 p n) (I i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply vge_trans with (Uns p n).\napply vge_uns_uns'.\nauto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i) : vge (uns1 p n) (Uns p n).","conclusion":"vge (uns1 p n) (Uns p n)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply vge_uns_uns'."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i) : vge (Uns p n) (I i).","conclusion":"vge (Uns p n) (I i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i)","proofString":"auto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i) : vge (uns1 p n) (IU i).","conclusion":"vge (uns1 p n) (IU i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply vge_trans with (Uns p n).\napply vge_uns_uns'.\nauto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i) : vge (uns1 p n) (Uns p n).","conclusion":"vge (uns1 p n) (Uns p n)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply vge_uns_uns'."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i) : vge (Uns p n) (IU i).","conclusion":"vge (Uns p n) (IU i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 <= n) (H0 : is_uns n i)","proofString":"auto with va."},{"statement":"(p : aptr) (n : Z) : vge (if zle n 8 then Sgn p 8 else if zle n 16 then Sgn p 16 else Num p)\n  (Sgn p n).","conclusion":"vge (if zle n 8 then Sgn p 8 else if zle n 16 then Sgn p 16 else Num p)\n  (Sgn p n)","hypotheses":"(p : aptr) (n : Z)","proofString":"repeat (destruct zle); eauto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : vge (sgn p n) (I i).","conclusion":"vge (sgn p n) (I i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply vge_trans with (Sgn p n).\napply vge_sgn_sgn'.\nauto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : vge (sgn p n) (Sgn p n).","conclusion":"vge (sgn p n) (Sgn p n)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply vge_sgn_sgn'."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : vge (Sgn p n) (I i).","conclusion":"vge (Sgn p n) (I i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"auto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : vge (sgn p n) (IU i).","conclusion":"vge (sgn p n) (IU i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply vge_trans with (Sgn p n).\napply vge_sgn_sgn'.\nauto with va."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : vge (sgn p n) (Sgn p n).","conclusion":"vge (sgn p n) (Sgn p n)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply vge_sgn_sgn'."},{"statement":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i) : vge (Sgn p n) (IU i).","conclusion":"vge (Sgn p n) (IU i)","hypotheses":"(p : aptr) (n : Z) (i : int) (H : 0 < n) (H0 : is_sgn n i)","proofString":"auto with va."},{"statement":"forall i j : int, vge (vlub_int I i j) (I i).","conclusion":"forall i j : int, vge (vlub_int I i j) (I i)","hypotheses":"","proofString":"unfold vlub_int; intros.\npredSpec Int.eq Int.eq_spec i j.\nauto with va.\ndestruct orb.\neauto with va.\napply vge_sgn_i'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_i'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(i j : int) : vge\n  (if Int.eq i j\n   then I i\n   else\n    if Int.lt i Int.zero || Int.lt j Int.zero\n    then sgn Pbot (Z.max (ssize i) (ssize j))\n    else uns1 Pbot (Z.max (usize i) (usize j))) (I i).","conclusion":"vge\n  (if Int.eq i j\n   then I i\n   else\n    if Int.lt i Int.zero || Int.lt j Int.zero\n    then sgn Pbot (Z.max (ssize i) (ssize j))\n    else uns1 Pbot (Z.max (usize i) (usize j))) (I i)","hypotheses":"(i j : int)","proofString":"predSpec Int.eq Int.eq_spec i j.\nauto with va.\ndestruct orb.\neauto with va.\napply vge_sgn_i'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_i'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(i j : int) (H : i = j) : vge (I i) (I i).","conclusion":"vge (I i) (I i)","hypotheses":"(i j : int) (H : i = j)","proofString":"auto with va."},{"statement":"(i j : int) (H : i <> j) : vge\n  (if Int.lt i Int.zero || Int.lt j Int.zero\n   then sgn Pbot (Z.max (ssize i) (ssize j))\n   else uns1 Pbot (Z.max (usize i) (usize j))) (I i).","conclusion":"vge\n  (if Int.lt i Int.zero || Int.lt j Int.zero\n   then sgn Pbot (Z.max (ssize i) (ssize j))\n   else uns1 Pbot (Z.max (usize i) (usize j))) (I i)","hypotheses":"(i j : int) (H : i <> j)","proofString":"destruct orb.\neauto with va.\napply vge_sgn_i'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_i'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(i j : int) (H : i <> j) : vge (sgn Pbot (Z.max (ssize i) (ssize j))) (I i).","conclusion":"vge (sgn Pbot (Z.max (ssize i) (ssize j))) (I i)","hypotheses":"(i j : int) (H : i <> j)","proofString":"eauto with va.\napply vge_sgn_i'.\ngeneralize (ssize_pos i); lia.\neauto with va."},{"statement":"(i j : int) (H : i <> j) : vge (sgn Pbot (Z.max (ssize i) (ssize j))) (I i).","conclusion":"vge (sgn Pbot (Z.max (ssize i) (ssize j))) (I i)","hypotheses":"(i j : int) (H : i <> j)","proofString":"apply vge_sgn_i'.\ngeneralize (ssize_pos i); lia.\neauto with va."},{"statement":"(i j : int) (H : i <> j) : 0 < Z.max (ssize i) (ssize j).","conclusion":"0 < Z.max (ssize i) (ssize j)","hypotheses":"(i j : int) (H : i <> j)","proofString":"generalize (ssize_pos i); lia."},{"statement":"(i j : int) (H : i <> j) : is_sgn (Z.max (ssize i) (ssize j)) i.","conclusion":"is_sgn (Z.max (ssize i) (ssize j)) i","hypotheses":"(i j : int) (H : i <> j)","proofString":"eauto with va."},{"statement":"(i j : int) (H : i <> j) : vge (uns1 Pbot (Z.max (usize i) (usize j))) (I i).","conclusion":"vge (uns1 Pbot (Z.max (usize i) (usize j))) (I i)","hypotheses":"(i j : int) (H : i <> j)","proofString":"apply vge_uns_i'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(i j : int) (H : i <> j) : 0 <= Z.max (usize i) (usize j).","conclusion":"0 <= Z.max (usize i) (usize j)","hypotheses":"(i j : int) (H : i <> j)","proofString":"generalize (usize_pos i); lia."},{"statement":"(i j : int) (H : i <> j) : is_uns (Z.max (usize i) (usize j)) i.","conclusion":"is_uns (Z.max (usize i) (usize j)) i","hypotheses":"(i j : int) (H : i <> j)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) : forall x y : aval, vge (vlub x y) x.","conclusion":"forall x y : aval, vge (vlub x y) x","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i))","proofString":"assert (INTU: forall i j, vge (vlub_int IU i j) (IU i)).\nunfold vlub_int; intros.\npredSpec Int.eq Int.eq_spec i j.\nauto with va.\ndestruct orb.\napply vge_sgn_iu'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos i); lia.\neauto with va.\nunfold vlub, ntop; destruct x, y; eauto using vge_trans, pge_lub_l with va.\ndestruct (Int.lt n Int.zero).\napply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va.\napply vge_uns_i'.\ngeneralize (usize_pos n); lia.\neauto with va.\napply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va.\ndestruct (Int.lt n Int.zero).\napply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos n); lia.\neauto with va.\napply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va.\ndestruct (Int.lt n0 Int.zero).\neapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va.\neapply vge_trans.\napply vge_uns_uns'.\neauto with va.\ndestruct (Int.lt n0 Int.zero).\neapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va.\neapply vge_trans.\napply vge_uns_uns'.\neauto with va.\ndestruct (Int64.eq n n0); constructor.\ndestruct (Float.eq_dec f f0); constructor.\ndestruct (Float32.eq_dec f f0); constructor."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) : forall i j : int, vge (vlub_int IU i j) (IU i).","conclusion":"forall i j : int, vge (vlub_int IU i j) (IU i)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i))","proofString":"unfold vlub_int; intros.\npredSpec Int.eq Int.eq_spec i j.\nauto with va.\ndestruct orb.\napply vge_sgn_iu'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) : vge\n  (if Int.eq i j\n   then IU i\n   else\n    if Int.lt i Int.zero || Int.lt j Int.zero\n    then sgn Pbot (Z.max (ssize i) (ssize j))\n    else uns1 Pbot (Z.max (usize i) (usize j))) (IU i).","conclusion":"vge\n  (if Int.eq i j\n   then IU i\n   else\n    if Int.lt i Int.zero || Int.lt j Int.zero\n    then sgn Pbot (Z.max (ssize i) (ssize j))\n    else uns1 Pbot (Z.max (usize i) (usize j))) (IU i)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int)","proofString":"predSpec Int.eq Int.eq_spec i j.\nauto with va.\ndestruct orb.\napply vge_sgn_iu'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i = j) : vge (IU i) (IU i).","conclusion":"vge (IU i) (IU i)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i = j)","proofString":"auto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : vge\n  (if Int.lt i Int.zero || Int.lt j Int.zero\n   then sgn Pbot (Z.max (ssize i) (ssize j))\n   else uns1 Pbot (Z.max (usize i) (usize j))) (IU i).","conclusion":"vge\n  (if Int.lt i Int.zero || Int.lt j Int.zero\n   then sgn Pbot (Z.max (ssize i) (ssize j))\n   else uns1 Pbot (Z.max (usize i) (usize j))) (IU i)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"destruct orb.\napply vge_sgn_iu'.\ngeneralize (ssize_pos i); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : vge (sgn Pbot (Z.max (ssize i) (ssize j))) (IU i).","conclusion":"vge (sgn Pbot (Z.max (ssize i) (ssize j))) (IU i)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"apply vge_sgn_iu'.\ngeneralize (ssize_pos i); lia.\neauto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : 0 < Z.max (ssize i) (ssize j).","conclusion":"0 < Z.max (ssize i) (ssize j)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"generalize (ssize_pos i); lia."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : is_sgn (Z.max (ssize i) (ssize j)) i.","conclusion":"is_sgn (Z.max (ssize i) (ssize j)) i","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"eauto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : vge (uns1 Pbot (Z.max (usize i) (usize j))) (IU i).","conclusion":"vge (uns1 Pbot (Z.max (usize i) (usize j))) (IU i)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"apply vge_uns_iu'.\ngeneralize (usize_pos i); lia.\neauto with va."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : 0 <= Z.max (usize i) (usize j).","conclusion":"0 <= Z.max (usize i) (usize j)","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"generalize (usize_pos i); lia."},{"statement":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j) : is_uns (Z.max (usize i) (usize j)) i.","conclusion":"is_uns (Z.max (usize i) (usize j)) i","hypotheses":"(INT : forall i0 j0 : int, vge (vlub_int I i0 j0) (I i0)) (i j : int) (H : i <> j)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) : forall x y : aval, vge (vlub x y) x.","conclusion":"forall x y : aval, vge (vlub x y) x","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i))","proofString":"unfold vlub, ntop; destruct x, y; eauto using vge_trans, pge_lub_l with va.\ndestruct (Int.lt n Int.zero).\napply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va.\napply vge_uns_i'.\ngeneralize (usize_pos n); lia.\neauto with va.\napply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va.\ndestruct (Int.lt n Int.zero).\napply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos n); lia.\neauto with va.\napply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va.\ndestruct (Int.lt n0 Int.zero).\neapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va.\neapply vge_trans.\napply vge_uns_uns'.\neauto with va.\ndestruct (Int.lt n0 Int.zero).\neapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va.\neapply vge_trans.\napply vge_uns_uns'.\neauto with va.\ndestruct (Int64.eq n n0); constructor.\ndestruct (Float.eq_dec f f0); constructor.\ndestruct (Float32.eq_dec f f0); constructor."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge\n  (if Int.lt n Int.zero\n   then sgn p (Z.max (ssize n) (n0 + 1))\n   else uns1 p (Z.max (usize n) n0)) (I n).","conclusion":"vge\n  (if Int.lt n Int.zero\n   then sgn p (Z.max (ssize n) (n0 + 1))\n   else uns1 p (Z.max (usize n) n0)) (I n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"destruct (Int.lt n Int.zero).\napply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va.\napply vge_uns_i'.\ngeneralize (usize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge (sgn p (Z.max (ssize n) (n0 + 1))) (I n).","conclusion":"vge (sgn p (Z.max (ssize n) (n0 + 1))) (I n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"apply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : 0 < Z.max (ssize n) (n0 + 1).","conclusion":"0 < Z.max (ssize n) (n0 + 1)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"generalize (ssize_pos n); lia."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : is_sgn (Z.max (ssize n) (n0 + 1)) n.","conclusion":"is_sgn (Z.max (ssize n) (n0 + 1)) n","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge (uns1 p (Z.max (usize n) n0)) (I n).","conclusion":"vge (uns1 p (Z.max (usize n) n0)) (I n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"apply vge_uns_i'.\ngeneralize (usize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : 0 <= Z.max (usize n) n0.","conclusion":"0 <= Z.max (usize n) n0","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"generalize (usize_pos n); lia."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : is_uns (Z.max (usize n) n0) n.","conclusion":"is_uns (Z.max (usize n) n0) n","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge (sgn p (Z.max (ssize n) n0)) (I n).","conclusion":"vge (sgn p (Z.max (ssize n) n0)) (I n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"apply vge_sgn_i'.\ngeneralize (ssize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : 0 < Z.max (ssize n) n0.","conclusion":"0 < Z.max (ssize n) n0","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"generalize (ssize_pos n); lia."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : is_sgn (Z.max (ssize n) n0) n.","conclusion":"is_sgn (Z.max (ssize n) n0) n","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge\n  (if Int.lt n Int.zero\n   then sgn p (Z.max (ssize n) (n0 + 1))\n   else uns1 p (Z.max (usize n) n0)) (IU n).","conclusion":"vge\n  (if Int.lt n Int.zero\n   then sgn p (Z.max (ssize n) (n0 + 1))\n   else uns1 p (Z.max (usize n) n0)) (IU n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"destruct (Int.lt n Int.zero).\napply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va.\napply vge_uns_iu'.\ngeneralize (usize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge (sgn p (Z.max (ssize n) (n0 + 1))) (IU n).","conclusion":"vge (sgn p (Z.max (ssize n) (n0 + 1))) (IU n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"apply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : 0 < Z.max (ssize n) (n0 + 1).","conclusion":"0 < Z.max (ssize n) (n0 + 1)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"generalize (ssize_pos n); lia."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : is_sgn (Z.max (ssize n) (n0 + 1)) n.","conclusion":"is_sgn (Z.max (ssize n) (n0 + 1)) n","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge (uns1 p (Z.max (usize n) n0)) (IU n).","conclusion":"vge (uns1 p (Z.max (usize n) n0)) (IU n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"apply vge_uns_iu'.\ngeneralize (usize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : 0 <= Z.max (usize n) n0.","conclusion":"0 <= Z.max (usize n) n0","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"generalize (usize_pos n); lia."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : is_uns (Z.max (usize n) n0) n.","conclusion":"is_uns (Z.max (usize n) n0) n","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : vge (sgn p (Z.max (ssize n) n0)) (IU n).","conclusion":"vge (sgn p (Z.max (ssize n) n0)) (IU n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"apply vge_sgn_iu'.\ngeneralize (ssize_pos n); lia.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : 0 < Z.max (ssize n) n0.","conclusion":"0 < Z.max (ssize n) n0","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"generalize (ssize_pos n); lia."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z) : is_sgn (Z.max (ssize n) n0) n.","conclusion":"is_sgn (Z.max (ssize n) n0) n","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n : int) (p : aptr) (n0 : Z)","proofString":"eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int) : vge\n  (if Int.lt n0 Int.zero\n   then sgn p (Z.max (ssize n0) (n + 1))\n   else uns1 p (Z.max (usize n0) n)) (Uns p n).","conclusion":"vge\n  (if Int.lt n0 Int.zero\n   then sgn p (Z.max (ssize n0) (n + 1))\n   else uns1 p (Z.max (usize n0) n)) (Uns p n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int)","proofString":"destruct (Int.lt n0 Int.zero).\neapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va.\neapply vge_trans.\napply vge_uns_uns'.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int) : vge (sgn p (Z.max (ssize n0) (n + 1))) (Uns p n).","conclusion":"vge (sgn p (Z.max (ssize n0) (n + 1))) (Uns p n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int)","proofString":"eapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int) : vge (uns1 p (Z.max (usize n0) n)) (Uns p n).","conclusion":"vge (uns1 p (Z.max (usize n0) n)) (Uns p n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int)","proofString":"eapply vge_trans.\napply vge_uns_uns'.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int) : vge\n  (if Int.lt n0 Int.zero\n   then sgn p (Z.max (ssize n0) (n + 1))\n   else uns1 p (Z.max (usize n0) n)) (Uns p n).","conclusion":"vge\n  (if Int.lt n0 Int.zero\n   then sgn p (Z.max (ssize n0) (n + 1))\n   else uns1 p (Z.max (usize n0) n)) (Uns p n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int)","proofString":"destruct (Int.lt n0 Int.zero).\neapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va.\neapply vge_trans.\napply vge_uns_uns'.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int) : vge (sgn p (Z.max (ssize n0) (n + 1))) (Uns p n).","conclusion":"vge (sgn p (Z.max (ssize n0) (n + 1))) (Uns p n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int)","proofString":"eapply vge_trans.\napply vge_sgn_sgn'.\napply vge_trans with (Sgn p (n + 1)); eauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int) : vge (uns1 p (Z.max (usize n0) n)) (Uns p n).","conclusion":"vge (uns1 p (Z.max (usize n0) n)) (Uns p n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (p : aptr) (n : Z) (n0 : int)","proofString":"eapply vge_trans.\napply vge_uns_uns'.\neauto with va."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n n0 : int64) : vge (if Int64.eq n n0 then L n else Num Pbot) (L n).","conclusion":"vge (if Int64.eq n n0 then L n else Num Pbot) (L n)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (n n0 : int64)","proofString":"destruct (Int64.eq n n0); constructor."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (f f0 : float) : vge (if Float.eq_dec f f0 then F f else Num Pbot) (F f).","conclusion":"vge (if Float.eq_dec f f0 then F f else Num Pbot) (F f)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (f f0 : float)","proofString":"destruct (Float.eq_dec f f0); constructor."},{"statement":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (f f0 : float32) : vge (if Float32.eq_dec f f0 then FS f else Num Pbot) (FS f).","conclusion":"vge (if Float32.eq_dec f f0 then FS f else Num Pbot) (FS f)","hypotheses":"(INT : forall i j : int, vge (vlub_int I i j) (I i)) (INTU : forall i j : int, vge (vlub_int IU i j) (IU i)) (f f0 : float32)","proofString":"destruct (Float32.eq_dec f f0); constructor."},{"statement":"(x y : aval) : vge (vlub x y) y.","conclusion":"vge (vlub x y) y","hypotheses":"(x y : aval)","proofString":"rewrite vlub_comm.\napply vge_lub_l."},{"statement":"(x y : aval) : vge (vlub y x) y.","conclusion":"vge (vlub y x) y","hypotheses":"(x y : aval)","proofString":"apply vge_lub_l."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) : vmatch v (vlub x y).","conclusion":"vmatch v (vlub x y)","hypotheses":"(v : val) (x y : aval) (H : vmatch v x)","proofString":"eapply vmatch_ge; eauto.\napply vge_lub_l."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) : vge (vlub x y) x.","conclusion":"vge (vlub x y) x","hypotheses":"(v : val) (x y : aval) (H : vmatch v x)","proofString":"apply vge_lub_l."},{"statement":"(v : val) (x y : aval) (H : vmatch v y) : vmatch v (vlub x y).","conclusion":"vmatch v (vlub x y)","hypotheses":"(v : val) (x y : aval) (H : vmatch v y)","proofString":"rewrite vlub_comm.\napply vmatch_lub_l; auto."},{"statement":"(v : val) (x y : aval) (H : vmatch v y) : vmatch v (vlub y x).","conclusion":"vmatch v (vlub y x)","hypotheses":"(v : val) (x y : aval) (H : vmatch v y)","proofString":"apply vmatch_lub_l; auto."},{"statement":"(b : block) (ofs : ptrofs) (av : aval) (H : vmatch (Vptr b ofs) av) : pmatch b ofs\n  match av with\n  | I i => int_provenance i\n  | L i => long_provenance i\n  | Uns p _ | Sgn p _ | Num p => if va_strict tt then Pbot else p\n  | Ptr p | Ifptr p => p\n  | _ => Pbot\n  end.","conclusion":"pmatch b ofs\n  match av with\n  | I i => int_provenance i\n  | L i => long_provenance i\n  | Uns p _ | Sgn p _ | Num p => if va_strict tt then Pbot else p\n  | Ptr p | Ifptr p => p\n  | _ => Pbot\n  end","hypotheses":"(b : block) (ofs : ptrofs) (av : aval) (H : vmatch (Vptr b ofs) av)","proofString":"inv H; auto."},{"statement":"(v : val) (x : aval) (p : aptr) (H : vmatch v x) : vmatch v (Ifptr (vplub x p)).","conclusion":"vmatch v (Ifptr (vplub x p))","hypotheses":"(v : val) (x : aval) (p : aptr) (H : vmatch v x)","proofString":"unfold vplub; inv H; auto with va; constructor; eapply pmatch_lub_l; eauto."},{"statement":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p) : pmatch b ofs (vplub x p).","conclusion":"pmatch b ofs (vplub x p)","hypotheses":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p)","proofString":"assert (DFL: pmatch b ofs (if va_strict tt then p else Ptop)).\ndestruct (va_strict tt); auto.\neapply pmatch_top'; eauto.\nunfold vplub; destruct x; auto; apply pmatch_lub_r; auto."},{"statement":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p) : pmatch b ofs (if va_strict tt then p else Ptop).","conclusion":"pmatch b ofs (if va_strict tt then p else Ptop)","hypotheses":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p)","proofString":"destruct (va_strict tt); auto.\neapply pmatch_top'; eauto."},{"statement":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p) : pmatch b ofs Ptop.","conclusion":"pmatch b ofs Ptop","hypotheses":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p)","proofString":"eapply pmatch_top'; eauto."},{"statement":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p) (DFL : pmatch b ofs (if va_strict tt then p else Ptop)) : pmatch b ofs (vplub x p).","conclusion":"pmatch b ofs (vplub x p)","hypotheses":"(b : block) (ofs : ptrofs) (x : aval) (p : aptr) (H : pmatch b ofs p) (DFL : pmatch b ofs (if va_strict tt then p else Ptop))","proofString":"unfold vplub; destruct x; auto; apply pmatch_lub_r; auto."},{"statement":"(v : val) (x : aval) (p : aptr) (H : vmatch v (Ifptr p)) : vmatch v (Ifptr (vplub x p)).","conclusion":"vmatch v (Ifptr (vplub x p))","hypotheses":"(v : val) (x : aval) (p : aptr) (H : vmatch v (Ifptr p))","proofString":"apply vmatch_ifptr; intros; subst v.\ninv H.\napply pmatch_vplub; auto."},{"statement":"(x : aval) (p : aptr) (b : block) (ofs : ptrofs) (H : vmatch (Vptr b ofs) (Ifptr p)) : pmatch b ofs (vplub x p).","conclusion":"pmatch b ofs (vplub x p)","hypotheses":"(x : aval) (p : aptr) (b : block) (ofs : ptrofs) (H : vmatch (Vptr b ofs) (Ifptr p))","proofString":"inv H.\napply pmatch_vplub; auto."},{"statement":"(x : aval) (p : aptr) (b : block) (ofs : ptrofs) (H1 : pmatch b ofs p) : pmatch b ofs (vplub x p).","conclusion":"pmatch b ofs (vplub x p)","hypotheses":"(x : aval) (p : aptr) (b : block) (ofs : ptrofs) (H1 : pmatch b ofs p)","proofString":"apply pmatch_vplub; auto."},{"statement":"(x : aval) (p : aptr) (H : match x with\n| Uns q _ | Sgn q _ | Num q | Ptr q | Ifptr q => pincl q p\n| _ => true\nend = true) : vge (Ifptr p) x.","conclusion":"vge (Ifptr p) x","hypotheses":"(x : aval) (p : aptr) (H : match x with\n| Uns q _ | Sgn q _ | Num q | Ptr q | Ifptr q => pincl q p\n| _ => true\nend = true)","proofString":"destruct x; eauto using pincl_ge with va."},{"statement":"(v : val) (x : aval) (p : aptr) (H : vpincl x p = true) (H0 : vmatch v x) : vmatch v (Ifptr p).","conclusion":"vmatch v (Ifptr p)","hypotheses":"(v : val) (x : aval) (p : aptr) (H : vpincl x p = true) (H0 : vmatch v x)","proofString":"apply vmatch_ge with x; auto.\napply vpincl_ge; auto."},{"statement":"(v : val) (x : aval) (p : aptr) (H : vpincl x p = true) (H0 : vmatch v x) : vge (Ifptr p) x.","conclusion":"vge (Ifptr p) x","hypotheses":"(v : val) (x : aval) (p : aptr) (H : vpincl x p = true) (H0 : vmatch v x)","proofString":"apply vpincl_ge; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n) : vge (Uns p n0) (I n).","conclusion":"vge (Uns p n0) (I n)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n)","proofString":"constructor; auto.\nrewrite is_uns_zero_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n) : is_uns n0 n.","conclusion":"is_uns n0 n","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n)","proofString":"rewrite is_uns_zero_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n) : vge (Sgn p n0) (I n).","conclusion":"vge (Sgn p n0) (I n)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n)","proofString":"constructor; auto.\nrewrite is_sgn_sign_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n) : is_sgn n0 n.","conclusion":"is_sgn n0 n","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n)","proofString":"rewrite is_sgn_sign_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n) : vge (Uns p n0) (IU n).","conclusion":"vge (Uns p n0) (IU n)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n)","proofString":"constructor; auto.\nrewrite is_uns_zero_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n) : is_uns n0 n.","conclusion":"is_uns n0 n","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 <= n0) (H0 : Int.zero_ext n0 n = n)","proofString":"rewrite is_uns_zero_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n) : vge (Sgn p n0) (IU n).","conclusion":"vge (Sgn p n0) (IU n)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n)","proofString":"constructor; auto.\nrewrite is_sgn_sign_ext; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n) : is_sgn n0 n.","conclusion":"is_sgn n0 n","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H : 0 < n0) (H0 : Int.sign_ext n0 n = n)","proofString":"rewrite is_sgn_sign_ext; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) : vmatch (Genv.symbol_address ge id ofs) (Ptr (Gl id ofs)).","conclusion":"vmatch (Genv.symbol_address ge id ofs) (Ptr (Gl id ofs))","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge)","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:F.\nconstructor.\nconstructor.\napply H; auto.\nconstructor."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) : vmatch\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Ptr (Gl id ofs)).","conclusion":"vmatch\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Ptr (Gl id ofs))","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge)","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:F.\nconstructor.\nconstructor.\napply H; auto.\nconstructor."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (F : Genv.find_symbol ge id = Some b) : vmatch (Vptr b ofs) (Ptr (Gl id ofs)).","conclusion":"vmatch (Vptr b ofs) (Ptr (Gl id ofs))","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (F : Genv.find_symbol ge id = Some b)","proofString":"constructor.\nconstructor.\napply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (F : Genv.find_symbol ge id = Some b) : pmatch b ofs (Gl id ofs).","conclusion":"pmatch b ofs (Gl id ofs)","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (F : Genv.find_symbol ge id = Some b)","proofString":"constructor.\napply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (F : Genv.find_symbol ge id = Some b) : bc b = BCglob id.","conclusion":"bc b = BCglob id","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (F : Genv.find_symbol ge id = Some b)","proofString":"apply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (F : Genv.find_symbol ge id = None) : vmatch Vundef (Ptr (Gl id ofs)).","conclusion":"vmatch Vundef (Ptr (Gl id ofs))","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (F : Genv.find_symbol ge id = None)","proofString":"constructor."},{"statement":"(ge : genv) (v : val) (id : ident) (ofs : ptrofs) (H : genv_match ge) (H0 : vmatch v (Ptr (Gl id ofs))) : Val.lessdef v (Genv.symbol_address ge id ofs).","conclusion":"Val.lessdef v (Genv.symbol_address ge id ofs)","hypotheses":"(ge : genv) (v : val) (id : ident) (ofs : ptrofs) (H : genv_match ge) (H0 : vmatch v (Ptr (Gl id ofs)))","proofString":"unfold Genv.symbol_address.\ninv H0.\ninv H3.\nreplace (Genv.find_symbol ge id) with (Some b).\nconstructor.\nsymmetry.\napply H; auto.\nconstructor."},{"statement":"(ge : genv) (v : val) (id : ident) (ofs : ptrofs) (H : genv_match ge) (H0 : vmatch v (Ptr (Gl id ofs))) : Val.lessdef v\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.lessdef v\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(ge : genv) (v : val) (id : ident) (ofs : ptrofs) (H : genv_match ge) (H0 : vmatch v (Ptr (Gl id ofs)))","proofString":"inv H0.\ninv H3.\nreplace (Genv.find_symbol ge id) with (Some b).\nconstructor.\nsymmetry.\napply H; auto.\nconstructor."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (ofs0 : ptrofs) (H3 : pmatch b ofs0 (Gl id ofs)) : Val.lessdef (Vptr b ofs0)\n  match Genv.find_symbol ge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","conclusion":"Val.lessdef (Vptr b ofs0)\n  match Genv.find_symbol ge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (ofs0 : ptrofs) (H3 : pmatch b ofs0 (Gl id ofs))","proofString":"inv H3.\nreplace (Genv.find_symbol ge id) with (Some b).\nconstructor.\nsymmetry.\napply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id) : Val.lessdef (Vptr b ofs)\n  match Genv.find_symbol ge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","conclusion":"Val.lessdef (Vptr b ofs)\n  match Genv.find_symbol ge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id)","proofString":"replace (Genv.find_symbol ge id) with (Some b).\nconstructor.\nsymmetry.\napply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id) : Val.lessdef (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.lessdef (Vptr b ofs) (Vptr b ofs)","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id)","proofString":"constructor."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id) : Some b = Genv.find_symbol ge id.","conclusion":"Some b = Genv.find_symbol ge id","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id)","proofString":"symmetry.\napply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id) : Genv.find_symbol ge id = Some b.","conclusion":"Genv.find_symbol ge id = Some b","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) (b : block) (H1 : bc b = BCglob id)","proofString":"apply H; auto."},{"statement":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge) : Val.lessdef Vundef\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.lessdef Vundef\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(ge : genv) (id : ident) (ofs : ptrofs) (H : genv_match ge)","proofString":"constructor."},{"statement":"(v : val) (ofs : ptrofs) (sp : block) (H : vmatch v (Ptr (Stk ofs))) (H0 : bc sp = BCstack) : Val.lessdef v (Vptr sp ofs).","conclusion":"Val.lessdef v (Vptr sp ofs)","hypotheses":"(v : val) (ofs : ptrofs) (sp : block) (H : vmatch v (Ptr (Stk ofs))) (H0 : bc sp = BCstack)","proofString":"inv H.\ninv H3.\nreplace b with sp by (eapply bc_stack; eauto).\nconstructor.\nconstructor."},{"statement":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) (b : block) (ofs0 : ptrofs) (H3 : pmatch b ofs0 (Stk ofs)) : Val.lessdef (Vptr b ofs0) (Vptr sp ofs).","conclusion":"Val.lessdef (Vptr b ofs0) (Vptr sp ofs)","hypotheses":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) (b : block) (ofs0 : ptrofs) (H3 : pmatch b ofs0 (Stk ofs))","proofString":"inv H3.\nreplace b with sp by (eapply bc_stack; eauto).\nconstructor."},{"statement":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) (b : block) (H1 : bc b = BCstack) : Val.lessdef (Vptr b ofs) (Vptr sp ofs).","conclusion":"Val.lessdef (Vptr b ofs) (Vptr sp ofs)","hypotheses":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) (b : block) (H1 : bc b = BCstack)","proofString":"replace b with sp by (eapply bc_stack; eauto).\nconstructor."},{"statement":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) (b : block) (H1 : bc b = BCstack) : Val.lessdef (Vptr sp ofs) (Vptr sp ofs).","conclusion":"Val.lessdef (Vptr sp ofs) (Vptr sp ofs)","hypotheses":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) (b : block) (H1 : bc b = BCstack)","proofString":"constructor."},{"statement":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack) : Val.lessdef Vundef (Vptr sp ofs).","conclusion":"Val.lessdef Vundef (Vptr sp ofs)","hypotheses":"(ofs : ptrofs) (sp : block) (H0 : bc sp = BCstack)","proofString":"constructor."},{"statement":"(sem : int -> int) (v : val) (x : aval) (H : vmatch v x) : vmatch match v with\n       | Vint i => Vint (sem i)\n       | _ => Vundef\n       end (unop_int sem x).","conclusion":"vmatch match v with\n       | Vint i => Vint (sem i)\n       | _ => Vundef\n       end (unop_int sem x)","hypotheses":"(sem : int -> int) (v : val) (x : aval) (H : vmatch v x)","proofString":"unfold unop_int; inv H; auto with va."},{"statement":"(sem : int -> int -> int) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint i => match w with\n              | Vint j => Vint (sem i j)\n              | _ => Vundef\n              end\n  | _ => Vundef\n  end (binop_int sem x y).","conclusion":"vmatch\n  match v with\n  | Vint i => match w with\n              | Vint j => Vint (sem i j)\n              | _ => Vundef\n              end\n  | _ => Vundef\n  end (binop_int sem x y)","hypotheses":"(sem : int -> int -> int) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold binop_int; inv H; auto with va; inv H0; auto with va."},{"statement":"(sem : int64 -> int64) (v : val) (x : aval) (H : vmatch v x) : vmatch match v with\n       | Vlong i => Vlong (sem i)\n       | _ => Vundef\n       end (unop_long sem x).","conclusion":"vmatch match v with\n       | Vlong i => Vlong (sem i)\n       | _ => Vundef\n       end (unop_long sem x)","hypotheses":"(sem : int64 -> int64) (v : val) (x : aval) (H : vmatch v x)","proofString":"unfold unop_long; inv H; auto with va."},{"statement":"(sem : int64 -> int64 -> int64) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong i => match w with\n               | Vlong j => Vlong (sem i j)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end (binop_long sem x y).","conclusion":"vmatch\n  match v with\n  | Vlong i => match w with\n               | Vlong j => Vlong (sem i j)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end (binop_long sem x y)","hypotheses":"(sem : int64 -> int64 -> int64) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold binop_long; inv H; auto with va; inv H0; auto with va."},{"statement":"(sem : float -> float) (v : val) (x : aval) (H : vmatch v x) : vmatch match v with\n       | Vfloat i => Vfloat (sem i)\n       | _ => Vundef\n       end (unop_float sem x).","conclusion":"vmatch match v with\n       | Vfloat i => Vfloat (sem i)\n       | _ => Vundef\n       end (unop_float sem x)","hypotheses":"(sem : float -> float) (v : val) (x : aval) (H : vmatch v x)","proofString":"unfold unop_float; inv H; auto with va."},{"statement":"(sem : float -> float -> float) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vfloat i => match w with\n                | Vfloat j => Vfloat (sem i j)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end (binop_float sem x y).","conclusion":"vmatch\n  match v with\n  | Vfloat i => match w with\n                | Vfloat j => Vfloat (sem i j)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end (binop_float sem x y)","hypotheses":"(sem : float -> float -> float) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold binop_float; inv H; auto with va; inv H0; auto with va."},{"statement":"(sem : float32 -> float32) (v : val) (x : aval) (H : vmatch v x) : vmatch match v with\n       | Vsingle i => Vsingle (sem i)\n       | _ => Vundef\n       end (unop_single sem x).","conclusion":"vmatch match v with\n       | Vsingle i => Vsingle (sem i)\n       | _ => Vundef\n       end (unop_single sem x)","hypotheses":"(sem : float32 -> float32) (v : val) (x : aval) (H : vmatch v x)","proofString":"unfold unop_single; inv H; auto with va."},{"statement":"(sem : float32 -> float32 -> float32) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vsingle i =>\n      match w with\n      | Vsingle j => Vsingle (sem i j)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (binop_single sem x y).","conclusion":"vmatch\n  match v with\n  | Vsingle i =>\n      match w with\n      | Vsingle j => Vsingle (sem i j)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (binop_single sem x y)","hypotheses":"(sem : float32 -> float32 -> float32) (v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold binop_single; inv H; auto with va; inv H0; auto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.shl v w) (shl x y).","conclusion":"vmatch (Val.shl v w) (shl x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT: vmatch (Val.shl v w) (ntop1 x)).\ndestruct v; destruct w; simpl; try constructor.\ndestruct (Int.ltu i0 Int.iwordsize); constructor.\ndestruct y; auto.\nsimpl.\ninv H0.\nunfold Val.shl.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct v; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.shl v w) (ntop1 x).","conclusion":"vmatch (Val.shl v w) (ntop1 x)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; destruct w; simpl; try constructor.\ndestruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) : vmatch (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (ntop1 x).","conclusion":"vmatch (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (ntop1 x)","hypotheses":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y)","proofString":"destruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch (Val.shl v w) (ntop1 x)) : vmatch (Val.shl v w) (shl x y).","conclusion":"vmatch (Val.shl v w) (shl x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch (Val.shl v w) (ntop1 x))","proofString":"destruct y; auto.\nsimpl.\ninv H0.\nunfold Val.shl.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct v; constructor."},{"statement":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shl v w) (ntop1 x)) : vmatch (Val.shl v w) (shl x (I n)).","conclusion":"vmatch (Val.shl v w) (shl x (I n))","hypotheses":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shl v w) (ntop1 x))","proofString":"simpl.\ninv H0.\nunfold Val.shl.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct v; constructor."},{"statement":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shl v w) (ntop1 x)) : vmatch (Val.shl v w)\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shl i n)\n    | IU i => IU (Int.shl i n)\n    | Uns p n0 => uns p (n0 + Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n    | _ => ntop1 x\n    end\n   else ntop1 x).","conclusion":"vmatch (Val.shl v w)\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shl i n)\n    | IU i => IU (Int.shl i n)\n    | Uns p n0 => uns p (n0 + Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n    | _ => ntop1 x\n    end\n   else ntop1 x)","hypotheses":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shl v w) (ntop1 x))","proofString":"inv H0.\nunfold Val.shl.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) : vmatch (Val.shl v (Vint n))\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shl i n)\n    | IU i => IU (Int.shl i n)\n    | Uns p n0 => uns p (n0 + Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n    | _ => ntop1 x\n    end\n   else ntop1 x).","conclusion":"vmatch (Val.shl v (Vint n))\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shl i n)\n    | IU i => IU (Int.shl i n)\n    | Uns p n0 => uns p (n0 + Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n    | _ => ntop1 x\n    end\n   else ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x))","proofString":"unfold Val.shl.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) : vmatch\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shl i n)\n    | IU i => IU (Int.shl i n)\n    | Uns p n0 => uns p (n0 + Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n    | _ => ntop1 x\n    end\n   else ntop1 x).","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shl i n)\n    | IU i => IU (Int.shl i n)\n    | Uns p n0 => uns p (n0 + Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n    | _ => ntop1 x\n    end\n   else ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x))","proofString":"destruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) : vmatch match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shl i n)\n  | IU i => IU (Int.shl i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n  | _ => ntop1 x\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shl i n)\n  | IU i => IU (Int.shl i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true)","proofString":"exploit Int.ltu_inv; eauto.\nintros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize ->\nvmatch match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shl i n)\n  | IU i => IU (Int.shl i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n  | _ => ntop1 x\n  end.","conclusion":"0 <= Int.unsigned n < Int.unsigned Int.iwordsize ->\nvmatch match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shl i n)\n  | IU i => IU (Int.shl i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true)","proofString":"intros RANGE.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) : vmatch match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shl i n)\n  | IU i => IU (Int.shl i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n  | _ => ntop1 x\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shl i n)\n  | IU i => IU (Int.shl i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 + Int.unsigned n)\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize)","proofString":"inv H; auto with va.\napply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) : vmatch (Vint (Int.shl i n)) (uns p (n0 + Int.unsigned n)).","conclusion":"vmatch (Vint (Int.shl i n)) (uns p (n0 + Int.unsigned n))","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i)","proofString":"apply vmatch_uns'.\nred; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) : is_uns (Z.max 0 (n0 + Int.unsigned n)) (Int.shl i n).","conclusion":"is_uns (Z.max 0 (n0 + Int.unsigned n)) (Int.shl i n)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i)","proofString":"red; intros.\nrewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n)) : Int.testbit (Int.shl i n) m = false.","conclusion":"Int.testbit (Int.shl i n) m = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n))","proofString":"rewrite Int.bits_shl by lia.\ndestruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n)) : (if zlt m (Int.unsigned n) then false else Int.testbit i (m - Int.unsigned n)) =\nfalse.","conclusion":"(if zlt m (Int.unsigned n) then false else Int.testbit i (m - Int.unsigned n)) =\nfalse","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n))","proofString":"destruct (zlt m (Int.unsigned n)).\nauto.\napply H1; extlia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n)) (l : m < Int.unsigned n) : false = false.","conclusion":"false = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n)) (l : m < Int.unsigned n)","proofString":"auto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n)) (g : m >= Int.unsigned n) : Int.testbit i (m - Int.unsigned n) = false.","conclusion":"Int.testbit i (m - Int.unsigned n) = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 + Int.unsigned n)) (g : m >= Int.unsigned n)","proofString":"apply H1; extlia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) : vmatch (Vint (Int.shl i n)) (sgn p (n0 + Int.unsigned n)).","conclusion":"vmatch (Vint (Int.shl i n)) (sgn p (n0 + Int.unsigned n))","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i)","proofString":"apply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) : is_sgn (Z.max 1 (n0 + Int.unsigned n)) (Int.shl i n).","conclusion":"is_sgn (Z.max 1 (n0 + Int.unsigned n)) (Int.shl i n)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i)","proofString":"red; intros.\nzify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 1 (n0 + Int.unsigned n) - 1) : Int.testbit (Int.shl i n) m = Int.testbit (Int.shl i n) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shl i n) m = Int.testbit (Int.shl i n) (Int.zwordsize - 1)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 1 (n0 + Int.unsigned n) - 1)","proofString":"zify.\nrewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1) : Int.testbit (Int.shl i n) m = Int.testbit (Int.shl i n) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shl i n) m = Int.testbit (Int.shl i n) (Int.zwordsize - 1)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1)","proofString":"rewrite ! Int.bits_shl by lia.\nrewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1) : (if zlt m (Int.unsigned n) then false else Int.testbit i (m - Int.unsigned n)) =\n(if zlt (Int.zwordsize - 1) (Int.unsigned n)\n then false\n else Int.testbit i (Int.zwordsize - 1 - Int.unsigned n)).","conclusion":"(if zlt m (Int.unsigned n) then false else Int.testbit i (m - Int.unsigned n)) =\n(if zlt (Int.zwordsize - 1) (Int.unsigned n)\n then false\n else Int.testbit i (Int.zwordsize - 1 - Int.unsigned n))","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1)","proofString":"rewrite ! zlt_false by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1) : Int.testbit i (m - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n).","conclusion":"Int.testbit i (m - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1)","proofString":"rewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1) : Int.testbit i (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n).","conclusion":"Int.testbit i (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1)","proofString":"symmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1) : Int.testbit i (Int.zwordsize - 1 - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1 - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1)","proofString":"rewrite H1 by lia.\nauto."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1) : Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shl (Vint i) (Vint n)) (ntop1 (Sgn p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) (H0 : 0 < n0) (H1 : is_sgn n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3 - 1) (H3 : 1 < n0 + Int.unsigned n /\\ z3 = n0 + Int.unsigned n \\/\nn0 + Int.unsigned n <= 1 /\\ z3 = 1)","proofString":"auto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = false) : vmatch match v with\n       | Vundef | _ => Vundef\n       end (ntop1 x).","conclusion":"vmatch match v with\n       | Vundef | _ => Vundef\n       end (ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shl v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = false)","proofString":"destruct v; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.shru v w) (shru x y).","conclusion":"vmatch (Val.shru v w) (shru x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT: vmatch (Val.shru v w) (ntop1 x)).\ndestruct v; destruct w; simpl; try constructor.\ndestruct (Int.ltu i0 Int.iwordsize); constructor.\ndestruct y; auto.\ninv H0.\nunfold shru, Val.shru.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia.\ndestruct v; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.shru v w) (ntop1 x).","conclusion":"vmatch (Val.shru v w) (ntop1 x)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; destruct w; simpl; try constructor.\ndestruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) : vmatch (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (ntop1 x).","conclusion":"vmatch (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (ntop1 x)","hypotheses":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y)","proofString":"destruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch (Val.shru v w) (ntop1 x)) : vmatch (Val.shru v w) (shru x y).","conclusion":"vmatch (Val.shru v w) (shru x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch (Val.shru v w) (ntop1 x))","proofString":"destruct y; auto.\ninv H0.\nunfold shru, Val.shru.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia.\ndestruct v; constructor."},{"statement":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shru v w) (ntop1 x)) : vmatch (Val.shru v w) (shru x (I n)).","conclusion":"vmatch (Val.shru v w) (shru x (I n))","hypotheses":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shru v w) (ntop1 x))","proofString":"inv H0.\nunfold shru, Val.shru.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) : vmatch (Val.shru v (Vint n)) (shru x (I n)).","conclusion":"vmatch (Val.shru v (Vint n)) (shru x (I n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x))","proofString":"unfold shru, Val.shru.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) : vmatch\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shru i n)\n    | IU i => IU (Int.shru i n)\n    | Uns p n0 => uns p (n0 - Int.unsigned n)\n    | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n    end\n   else ntop1 x).","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shru i n)\n    | IU i => IU (Int.shru i n)\n    | Uns p n0 => uns p (n0 - Int.unsigned n)\n    | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n    end\n   else ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x))","proofString":"destruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) : vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true)","proofString":"exploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize ->\nvmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"0 <= Int.unsigned n < Int.unsigned Int.iwordsize ->\nvmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true)","proofString":"intros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) : vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize)","proofString":"change (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) : vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize)","proofString":"assert (DEFAULT2: forall i, vmatch (Vint (Int.shru i n)) (uns (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia.\ninv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) : forall i : int,\nvmatch (Vint (Int.shru i n))\n  (uns (provenance x) (Int.zwordsize - Int.unsigned n)).","conclusion":"forall i : int,\nvmatch (Vint (Int.shru i n))\n  (uns (provenance x) (Int.zwordsize - Int.unsigned n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize)","proofString":"intros.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) : vmatch (Vint (Int.shru i n))\n  (uns (provenance x) (Int.zwordsize - Int.unsigned n)).","conclusion":"vmatch (Vint (Int.shru i n))\n  (uns (provenance x) (Int.zwordsize - Int.unsigned n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int)","proofString":"apply vmatch_uns.\nred; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) : is_uns (Int.zwordsize - Int.unsigned n) (Int.shru i n).","conclusion":"is_uns (Int.zwordsize - Int.unsigned n) (Int.shru i n)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int)","proofString":"red; intros.\nrewrite Int.bits_shru by lia.\napply zlt_false.\nlia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n) : Int.testbit (Int.shru i n) m = false.","conclusion":"Int.testbit (Int.shru i n) m = false","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n)","proofString":"rewrite Int.bits_shru by lia.\napply zlt_false.\nlia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n) : (if zlt (m + Int.unsigned n) Int.zwordsize\n then Int.testbit i (m + Int.unsigned n)\n else false) = false.","conclusion":"(if zlt (m + Int.unsigned n) Int.zwordsize\n then Int.testbit i (m + Int.unsigned n)\n else false) = false","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n)","proofString":"apply zlt_false.\nlia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n) : m + Int.unsigned n >= Int.zwordsize.","conclusion":"m + Int.unsigned n >= Int.zwordsize","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n)","proofString":"lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shru i n))\n  (uns (provenance x) (Int.zwordsize - Int.unsigned n))) : vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shru i n)\n  | IU i => IU (Int.shru i n)\n  | Uns p n0 => uns p (n0 - Int.unsigned n)\n  | _ => uns (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shru i n))\n  (uns (provenance x) (Int.zwordsize - Int.unsigned n)))","proofString":"inv H; auto with va.\napply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) : vmatch (Vint (Int.shru i n)) (uns p (n0 - Int.unsigned n)).","conclusion":"vmatch (Vint (Int.shru i n)) (uns p (n0 - Int.unsigned n))","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i)","proofString":"apply vmatch_uns'.\nred; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) : is_uns (Z.max 0 (n0 - Int.unsigned n)) (Int.shru i n).","conclusion":"is_uns (Z.max 0 (n0 - Int.unsigned n)) (Int.shru i n)","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i)","proofString":"red; intros.\nzify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 - Int.unsigned n)) : Int.testbit (Int.shru i n) m = false.","conclusion":"Int.testbit (Int.shru i n) m = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.max 0 (n0 - Int.unsigned n))","proofString":"zify.\nrewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : 0 < n0 - Int.unsigned n /\\ z3 = n0 - Int.unsigned n \\/\nn0 - Int.unsigned n <= 0 /\\ z3 = 0) : Int.testbit (Int.shru i n) m = false.","conclusion":"Int.testbit (Int.shru i n) m = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : 0 < n0 - Int.unsigned n /\\ z3 = n0 - Int.unsigned n \\/\nn0 - Int.unsigned n <= 0 /\\ z3 = 0)","proofString":"rewrite Int.bits_shru by lia.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : 0 < n0 - Int.unsigned n /\\ z3 = n0 - Int.unsigned n \\/\nn0 - Int.unsigned n <= 0 /\\ z3 = 0) : (if zlt (m + Int.unsigned n) Int.zwordsize\n then Int.testbit i (m + Int.unsigned n)\n else false) = false.","conclusion":"(if zlt (m + Int.unsigned n) Int.zwordsize\n then Int.testbit i (m + Int.unsigned n)\n else false) = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : 0 < n0 - Int.unsigned n /\\ z3 = n0 - Int.unsigned n \\/\nn0 - Int.unsigned n <= 0 /\\ z3 = 0)","proofString":"destruct (zlt (m + Int.unsigned n) Int.zwordsize); auto.\napply H1; lia."},{"statement":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : 0 < n0 - Int.unsigned n /\\ z3 = n0 - Int.unsigned n \\/\nn0 - Int.unsigned n <= 0 /\\ z3 = 0) (l : m + Int.unsigned n < Int.zwordsize) : Int.testbit i (m + Int.unsigned n) = false.","conclusion":"Int.testbit i (m + Int.unsigned n) = false","hypotheses":"(n i : int) (p : aptr) (n0 : Z) (DEFAULT : vmatch (Val.shru (Vint i) (Vint n)) (ntop1 (Uns p n0))) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shru i0 n))\n  (uns (provenance (Uns p n0)) (Int.zwordsize - Int.unsigned n))) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : 0 < n0 - Int.unsigned n /\\ z3 = n0 - Int.unsigned n \\/\nn0 - Int.unsigned n <= 0 /\\ z3 = 0) (l : m + Int.unsigned n < Int.zwordsize)","proofString":"apply H1; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = false) : vmatch match v with\n       | Vundef | _ => Vundef\n       end (ntop1 x).","conclusion":"vmatch match v with\n       | Vundef | _ => Vundef\n       end (ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shru v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = false)","proofString":"destruct v; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.shr v w) (shr x y).","conclusion":"vmatch (Val.shr v w) (shr x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT: vmatch (Val.shr v w) (ntop1 x)).\ndestruct v; destruct w; simpl; try constructor.\ndestruct (Int.ltu i0 Int.iwordsize); constructor.\ndestruct y; auto.\ninv H0.\nunfold shr, Val.shr.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va.\ndestruct v; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.shr v w) (ntop1 x).","conclusion":"vmatch (Val.shr v w) (ntop1 x)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; destruct w; simpl; try constructor.\ndestruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) : vmatch (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (ntop1 x).","conclusion":"vmatch (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (ntop1 x)","hypotheses":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y)","proofString":"destruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch (Val.shr v w) (ntop1 x)) : vmatch (Val.shr v w) (shr x y).","conclusion":"vmatch (Val.shr v w) (shr x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch (Val.shr v w) (ntop1 x))","proofString":"destruct y; auto.\ninv H0.\nunfold shr, Val.shr.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va.\ndestruct v; constructor."},{"statement":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shr v w) (ntop1 x)) : vmatch (Val.shr v w) (shr x (I n)).","conclusion":"vmatch (Val.shr v w) (shr x (I n))","hypotheses":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch (Val.shr v w) (ntop1 x))","proofString":"inv H0.\nunfold shr, Val.shr.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) : vmatch (Val.shr v (Vint n)) (shr x (I n)).","conclusion":"vmatch (Val.shr v (Vint n)) (shr x (I n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x))","proofString":"unfold shr, Val.shr.\ndestruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) : vmatch\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shr i n)\n    | IU i => IU (Int.shr i n)\n    | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n    | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n    end\n   else ntop1 x).","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end\n  (if Int.ltu n Int.iwordsize\n   then\n    match x with\n    | I i => I (Int.shr i n)\n    | IU i => IU (Int.shr i n)\n    | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n    | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n    | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n    end\n   else ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x))","proofString":"destruct (Int.ltu n Int.iwordsize) eqn:LTU; auto.\nexploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va.\ndestruct v; constructor."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) : vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true)","proofString":"exploit Int.ltu_inv; eauto.\nintros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize ->\nvmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"0 <= Int.unsigned n < Int.unsigned Int.iwordsize ->\nvmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true)","proofString":"intros RANGE.\nchange (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize) : vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize)","proofString":"change (Int.unsigned Int.iwordsize) with Int.zwordsize in RANGE.\nassert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) : vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize)","proofString":"assert (DEFAULT2: forall i, vmatch (Vint (Int.shr i n)) (sgn (provenance x) (Int.zwordsize - Int.unsigned n))).\nintros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia.\nassert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n)).","conclusion":"forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize)","proofString":"intros.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) : vmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n)).","conclusion":"vmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int)","proofString":"apply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) : is_sgn (Int.zwordsize - Int.unsigned n) (Int.shr i n).","conclusion":"is_sgn (Int.zwordsize - Int.unsigned n) (Int.shr i n)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int)","proofString":"red; intros.\nrewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n - 1) : Int.testbit (Int.shr i n) m = Int.testbit (Int.shr i n) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shr i n) m = Int.testbit (Int.shr i n) (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n - 1)","proofString":"rewrite ! Int.bits_shr by lia.\nf_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n - 1) : Int.testbit i\n  (if zlt (m + Int.unsigned n) Int.zwordsize\n   then m + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1).","conclusion":"Int.testbit i\n  (if zlt (m + Int.unsigned n) Int.zwordsize\n   then m + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n - 1)","proofString":"f_equal.\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n - 1) : (if zlt (m + Int.unsigned n) Int.zwordsize\n then m + Int.unsigned n\n else Int.zwordsize - 1) =\n(if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n then Int.zwordsize - 1 + Int.unsigned n\n else Int.zwordsize - 1).","conclusion":"(if zlt (m + Int.unsigned n) Int.zwordsize\n then m + Int.unsigned n\n else Int.zwordsize - 1) =\n(if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n then Int.zwordsize - 1 + Int.unsigned n\n else Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (i : int) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= Int.zwordsize - Int.unsigned n - 1)","proofString":"destruct (zlt (m + Int.unsigned n) Int.zwordsize);    destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize);    lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) : vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n)))","proofString":"assert (SGN: forall q i p, is_sgn p i -> 0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))).\nintros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\ninv H; eauto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) : forall (q : aptr) (i : int) (p : Z),\nis_sgn p i ->\n0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n)).","conclusion":"forall (q : aptr) (i : int) (p : Z),\nis_sgn p i ->\n0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n)))","proofString":"intros.\napply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) : vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n)).","conclusion":"vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p)","proofString":"apply vmatch_sgn'.\nred; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) : is_sgn (Z.max 1 (p - Int.unsigned n)) (Int.shr i n).","conclusion":"is_sgn (Z.max 1 (p - Int.unsigned n)) (Int.shr i n)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p)","proofString":"red; intros.\nzify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (H3 : m >= Z.max 1 (p - Int.unsigned n) - 1) : Int.testbit (Int.shr i n) m = Int.testbit (Int.shr i n) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shr i n) m = Int.testbit (Int.shr i n) (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (H3 : m >= Z.max 1 (p - Int.unsigned n) - 1)","proofString":"zify.\nrewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) : Int.testbit (Int.shr i n) m = Int.testbit (Int.shr i n) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shr i n) m = Int.testbit (Int.shr i n) (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1)","proofString":"rewrite ! Int.bits_shr by lia.\ntransitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) : Int.testbit i\n  (if zlt (m + Int.unsigned n) Int.zwordsize\n   then m + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1).","conclusion":"Int.testbit i\n  (if zlt (m + Int.unsigned n) Int.zwordsize\n   then m + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1)","proofString":"transitivity (Int.testbit i (Int.zwordsize - 1)).\ndestruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto.\nsymmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) : Int.testbit i\n  (if zlt (m + Int.unsigned n) Int.zwordsize\n   then m + Int.unsigned n\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i\n  (if zlt (m + Int.unsigned n) Int.zwordsize\n   then m + Int.unsigned n\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1)","proofString":"destruct (zlt (m + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (l : m + Int.unsigned n < Int.zwordsize) : Int.testbit i (m + Int.unsigned n) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (m + Int.unsigned n) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (l : m + Int.unsigned n < Int.zwordsize)","proofString":"apply H0; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (g : m + Int.unsigned n >= Int.zwordsize) : Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (g : m + Int.unsigned n >= Int.zwordsize)","proofString":"auto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) : Int.testbit i (Int.zwordsize - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) =\nInt.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1)","proofString":"symmetry.\ndestruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) : Int.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i\n  (if zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize\n   then Int.zwordsize - 1 + Int.unsigned n\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1)","proofString":"destruct (zlt (Int.zwordsize - 1 + Int.unsigned n) Int.zwordsize).\napply H0; lia.\nauto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (l : Int.zwordsize - 1 + Int.unsigned n < Int.zwordsize) : Int.testbit i (Int.zwordsize - 1 + Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1 + Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (l : Int.zwordsize - 1 + Int.unsigned n < Int.zwordsize)","proofString":"apply H0; lia."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (g : Int.zwordsize - 1 + Int.unsigned n >= Int.zwordsize) : Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i0 : int,\nvmatch (Vint (Int.shr i0 n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (q : aptr) (i : int) (p : Z) (H0 : is_sgn p i) (H1 : 0 < p) (m : Z) (H2 : 0 <= m < Int.zwordsize) (z4 : Z) (H3 : m >= z4 - 1) (H4 : 1 < p - Int.unsigned n /\\ z4 = p - Int.unsigned n \\/\np - Int.unsigned n <= 1 /\\ z4 = 1) (g : Int.zwordsize - 1 + Int.unsigned n >= Int.zwordsize)","proofString":"auto."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (SGN : forall (q : aptr) (i : int) (p : Z),\nis_sgn p i ->\n0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n))) : vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.shr i n)\n  | IU i => IU (Int.shr i n)\n  | Uns p n0 => sgn p (n0 + 1 - Int.unsigned n)\n  | Sgn p n0 => sgn p (n0 - Int.unsigned n)\n  | _ => sgn (provenance x) (Int.zwordsize - Int.unsigned n)\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = true) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (DEFAULT2 : forall i : int,\nvmatch (Vint (Int.shr i n))\n  (sgn (provenance x) (Int.zwordsize - Int.unsigned n))) (SGN : forall (q : aptr) (i : int) (p : Z),\nis_sgn p i ->\n0 < p -> vmatch (Vint (Int.shr i n)) (sgn q (p - Int.unsigned n)))","proofString":"inv H; eauto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = false) : vmatch match v with\n       | Vundef | _ => Vundef\n       end (ntop1 x).","conclusion":"vmatch match v with\n       | Vundef | _ => Vundef\n       end (ntop1 x)","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : vmatch (Val.shr v (Vint n)) (ntop1 x)) (LTU : Int.ltu n Int.iwordsize = false)","proofString":"destruct v; constructor."},{"statement":"forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j).","conclusion":"forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)","hypotheses":"","proofString":"intros; red; intros.\nrewrite Int.bits_and by auto.\nrewrite (H m) by auto.\napply andb_false_l."},{"statement":"(i j : int) (n : Z) (H : is_uns n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n) : Int.testbit (Int.and i j) m = false.","conclusion":"Int.testbit (Int.and i j) m = false","hypotheses":"(i j : int) (n : Z) (H : is_uns n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n)","proofString":"rewrite Int.bits_and by auto.\nrewrite (H m) by auto.\napply andb_false_l."},{"statement":"(i j : int) (n : Z) (H : is_uns n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n) : Int.testbit i m && Int.testbit j m = false.","conclusion":"Int.testbit i m && Int.testbit j m = false","hypotheses":"(i j : int) (n : Z) (H : is_uns n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n)","proofString":"rewrite (H m) by auto.\napply andb_false_l."},{"statement":"(i j : int) (n : Z) (H : is_uns n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n) : false && Int.testbit j m = false.","conclusion":"false && Int.testbit j m = false","hypotheses":"(i j : int) (n : Z) (H : is_uns n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n)","proofString":"apply andb_false_l."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j))","proofString":"assert (UNS_r: forall i j n, is_uns n i -> is_uns n (Int.and j i)).\nintros.\nrewrite Int.and_commut.\neauto.\nassert (UNS: forall i j n m, is_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)).\nintros.\napply Z.min_case; auto.\nassert (SGN: forall i j n m, is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)).\nintros; red; intros.\nrewrite ! Int.bits_and by auto with va.\nrewrite H by auto with va.\nrewrite H0 by auto with va.\nauto.\nintros.\nunfold and, Val.and; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i).","conclusion":"forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j))","proofString":"intros.\nrewrite Int.and_commut.\neauto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (i j : int) (n : Z) (H : is_uns n i) : is_uns n (Int.and j i).","conclusion":"is_uns n (Int.and j i)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (i j : int) (n : Z) (H : is_uns n i)","proofString":"rewrite Int.and_commut.\neauto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (i j : int) (n : Z) (H : is_uns n i) : is_uns n (Int.and i j).","conclusion":"is_uns n (Int.and i j)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (i j : int) (n : Z) (H : is_uns n i)","proofString":"eauto."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i))","proofString":"assert (UNS: forall i j n m, is_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)).\nintros.\napply Z.min_case; auto.\nassert (SGN: forall i j n m, is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)).\nintros; red; intros.\nrewrite ! Int.bits_and by auto with va.\nrewrite H by auto with va.\nrewrite H0 by auto with va.\nauto.\nintros.\nunfold and, Val.and; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j).","conclusion":"forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i))","proofString":"intros.\napply Z.min_case; auto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) : is_uns (Z.min n m) (Int.and i j).","conclusion":"is_uns (Z.min n m) (Int.and i j)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j)","proofString":"apply Z.min_case; auto."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j))","proofString":"assert (SGN: forall i j n m, is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)).\nintros; red; intros.\nrewrite ! Int.bits_and by auto with va.\nrewrite H by auto with va.\nrewrite H0 by auto with va.\nauto.\nintros.\nunfold and, Val.and; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)) : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j).","conclusion":"forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j))","proofString":"intros; red; intros.\nrewrite ! Int.bits_and by auto with va.\nrewrite H by auto with va.\nrewrite H0 by auto with va.\nauto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit (Int.and i j) m0 = Int.testbit (Int.and i j) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.and i j) m0 = Int.testbit (Int.and i j) (Int.zwordsize - 1)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite ! Int.bits_and by auto with va.\nrewrite H by auto with va.\nrewrite H0 by auto with va.\nauto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit i m0 && Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1).","conclusion":"Int.testbit i m0 && Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite H by auto with va.\nrewrite H0 by auto with va.\nauto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit i (Int.zwordsize - 1) && Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) && Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite H0 by auto with va.\nauto."},{"statement":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1) && Int.testbit j (Int.zwordsize - 1)","hypotheses":"(UNS_l : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and i0 j0)) (UNS_r : forall (i0 j0 : int) (n0 : Z), is_uns n0 i0 -> is_uns n0 (Int.and j0 i0)) (UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.min n0 m1) (Int.and i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"auto."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j))","proofString":"intros.\nunfold and, Val.and; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.and v w) (and x y).","conclusion":"vmatch (Val.and v w) (and x y)","hypotheses":"(UNS_l : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and i j)) (UNS_r : forall (i j : int) (n : Z), is_uns n i -> is_uns n (Int.and j i)) (UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.min n m) (Int.and i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.and i j)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold and, Val.and; inv H; eauto with va; inv H0; eauto with va."},{"statement":"forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j).","conclusion":"forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)","hypotheses":"","proofString":"intros; red; intros.\nrewrite Int.bits_or by auto.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : Int.testbit (Int.or i j) m0 = false.","conclusion":"Int.testbit (Int.or i j) m0 = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"rewrite Int.bits_or by auto.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : Int.testbit i m0 || Int.testbit j m0 = false.","conclusion":"Int.testbit i m0 || Int.testbit j m0 = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"rewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : false || Int.testbit j m0 = false.","conclusion":"false || Int.testbit j m0 = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"rewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : false || false = false.","conclusion":"false || false = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"auto."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.or v w) (or x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.or v w) (or x y)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j))","proofString":"assert (SGN: forall i j n m, is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j)).\nintros; red; intros.\nrewrite ! Int.bits_or by extlia.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto.\nintros.\nunfold or, Val.or; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)) : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j).","conclusion":"forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j))","proofString":"intros; red; intros.\nrewrite ! Int.bits_or by extlia.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit (Int.or i j) m0 = Int.testbit (Int.or i j) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.or i j) m0 = Int.testbit (Int.or i j) (Int.zwordsize - 1)","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite ! Int.bits_or by extlia.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit i m0 || Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1).","conclusion":"Int.testbit i m0 || Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1)","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit i (Int.zwordsize - 1) || Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) || Int.testbit j m0 =\nInt.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1)","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1) || Int.testbit j (Int.zwordsize - 1)","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.or i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"auto."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.or v w) (or x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.or v w) (or x y)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j))","proofString":"intros.\nunfold or, Val.or; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.or v w) (or x y).","conclusion":"vmatch (Val.or v w) (or x y)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.or i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.or i j)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold or, Val.or; inv H; eauto with va; inv H0; eauto with va."},{"statement":"forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j).","conclusion":"forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)","hypotheses":"","proofString":"intros; red; intros.\nrewrite Int.bits_xor by auto.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : Int.testbit (Int.xor i j) m0 = false.","conclusion":"Int.testbit (Int.xor i j) m0 = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"rewrite Int.bits_xor by auto.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : xorb (Int.testbit i m0) (Int.testbit j m0) = false.","conclusion":"xorb (Int.testbit i m0) (Int.testbit j m0) = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"rewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : xorb false (Int.testbit j m0) = false.","conclusion":"xorb false (Int.testbit j m0) = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"rewrite H0 by extlia.\nauto."},{"statement":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m) : xorb false false = false.","conclusion":"xorb false false = false","hypotheses":"(i j : int) (n m : Z) (H : is_uns n i) (H0 : is_uns m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m)","proofString":"auto."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.xor v w) (xor x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.xor v w) (xor x y)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j))","proofString":"assert (SGN: forall i j n m, is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j)).\nintros; red; intros.\nrewrite ! Int.bits_xor by extlia.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto.\nintros.\nunfold xor, Val.xor; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)) : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j).","conclusion":"forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j))","proofString":"intros; red; intros.\nrewrite ! Int.bits_xor by extlia.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : Int.testbit (Int.xor i j) m0 = Int.testbit (Int.xor i j) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.xor i j) m0 = Int.testbit (Int.xor i j) (Int.zwordsize - 1)","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite ! Int.bits_xor by extlia.\nrewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : xorb (Int.testbit i m0) (Int.testbit j m0) =\nxorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1)).","conclusion":"xorb (Int.testbit i m0) (Int.testbit j m0) =\nxorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1))","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite H by extlia.\nrewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : xorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j m0) =\nxorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1)).","conclusion":"xorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j m0) =\nxorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1))","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"rewrite H0 by extlia.\nauto."},{"statement":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1) : xorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1)) =\nxorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1)).","conclusion":"xorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1)) =\nxorb (Int.testbit i (Int.zwordsize - 1)) (Int.testbit j (Int.zwordsize - 1))","hypotheses":"(UNS : forall (i0 j0 : int) (n0 m1 : Z),\nis_uns n0 i0 -> is_uns m1 j0 -> is_uns (Z.max n0 m1) (Int.xor i0 j0)) (i j : int) (n m : Z) (H : is_sgn n i) (H0 : is_sgn m j) (m0 : Z) (H1 : 0 <= m0 < Int.zwordsize) (H2 : m0 >= Z.max n m - 1)","proofString":"auto."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.xor v w) (xor x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.xor v w) (xor x y)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j))","proofString":"intros.\nunfold xor, Val.xor; inv H; eauto with va; inv H0; eauto with va."},{"statement":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.xor v w) (xor x y).","conclusion":"vmatch (Val.xor v w) (xor x y)","hypotheses":"(UNS : forall (i j : int) (n m : Z),\nis_uns n i -> is_uns m j -> is_uns (Z.max n m) (Int.xor i j)) (SGN : forall (i j : int) (n m : Z),\nis_sgn n i -> is_sgn m j -> is_sgn (Z.max n m) (Int.xor i j)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold xor, Val.xor; inv H; eauto with va; inv H0; eauto with va."},{"statement":"forall (n : Z) (i : int), is_sgn n i -> is_sgn n (Int.not i).","conclusion":"forall (n : Z) (i : int), is_sgn n i -> is_sgn n (Int.not i)","hypotheses":"","proofString":"intros; red; intros.\nrewrite ! Int.bits_not by lia.\nf_equal.\napply H; auto."},{"statement":"(n : Z) (i : int) (H : is_sgn n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n - 1) : Int.testbit (Int.not i) m = Int.testbit (Int.not i) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.not i) m = Int.testbit (Int.not i) (Int.zwordsize - 1)","hypotheses":"(n : Z) (i : int) (H : is_sgn n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n - 1)","proofString":"rewrite ! Int.bits_not by lia.\nf_equal.\napply H; auto."},{"statement":"(n : Z) (i : int) (H : is_sgn n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n - 1) : negb (Int.testbit i m) = negb (Int.testbit i (Int.zwordsize - 1)).","conclusion":"negb (Int.testbit i m) = negb (Int.testbit i (Int.zwordsize - 1))","hypotheses":"(n : Z) (i : int) (H : is_sgn n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n - 1)","proofString":"f_equal.\napply H; auto."},{"statement":"(n : Z) (i : int) (H : is_sgn n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n - 1) : Int.testbit i m = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i m = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(n : Z) (i : int) (H : is_sgn n i) (m : Z) (H0 : 0 <= m < Int.zwordsize) (H1 : m >= n - 1)","proofString":"apply H; auto."},{"statement":"(SGN : forall (n : Z) (i : int), is_sgn n i -> is_sgn n (Int.not i)) : forall (v : val) (x : aval), vmatch v x -> vmatch (Val.notint v) (notint x).","conclusion":"forall (v : val) (x : aval), vmatch v x -> vmatch (Val.notint v) (notint x)","hypotheses":"(SGN : forall (n : Z) (i : int), is_sgn n i -> is_sgn n (Int.not i))","proofString":"intros.\nunfold Val.notint, notint; inv H; eauto with va."},{"statement":"(SGN : forall (n : Z) (i : int), is_sgn n i -> is_sgn n (Int.not i)) (v : val) (x : aval) (H : vmatch v x) : vmatch (Val.notint v) (notint x).","conclusion":"vmatch (Val.notint v) (notint x)","hypotheses":"(SGN : forall (n : Z) (i : int), is_sgn n i -> is_sgn n (Int.not i)) (v : val) (x : aval) (H : vmatch v x)","proofString":"unfold Val.notint, notint; inv H; eauto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.rol v w) (rol x y).","conclusion":"vmatch (Val.rol v w) (rol x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT: forall p, vmatch (Val.rol v w) (Num p)).\ndestruct v; destruct w; simpl; constructor.\nunfold rol; destruct y; try apply DEFAULT; auto.\ninv H0.\nunfold Val.rol.\ninv H; auto with va.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia.\ndestruct (zlt n0 Int.zwordsize); auto with va.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct (zlt n0 Int.zwordsize); auto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : forall p : aptr, vmatch (Val.rol v w) (Num p).","conclusion":"forall p : aptr, vmatch (Val.rol v w) (Num p)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; destruct w; simpl; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : forall p : aptr, vmatch (Val.rol v w) (Num p)) : vmatch (Val.rol v w) (rol x y).","conclusion":"vmatch (Val.rol v w) (rol x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : forall p : aptr, vmatch (Val.rol v w) (Num p))","proofString":"unfold rol; destruct y; try apply DEFAULT; auto.\ninv H0.\nunfold Val.rol.\ninv H; auto with va.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia.\ndestruct (zlt n0 Int.zwordsize); auto with va.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct (zlt n0 Int.zwordsize); auto with va."},{"statement":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : forall p : aptr, vmatch (Val.rol v w) (Num p)) : vmatch (Val.rol v w)\n  match x with\n  | I i => I (Int.rol i n)\n  | IU i => IU (Int.rol i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 =>\n      if zlt n0 Int.zwordsize then sgn p (n0 + Int.unsigned n) else ntop1 x\n  | _ => ntop1 x\n  end.","conclusion":"vmatch (Val.rol v w)\n  match x with\n  | I i => I (Int.rol i n)\n  | IU i => IU (Int.rol i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 =>\n      if zlt n0 Int.zwordsize then sgn p (n0 + Int.unsigned n) else ntop1 x\n  | _ => ntop1 x\n  end","hypotheses":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : forall p : aptr, vmatch (Val.rol v w) (Num p))","proofString":"inv H0.\nunfold Val.rol.\ninv H; auto with va.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia.\ndestruct (zlt n0 Int.zwordsize); auto with va.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct (zlt n0 Int.zwordsize); auto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.rol v (Vint n)) (Num p)) : vmatch (Val.rol v (Vint n))\n  match x with\n  | I i => I (Int.rol i n)\n  | IU i => IU (Int.rol i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 =>\n      if zlt n0 Int.zwordsize then sgn p (n0 + Int.unsigned n) else ntop1 x\n  | _ => ntop1 x\n  end.","conclusion":"vmatch (Val.rol v (Vint n))\n  match x with\n  | I i => I (Int.rol i n)\n  | IU i => IU (Int.rol i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 =>\n      if zlt n0 Int.zwordsize then sgn p (n0 + Int.unsigned n) else ntop1 x\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.rol v (Vint n)) (Num p))","proofString":"unfold Val.rol.\ninv H; auto with va.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia.\ndestruct (zlt n0 Int.zwordsize); auto with va.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct (zlt n0 Int.zwordsize); auto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.rol v (Vint n)) (Num p)) : vmatch match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.rol i n)\n  | IU i => IU (Int.rol i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 =>\n      if zlt n0 Int.zwordsize then sgn p (n0 + Int.unsigned n) else ntop1 x\n  | _ => ntop1 x\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.rol i n)\n  | IU i => IU (Int.rol i n)\n  | Uns p n0 => uns p (n0 + Int.unsigned n)\n  | Sgn p n0 =>\n      if zlt n0 Int.zwordsize then sgn p (n0 + Int.unsigned n) else ntop1 x\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.rol v (Vint n)) (Num p))","proofString":"inv H; auto with va.\napply vmatch_uns.\nred; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia.\ndestruct (zlt n0 Int.zwordsize); auto with va.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto.\ndestruct (zlt n0 Int.zwordsize); auto with va."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) : vmatch (Vint (Int.rol i n)) (uns p (n0 + Int.unsigned n)).","conclusion":"vmatch (Vint (Int.rol i n)) (uns p (n0 + Int.unsigned n))","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i)","proofString":"apply vmatch_uns.\nred; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) : is_uns (n0 + Int.unsigned n) (Int.rol i n).","conclusion":"is_uns (n0 + Int.unsigned n) (Int.rol i n)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i)","proofString":"red; intros.\nrewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) : Int.testbit (Int.rol i n) m = false.","conclusion":"Int.testbit (Int.rol i n) m = false","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n)","proofString":"rewrite Int.bits_rol by auto.\ngeneralize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) : Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) = false.","conclusion":"Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) = false","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n)","proofString":"generalize (Int.unsigned_range n); intros.\nrewrite Z.mod_small by lia.\napply H1.\nlia.\nlia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) = false.","conclusion":"Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) = false","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"rewrite Z.mod_small by lia.\napply H1.\nlia.\nlia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i (m - Int.unsigned n) = false.","conclusion":"Int.testbit i (m - Int.unsigned n) = false","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"apply H1.\nlia.\nlia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus) : 0 <= m - Int.unsigned n < Int.zwordsize.","conclusion":"0 <= m - Int.unsigned n < Int.zwordsize","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"lia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus) : m - Int.unsigned n >= n0.","conclusion":"m - Int.unsigned n >= n0","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 <= n0) (H1 : is_uns n0 i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"lia."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) : vmatch (Vint (Int.rol i n))\n  (if zlt n0 Int.zwordsize\n   then sgn p (n0 + Int.unsigned n)\n   else ntop1 (Sgn p n0)).","conclusion":"vmatch (Vint (Int.rol i n))\n  (if zlt n0 Int.zwordsize\n   then sgn p (n0 + Int.unsigned n)\n   else ntop1 (Sgn p n0))","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i)","proofString":"destruct (zlt n0 Int.zwordsize); auto with va.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) : vmatch (Vint (Int.rol i n)) (sgn p (n0 + Int.unsigned n)).","conclusion":"vmatch (Vint (Int.rol i n)) (sgn p (n0 + Int.unsigned n))","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize)","proofString":"apply vmatch_sgn.\nred; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) : is_sgn (n0 + Int.unsigned n) (Int.rol i n).","conclusion":"is_sgn (n0 + Int.unsigned n) (Int.rol i n)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize)","proofString":"red; intros.\nrewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) : Int.testbit (Int.rol i n) m = Int.testbit (Int.rol i n) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.rol i n) m = Int.testbit (Int.rol i n) (Int.zwordsize - 1)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1)","proofString":"rewrite ! Int.bits_rol by lia.\ngeneralize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) : Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) =\nInt.testbit i ((Int.zwordsize - 1 - Int.unsigned n) mod Int.zwordsize).","conclusion":"Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) =\nInt.testbit i ((Int.zwordsize - 1 - Int.unsigned n) mod Int.zwordsize)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1)","proofString":"generalize (Int.unsigned_range n); intros.\nrewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) =\nInt.testbit i ((Int.zwordsize - 1 - Int.unsigned n) mod Int.zwordsize).","conclusion":"Int.testbit i ((m - Int.unsigned n) mod Int.zwordsize) =\nInt.testbit i ((Int.zwordsize - 1 - Int.unsigned n) mod Int.zwordsize)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"rewrite ! Z.mod_small by lia.\nrewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i (m - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n).","conclusion":"Int.testbit i (m - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"rewrite H1 by lia.\nsymmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n).","conclusion":"Int.testbit i (Int.zwordsize - 1) =\nInt.testbit i (Int.zwordsize - 1 - Int.unsigned n)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"symmetry.\nrewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i (Int.zwordsize - 1 - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1 - Int.unsigned n) =\nInt.testbit i (Int.zwordsize - 1)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"rewrite H1 by lia.\nauto."},{"statement":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i (Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(n i : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol (Vint i) (Vint n)) (Num p0)) (p : aptr) (n0 : Z) (H0 : 0 < n0) (H1 : is_sgn n0 i) (l : n0 < Int.zwordsize) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= n0 + Int.unsigned n - 1) (H3 : 0 <= Int.unsigned n < Int.modulus)","proofString":"auto."},{"statement":"(n : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol Vundef (Vint n)) (Num p0)) (p : aptr) (n0 : Z) : vmatch Vundef\n  (if zlt n0 Int.zwordsize\n   then sgn p (n0 + Int.unsigned n)\n   else ntop1 (Sgn p n0)).","conclusion":"vmatch Vundef\n  (if zlt n0 Int.zwordsize\n   then sgn p (n0 + Int.unsigned n)\n   else ntop1 (Sgn p n0))","hypotheses":"(n : int) (DEFAULT : forall p0 : aptr, vmatch (Val.rol Vundef (Vint n)) (Num p0)) (p : aptr) (n0 : Z)","proofString":"destruct (zlt n0 Int.zwordsize); auto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.ror v w) (ror x y).","conclusion":"vmatch (Val.ror v w) (ror x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT: forall p, vmatch (Val.ror v w) (Num p)).\ndestruct v; destruct w; simpl; constructor.\nunfold ror; destruct y; try apply DEFAULT; auto.\ninv H0.\nunfold Val.ror.\ninv H; auto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : forall p : aptr, vmatch (Val.ror v w) (Num p).","conclusion":"forall p : aptr, vmatch (Val.ror v w) (Num p)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; destruct w; simpl; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : forall p : aptr, vmatch (Val.ror v w) (Num p)) : vmatch (Val.ror v w) (ror x y).","conclusion":"vmatch (Val.ror v w) (ror x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : forall p : aptr, vmatch (Val.ror v w) (Num p))","proofString":"unfold ror; destruct y; try apply DEFAULT; auto.\ninv H0.\nunfold Val.ror.\ninv H; auto with va."},{"statement":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : forall p : aptr, vmatch (Val.ror v w) (Num p)) : vmatch (Val.ror v w)\n  match x with\n  | I i => I (Int.ror i n)\n  | IU i => IU (Int.ror i n)\n  | _ => ntop1 x\n  end.","conclusion":"vmatch (Val.ror v w)\n  match x with\n  | I i => I (Int.ror i n)\n  | IU i => IU (Int.ror i n)\n  | _ => ntop1 x\n  end","hypotheses":"(v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : forall p : aptr, vmatch (Val.ror v w) (Num p))","proofString":"inv H0.\nunfold Val.ror.\ninv H; auto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.ror v (Vint n)) (Num p)) : vmatch (Val.ror v (Vint n))\n  match x with\n  | I i => I (Int.ror i n)\n  | IU i => IU (Int.ror i n)\n  | _ => ntop1 x\n  end.","conclusion":"vmatch (Val.ror v (Vint n))\n  match x with\n  | I i => I (Int.ror i n)\n  | IU i => IU (Int.ror i n)\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.ror v (Vint n)) (Num p))","proofString":"unfold Val.ror.\ninv H; auto with va."},{"statement":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.ror v (Vint n)) (Num p)) : vmatch match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.ror i n)\n  | IU i => IU (Int.ror i n)\n  | _ => ntop1 x\n  end.","conclusion":"vmatch match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match x with\n  | I i => I (Int.ror i n)\n  | IU i => IU (Int.ror i n)\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : int) (H : vmatch v x) (DEFAULT : forall p : aptr, vmatch (Val.ror v (Vint n)) (Num p))","proofString":"inv H; auto with va."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : vmatch (Val.rolm v amount mask) (rolm x amount mask).","conclusion":"vmatch (Val.rolm v amount mask) (rolm x amount mask)","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"replace (Val.rolm v amount mask) with (Val.and (Val.rol v (Vint amount)) (Vint mask)).\napply and_sound.\napply rol_sound.\nauto.\nconstructor.\nconstructor.\ndestruct v; auto."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : vmatch (Val.and (Val.rol v (Vint amount)) (Vint mask)) (rolm x amount mask).","conclusion":"vmatch (Val.and (Val.rol v (Vint amount)) (Vint mask)) (rolm x amount mask)","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"apply and_sound.\napply rol_sound.\nauto.\nconstructor.\nconstructor."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : vmatch (Val.rol v (Vint amount)) (rol x (I amount)).","conclusion":"vmatch (Val.rol v (Vint amount)) (rol x (I amount))","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"apply rol_sound.\nauto.\nconstructor."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : vmatch v x.","conclusion":"vmatch v x","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"auto."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : vmatch (Vint amount) (I amount).","conclusion":"vmatch (Vint amount) (I amount)","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"constructor."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : vmatch (Vint mask) (I mask).","conclusion":"vmatch (Vint mask) (I mask)","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"constructor."},{"statement":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x) : Val.and (Val.rol v (Vint amount)) (Vint mask) = Val.rolm v amount mask.","conclusion":"Val.and (Val.rol v (Vint amount)) (Vint mask) = Val.rolm v amount mask","hypotheses":"(v : val) (x : aval) (amount mask : int) (H : vmatch v x)","proofString":"destruct v; auto."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : vmatch (Vint (Int.neg i)) (sgn p (n + 1)).","conclusion":"vmatch (Vint (Int.neg i)) (sgn p (n + 1))","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"assert (A: Int.neg i = Int.repr (- Int.signed i)).\nintros.\napply Int.eqm_samerepr.\napply eqmod_neg.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned.\nrewrite A.\nexploit range_is_sgn; eauto.\nintros B.\napply vmatch_sgn.\napply is_sgn_range.\nlia.\nassert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : Int.neg i = Int.repr (- Int.signed i).","conclusion":"Int.neg i = Int.repr (- Int.signed i)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"intros.\napply Int.eqm_samerepr.\napply eqmod_neg.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : Int.neg i = Int.repr (- Int.signed i).","conclusion":"Int.neg i = Int.repr (- Int.signed i)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply Int.eqm_samerepr.\napply eqmod_neg.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : Int.eqm (- Int.unsigned i) (- Int.signed i).","conclusion":"Int.eqm (- Int.unsigned i) (- Int.signed i)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply eqmod_neg.\napply Int.eqm_sym.\napply Int.eqm_signed_unsigned."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : eqmod Int.modulus (Int.unsigned i) (Int.signed i).","conclusion":"eqmod Int.modulus (Int.unsigned i) (Int.signed i)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply Int.eqm_sym.\napply Int.eqm_signed_unsigned."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : Int.eqm (Int.signed i) (Int.unsigned i).","conclusion":"Int.eqm (Int.signed i) (Int.unsigned i)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply Int.eqm_signed_unsigned."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) : vmatch (Vint (Int.neg i)) (sgn p (n + 1)).","conclusion":"vmatch (Vint (Int.neg i)) (sgn p (n + 1))","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i))","proofString":"rewrite A.\nexploit range_is_sgn; eauto.\nintros B.\napply vmatch_sgn.\napply is_sgn_range.\nlia.\nassert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) : vmatch (Vint (Int.repr (- Int.signed i))) (sgn p (n + 1)).","conclusion":"vmatch (Vint (Int.repr (- Int.signed i))) (sgn p (n + 1))","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i))","proofString":"exploit range_is_sgn; eauto.\nintros B.\napply vmatch_sgn.\napply is_sgn_range.\nlia.\nassert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) : - two_p (n - 1) <= Int.signed i < two_p (n - 1) ->\nvmatch (Vint (Int.repr (- Int.signed i))) (sgn p (n + 1)).","conclusion":"- two_p (n - 1) <= Int.signed i < two_p (n - 1) ->\nvmatch (Vint (Int.repr (- Int.signed i))) (sgn p (n + 1))","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i))","proofString":"intros B.\napply vmatch_sgn.\napply is_sgn_range.\nlia.\nassert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) : vmatch (Vint (Int.repr (- Int.signed i))) (sgn p (n + 1)).","conclusion":"vmatch (Vint (Int.repr (- Int.signed i))) (sgn p (n + 1))","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1))","proofString":"apply vmatch_sgn.\napply is_sgn_range.\nlia.\nassert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) : is_sgn (n + 1) (Int.repr (- Int.signed i)).","conclusion":"is_sgn (n + 1) (Int.repr (- Int.signed i))","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1))","proofString":"apply is_sgn_range.\nlia.\nassert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) : 0 < n + 1.","conclusion":"0 < n + 1","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1))","proofString":"lia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) : - two_p (n + 1 - 1) <= - Int.signed i < two_p (n + 1 - 1).","conclusion":"- two_p (n + 1 - 1) <= - Int.signed i < two_p (n + 1 - 1)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1))","proofString":"assert (two_p (n + 1 - 1) = two_p (n - 1) * 2).\nreplace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) : two_p (n + 1 - 1) = two_p (n - 1) * 2.","conclusion":"two_p (n + 1 - 1) = two_p (n - 1) * 2","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1))","proofString":"replace (n + 1 - 1) with ((n - 1) + 1) by lia.\napply two_p_is_exp; lia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) : two_p (n - 1 + 1) = two_p (n - 1) * 2.","conclusion":"two_p (n - 1 + 1) = two_p (n - 1) * 2","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1))","proofString":"apply two_p_is_exp; lia."},{"statement":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H1 : two_p (n + 1 - 1) = two_p (n - 1) * 2) : - two_p (n + 1 - 1) <= - Int.signed i < two_p (n + 1 - 1).","conclusion":"- two_p (n + 1 - 1) <= - Int.signed i < two_p (n + 1 - 1)","hypotheses":"(p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) (A : Int.neg i = Int.repr (- Int.signed i)) (B : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H1 : two_p (n + 1 - 1) = two_p (n - 1) * 2)","proofString":"lia."},{"statement":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j).","conclusion":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)","hypotheses":"","proofString":"intros.\napply range_is_uns in H1; auto.\napply range_is_uns in H2; auto.\napply is_uns_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : is_uns n i) (H2 : is_uns m j) : is_uns (Z.max n m + 1) (Int.add i j).","conclusion":"is_uns (Z.max n m + 1) (Int.add i j)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : is_uns n i) (H2 : is_uns m j)","proofString":"apply range_is_uns in H1; auto.\napply range_is_uns in H2; auto.\napply is_uns_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : is_uns m j) : is_uns (Z.max n m + 1) (Int.add i j).","conclusion":"is_uns (Z.max n m + 1) (Int.add i j)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : is_uns m j)","proofString":"apply range_is_uns in H2; auto.\napply is_uns_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) : is_uns (Z.max n m + 1) (Int.add i j).","conclusion":"is_uns (Z.max n m + 1) (Int.add i j)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m)","proofString":"apply is_uns_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) : 0 <= Z.max n m + 1.","conclusion":"0 <= Z.max n m + 1","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m)","proofString":"lia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) : 0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1).","conclusion":"0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m)","proofString":"assert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) : 0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1).","conclusion":"0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m))","proofString":"assert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m)) : 0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1).","conclusion":"0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m))","proofString":"assert (two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) by (apply two_p_is_exp; lia).\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m)) (H5 : two_p (Z.max n m + 1) = two_p (Z.max n m) * 2) : 0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1).","conclusion":"0 <= Int.unsigned i + Int.unsigned j < two_p (Z.max n m + 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m)) (H5 : two_p (Z.max n m + 1) = two_p (Z.max n m) * 2)","proofString":"lia."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.add v w) (add x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.add v w) (add x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j))","proofString":"assert (SGN: forall n i m j,               0 < n -> 0 < m -> is_sgn n i -> is_sgn m j ->               is_sgn (Z.max n m + 1) (Int.add i j)).\nintros.\napply range_is_sgn in H1; auto.\napply range_is_sgn in H2; auto.\nrewrite Int.add_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia.\nassert (SGN2: forall n i m j,               0 < n -> 0 < m -> is_sgn n i -> is_sgn m j ->               is_sgn (Z.max n m + 1) (Int.add j i)).\nintros.\nrewrite Z.max_comm; eauto.\nintros.\nunfold Val.add, add.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; eauto with va; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j).","conclusion":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j))","proofString":"intros.\napply range_is_sgn in H1; auto.\napply range_is_sgn in H2; auto.\nrewrite Int.add_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j) : is_sgn (Z.max n m + 1) (Int.add i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.add i j)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j)","proofString":"apply range_is_sgn in H1; auto.\napply range_is_sgn in H2; auto.\nrewrite Int.add_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : is_sgn m j) : is_sgn (Z.max n m + 1) (Int.add i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.add i j)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : is_sgn m j)","proofString":"apply range_is_sgn in H2; auto.\nrewrite Int.add_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : is_sgn (Z.max n m + 1) (Int.add i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.add i j)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"rewrite Int.add_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : is_sgn (Z.max n m + 1) (Int.repr (Int.signed i + Int.signed j)).","conclusion":"is_sgn (Z.max n m + 1) (Int.repr (Int.signed i + Int.signed j))","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"apply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : 0 < Z.max n m + 1.","conclusion":"0 < Z.max n m + 1","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"lia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : - two_p (Z.max n m + 1 - 1) <= Int.signed i + Int.signed j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.signed i + Int.signed j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"set (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) (p : Z) (H3 : two_p (n - 1) <= two_p p) (H4 : two_p (m - 1) <= two_p p) (H5 : two_p (Z.max n m + 1 - 1) = two_p p * 2) : - two_p (Z.max n m + 1 - 1) <= Int.signed i + Int.signed j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.signed i + Int.signed j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) (p : Z) (H3 : two_p (n - 1) <= two_p p) (H4 : two_p (m - 1) <= two_p p) (H5 : two_p (Z.max n m + 1 - 1) = two_p p * 2)","proofString":"lia."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.add v w) (add x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.add v w) (add x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j))","proofString":"assert (SGN2: forall n i m j,               0 < n -> 0 < m -> is_sgn n i -> is_sgn m j ->               is_sgn (Z.max n m + 1) (Int.add j i)).\nintros.\nrewrite Z.max_comm; eauto.\nintros.\nunfold Val.add, add.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; eauto with va; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i).","conclusion":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j))","proofString":"intros.\nrewrite Z.max_comm; eauto."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (SGN : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 < n0 ->\n0 < m0 ->\nis_sgn n0 i0 -> is_sgn m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j) : is_sgn (Z.max n m + 1) (Int.add j i).","conclusion":"is_sgn (Z.max n m + 1) (Int.add j i)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_uns (Z.max n0 m0 + 1) (Int.add i0 j0)) (SGN : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 < n0 ->\n0 < m0 ->\nis_sgn n0 i0 -> is_sgn m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.add i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j)","proofString":"rewrite Z.max_comm; eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.add v w) (add x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.add v w) (add x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i))","proofString":"intros.\nunfold Val.add, add.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; eauto with va; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.add v w) (add x y).","conclusion":"vmatch (Val.add v w) (add x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold Val.add, add.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; eauto with va; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I j => I (Int.add i j)\n      | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p =>\n          Ptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | Ifptr p =>\n          Ifptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I j | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p =>\n          Ptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | Ifptr p =>\n          Ifptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => uns p1 (Z.max n1 (usize i) + 1)\n      | Uns p2 n2 => uns (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i =>\n          Ptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i =>\n          Ifptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end.","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I j => I (Int.add i j)\n      | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p =>\n          Ptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | Ifptr p =>\n          Ifptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I j | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p =>\n          Ptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | Ifptr p =>\n          Ifptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => uns p1 (Z.max n1 (usize i) + 1)\n      | Uns p2 n2 => uns (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i =>\n          Ptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i =>\n          Ifptr (if Archi.ptr64 then poffset p else padd p (Ptrofs.of_int i))\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; eauto with va; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match w with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I j => I (Int.add i j)\n      | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I j | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => uns p1 (Z.max n1 (usize i) + 1)\n      | Uns p2 n2 => uns (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p => match y with\n             | Vbot | _ => Ptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end.","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match w with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I j => I (Int.add i j)\n      | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I j | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => uns p1 (Z.max n1 (usize i) + 1)\n      | Uns p2 n2 => uns (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p => match y with\n             | Vbot | _ => Ptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; eauto with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I j => I (Int.add i j)\n      | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (padd p (Ptrofs.of_int i))\n      | Ifptr p => Ifptr (padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I j | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (padd p (Ptrofs.of_int i))\n      | Ifptr p => Ifptr (padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => uns p1 (Z.max n1 (usize i) + 1)\n      | Uns p2 n2 => uns (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i => Ptr (padd p (Ptrofs.of_int i))\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i => Ifptr (padd p (Ptrofs.of_int i))\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end.","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I j => I (Int.add i j)\n      | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (padd p (Ptrofs.of_int i))\n      | Ifptr p => Ifptr (padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I j | IU j => IU (Int.add i j)\n      | Uns p n => uns p (Z.max n (usize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | Ptr p => Ptr (padd p (Ptrofs.of_int i))\n      | Ifptr p => Ifptr (padd p (Ptrofs.of_int i))\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => uns p1 (Z.max n1 (usize i) + 1)\n      | Uns p2 n2 => uns (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i => Ptr (padd p (Ptrofs.of_int i))\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i => Ifptr (padd p (Ptrofs.of_int i))\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; eauto with va; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (i : int) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (plub (poffset p) (poffset p0)).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (plub (poffset p) (poffset p0))","hypotheses":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (i : int) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0)","proofString":"apply pmatch_lub_r.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (i : int) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (poffset p0).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (poffset p0)","hypotheses":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (i : int) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0)","proofString":"eapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int) (p0 : aptr) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (plub (poffset p) (poffset p0)).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (plub (poffset p) (poffset p0))","hypotheses":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int) (p0 : aptr)","proofString":"apply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int) (p0 : aptr) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (poffset p).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int i)) (poffset p)","hypotheses":"(UNS : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i0 -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i0 j)) (SGN : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add i0 j)) (SGN2 : forall (n : Z) (i0 : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i0 -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.add j i0)) (b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int) (p0 : aptr)","proofString":"eapply poffset_sound; eauto."},{"statement":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"","proofString":"intros.\napply range_is_uns in H1; auto.\napply range_is_uns in H2; auto.\napply is_sgn_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nreplace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : is_uns n i) (H2 : is_uns m j) : is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : is_uns n i) (H2 : is_uns m j)","proofString":"apply range_is_uns in H1; auto.\napply range_is_uns in H2; auto.\napply is_sgn_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nreplace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : is_uns m j) : is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : is_uns m j)","proofString":"apply range_is_uns in H2; auto.\napply is_sgn_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nreplace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) : is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m)","proofString":"apply is_sgn_range.\nlia.\nassert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nreplace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) : 0 < Z.max n m + 1.","conclusion":"0 < Z.max n m + 1","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m)","proofString":"lia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) : - two_p (Z.max n m + 1 - 1) <= Int.unsigned i - Int.unsigned j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.unsigned i - Int.unsigned j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m)","proofString":"assert (two_p n <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nassert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nreplace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) : - two_p (Z.max n m + 1 - 1) <= Int.unsigned i - Int.unsigned j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.unsigned i - Int.unsigned j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m))","proofString":"assert (two_p m <= two_p (Z.max n m)) by (apply two_p_monotone; lia).\nreplace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m)) : - two_p (Z.max n m + 1 - 1) <= Int.unsigned i - Int.unsigned j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.unsigned i - Int.unsigned j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m))","proofString":"replace (Z.max n m + 1 - 1) with (Z.max n m) by lia.\nlia."},{"statement":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m)) : - two_p (Z.max n m) <= Int.unsigned i - Int.unsigned j < two_p (Z.max n m).","conclusion":"- two_p (Z.max n m) <= Int.unsigned i - Int.unsigned j < two_p (Z.max n m)","hypotheses":"(n : Z) (i : int) (m : Z) (j : int) (H : 0 <= n) (H0 : 0 <= m) (H1 : 0 <= Int.unsigned i < two_p n) (H2 : 0 <= Int.unsigned j < two_p m) (H3 : two_p n <= two_p (Z.max n m)) (H4 : two_p m <= two_p (Z.max n m))","proofString":"lia."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.sub v w) (sub x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.sub v w) (sub x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j))","proofString":"assert (SGN: forall n i m j,               0 < n -> 0 < m -> is_sgn n i -> is_sgn m j ->               is_sgn (Z.max n m + 1) (Int.sub i j)).\nintros.\napply range_is_sgn in H1; auto.\napply range_is_sgn in H2; auto.\nrewrite Int.sub_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia.\nassert (SGN2: forall n i m j,               0 < n -> 0 < m -> is_sgn n i -> is_sgn m j ->               is_sgn (Z.max n m + 1) (Int.sub j i)).\nintros.\nrewrite Z.max_comm.\neauto.\nintros.\nunfold Val.sub, sub.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j))","proofString":"intros.\napply range_is_sgn in H1; auto.\napply range_is_sgn in H2; auto.\nrewrite Int.sub_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j) : is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j)","proofString":"apply range_is_sgn in H1; auto.\napply range_is_sgn in H2; auto.\nrewrite Int.sub_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : is_sgn m j) : is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : is_sgn m j)","proofString":"apply range_is_sgn in H2; auto.\nrewrite Int.sub_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : is_sgn (Z.max n m + 1) (Int.sub i j).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub i j)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"rewrite Int.sub_signed.\napply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : is_sgn (Z.max n m + 1) (Int.repr (Int.signed i - Int.signed j)).","conclusion":"is_sgn (Z.max n m + 1) (Int.repr (Int.signed i - Int.signed j))","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"apply is_sgn_range.\nlia.\nset (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : 0 < Z.max n m + 1.","conclusion":"0 < Z.max n m + 1","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"lia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : - two_p (Z.max n m + 1 - 1) <= Int.signed i - Int.signed j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.signed i - Int.signed j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"set (p := Z.max n m - 1).\nassert (two_p (n-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (m-1) <= two_p p) by (apply two_p_monotone; lia).\nassert (two_p (Z.max n m + 1 - 1) = two_p p * 2).\nreplace (Z.max n m + 1 - 1) with (p + 1) by lia.\napply two_p_is_exp; lia.\nlia."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) (p : Z) (H3 : two_p (n - 1) <= two_p p) (H4 : two_p (m - 1) <= two_p p) (H5 : two_p (Z.max n m + 1 - 1) = two_p p * 2) : - two_p (Z.max n m + 1 - 1) <= Int.signed i - Int.signed j <\ntwo_p (Z.max n m + 1 - 1).","conclusion":"- two_p (Z.max n m + 1 - 1) <= Int.signed i - Int.signed j <\ntwo_p (Z.max n m + 1 - 1)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (H2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) (p : Z) (H3 : two_p (n - 1) <= two_p p) (H4 : two_p (m - 1) <= two_p p) (H5 : two_p (Z.max n m + 1 - 1) = two_p p * 2)","proofString":"lia."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.sub v w) (sub x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.sub v w) (sub x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j))","proofString":"assert (SGN2: forall n i m j,               0 < n -> 0 < m -> is_sgn n i -> is_sgn m j ->               is_sgn (Z.max n m + 1) (Int.sub j i)).\nintros.\nrewrite Z.max_comm.\neauto.\nintros.\nunfold Val.sub, sub.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i).","conclusion":"forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j))","proofString":"intros.\nrewrite Z.max_comm.\neauto."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (SGN : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 < n0 ->\n0 < m0 ->\nis_sgn n0 i0 -> is_sgn m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j) : is_sgn (Z.max n m + 1) (Int.sub j i).","conclusion":"is_sgn (Z.max n m + 1) (Int.sub j i)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (SGN : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 < n0 ->\n0 < m0 ->\nis_sgn n0 i0 -> is_sgn m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j)","proofString":"rewrite Z.max_comm.\neauto."},{"statement":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (SGN : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 < n0 ->\n0 < m0 ->\nis_sgn n0 i0 -> is_sgn m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j) : is_sgn (Z.max m n + 1) (Int.sub j i).","conclusion":"is_sgn (Z.max m n + 1) (Int.sub j i)","hypotheses":"(UNS : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 <= n0 ->\n0 <= m0 ->\nis_uns n0 i0 -> is_uns m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (SGN : forall (n0 : Z) (i0 : int) (m0 : Z) (j0 : int),\n0 < n0 ->\n0 < m0 ->\nis_sgn n0 i0 -> is_sgn m0 j0 -> is_sgn (Z.max n0 m0 + 1) (Int.sub i0 j0)) (n : Z) (i : int) (m : Z) (j : int) (H : 0 < n) (H0 : 0 < m) (H1 : is_sgn n i) (H2 : is_sgn m j)","proofString":"eauto."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) : forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.sub v w) (sub x y).","conclusion":"forall (v w : val) (x y : aval),\nvmatch v x -> vmatch w y -> vmatch (Val.sub v w) (sub x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i))","proofString":"intros.\nunfold Val.sub, sub.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.sub v w) (sub x y).","conclusion":"vmatch (Val.sub v w) (sub x y)","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold Val.sub, sub.\ndestruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I i2 => I (Int.sub i i2)\n      | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I i2 | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => sgn p1 (Z.max (n1 + 1) (ssize i) + 1)\n      | Uns p2 n2 => sgn (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i =>\n          if Archi.ptr64\n          then Ifptr (poffset p)\n          else Ptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i =>\n          if Archi.ptr64\n          then Ifptr (plub (poffset p) (provenance y))\n          else Ifptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I i2 => I (Int.sub i i2)\n      | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I i2 | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => sgn p1 (Z.max (n1 + 1) (ssize i) + 1)\n      | Uns p2 n2 => sgn (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i =>\n          if Archi.ptr64\n          then Ifptr (poffset p)\n          else Ptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i =>\n          if Archi.ptr64\n          then Ifptr (plub (poffset p) (provenance y))\n          else Ifptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct Archi.ptr64.\ninv H; inv H0; eauto with va.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match w with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I i2 => I (Int.sub i i2)\n      | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I i2 | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => sgn p1 (Z.max (n1 + 1) (ssize i) + 1)\n      | Uns p2 n2 => sgn (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | _ => ntop2 x y\n      end\n  | Ptr p => match y with\n             | Vbot | _ => Ifptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Vbot | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match w with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I i2 => I (Int.sub i i2)\n      | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I i2 | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => sgn p1 (Z.max (n1 + 1) (ssize i) + 1)\n      | Uns p2 n2 => sgn (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | _ => ntop2 x y\n      end\n  | Ptr p => match y with\n             | Vbot | _ => Ifptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Vbot | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; eauto with va."},{"statement":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if eq_block b1 b2\n          then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I i2 => I (Int.sub i i2)\n      | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I i2 | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => sgn p1 (Z.max (n1 + 1) (ssize i) + 1)\n      | Uns p2 n2 => sgn (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i => Ptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i => Ifptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch\n  match v with\n  | Vint n1 =>\n      match w with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vint n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if eq_block b1 b2\n          then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | I i =>\n      match y with\n      | I i2 => I (Int.sub i i2)\n      | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | IU i =>\n      match y with\n      | I i2 | IU i2 => IU (Int.sub i i2)\n      | Uns p n => sgn p (Z.max (n + 1) (ssize i) + 1)\n      | Sgn p n => sgn p (Z.max n (ssize i) + 1)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I i | IU i => sgn p1 (Z.max (n1 + 1) (ssize i) + 1)\n      | Uns p2 n2 => sgn (plub p1 p2) (Z.max n1 n2 + 1)\n      | Sgn p2 n2 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | _ => ntop2 x y\n      end\n  | Sgn p2 n2 =>\n      match y with\n      | I i | IU i => sgn p2 (Z.max n2 (ssize i) + 1)\n      | Uns p1 n1 => sgn (plub p1 p2) (Z.max (n1 + 1) n2 + 1)\n      | Sgn p0 n0 => sgn (plub p2 p0) (Z.max n2 n0 + 1)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | I i | IU i => Ptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | I i | IU i => Ifptr (psub p (Ptrofs.of_int i))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(UNS : forall (n : Z) (i : int) (m : Z) (j : int),\n0 <= n ->\n0 <= m -> is_uns n i -> is_uns m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub i j)) (SGN2 : forall (n : Z) (i : int) (m : Z) (j : int),\n0 < n ->\n0 < m -> is_sgn n i -> is_sgn m j -> is_sgn (Z.max n m + 1) (Int.sub j i)) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mul v w) (mul_base x y).","conclusion":"vmatch (Val.mul v w) (mul_base x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (UNS: forall i1 i2 n1 n2 p,             0 <= n1 -> is_uns n1 i1 ->             0 <= n2 -> is_uns n2 i2 ->             vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))).\nintros.\napply vmatch_uns.\napply is_uns_range.\nlia.\napply Zmult_unsigned_range; auto using range_is_uns.\nassert (SGN: forall i1 i2 n1 n2 p,             0 < n1 -> is_sgn n1 i1 ->             0 < n2 -> is_sgn n2 i2 ->             vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2))).\nintros.\napply vmatch_sgn.\nrewrite Int.mul_signed.\napply is_sgn_range.\nlia.\nreplace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia.\nunfold mul_base.\ninv H; inv H0; eauto with va; rewrite Z.add_comm; eauto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2)).","conclusion":"forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"intros.\napply vmatch_uns.\napply is_uns_range.\nlia.\napply Zmult_unsigned_range; auto using range_is_uns."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2) : vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2)).","conclusion":"vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2)","proofString":"apply vmatch_uns.\napply is_uns_range.\nlia.\napply Zmult_unsigned_range; auto using range_is_uns."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2) : is_uns (n1 + n2) (Int.mul i1 i2).","conclusion":"is_uns (n1 + n2) (Int.mul i1 i2)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2)","proofString":"apply is_uns_range.\nlia.\napply Zmult_unsigned_range; auto using range_is_uns."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2) : 0 <= n1 + n2.","conclusion":"0 <= n1 + n2","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2)","proofString":"lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2) : 0 <= Int.unsigned i1 * Int.unsigned i2 < two_p (n1 + n2).","conclusion":"0 <= Int.unsigned i1 * Int.unsigned i2 < two_p (n1 + n2)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 <= n1) (H2 : is_uns n1 i1) (H3 : 0 <= n2) (H4 : is_uns n2 i2)","proofString":"apply Zmult_unsigned_range; auto using range_is_uns."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) : vmatch (Val.mul v w) (mul_base x y).","conclusion":"vmatch (Val.mul v w) (mul_base x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2)))","proofString":"assert (SGN: forall i1 i2 n1 n2 p,             0 < n1 -> is_sgn n1 i1 ->             0 < n2 -> is_sgn n2 i2 ->             vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2))).\nintros.\napply vmatch_sgn.\nrewrite Int.mul_signed.\napply is_sgn_range.\nlia.\nreplace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia.\nunfold mul_base.\ninv H; inv H0; eauto with va; rewrite Z.add_comm; eauto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 < n1 ->\nis_sgn n1 i1 ->\n0 < n2 ->\nis_sgn n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2)).","conclusion":"forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 < n1 ->\nis_sgn n1 i1 ->\n0 < n2 ->\nis_sgn n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2))","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2)))","proofString":"intros.\napply vmatch_sgn.\nrewrite Int.mul_signed.\napply is_sgn_range.\nlia.\nreplace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2) : vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2)).","conclusion":"vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2))","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2)","proofString":"apply vmatch_sgn.\nrewrite Int.mul_signed.\napply is_sgn_range.\nlia.\nreplace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2) : is_sgn (n1 + n2) (Int.mul i1 i2).","conclusion":"is_sgn (n1 + n2) (Int.mul i1 i2)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2)","proofString":"rewrite Int.mul_signed.\napply is_sgn_range.\nlia.\nreplace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2) : is_sgn (n1 + n2) (Int.repr (Int.signed i1 * Int.signed i2)).","conclusion":"is_sgn (n1 + n2) (Int.repr (Int.signed i1 * Int.signed i2))","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2)","proofString":"apply is_sgn_range.\nlia.\nreplace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2) : 0 < n1 + n2.","conclusion":"0 < n1 + n2","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2)","proofString":"lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2) : - two_p (n1 + n2 - 1) <= Int.signed i1 * Int.signed i2 < two_p (n1 + n2 - 1).","conclusion":"- two_p (n1 + n2 - 1) <= Int.signed i1 * Int.signed i2 < two_p (n1 + n2 - 1)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2)","proofString":"replace (n1 + n2 - 1) with ((n1 - 1) + (n2 - 1) + 1) by lia.\napply Zmult_signed_range; auto using range_is_sgn; lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2) : - two_p (n1 - 1 + (n2 - 1) + 1) <= Int.signed i1 * Int.signed i2 <\ntwo_p (n1 - 1 + (n2 - 1) + 1).","conclusion":"- two_p (n1 - 1 + (n2 - 1) + 1) <= Int.signed i1 * Int.signed i2 <\ntwo_p (n1 - 1 + (n2 - 1) + 1)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i0 i3 : int) (n0 n3 : Z) (p0 : aptr),\n0 <= n0 ->\nis_uns n0 i0 ->\n0 <= n3 ->\nis_uns n3 i3 -> vmatch (Val.mul (Vint i0) (Vint i3)) (uns p0 (n0 + n3))) (i1 i2 : int) (n1 n2 : Z) (p : aptr) (H1 : 0 < n1) (H2 : is_sgn n1 i1) (H3 : 0 < n2) (H4 : is_sgn n2 i2)","proofString":"apply Zmult_signed_range; auto using range_is_sgn; lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) (SGN : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 < n1 ->\nis_sgn n1 i1 ->\n0 < n2 ->\nis_sgn n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2))) : vmatch (Val.mul v w) (mul_base x y).","conclusion":"vmatch (Val.mul v w) (mul_base x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) (SGN : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 < n1 ->\nis_sgn n1 i1 ->\n0 < n2 ->\nis_sgn n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2)))","proofString":"unfold mul_base.\ninv H; inv H0; eauto with va; rewrite Z.add_comm; eauto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) (SGN : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 < n1 ->\nis_sgn n1 i1 ->\n0 < n2 ->\nis_sgn n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2))) : vmatch (Val.mul v w)\n  match x with\n  | I n2 | IU n2 =>\n      match y with\n      | Uns p n1 => uns p (n1 + usize n2)\n      | Sgn p n1 => sgn p (n1 + ssize n2)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I n2 | IU n2 => uns p1 (n1 + usize n2)\n      | Uns p2 n2 => uns (plub p1 p2) (n1 + n2)\n      | Sgn p2 n2 => sgn (plub p1 p2) (n1 + 1 + n2)\n      | _ => ntop2 x y\n      end\n  | Sgn p1 n1 =>\n      match y with\n      | I n2 | IU n2 => sgn p1 (n1 + ssize n2)\n      | Uns p2 n2 => sgn (plub p1 p2) (n1 + (n2 + 1))\n      | Sgn p2 n2 => sgn (plub p1 p2) (n1 + n2)\n      | _ => ntop2 x y\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch (Val.mul v w)\n  match x with\n  | I n2 | IU n2 =>\n      match y with\n      | Uns p n1 => uns p (n1 + usize n2)\n      | Sgn p n1 => sgn p (n1 + ssize n2)\n      | _ => ntop2 x y\n      end\n  | Uns p1 n1 =>\n      match y with\n      | I n2 | IU n2 => uns p1 (n1 + usize n2)\n      | Uns p2 n2 => uns (plub p1 p2) (n1 + n2)\n      | Sgn p2 n2 => sgn (plub p1 p2) (n1 + 1 + n2)\n      | _ => ntop2 x y\n      end\n  | Sgn p1 n1 =>\n      match y with\n      | I n2 | IU n2 => sgn p1 (n1 + ssize n2)\n      | Uns p2 n2 => sgn (plub p1 p2) (n1 + (n2 + 1))\n      | Sgn p2 n2 => sgn (plub p1 p2) (n1 + n2)\n      | _ => ntop2 x y\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (UNS : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 <= n1 ->\nis_uns n1 i1 ->\n0 <= n2 ->\nis_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) (SGN : forall (i1 i2 : int) (n1 n2 : Z) (p : aptr),\n0 < n1 ->\nis_sgn n1 i1 ->\n0 < n2 ->\nis_sgn n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (sgn p (n1 + n2)))","proofString":"inv H; inv H0; eauto with va; rewrite Z.add_comm; eauto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mul v w) (mul x y).","conclusion":"vmatch (Val.mul v w) (mul x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (vmatch (Val.mul v w)            (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)             then IU Int.zero             else mul_base x y)).\ndestruct orb eqn:INCL; auto using mul_base_sound.\nrewrite orb_true_iff in INCL; destruct INCL;    exploit vmatch_Uns_0; eauto using vmatch_ge, vincl_ge;    intros [E|E]; subst; simpl.\nauto with va.\ndestruct w; auto with va.\ndestruct v; auto with va.\ndestruct v; simpl; rewrite ? Int.mul_zero; auto with va.\ninv H; inv H0; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mul v w)\n  (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n   then IU Int.zero\n   else mul_base x y).","conclusion":"vmatch (Val.mul v w)\n  (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n   then IU Int.zero\n   else mul_base x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct orb eqn:INCL; auto using mul_base_sound.\nrewrite orb_true_iff in INCL; destruct INCL;    exploit vmatch_Uns_0; eauto using vmatch_ge, vincl_ge;    intros [E|E]; subst; simpl.\nauto with va.\ndestruct w; auto with va.\ndestruct v; auto with va.\ndestruct v; simpl; rewrite ? Int.mul_zero; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (INCL : vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) = true) : vmatch (Val.mul v w) (IU Int.zero).","conclusion":"vmatch (Val.mul v w) (IU Int.zero)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (INCL : vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) = true)","proofString":"rewrite orb_true_iff in INCL; destruct INCL;    exploit vmatch_Uns_0; eauto using vmatch_ge, vincl_ge;    intros [E|E]; subst; simpl.\nauto with va.\ndestruct w; auto with va.\ndestruct v; auto with va.\ndestruct v; simpl; rewrite ? Int.mul_zero; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch Vundef x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true) : vmatch Vundef (IU Int.zero).","conclusion":"vmatch Vundef (IU Int.zero)","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch Vundef x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true)","proofString":"auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.zero) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true) : vmatch match w with\n       | Vint n2 => Vint (Int.mul Int.zero n2)\n       | _ => Vundef\n       end (IU Int.zero).","conclusion":"vmatch match w with\n       | Vint n2 => Vint (Int.mul Int.zero n2)\n       | _ => Vundef\n       end (IU Int.zero)","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.zero) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true)","proofString":"destruct w; auto with va."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch Vundef y) (H1 : vincl y (Uns Ptop 0) = true) : vmatch (Val.mul v Vundef) (IU Int.zero).","conclusion":"vmatch (Val.mul v Vundef) (IU Int.zero)","hypotheses":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch Vundef y) (H1 : vincl y (Uns Ptop 0) = true)","proofString":"destruct v; auto with va."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch (Vint Int.zero) y) (H1 : vincl y (Uns Ptop 0) = true) : vmatch (Val.mul v (Vint Int.zero)) (IU Int.zero).","conclusion":"vmatch (Val.mul v (Vint Int.zero)) (IU Int.zero)","hypotheses":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch (Vint Int.zero) y) (H1 : vincl y (Uns Ptop 0) = true)","proofString":"destruct v; simpl; rewrite ? Int.mul_zero; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vmatch (Val.mul v w)\n  (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n   then IU Int.zero\n   else mul_base x y)) : vmatch (Val.mul v w) (mul x y).","conclusion":"vmatch (Val.mul v w) (mul x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vmatch (Val.mul v w)\n  (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n   then IU Int.zero\n   else mul_base x y))","proofString":"inv H; inv H0; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mulhs v w) (mulhs_base x y).","conclusion":"vmatch (Val.mulhs v w) (mulhs_base x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold Val.mulhs, mulhs_base; destruct v, w; auto with va.\nrename i0 into j.\napply srange_sound in H.\ndestruct H as [A1 B1].\napply range_is_sgn in B1; auto.\napply srange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) : vmatch (Vint (Int.mulhs i i0))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i i0))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y)","proofString":"rename i0 into j.\napply srange_sound in H.\ndestruct H as [A1 B1].\napply range_is_sgn in B1; auto.\napply srange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y)","proofString":"apply srange_sound in H.\ndestruct H as [A1 B1].\napply range_is_sgn in B1; auto.\napply srange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (H : 0 < srange x /\\ is_sgn (srange x) i) (H0 : vmatch (Vint j) y) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (H : 0 < srange x /\\ is_sgn (srange x) i) (H0 : vmatch (Vint j) y)","proofString":"destruct H as [A1 B1].\napply range_is_sgn in B1; auto.\napply srange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : is_sgn (srange x) i) (H0 : vmatch (Vint j) y) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : is_sgn (srange x) i) (H0 : vmatch (Vint j) y)","proofString":"apply range_is_sgn in B1; auto.\napply srange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : vmatch (Vint j) y) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : vmatch (Vint j) y)","proofString":"apply srange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : 0 < srange y /\\ is_sgn (srange y) j) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : 0 < srange y /\\ is_sgn (srange y) j)","proofString":"destruct H0 as [A2 B2].\napply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (A2 : 0 < srange y) (B2 : is_sgn (srange y) j) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (A2 : 0 < srange y) (B2 : is_sgn (srange y) j)","proofString":"apply range_is_sgn in B2; auto.\nset (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (A2 : 0 < srange y) (B2 : - two_p (srange y - 1) <= Int.signed j < two_p (srange y - 1)) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y))\n     (srange x + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (A1 : 0 < srange x) (B1 : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (A2 : 0 < srange y) (B2 : - two_p (srange y - 1) <= Int.signed j < two_p (srange y - 1))","proofString":"set (n := srange x) in *.\nset (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (B1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (A2 : 0 < srange y) (B2 : - two_p (srange y - 1) <= Int.signed j < two_p (srange y - 1)) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y)) (n + srange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y)) (n + srange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (B1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (A2 : 0 < srange y) (B2 : - two_p (srange y - 1) <= Int.signed j < two_p (srange y - 1))","proofString":"set (m := srange y) in *.\nunfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (B1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (m : Z) (A2 : 0 < m) (B2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhs i j))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (B1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (m : Z) (A2 : 0 < m) (B2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"unfold Int.mulhs.\nset (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (B1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (m : Z) (A2 : 0 < m) (B2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : vmatch (Vint (Int.repr (Int.signed i * Int.signed j / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (Int.signed i * Int.signed j / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (B1 : - two_p (n - 1) <= Int.signed i < two_p (n - 1)) (m : Z) (A2 : 0 < m) (B2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"set (a := Int.signed i) in *.\nset (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (B2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1)) : vmatch (Vint (Int.repr (a * Int.signed j / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (a * Int.signed j / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (B2 : - two_p (m - 1) <= Int.signed j < two_p (m - 1))","proofString":"set (b := Int.signed j) in *.\nexploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) : vmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1))","proofString":"exploit (Zmult_signed_range (n-1) a (m-1) b); auto with va.\nreplace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) : - two_p (n - 1 + (m - 1) + 1) <= a * b < two_p (n - 1 + (m - 1) + 1) ->\nvmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"- two_p (n - 1 + (m - 1) + 1) <= a * b < two_p (n - 1 + (m - 1) + 1) ->\nvmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1))","proofString":"replace (n - 1 + (m - 1) + 1) with (n + m - 1) by lia.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) : - two_p (n + m - 1) <= a * b < two_p (n + m - 1) ->\nvmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"- two_p (n + m - 1) <= a * b < two_p (n + m - 1) ->\nvmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1))","proofString":"intros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) : vmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (a * b / Int.modulus)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1))","proofString":"rewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) : vmatch (Vint (Int.repr (a * b / two_p Int.zwordsize)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (a * b / two_p Int.zwordsize)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1))","proofString":"change Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) : vmatch (Vint (Int.repr (a * b / two_p 32)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - 32)).","conclusion":"vmatch (Vint (Int.repr (a * b / two_p 32)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - 32))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1))","proofString":"rewrite <- Zshiftr_div_two_p by lia.\napply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) : vmatch (Vint (Int.repr (Z.shiftr (a * b) 32)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - 32)).","conclusion":"vmatch (Vint (Int.repr (Z.shiftr (a * b) 32)))\n  (sgn (plub (provenance x) (provenance y)) (n + m - 32))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1))","proofString":"apply vmatch_sgn.\nred; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) : is_sgn (n + m - 32) (Int.repr (Z.shiftr (a * b) 32)).","conclusion":"is_sgn (n + m - 32) (Int.repr (Z.shiftr (a * b) 32))","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1))","proofString":"red; intros.\nrewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) (m0 : Z) (H : 0 <= m0 < Int.zwordsize) (H0 : m0 >= n + m - 32 - 1) : Int.testbit (Int.repr (Z.shiftr (a * b) 32)) m0 =\nInt.testbit (Int.repr (Z.shiftr (a * b) 32)) (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.repr (Z.shiftr (a * b) 32)) m0 =\nInt.testbit (Int.repr (Z.shiftr (a * b) 32)) (Int.zwordsize - 1)","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) (m0 : Z) (H : 0 <= m0 < Int.zwordsize) (H0 : m0 >= n + m - 32 - 1)","proofString":"rewrite ! Int.testbit_repr by lia.\nrewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) (m0 : Z) (H : 0 <= m0 < Int.zwordsize) (H0 : m0 >= n + m - 32 - 1) : Z.testbit (Z.shiftr (a * b) 32) m0 =\nZ.testbit (Z.shiftr (a * b) 32) (Int.zwordsize - 1).","conclusion":"Z.testbit (Z.shiftr (a * b) 32) m0 =\nZ.testbit (Z.shiftr (a * b) 32) (Int.zwordsize - 1)","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) (m0 : Z) (H : 0 <= m0 < Int.zwordsize) (H0 : m0 >= n + m - 32 - 1)","proofString":"rewrite ! Z.shiftr_spec by lia.\napply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) (m0 : Z) (H : 0 <= m0 < Int.zwordsize) (H0 : m0 >= n + m - 32 - 1) : Z.testbit (a * b) (m0 + 32) = Z.testbit (a * b) (Int.zwordsize - 1 + 32).","conclusion":"Z.testbit (a * b) (m0 + 32) = Z.testbit (a * b) (Int.zwordsize - 1 + 32)","hypotheses":"(i : int) (x : aval) (j : int) (y : aval) (n : Z) (A1 : 0 < n) (a : Z) (B1 : - two_p (n - 1) <= a < two_p (n - 1)) (m : Z) (A2 : 0 < m) (b : Z) (B2 : - two_p (m - 1) <= b < two_p (m - 1)) (P : - two_p (n + m - 1) <= a * b < two_p (n + m - 1)) (m0 : Z) (H : 0 <= m0 < Int.zwordsize) (H0 : m0 >= n + m - 32 - 1)","proofString":"apply (Zbits_signed_range (n + m - 1)); lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mulhs v w) (mulhs x y).","conclusion":"vmatch (Val.mulhs v w) (mulhs x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold mulhs.\ndestruct (vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)) eqn:?; auto with va.\nrewrite orb_true_iff in Heqb;  destruct Heqb.\nexploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H.\nintros.\ndestruct H2; inv H2; inv H; inv H0; auto with va.\nexploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H0.\nintros.\ndestruct H2; inv H2; inv H; inv H0; simpl; try rewrite Int.mulhs_zero; auto with va.\ninversion H; inversion H0; subst; eauto using mulhs_base_sound with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ =>\n          if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n          then IU Int.zero\n          else mulhs_base x y\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ =>\n          if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n          then IU Int.zero\n          else mulhs_base x y\n      end\n  | _ =>\n      if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n      then IU Int.zero\n      else mulhs_base x y\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ =>\n          if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n          then IU Int.zero\n          else mulhs_base x y\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ =>\n          if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n          then IU Int.zero\n          else mulhs_base x y\n      end\n  | _ =>\n      if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)\n      then IU Int.zero\n      else mulhs_base x y\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct (vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0)) eqn:?; auto with va.\nrewrite orb_true_iff in Heqb;  destruct Heqb.\nexploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H.\nintros.\ndestruct H2; inv H2; inv H; inv H0; auto with va.\nexploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H0.\nintros.\ndestruct H2; inv H2; inv H; inv H0; simpl; try rewrite Int.mulhs_zero; auto with va.\ninversion H; inversion H0; subst; eauto using mulhs_base_sound with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) = true) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) = true)","proofString":"rewrite orb_true_iff in Heqb;  destruct Heqb.\nexploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H.\nintros.\ndestruct H2; inv H2; inv H; inv H0; auto with va.\nexploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H0.\nintros.\ndestruct H2; inv H2; inv H; inv H0; simpl; try rewrite Int.mulhs_zero; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true)","proofString":"exploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H.\nintros.\ndestruct H2; inv H2; inv H; inv H0; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true) (H2 : v = Vundef \\/ v = Vint Int.zero) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 0) = true) (H2 : v = Vundef \\/ v = Vint Int.zero)","proofString":"destruct H2; inv H2; inv H; inv H0; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 0) = true) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 0) = true)","proofString":"exploit vmatch_Uns_0.\neapply vmatch_ge.\neapply vincl_ge; eauto.\neexact H0.\nintros.\ndestruct H2; inv H2; inv H; inv H0; simpl; try rewrite Int.mulhs_zero; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 0) = true) (H2 : w = Vundef \\/ w = Vint Int.zero) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 0) = true) (H2 : w = Vundef \\/ w = Vint Int.zero)","proofString":"destruct H2; inv H2; inv H; inv H0; simpl; try rewrite Int.mulhs_zero; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) = false) : vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => mulhs_base x y\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => mulhs_base x y\n      end\n  | _ => mulhs_base x y\n  end.","conclusion":"vmatch (Val.mulhs v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhs i1 i2)\n      | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => mulhs_base x y\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhs i1 i2)\n      | _ => mulhs_base x y\n      end\n  | _ => mulhs_base x y\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) = false)","proofString":"inversion H; inversion H0; subst; eauto using mulhs_base_sound with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mulhu v w) (mulhu_base x y).","conclusion":"vmatch (Val.mulhu v w) (mulhu_base x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold Val.mulhu, mulhu_base; destruct v, w; auto with va.\napply urange_sound in H.\ndestruct H as [A1 B1].\napply range_is_uns in B1; auto.\napply urange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y)","proofString":"apply urange_sound in H.\ndestruct H as [A1 B1].\napply range_is_uns in B1; auto.\napply urange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (H : 0 <= urange x /\\ is_uns (urange x) i) (H0 : vmatch (Vint i0) y) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (H : 0 <= urange x /\\ is_uns (urange x) i) (H0 : vmatch (Vint i0) y)","proofString":"destruct H as [A1 B1].\napply range_is_uns in B1; auto.\napply urange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : is_uns (urange x) i) (H0 : vmatch (Vint i0) y) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : is_uns (urange x) i) (H0 : vmatch (Vint i0) y)","proofString":"apply range_is_uns in B1; auto.\napply urange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint i0) y) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint i0) y)","proofString":"apply urange_sound in H0.\ndestruct H0 as [A2 B2].\napply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (H0 : 0 <= urange y /\\ is_uns (urange y) i0) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (H0 : 0 <= urange y /\\ is_uns (urange y) i0)","proofString":"destruct H0 as [A2 B2].\napply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (A2 : 0 <= urange y) (B2 : is_uns (urange y) i0) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (A2 : 0 <= urange y) (B2 : is_uns (urange y) i0)","proofString":"apply range_is_uns in B2; auto.\nset (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (A2 : 0 <= urange y) (B2 : 0 <= Int.unsigned i0 < two_p (urange y)) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y))\n     (urange x + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (A1 : 0 <= urange x) (B1 : 0 <= Int.unsigned i < two_p (urange x)) (A2 : 0 <= urange y) (B2 : 0 <= Int.unsigned i0 < two_p (urange y))","proofString":"set (n1 := urange x) in *.\nset (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (B1 : 0 <= Int.unsigned i < two_p n1) (A2 : 0 <= urange y) (B2 : 0 <= Int.unsigned i0 < two_p (urange y)) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y)) (n1 + urange y - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y)) (n1 + urange y - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (B1 : 0 <= Int.unsigned i < two_p n1) (A2 : 0 <= urange y) (B2 : 0 <= Int.unsigned i0 < two_p (urange y))","proofString":"set (n2 := urange y) in *.\nunfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (B1 : 0 <= Int.unsigned i < two_p n1) (n2 : Z) (A2 : 0 <= n2) (B2 : 0 <= Int.unsigned i0 < two_p n2) : vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.mulhu i i0))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (B1 : 0 <= Int.unsigned i < two_p n1) (n2 : Z) (A2 : 0 <= n2) (B2 : 0 <= Int.unsigned i0 < two_p n2)","proofString":"unfold Int.mulhu.\nset (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (B1 : 0 <= Int.unsigned i < two_p n1) (n2 : Z) (A2 : 0 <= n2) (B2 : 0 <= Int.unsigned i0 < two_p n2) : vmatch (Vint (Int.repr (Int.unsigned i * Int.unsigned i0 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (Int.unsigned i * Int.unsigned i0 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (B1 : 0 <= Int.unsigned i < two_p n1) (n2 : Z) (A2 : 0 <= n2) (B2 : 0 <= Int.unsigned i0 < two_p n2)","proofString":"set (x1 := Int.unsigned i) in *.\nset (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (B2 : 0 <= Int.unsigned i0 < two_p n2) : vmatch (Vint (Int.repr (x1 * Int.unsigned i0 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (x1 * Int.unsigned i0 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (B2 : 0 <= Int.unsigned i0 < two_p n2)","proofString":"set (x2 := Int.unsigned i0) in *.\nexploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) : vmatch (Vint (Int.repr (x1 * x2 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (x1 * x2 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2)","proofString":"exploit (Zmult_unsigned_range n1 x1 n2 x2); auto.\nintros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) : 0 <= x1 * x2 < two_p (n1 + n2) ->\nvmatch (Vint (Int.repr (x1 * x2 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"0 <= x1 * x2 < two_p (n1 + n2) ->\nvmatch (Vint (Int.repr (x1 * x2 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2)","proofString":"intros P.\nrewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) : vmatch (Vint (Int.repr (x1 * x2 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (x1 * x2 / Int.modulus)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2))","proofString":"rewrite Int.modulus_power.\nchange Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) : vmatch (Vint (Int.repr (x1 * x2 / two_p Int.zwordsize)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize)).","conclusion":"vmatch (Vint (Int.repr (x1 * x2 / two_p Int.zwordsize)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - Int.zwordsize))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2))","proofString":"change Int.zwordsize with 32.\nrewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) : vmatch (Vint (Int.repr (x1 * x2 / two_p 32)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - 32)).","conclusion":"vmatch (Vint (Int.repr (x1 * x2 / two_p 32)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - 32))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2))","proofString":"rewrite <- Zshiftr_div_two_p by lia.\napply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) : vmatch (Vint (Int.repr (Z.shiftr (x1 * x2) 32)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - 32)).","conclusion":"vmatch (Vint (Int.repr (Z.shiftr (x1 * x2) 32)))\n  (uns (plub (provenance x) (provenance y)) (n1 + n2 - 32))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2))","proofString":"apply vmatch_uns.\nred; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) : is_uns (n1 + n2 - 32) (Int.repr (Z.shiftr (x1 * x2) 32)).","conclusion":"is_uns (n1 + n2 - 32) (Int.repr (Z.shiftr (x1 * x2) 32))","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2))","proofString":"red; intros.\nrewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= n1 + n2 - 32) : Int.testbit (Int.repr (Z.shiftr (x1 * x2) 32)) m = false.","conclusion":"Int.testbit (Int.repr (Z.shiftr (x1 * x2) 32)) m = false","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= n1 + n2 - 32)","proofString":"rewrite Int.testbit_repr by auto.\nrewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= n1 + n2 - 32) : Z.testbit (Z.shiftr (x1 * x2) 32) m = false.","conclusion":"Z.testbit (Z.shiftr (x1 * x2) 32) m = false","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= n1 + n2 - 32)","proofString":"rewrite Z.shiftr_spec by lia.\napply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= n1 + n2 - 32) : Z.testbit (x1 * x2) (m + 32) = false.","conclusion":"Z.testbit (x1 * x2) (m + 32) = false","hypotheses":"(i : int) (x : aval) (i0 : int) (y : aval) (n1 : Z) (A1 : 0 <= n1) (x1 : Z) (B1 : 0 <= x1 < two_p n1) (n2 : Z) (A2 : 0 <= n2) (x2 : Z) (B2 : 0 <= x2 < two_p n2) (P : 0 <= x1 * x2 < two_p (n1 + n2)) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= n1 + n2 - 32)","proofString":"apply (Zbits_unsigned_range (n1 + n2)); lia."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.mulhu v w) (mulhu x y).","conclusion":"vmatch (Val.mulhu v w) (mulhu x y)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct (vincl x (Uns Ptop 1) || vincl y (Uns Ptop 1)) eqn:?; try eapply mulhu_base_sound; eauto; unfold mulhu; rewrite Heqb.\nrewrite orb_true_iff in Heqb.\ndestruct Heqb.\nexploit (vmatch_Uns_1 Ptop v).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\nsimpl.\ninv H; destruct y; auto with va.\nsimpl.\ninv H; destruct y; inv H0; auto with va.\nsimpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va.\nexploit (vmatch_Uns_1 Ptop w).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\ninv H; inv H0; simpl; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va.\ninversion H; inversion H0; subst; eauto using mulhu_base_sound with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 1) || vincl y (Uns Ptop 1) = true) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 1) || vincl y (Uns Ptop 1) = true)","proofString":"rewrite orb_true_iff in Heqb.\ndestruct Heqb.\nexploit (vmatch_Uns_1 Ptop v).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\nsimpl.\ninv H; destruct y; auto with va.\nsimpl.\ninv H; destruct y; inv H0; auto with va.\nsimpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va.\nexploit (vmatch_Uns_1 Ptop w).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\ninv H; inv H0; simpl; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 1) = true \\/ vincl y (Uns Ptop 1) = true) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 1) = true \\/ vincl y (Uns Ptop 1) = true)","proofString":"destruct Heqb.\nexploit (vmatch_Uns_1 Ptop v).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\nsimpl.\ninv H; destruct y; auto with va.\nsimpl.\ninv H; destruct y; inv H0; auto with va.\nsimpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va.\nexploit (vmatch_Uns_1 Ptop w).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\ninv H; inv H0; simpl; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"exploit (vmatch_Uns_1 Ptop v).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\nsimpl.\ninv H; destruct y; auto with va.\nsimpl.\ninv H; destruct y; inv H0; auto with va.\nsimpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch v (Uns Ptop 1).","conclusion":"vmatch v (Uns Ptop 1)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"eapply vmatch_ge; eauto.\neapply vincl_ge; eauto."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vge (Uns Ptop 1) x.","conclusion":"vge (Uns Ptop 1) x","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"eapply vincl_ge; eauto."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one ->\nvmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one ->\nvmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"intros.\ndestruct H2; inv H2.\nsimpl.\ninv H; destruct y; auto with va.\nsimpl.\ninv H; destruct y; inv H0; auto with va.\nsimpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) (H2 : v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) (H2 : v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one)","proofString":"destruct H2; inv H2.\nsimpl.\ninv H; destruct y; auto with va.\nsimpl.\ninv H; destruct y; inv H0; auto with va.\nsimpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch Vundef x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch (Val.mulhu Vundef w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu Vundef w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch Vundef x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"simpl.\ninv H; destruct y; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch Vundef x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch Vundef\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch Vundef\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch Vundef x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"inv H; destruct y; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.zero) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch (Val.mulhu (Vint Int.zero) w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu (Vint Int.zero) w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.zero) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"simpl.\ninv H; destruct y; inv H0; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.zero) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch\n  match w with\n  | Vint n2 => Vint (Int.mulhu Int.zero n2)\n  | _ => Vundef\n  end\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch\n  match w with\n  | Vint n2 => Vint (Int.mulhu Int.zero n2)\n  | _ => Vundef\n  end\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.zero) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"inv H; destruct y; inv H0; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.one) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch (Val.mulhu (Vint Int.one) w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu (Vint Int.one) w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.one) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"simpl.\ninv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va."},{"statement":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.one) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true) : vmatch\n  match w with\n  | Vint n2 => Vint (Int.mulhu Int.one n2)\n  | _ => Vundef\n  end\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch\n  match w with\n  | Vint n2 => Vint (Int.mulhu Int.one n2)\n  | _ => Vundef\n  end\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(x : aval) (w : val) (y : aval) (H : vmatch (Vint Int.one) x) (H0 : vmatch w y) (H1 : vincl x (Uns Ptop 1) = true)","proofString":"inv H; destruct y; inv H0; try rewrite Int.mulhu_commut; try rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"exploit (vmatch_Uns_1 Ptop w).\neapply vmatch_ge; eauto.\neapply vincl_ge; eauto.\nintros.\ndestruct H2; inv H2.\ninv H; inv H0; simpl; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true) : vmatch w (Uns Ptop 1).","conclusion":"vmatch w (Uns Ptop 1)","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"eapply vmatch_ge; eauto.\neapply vincl_ge; eauto."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true) : vge (Uns Ptop 1) y.","conclusion":"vge (Uns Ptop 1) y","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"eapply vincl_ge; eauto."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true) : w = Vundef \\/ w = Vint Int.zero \\/ w = Vint Int.one ->\nvmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"w = Vundef \\/ w = Vint Int.zero \\/ w = Vint Int.one ->\nvmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"intros.\ndestruct H2; inv H2.\ninv H; inv H0; simpl; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true) (H2 : w = Vundef \\/ w = Vint Int.zero \\/ w = Vint Int.one) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : vincl y (Uns Ptop 1) = true) (H2 : w = Vundef \\/ w = Vint Int.zero \\/ w = Vint Int.one)","proofString":"destruct H2; inv H2.\ninv H; inv H0; simpl; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va.\ninv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch Vundef y) (H1 : vincl y (Uns Ptop 1) = true) : vmatch (Val.mulhu v Vundef)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v Vundef)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch Vundef y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"inv H; inv H0; simpl; auto with va."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch (Vint Int.zero) y) (H1 : vincl y (Uns Ptop 1) = true) : vmatch (Val.mulhu v (Vint Int.zero))\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v (Vint Int.zero))\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch (Vint Int.zero) y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"inv H0; inv H; simpl; auto with va; rewrite Int.mulhu_zero; auto with va."},{"statement":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch (Vint Int.one) y) (H1 : vincl y (Uns Ptop 1) = true) : vmatch (Val.mulhu v (Vint Int.one))\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end.","conclusion":"vmatch (Val.mulhu v (Vint Int.one))\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => IU Int.zero\n      end\n  | _ => IU Int.zero\n  end","hypotheses":"(v : val) (x y : aval) (H : vmatch v x) (H0 : vmatch (Vint Int.one) y) (H1 : vincl y (Uns Ptop 1) = true)","proofString":"inv H0; inv H; simpl; auto with va; rewrite Int.mulhu_one; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 1) || vincl y (Uns Ptop 1) = false) : vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => mulhu_base x y\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => mulhu_base x y\n      end\n  | _ => mulhu_base x y\n  end.","conclusion":"vmatch (Val.mulhu v w)\n  match x with\n  | I i1 =>\n      match y with\n      | I i2 => I (Int.mulhu i1 i2)\n      | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => mulhu_base x y\n      end\n  | IU i1 =>\n      match y with\n      | I i2 | IU i2 => IU (Int.mulhu i1 i2)\n      | _ => mulhu_base x y\n      end\n  | _ => mulhu_base x y\n  end","hypotheses":"(v : val) (x : aval) (w : val) (y : aval) (H : vmatch v x) (H0 : vmatch w y) (Heqb : vincl x (Uns Ptop 1) || vincl y (Uns Ptop 1) = false)","proofString":"inversion H; inversion H0; subst; eauto using mulhu_base_sound with va."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divs v w = Some u) : vmatch u (divs x y).","conclusion":"vmatch u (divs x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divs v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct orb eqn:E; inv H1.\nrename i0 into j.\nassert (E': Int.eq j Int.zero = false).\napply orb_false_elim in E.\ntauto.\nassert (Int.signed j <> 0).\nred; intros.\nrewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate.\nset (q := srange x + 1 - Z.log2 (Z.abs (Int.signed j))).\nset (q1 := Z.max 0 ((srange x - 1) + 1 - Z.log2 (Z.abs (Int.signed j)))).\nassert (Z.max 1 q - 1 = q1) by lia.\nassert (vmatch (Vint (Int.divs i j)) (sgn (provenance x) q)).\napply srange_sound in H.\ndestruct H as [A B].\napply range_is_sgn in B; auto.\napply vmatch_sgn'.\napply is_sgn_range.\nlia.\nrewrite ! H2.\napply Zdiv_signed_range; auto.\nlia.\nunfold divs; inv H; inv H0; auto with va; rewrite ? E, ? E'; auto with va."},{"statement":"(i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some u) : vmatch u (divs x y).","conclusion":"vmatch u (divs x y)","hypotheses":"(i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some u)","proofString":"destruct orb eqn:E; inv H1.\nrename i0 into j.\nassert (E': Int.eq j Int.zero = false).\napply orb_false_elim in E.\ntauto.\nassert (Int.signed j <> 0).\nred; intros.\nrewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate.\nset (q := srange x + 1 - Z.log2 (Z.abs (Int.signed j))).\nset (q1 := Z.max 0 ((srange x - 1) + 1 - Z.log2 (Z.abs (Int.signed j)))).\nassert (Z.max 1 q - 1 = q1) by lia.\nassert (vmatch (Vint (Int.divs i j)) (sgn (provenance x) q)).\napply srange_sound in H.\ndestruct H as [A B].\napply range_is_sgn in B; auto.\napply vmatch_sgn'.\napply is_sgn_range.\nlia.\nrewrite ! H2.\napply Zdiv_signed_range; auto.\nlia.\nunfold divs; inv H; inv H0; auto with va; rewrite ? E, ? E'; auto with va."},{"statement":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : vmatch (Vint (Int.divs i i0)) (divs x y).","conclusion":"vmatch (Vint (Int.divs i i0)) (divs x y)","hypotheses":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false)","proofString":"rename i0 into j.\nassert (E': Int.eq j Int.zero = false).\napply orb_false_elim in E.\ntauto.\nassert (Int.signed j <> 0).\nred; intros.\nrewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate.\nset (q := srange x + 1 - Z.log2 (Z.abs (Int.signed j))).\nset (q1 := Z.max 0 ((srange x - 1) + 1 - Z.log2 (Z.abs (Int.signed j)))).\nassert (Z.max 1 q - 1 = q1) by lia.\nassert (vmatch (Vint (Int.divs i j)) (sgn (provenance x) q)).\napply srange_sound in H.\ndestruct H as [A B].\napply range_is_sgn in B; auto.\napply vmatch_sgn'.\napply is_sgn_range.\nlia.\nrewrite ! H2.\napply Zdiv_signed_range; auto.\nlia.\nunfold divs; inv H; inv H0; auto with va; rewrite ? E, ? E'; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) : vmatch (Vint (Int.divs i j)) (divs x y).","conclusion":"vmatch (Vint (Int.divs i j)) (divs x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse)","proofString":"assert (E': Int.eq j Int.zero = false).\napply orb_false_elim in E.\ntauto.\nassert (Int.signed j <> 0).\nred; intros.\nrewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate.\nset (q := srange x + 1 - Z.log2 (Z.abs (Int.signed j))).\nset (q1 := Z.max 0 ((srange x - 1) + 1 - Z.log2 (Z.abs (Int.signed j)))).\nassert (Z.max 1 q - 1 = q1) by lia.\nassert (vmatch (Vint (Int.divs i j)) (sgn (provenance x) q)).\napply srange_sound in H.\ndestruct H as [A B].\napply range_is_sgn in B; auto.\napply vmatch_sgn'.\napply is_sgn_range.\nlia.\nrewrite ! H2.\napply Zdiv_signed_range; auto.\nlia.\nunfold divs; inv H; inv H0; auto with va; rewrite ? E, ? E'; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) : Int.eq j Int.zero = false.","conclusion":"Int.eq j Int.zero = false","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse)","proofString":"apply orb_false_elim in E.\ntauto."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false /\\\nInt.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone = false) : Int.eq j Int.zero = false.","conclusion":"Int.eq j Int.zero = false","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false /\\\nInt.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone = false)","proofString":"tauto."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) : vmatch (Vint (Int.divs i j)) (divs x y).","conclusion":"vmatch (Vint (Int.divs i j)) (divs x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false)","proofString":"assert (Int.signed j <> 0).\nred; intros.\nrewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate.\nset (q := srange x + 1 - Z.log2 (Z.abs (Int.signed j))).\nset (q1 := Z.max 0 ((srange x - 1) + 1 - Z.log2 (Z.abs (Int.signed j)))).\nassert (Z.max 1 q - 1 = q1) by lia.\nassert (vmatch (Vint (Int.divs i j)) (sgn (provenance x) q)).\napply srange_sound in H.\ndestruct H as [A B].\napply range_is_sgn in B; auto.\napply vmatch_sgn'.\napply is_sgn_range.\nlia.\nrewrite ! H2.\napply Zdiv_signed_range; auto.\nlia.\nunfold divs; inv H; inv H0; auto with va; rewrite ? E, ? E'; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) : Int.signed j <> 0.","conclusion":"Int.signed j <> 0","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false)","proofString":"red; intros.\nrewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j = 0)","proofString":"rewrite <- (Int.repr_signed j) in E.\nrewrite H1 in E.\ndiscriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr (Int.signed j)) Int.zero\n|| Int.eq i (Int.repr Int.min_signed) &&\n   Int.eq (Int.repr (Int.signed j)) Int.mone = false) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr (Int.signed j)) Int.zero\n|| Int.eq i (Int.repr Int.min_signed) &&\n   Int.eq (Int.repr (Int.signed j)) Int.mone = false) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j = 0)","proofString":"rewrite H1 in E.\ndiscriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr 0) Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq (Int.repr 0) Int.mone = false) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr 0) Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq (Int.repr 0) Int.mone = false) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j = 0)","proofString":"discriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j <> 0) : vmatch (Vint (Int.divs i j)) (divs x y).","conclusion":"vmatch (Vint (Int.divs i j)) (divs x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j <> 0)","proofString":"set (q := srange x + 1 - Z.log2 (Z.abs (Int.signed j))).\nset (q1 := Z.max 0 ((srange x - 1) + 1 - Z.log2 (Z.abs (Int.signed j)))).\nassert (Z.max 1 q - 1 = q1) by lia.\nassert (vmatch (Vint (Int.divs i j)) (sgn (provenance x) q)).\napply srange_sound in H.\ndestruct H as [A B].\napply range_is_sgn in B; auto.\napply vmatch_sgn'.\napply is_sgn_range.\nlia.\nrewrite ! H2.\napply Zdiv_signed_range; auto.\nlia.\nunfold divs; inv H; inv H0; auto with va; rewrite ? E, ? E'; auto with va."},{"statement":"(i j : int) (x y : aval) (A : 0 < srange x) (B : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j <> 0) (q : Z) (q1 : Z) (H2 : Z.max 1 q - 1 = q1) : 0 < Z.max 1 q.","conclusion":"0 < Z.max 1 q","hypotheses":"(i j : int) (x y : aval) (A : 0 < srange x) (B : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j <> 0) (q : Z) (q1 : Z) (H2 : Z.max 1 q - 1 = q1)","proofString":"lia."},{"statement":"(i j : int) (x y : aval) (A : 0 < srange x) (B : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j <> 0) (q : Z) (q1 : Z) (H2 : Z.max 1 q - 1 = q1) : 0 <= srange x - 1.","conclusion":"0 <= srange x - 1","hypotheses":"(i j : int) (x y : aval) (A : 0 < srange x) (B : - two_p (srange x - 1) <= Int.signed i < two_p (srange x - 1)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq j Int.mone =\nfalse) (E' : Int.eq j Int.zero = false) (H1 : Int.signed j <> 0) (q : Z) (q1 : Z) (H2 : Z.max 1 q - 1 = q1)","proofString":"lia."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divu v w = Some u) : vmatch u (divu x y).","conclusion":"vmatch u (divu x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divu v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\nrename i0 into j.\ndestruct (Int.eq j Int.zero) eqn:E; inv H1.\nassert (Int.unsigned j <> 0).\nred; intros.\nrewrite <- (Int.repr_unsigned j) in E.\nrewrite H1 in E.\ndiscriminate.\nassert (0 < Int.unsigned j).\npose proof (Int.unsigned_range j).\nlia.\nassert (vmatch (Vint (Int.divu i j)) (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))).\napply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto.\nunfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"(i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some u) : vmatch u (divu x y).","conclusion":"vmatch u (divu x y)","hypotheses":"(i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some u)","proofString":"rename i0 into j.\ndestruct (Int.eq j Int.zero) eqn:E; inv H1.\nassert (Int.unsigned j <> 0).\nred; intros.\nrewrite <- (Int.repr_unsigned j) in E.\nrewrite H1 in E.\ndiscriminate.\nassert (0 < Int.unsigned j).\npose proof (Int.unsigned_range j).\nlia.\nassert (vmatch (Vint (Int.divu i j)) (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))).\napply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto.\nunfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"(i j : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (H1 : (if Int.eq j Int.zero then None else Some (Vint (Int.divu i j))) = Some u) : vmatch u (divu x y).","conclusion":"vmatch u (divu x y)","hypotheses":"(i j : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (H1 : (if Int.eq j Int.zero then None else Some (Vint (Int.divu i j))) = Some u)","proofString":"destruct (Int.eq j Int.zero) eqn:E; inv H1.\nassert (Int.unsigned j <> 0).\nred; intros.\nrewrite <- (Int.repr_unsigned j) in E.\nrewrite H1 in E.\ndiscriminate.\nassert (0 < Int.unsigned j).\npose proof (Int.unsigned_range j).\nlia.\nassert (vmatch (Vint (Int.divu i j)) (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))).\napply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto.\nunfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) : vmatch (Vint (Int.divu i j)) (divu x y).","conclusion":"vmatch (Vint (Int.divu i j)) (divu x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false)","proofString":"assert (Int.unsigned j <> 0).\nred; intros.\nrewrite <- (Int.repr_unsigned j) in E.\nrewrite H1 in E.\ndiscriminate.\nassert (0 < Int.unsigned j).\npose proof (Int.unsigned_range j).\nlia.\nassert (vmatch (Vint (Int.divu i j)) (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))).\napply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto.\nunfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) : Int.unsigned j <> 0.","conclusion":"Int.unsigned j <> 0","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false)","proofString":"red; intros.\nrewrite <- (Int.repr_unsigned j) in E.\nrewrite H1 in E.\ndiscriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j = 0)","proofString":"rewrite <- (Int.repr_unsigned j) in E.\nrewrite H1 in E.\ndiscriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr (Int.unsigned j)) Int.zero = false) (H1 : Int.unsigned j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr (Int.unsigned j)) Int.zero = false) (H1 : Int.unsigned j = 0)","proofString":"rewrite H1 in E.\ndiscriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr 0) Int.zero = false) (H1 : Int.unsigned j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq (Int.repr 0) Int.zero = false) (H1 : Int.unsigned j = 0)","proofString":"discriminate."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) : vmatch (Vint (Int.divu i j)) (divu x y).","conclusion":"vmatch (Vint (Int.divu i j)) (divu x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0)","proofString":"assert (0 < Int.unsigned j).\npose proof (Int.unsigned_range j).\nlia.\nassert (vmatch (Vint (Int.divu i j)) (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))).\napply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto.\nunfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) : 0 < Int.unsigned j.","conclusion":"0 < Int.unsigned j","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0)","proofString":"pose proof (Int.unsigned_range j).\nlia."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 <= Int.unsigned j < Int.modulus) : 0 < Int.unsigned j.","conclusion":"0 < Int.unsigned j","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 <= Int.unsigned j < Int.modulus)","proofString":"lia."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : vmatch (Vint (Int.divu i j)) (divu x y).","conclusion":"vmatch (Vint (Int.divu i j)) (divu x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"assert (vmatch (Vint (Int.divu i j)) (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))).\napply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto.\nunfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j))).","conclusion":"vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"apply urange_sound in H.\ndestruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto."},{"statement":"(i j : int) (x y : aval) (H : 0 <= urange x /\\ is_uns (urange x) i) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j))).","conclusion":"vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))","hypotheses":"(i j : int) (x y : aval) (H : 0 <= urange x /\\ is_uns (urange x) i) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"destruct H as [A B].\napply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto."},{"statement":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : is_uns (urange x) i) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j))).","conclusion":"vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))","hypotheses":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : is_uns (urange x) i) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"apply range_is_uns in B; auto.\napply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto."},{"statement":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j))).","conclusion":"vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))","hypotheses":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"apply vmatch_uns'.\napply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto."},{"statement":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : is_uns (Z.max 0 (urange x - Z.log2 (Int.unsigned j))) (Int.divu i j).","conclusion":"is_uns (Z.max 0 (urange x - Z.log2 (Int.unsigned j))) (Int.divu i j)","hypotheses":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"apply is_uns_range.\nlia.\napply Zdiv_unsigned_range; auto."},{"statement":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : 0 <= Z.max 0 (urange x - Z.log2 (Int.unsigned j)).","conclusion":"0 <= Z.max 0 (urange x - Z.log2 (Int.unsigned j))","hypotheses":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"lia."},{"statement":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) : 0 <= Int.unsigned i / Int.unsigned j <\ntwo_p (Z.max 0 (urange x - Z.log2 (Int.unsigned j))).","conclusion":"0 <= Int.unsigned i / Int.unsigned j <\ntwo_p (Z.max 0 (urange x - Z.log2 (Int.unsigned j)))","hypotheses":"(i j : int) (x y : aval) (A : 0 <= urange x) (B : 0 <= Int.unsigned i < two_p (urange x)) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j)","proofString":"apply Zdiv_unsigned_range; auto."},{"statement":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) (H3 : vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j)))) : vmatch (Vint (Int.divu i j)) (divu x y).","conclusion":"vmatch (Vint (Int.divu i j)) (divu x y)","hypotheses":"(i j : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint j) y) (E : Int.eq j Int.zero = false) (H1 : Int.unsigned j <> 0) (H2 : 0 < Int.unsigned j) (H3 : vmatch (Vint (Int.divu i j))\n  (uns (provenance x) (urange x - Z.log2 (Int.unsigned j))))","proofString":"unfold divu; inv H; inv H0; auto with va; rewrite E; auto with va."},{"statement":"forall i j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i j).","conclusion":"forall i j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i j)","hypotheses":"","proofString":"intros.\nunfold Int.mods.\npose proof (is_sgn_ssize j).\napply range_is_sgn in H0; auto with va.\nset (x := Int.signed i) in *.\nset (y := Int.signed j) in *.\nassert (y <> 0).\nunfold y; red; intros.\nrewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate.\nassert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) : is_sgn (ssize j) (Int.mods i j).","conclusion":"is_sgn (ssize j) (Int.mods i j)","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false)","proofString":"unfold Int.mods.\npose proof (is_sgn_ssize j).\napply range_is_sgn in H0; auto with va.\nset (x := Int.signed i) in *.\nset (y := Int.signed j) in *.\nassert (y <> 0).\nunfold y; red; intros.\nrewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate.\nassert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) : is_sgn (ssize j) (Int.repr (Z.rem (Int.signed i) (Int.signed j))).","conclusion":"is_sgn (ssize j) (Int.repr (Z.rem (Int.signed i) (Int.signed j)))","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false)","proofString":"pose proof (is_sgn_ssize j).\napply range_is_sgn in H0; auto with va.\nset (x := Int.signed i) in *.\nset (y := Int.signed j) in *.\nassert (y <> 0).\nunfold y; red; intros.\nrewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate.\nassert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (H0 : is_sgn (ssize j) j) : is_sgn (ssize j) (Int.repr (Z.rem (Int.signed i) (Int.signed j))).","conclusion":"is_sgn (ssize j) (Int.repr (Z.rem (Int.signed i) (Int.signed j)))","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (H0 : is_sgn (ssize j) j)","proofString":"apply range_is_sgn in H0; auto with va.\nset (x := Int.signed i) in *.\nset (y := Int.signed j) in *.\nassert (y <> 0).\nunfold y; red; intros.\nrewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate.\nassert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (H0 : - two_p (ssize j - 1) <= Int.signed j < two_p (ssize j - 1)) : is_sgn (ssize j) (Int.repr (Z.rem (Int.signed i) (Int.signed j))).","conclusion":"is_sgn (ssize j) (Int.repr (Z.rem (Int.signed i) (Int.signed j)))","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (H0 : - two_p (ssize j - 1) <= Int.signed j < two_p (ssize j - 1))","proofString":"set (x := Int.signed i) in *.\nset (y := Int.signed j) in *.\nassert (y <> 0).\nunfold y; red; intros.\nrewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate.\nassert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (H0 : - two_p (ssize j - 1) <= Int.signed j < two_p (ssize j - 1)) (x : Z) : is_sgn (ssize j) (Int.repr (Z.rem x (Int.signed j))).","conclusion":"is_sgn (ssize j) (Int.repr (Z.rem x (Int.signed j)))","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (H0 : - two_p (ssize j - 1) <= Int.signed j < two_p (ssize j - 1)) (x : Z)","proofString":"set (y := Int.signed j) in *.\nassert (y <> 0).\nunfold y; red; intros.\nrewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate.\nassert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : Int.signed j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : Int.signed j = 0)","proofString":"rewrite <- (Int.repr_signed j), H1 in H.\ndiscriminate."},{"statement":"(i j : int) (H : Int.eq (Int.repr 0) Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : Int.signed j = 0) : False.","conclusion":"False","hypotheses":"(i j : int) (H : Int.eq (Int.repr 0) Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : Int.signed j = 0)","proofString":"discriminate."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) : is_sgn (ssize j) (Int.repr (Z.rem x y)).","conclusion":"is_sgn (ssize j) (Int.repr (Z.rem x y))","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0)","proofString":"assert (Z.abs (Z.rem x y) < Z.abs y) by (apply Z.rem_bound_abs; auto).\napply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) (H2 : Z.abs (Z.rem x y) < Z.abs y) : is_sgn (ssize j) (Int.repr (Z.rem x y)).","conclusion":"is_sgn (ssize j) (Int.repr (Z.rem x y))","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) (H2 : Z.abs (Z.rem x y) < Z.abs y)","proofString":"apply is_sgn_range.\nauto with va.\nlia."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) (H2 : Z.abs (Z.rem x y) < Z.abs y) : 0 < ssize j.","conclusion":"0 < ssize j","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) (H2 : Z.abs (Z.rem x y) < Z.abs y)","proofString":"auto with va."},{"statement":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) (H2 : Z.abs (Z.rem x y) < Z.abs y) : - two_p (ssize j - 1) <= Z.rem x y < two_p (ssize j - 1).","conclusion":"- two_p (ssize j - 1) <= Z.rem x y < two_p (ssize j - 1)","hypotheses":"(i j : int) (H : Int.eq j Int.zero = false) (y : Z) (H0 : - two_p (ssize j - 1) <= y < two_p (ssize j - 1)) (x : Z) (H1 : y <> 0) (H2 : Z.abs (Z.rem x y) < Z.abs y)","proofString":"lia."},{"statement":"(SGN : forall i j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i j)) : forall (v w u : val) (x y : aval),\nvmatch v x -> vmatch w y -> Val.mods v w = Some u -> vmatch u (mods x y).","conclusion":"forall (v w u : val) (x y : aval),\nvmatch v x -> vmatch w y -> Val.mods v w = Some u -> vmatch u (mods x y)","hypotheses":"(SGN : forall i j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i j))","proofString":"intros.\ndestruct v; destruct w; try discriminate; simpl in H1.\ndestruct orb eqn:E; inv H1.\nassert (E': Int.eq i0 Int.zero = false).\napply orb_false_elim in E.\ntauto.\nunfold mods; inv H; inv H0; auto with va; rewrite ? E; auto with va."},{"statement":"(SGN : forall i j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i j)) (v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.mods v w = Some u) : vmatch u (mods x y).","conclusion":"vmatch u (mods x y)","hypotheses":"(SGN : forall i j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i j)) (v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.mods v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct orb eqn:E; inv H1.\nassert (E': Int.eq i0 Int.zero = false).\napply orb_false_elim in E.\ntauto.\nunfold mods; inv H; inv H0; auto with va; rewrite ? E; auto with va."},{"statement":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some u) : vmatch u (mods x y).","conclusion":"vmatch u (mods x y)","hypotheses":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some u)","proofString":"destruct orb eqn:E; inv H1.\nassert (E': Int.eq i0 Int.zero = false).\napply orb_false_elim in E.\ntauto.\nunfold mods; inv H; inv H0; auto with va; rewrite ? E; auto with va."},{"statement":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : vmatch (Vint (Int.mods i i0)) (mods x y).","conclusion":"vmatch (Vint (Int.mods i i0)) (mods x y)","hypotheses":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false)","proofString":"assert (E': Int.eq i0 Int.zero = false).\napply orb_false_elim in E.\ntauto.\nunfold mods; inv H; inv H0; auto with va; rewrite ? E; auto with va."},{"statement":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : Int.eq i0 Int.zero = false.","conclusion":"Int.eq i0 Int.zero = false","hypotheses":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false)","proofString":"apply orb_false_elim in E.\ntauto."},{"statement":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero = false /\\\nInt.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) : Int.eq i0 Int.zero = false.","conclusion":"Int.eq i0 Int.zero = false","hypotheses":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero = false /\\\nInt.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false)","proofString":"tauto."},{"statement":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) (E' : Int.eq i0 Int.zero = false) : vmatch (Vint (Int.mods i i0)) (mods x y).","conclusion":"vmatch (Vint (Int.mods i i0)) (mods x y)","hypotheses":"(SGN : forall i1 j : int,\nInt.eq j Int.zero = false -> is_sgn (ssize j) (Int.mods i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (E : Int.eq i0 Int.zero\n|| Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone = false) (E' : Int.eq i0 Int.zero = false)","proofString":"unfold mods; inv H; inv H0; auto with va; rewrite ? E; auto with va."},{"statement":"forall i j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i j).","conclusion":"forall i j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i j)","hypotheses":"","proofString":"intros.\napply is_uns_mon with (usize (Int.modu i j)); auto with va.\nunfold usize, Int.size.\napply Zsize_monotone.\ngeneralize (Int.unsigned_range_2 j); intros RANGE.\nassert (Int.unsigned j <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto.\nexploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) : is_uns (usize j) (Int.modu i j).","conclusion":"is_uns (usize j) (Int.modu i j)","hypotheses":"(i j : int) (H : j <> Int.zero)","proofString":"apply is_uns_mon with (usize (Int.modu i j)); auto with va.\nunfold usize, Int.size.\napply Zsize_monotone.\ngeneralize (Int.unsigned_range_2 j); intros RANGE.\nassert (Int.unsigned j <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto.\nexploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) : usize (Int.modu i j) <= usize j.","conclusion":"usize (Int.modu i j) <= usize j","hypotheses":"(i j : int) (H : j <> Int.zero)","proofString":"unfold usize, Int.size.\napply Zsize_monotone.\ngeneralize (Int.unsigned_range_2 j); intros RANGE.\nassert (Int.unsigned j <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto.\nexploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) : Zsize (Int.unsigned (Int.modu i j)) <= Zsize (Int.unsigned j).","conclusion":"Zsize (Int.unsigned (Int.modu i j)) <= Zsize (Int.unsigned j)","hypotheses":"(i j : int) (H : j <> Int.zero)","proofString":"apply Zsize_monotone.\ngeneralize (Int.unsigned_range_2 j); intros RANGE.\nassert (Int.unsigned j <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto.\nexploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) : 0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j.","conclusion":"0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero)","proofString":"generalize (Int.unsigned_range_2 j); intros RANGE.\nassert (Int.unsigned j <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto.\nexploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) : 0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j.","conclusion":"0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned)","proofString":"assert (Int.unsigned j <> 0).\nred; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto.\nexploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) : Int.unsigned j <> 0.","conclusion":"Int.unsigned j <> 0","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned)","proofString":"red; intros; elim H.\nrewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j = 0) : j = Int.zero.","conclusion":"j = Int.zero","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j = 0)","proofString":"rewrite <- (Int.repr_unsigned j).\nrewrite H0.\nauto."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j = 0) : Int.repr (Int.unsigned j) = Int.zero.","conclusion":"Int.repr (Int.unsigned j) = Int.zero","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j = 0)","proofString":"rewrite H0.\nauto."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j = 0) : Int.repr 0 = Int.zero.","conclusion":"Int.repr 0 = Int.zero","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j = 0)","proofString":"auto."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) : 0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j.","conclusion":"0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0)","proofString":"exploit (Z_mod_lt (Int.unsigned i) (Int.unsigned j)).\nlia.\nintros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) : Int.unsigned j > 0.","conclusion":"Int.unsigned j > 0","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0)","proofString":"lia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j ->\n0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j.","conclusion":"0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j ->\n0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0)","proofString":"intros MOD.\nunfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j) : 0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j.","conclusion":"0 <= Int.unsigned (Int.modu i j) <= Int.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j)","proofString":"unfold Int.modu.\nrewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j) : 0 <= Int.unsigned (Int.repr (Int.unsigned i mod Int.unsigned j)) <=\nInt.unsigned j.","conclusion":"0 <= Int.unsigned (Int.repr (Int.unsigned i mod Int.unsigned j)) <=\nInt.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j)","proofString":"rewrite Int.unsigned_repr.\nlia.\nlia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j) : 0 <= Int.unsigned i mod Int.unsigned j <= Int.unsigned j.","conclusion":"0 <= Int.unsigned i mod Int.unsigned j <= Int.unsigned j","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j)","proofString":"lia."},{"statement":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j) : 0 <= Int.unsigned i mod Int.unsigned j <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned i mod Int.unsigned j <= Int.max_unsigned","hypotheses":"(i j : int) (H : j <> Int.zero) (RANGE : 0 <= Int.unsigned j <= Int.max_unsigned) (H0 : Int.unsigned j <> 0) (MOD : 0 <= Int.unsigned i mod Int.unsigned j < Int.unsigned j)","proofString":"lia."},{"statement":"(UNS : forall i j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i j)) : forall (v w u : val) (x y : aval),\nvmatch v x -> vmatch w y -> Val.modu v w = Some u -> vmatch u (modu x y).","conclusion":"forall (v w u : val) (x y : aval),\nvmatch v x -> vmatch w y -> Val.modu v w = Some u -> vmatch u (modu x y)","hypotheses":"(UNS : forall i j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i j))","proofString":"intros.\ndestruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int.eq i0 Int.zero) eqn:Z; inv H1.\nassert (i0 <> Int.zero) by (generalize (Int.eq_spec i0 Int.zero); rewrite Z; auto).\nunfold modu.\ninv H; inv H0; auto with va; rewrite Z; constructor."},{"statement":"(UNS : forall i j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i j)) (v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.modu v w = Some u) : vmatch u (modu x y).","conclusion":"vmatch u (modu x y)","hypotheses":"(UNS : forall i j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i j)) (v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.modu v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int.eq i0 Int.zero) eqn:Z; inv H1.\nassert (i0 <> Int.zero) by (generalize (Int.eq_spec i0 Int.zero); rewrite Z; auto).\nunfold modu.\ninv H; inv H0; auto with va; rewrite Z; constructor."},{"statement":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some u) : vmatch u (modu x y).","conclusion":"vmatch u (modu x y)","hypotheses":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some u)","proofString":"destruct (Int.eq i0 Int.zero) eqn:Z; inv H1.\nassert (i0 <> Int.zero) by (generalize (Int.eq_spec i0 Int.zero); rewrite Z; auto).\nunfold modu.\ninv H; inv H0; auto with va; rewrite Z; constructor."},{"statement":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (Z : Int.eq i0 Int.zero = false) : vmatch (Vint (Int.modu i i0)) (modu x y).","conclusion":"vmatch (Vint (Int.modu i i0)) (modu x y)","hypotheses":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (Z : Int.eq i0 Int.zero = false)","proofString":"assert (i0 <> Int.zero) by (generalize (Int.eq_spec i0 Int.zero); rewrite Z; auto).\nunfold modu.\ninv H; inv H0; auto with va; rewrite Z; constructor."},{"statement":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (Z : Int.eq i0 Int.zero = false) (H1 : i0 <> Int.zero) : vmatch (Vint (Int.modu i i0)) (modu x y).","conclusion":"vmatch (Vint (Int.modu i i0)) (modu x y)","hypotheses":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (Z : Int.eq i0 Int.zero = false) (H1 : i0 <> Int.zero)","proofString":"unfold modu.\ninv H; inv H0; auto with va; rewrite Z; constructor."},{"statement":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (Z : Int.eq i0 Int.zero = false) (H1 : i0 <> Int.zero) : vmatch (Vint (Int.modu i i0))\n  match y with\n  | I i2 | IU i2 =>\n      match x with\n      | I i1 | IU i1 =>\n          if Int.eq i2 Int.zero\n          then if va_strict tt then Vbot else ntop\n          else I (Int.modu i1 i2)\n      | _ => uns (provenance x) (usize i2)\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch (Vint (Int.modu i i0))\n  match y with\n  | I i2 | IU i2 =>\n      match x with\n      | I i1 | IU i1 =>\n          if Int.eq i2 Int.zero\n          then if va_strict tt then Vbot else ntop\n          else I (Int.modu i1 i2)\n      | _ => uns (provenance x) (usize i2)\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(UNS : forall i1 j : int, j <> Int.zero -> is_uns (usize j) (Int.modu i1 j)) (i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (Z : Int.eq i0 Int.zero = false) (H1 : i0 <> Int.zero)","proofString":"inv H; inv H0; auto with va; rewrite Z; constructor."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.shrx v w = Some u) : vmatch u (shrx x y).","conclusion":"vmatch u (shrx x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.shrx v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int.ltu i0 (Int.repr 31)) eqn:LTU; inv H1.\nunfold shrx; inv H; auto with va; inv H0; auto with va.\nrewrite LTU; auto with va."},{"statement":"(i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.ltu i0 (Int.repr 31) then Some (Vint (Int.shrx i i0)) else None) =\nSome u) : vmatch u (shrx x y).","conclusion":"vmatch u (shrx x y)","hypotheses":"(i i0 : int) (u : val) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.ltu i0 (Int.repr 31) then Some (Vint (Int.shrx i i0)) else None) =\nSome u)","proofString":"destruct (Int.ltu i0 (Int.repr 31)) eqn:LTU; inv H1.\nunfold shrx; inv H; auto with va; inv H0; auto with va.\nrewrite LTU; auto with va."},{"statement":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (LTU : Int.ltu i0 (Int.repr 31) = true) : vmatch (Vint (Int.shrx i i0)) (shrx x y).","conclusion":"vmatch (Vint (Int.shrx i i0)) (shrx x y)","hypotheses":"(i i0 : int) (x y : aval) (H : vmatch (Vint i) x) (H0 : vmatch (Vint i0) y) (LTU : Int.ltu i0 (Int.repr 31) = true)","proofString":"unfold shrx; inv H; auto with va; inv H0; auto with va.\nrewrite LTU; auto with va."},{"statement":"(i i0 : int) (LTU : Int.ltu i0 (Int.repr 31) = true) : vmatch (Vint (Int.shrx i i0))\n  (if Int.ltu i0 (Int.repr 31) then I (Int.shrx i i0) else ntop).","conclusion":"vmatch (Vint (Int.shrx i i0))\n  (if Int.ltu i0 (Int.repr 31) then I (Int.shrx i i0) else ntop)","hypotheses":"(i i0 : int) (LTU : Int.ltu i0 (Int.repr 31) = true)","proofString":"rewrite LTU; auto with va."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (shift_long sem x y).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (shift_long sem x y)","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT:    vmatch (match v, w with            | Vlong i, Vint j => if Int.ltu j Int64.iwordsize'                                 then Vlong (sem i j) else Vundef            | _, _ => Vundef end)           (ntop1 x)).\ndestruct v; try constructor; destruct w; try constructor.\ndestruct (Int.ltu i0 Int64.iwordsize'); constructor.\nunfold shift_long.\ndestruct y; auto.\ndestruct (Int.ltu n Int64.iwordsize') eqn:LT; auto.\ndestruct x; auto.\ninv H; inv H0.\nrewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; try constructor; destruct w; try constructor.\ndestruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(sem : int64 -> int -> int64) (i : int64) (i0 : int) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vint i0) y) : vmatch (if Int.ltu i0 Int64.iwordsize' then Vlong (sem i i0) else Vundef)\n  (ntop1 x).","conclusion":"vmatch (if Int.ltu i0 Int64.iwordsize' then Vlong (sem i i0) else Vundef)\n  (ntop1 x)","hypotheses":"(sem : int64 -> int -> int64) (i : int64) (i0 : int) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vint i0) y)","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (shift_long sem x y).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (shift_long sem x y)","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x))","proofString":"unfold shift_long.\ndestruct y; auto.\ndestruct (Int.ltu n Int64.iwordsize') eqn:LT; auto.\ndestruct x; auto.\ninv H; inv H0.\nrewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match y with\n  | I amount =>\n      if Int.ltu amount Int64.iwordsize'\n      then match x with\n           | L i => L (sem i amount)\n           | _ => ntop1 x\n           end\n      else ntop1 x\n  | _ => ntop1 x\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match y with\n  | I amount =>\n      if Int.ltu amount Int64.iwordsize'\n      then match x with\n           | L i => L (sem i amount)\n           | _ => ntop1 x\n           end\n      else ntop1 x\n  | _ => ntop1 x\n  end","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x))","proofString":"destruct y; auto.\ndestruct (Int.ltu n Int64.iwordsize') eqn:LT; auto.\ndestruct x; auto.\ninv H; inv H0.\nrewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  (if Int.ltu n Int64.iwordsize'\n   then match x with\n        | L i => L (sem i n)\n        | _ => ntop1 x\n        end\n   else ntop1 x).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  (if Int.ltu n Int64.iwordsize'\n   then match x with\n        | L i => L (sem i n)\n        | _ => ntop1 x\n        end\n   else ntop1 x)","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x))","proofString":"destruct (Int.ltu n Int64.iwordsize') eqn:LT; auto.\ndestruct x; auto.\ninv H; inv H0.\nrewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) (LT : Int.ltu n Int64.iwordsize' = true) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end match x with\n      | L i => L (sem i n)\n      | _ => ntop1 x\n      end.","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end match x with\n      | L i => L (sem i n)\n      | _ => ntop1 x\n      end","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (x : aval) (n : int) (H : vmatch v x) (H0 : vmatch w (I n)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) (LT : Int.ltu n Int64.iwordsize' = true)","proofString":"destruct x; auto.\ninv H; inv H0.\nrewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (v w : val) (n0 : int64) (n : int) (H : vmatch v (L n0)) (H0 : vmatch w (I n)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 (L n0))) (LT : Int.ltu n Int64.iwordsize' = true) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (L (sem n0 n)).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (L (sem n0 n))","hypotheses":"(sem : int64 -> int -> int64) (v w : val) (n0 : int64) (n : int) (H : vmatch v (L n0)) (H0 : vmatch w (I n)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j =>\n          if Int.ltu j Int64.iwordsize' then Vlong (sem i j) else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 (L n0))) (LT : Int.ltu n Int64.iwordsize' = true)","proofString":"inv H; inv H0.\nrewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (n0 : int64) (n : int) (DEFAULT : vmatch (if Int.ltu n Int64.iwordsize' then Vlong (sem n0 n) else Vundef)\n  (ntop1 (L n0))) (LT : Int.ltu n Int64.iwordsize' = true) : vmatch (if Int.ltu n Int64.iwordsize' then Vlong (sem n0 n) else Vundef)\n  (L (sem n0 n)).","conclusion":"vmatch (if Int.ltu n Int64.iwordsize' then Vlong (sem n0 n) else Vundef)\n  (L (sem n0 n))","hypotheses":"(sem : int64 -> int -> int64) (n0 : int64) (n : int) (DEFAULT : vmatch (if Int.ltu n Int64.iwordsize' then Vlong (sem n0 n) else Vundef)\n  (ntop1 (L n0))) (LT : Int.ltu n Int64.iwordsize' = true)","proofString":"rewrite LT.\nconstructor."},{"statement":"(sem : int64 -> int -> int64) (n0 : int64) (n : int) (DEFAULT : vmatch (if Int.ltu n Int64.iwordsize' then Vlong (sem n0 n) else Vundef)\n  (ntop1 (L n0))) (LT : Int.ltu n Int64.iwordsize' = true) : vmatch (Vlong (sem n0 n)) (L (sem n0 n)).","conclusion":"vmatch (Vlong (sem n0 n)) (L (sem n0 n))","hypotheses":"(sem : int64 -> int -> int64) (n0 : int64) (n : int) (DEFAULT : vmatch (if Int.ltu n Int64.iwordsize' then Vlong (sem n0 n) else Vundef)\n  (ntop1 (L n0))) (LT : Int.ltu n Int64.iwordsize' = true)","proofString":"constructor."},{"statement":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (rotate_long sem x y).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (rotate_long sem x y)","hypotheses":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (DEFAULT:    vmatch (match v, w with            | Vlong i, Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))            | _, _ => Vundef end)           (ntop1 x)).\ndestruct v; try constructor.\ndestruct w; constructor.\nunfold rotate_long.\ndestruct x; auto.\ndestruct y; auto.\ninv H; inv H0.\nconstructor."},{"statement":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)","hypotheses":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct v; try constructor.\ndestruct w; constructor."},{"statement":"(sem : int64 -> int64 -> int64) (i : int64) (w : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch w y) : vmatch\n  match w with\n  | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n  | _ => Vundef\n  end (ntop1 x).","conclusion":"vmatch\n  match w with\n  | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n  | _ => Vundef\n  end (ntop1 x)","hypotheses":"(sem : int64 -> int64 -> int64) (i : int64) (w : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch w y)","proofString":"destruct w; constructor."},{"statement":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (rotate_long sem x y).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (rotate_long sem x y)","hypotheses":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x))","proofString":"unfold rotate_long.\ndestruct x; auto.\ndestruct y; auto.\ninv H; inv H0.\nconstructor."},{"statement":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x)) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | I amount => L (sem i (Int64.repr (Int.unsigned amount)))\n      | _ => ntop1 x\n      end\n  | _ => ntop1 x\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | I amount => L (sem i (Int64.repr (Int.unsigned amount)))\n      | _ => ntop1 x\n      end\n  | _ => ntop1 x\n  end","hypotheses":"(sem : int64 -> int64 -> int64) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 x))","proofString":"destruct x; auto.\ndestruct y; auto.\ninv H; inv H0.\nconstructor."},{"statement":"(sem : int64 -> int64 -> int64) (v w : val) (n : int64) (y : aval) (H : vmatch v (L n)) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 (L n))) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match y with\n  | I amount => L (sem n (Int64.repr (Int.unsigned amount)))\n  | _ => ntop1 (L n)\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match y with\n  | I amount => L (sem n (Int64.repr (Int.unsigned amount)))\n  | _ => ntop1 (L n)\n  end","hypotheses":"(sem : int64 -> int64 -> int64) (v w : val) (n : int64) (y : aval) (H : vmatch v (L n)) (H0 : vmatch w y) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 (L n)))","proofString":"destruct y; auto.\ninv H; inv H0.\nconstructor."},{"statement":"(sem : int64 -> int64 -> int64) (v w : val) (n : int64) (n0 : int) (H : vmatch v (L n)) (H0 : vmatch w (I n0)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 (L n))) : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (L (sem n (Int64.repr (Int.unsigned n0)))).","conclusion":"vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (L (sem n (Int64.repr (Int.unsigned n0))))","hypotheses":"(sem : int64 -> int64 -> int64) (v w : val) (n : int64) (n0 : int) (H : vmatch v (L n)) (H0 : vmatch w (I n0)) (DEFAULT : vmatch\n  match v with\n  | Vlong i =>\n      match w with\n      | Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (ntop1 (L n)))","proofString":"inv H; inv H0.\nconstructor."},{"statement":"(sem : int64 -> int64 -> int64) (n : int64) (n0 : int) (DEFAULT : vmatch (Vlong (sem n (Int64.repr (Int.unsigned n0)))) (ntop1 (L n))) : vmatch (Vlong (sem n (Int64.repr (Int.unsigned n0))))\n  (L (sem n (Int64.repr (Int.unsigned n0)))).","conclusion":"vmatch (Vlong (sem n (Int64.repr (Int.unsigned n0))))\n  (L (sem n (Int64.repr (Int.unsigned n0))))","hypotheses":"(sem : int64 -> int64 -> int64) (n : int64) (n0 : int) (DEFAULT : vmatch (Vlong (sem n (Int64.repr (Int.unsigned n0)))) (ntop1 (L n)))","proofString":"constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.addl v w) (addl x y).","conclusion":"vmatch (Val.addl v w) (addl x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold Val.addl, addl.\ndestruct Archi.ptr64.\ninv H; inv H0; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto.\ninv H; inv H0; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | L j => L (Int64.add i j)\n      | Ptr p =>\n          Ptr (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | Ifptr p =>\n          Ifptr\n            (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | L i =>\n          Ptr (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i =>\n          Ifptr\n            (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | L j => L (Int64.add i j)\n      | Ptr p =>\n          Ptr (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | Ifptr p =>\n          Ifptr\n            (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | L i =>\n          Ptr (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i =>\n          Ifptr\n            (if Archi.ptr64 then padd p (Ptrofs.of_int64 i) else poffset p)\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct Archi.ptr64.\ninv H; inv H0; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto.\ninv H; inv H0; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | L j => L (Int64.add i j)\n      | Ptr p => Ptr (padd p (Ptrofs.of_int64 i))\n      | Ifptr p => Ifptr (padd p (Ptrofs.of_int64 i))\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | L i => Ptr (padd p (Ptrofs.of_int64 i))\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i => Ifptr (padd p (Ptrofs.of_int64 i))\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 => Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 => Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | L j => L (Int64.add i j)\n      | Ptr p => Ptr (padd p (Ptrofs.of_int64 i))\n      | Ifptr p => Ifptr (padd p (Ptrofs.of_int64 i))\n      | _ => ntop2 x y\n      end\n  | Ptr p =>\n      match y with\n      | L i => Ptr (padd p (Ptrofs.of_int64 i))\n      | _ => Ptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i => Ifptr (padd p (Ptrofs.of_int64 i))\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; constructor;  ((apply padd_sound; assumption) || (eapply poffset_sound; eassumption) || idtac).\napply pmatch_lub_r.\neapply poffset_sound; eauto.\napply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(i : int64) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (plub (poffset p) (poffset p0)).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (plub (poffset p) (poffset p0))","hypotheses":"(i : int64) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0)","proofString":"apply pmatch_lub_r.\neapply poffset_sound; eauto."},{"statement":"(i : int64) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (poffset p0).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (poffset p0)","hypotheses":"(i : int64) (p : aptr) (b : block) (ofs : ptrofs) (p0 : aptr) (H : pmatch b ofs p0)","proofString":"eapply poffset_sound; eauto."},{"statement":"(b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int64) (p0 : aptr) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (plub (poffset p) (poffset p0)).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (plub (poffset p) (poffset p0))","hypotheses":"(b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int64) (p0 : aptr)","proofString":"apply pmatch_lub_l.\neapply poffset_sound; eauto."},{"statement":"(b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int64) (p0 : aptr) : pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (poffset p).","conclusion":"pmatch b (Ptrofs.add ofs (Ptrofs.of_int64 i)) (poffset p)","hypotheses":"(b : block) (ofs : ptrofs) (p : aptr) (H1 : pmatch b ofs p) (i : int64) (p0 : aptr)","proofString":"eapply poffset_sound; eauto."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match w with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | L j => L (Int64.add i j)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p => match y with\n             | Vbot | _ => Ptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match w with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match x with\n  | L i =>\n      match y with\n      | L j => L (Int64.add i j)\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  | Ptr p => match y with\n             | Vbot | _ => Ptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Ptr p0 => Ptr (poffset p0)\n      | Ifptr p0 => Ifptr (plub (poffset p) (poffset p0))\n      | _ => Ifptr (poffset p)\n      end\n  | _ =>\n      match y with\n      | Ptr p => Ptr (poffset p)\n      | Ifptr p => Ifptr (poffset p)\n      | _ => ntop2 x y\n      end\n  end","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; constructor."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.subl v w) (subl x y).","conclusion":"vmatch (Val.subl v w) (subl x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold Val.subl, subl.\ndestruct Archi.ptr64.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va.\ninv H; inv H0; eauto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i1 => match y with\n            | L i2 => L (Int64.sub i1 i2)\n            | _ => ntop2 x y\n            end\n  | Ptr p =>\n      match y with\n      | L i =>\n          if Archi.ptr64\n          then Ptr (psub p (Ptrofs.of_int64 i))\n          else Ifptr (poffset p)\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i =>\n          if Archi.ptr64\n          then Ifptr (psub p (Ptrofs.of_int64 i))\n          else Ifptr (plub (poffset p) (provenance y))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i1 => match y with\n            | L i2 => L (Int64.sub i1 i2)\n            | _ => ntop2 x y\n            end\n  | Ptr p =>\n      match y with\n      | L i =>\n          if Archi.ptr64\n          then Ptr (psub p (Ptrofs.of_int64 i))\n          else Ifptr (poffset p)\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i =>\n          if Archi.ptr64\n          then Ifptr (psub p (Ptrofs.of_int64 i))\n          else Ifptr (plub (poffset p) (provenance y))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"destruct Archi.ptr64.\ninv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va.\ninv H; inv H0; eauto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n      | Vptr b2 ofs2 =>\n          if negb true\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i1 => match y with\n            | L i2 => L (Int64.sub i1 i2)\n            | _ => ntop2 x y\n            end\n  | Ptr p =>\n      match y with\n      | L i => Ptr (psub p (Ptrofs.of_int64 i))\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i => Ifptr (psub p (Ptrofs.of_int64 i))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vlong n2 => Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2))\n      | Vptr b2 ofs2 =>\n          if negb true\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i1 => match y with\n            | L i2 => L (Int64.sub i1 i2)\n            | _ => ntop2 x y\n            end\n  | Ptr p =>\n      match y with\n      | L i => Ptr (psub p (Ptrofs.of_int64 i))\n      | _ => Ifptr (poffset p)\n      end\n  | Ifptr p =>\n      match y with\n      | L i => Ifptr (psub p (Ptrofs.of_int64 i))\n      | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vptr b2 ofs2 =>\n          if negb false\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i1 => match y with\n            | L i2 => L (Int64.sub i1 i2)\n            | _ => ntop2 x y\n            end\n  | Ptr p => match y with\n             | Vbot | _ => Ifptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Vbot | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end.","conclusion":"vmatch\n  match v with\n  | Vlong n1 =>\n      match w with\n      | Vlong n2 => Vlong (Int64.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match w with\n      | Vptr b2 ofs2 =>\n          if negb false\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match x with\n  | L i1 => match y with\n            | L i2 => L (Int64.sub i1 i2)\n            | _ => ntop2 x y\n            end\n  | Ptr p => match y with\n             | Vbot | _ => Ifptr (poffset p)\n             end\n  | Ifptr p =>\n      match y with\n      | Vbot | _ => Ifptr (plub (poffset p) (provenance y))\n      end\n  | _ => ntop2 x y\n  end","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; inv H0; eauto with va."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divls v w = Some u) : vmatch u (divls x y).","conclusion":"vmatch u (divls x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divls v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int64.eq i0 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some u) : vmatch u (divls x y).","conclusion":"vmatch u (divls x y)","hypotheses":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some u)","proofString":"destruct (Int64.eq i0 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.divs i i0)) (divls x y).","conclusion":"vmatch (Vlong (Int64.divs i i0)) (divls x y)","hypotheses":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"inv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.divs i i0)) (divls (L i) (L i0)).","conclusion":"vmatch (Vlong (Int64.divs i i0)) (divls (L i) (L i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"simpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.divs i i0))\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.divs i i0)).","conclusion":"vmatch (Vlong (Int64.divs i i0))\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.divs i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"rewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.divs i i0)) (L (Int64.divs i i0)).","conclusion":"vmatch (Vlong (Int64.divs i i0)) (L (Int64.divs i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"constructor."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divlu v w = Some u) : vmatch u (divlu x y).","conclusion":"vmatch u (divlu x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.divlu v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int64.eq i0 Int64.zero) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome u) : vmatch u (divlu x y).","conclusion":"vmatch u (divlu x y)","hypotheses":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome u)","proofString":"destruct (Int64.eq i0 Int64.zero) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.divu i i0)) (divlu x y).","conclusion":"vmatch (Vlong (Int64.divu i i0)) (divlu x y)","hypotheses":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero = false)","proofString":"inv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.divu i i0)) (divlu (L i) (L i0)).","conclusion":"vmatch (Vlong (Int64.divu i i0)) (divlu (L i) (L i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false)","proofString":"simpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.divu i i0))\n  (if Int64.eq i0 Int64.zero\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.divu i i0)).","conclusion":"vmatch (Vlong (Int64.divu i i0))\n  (if Int64.eq i0 Int64.zero\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.divu i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false)","proofString":"rewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.divu i i0)) (L (Int64.divu i i0)).","conclusion":"vmatch (Vlong (Int64.divu i i0)) (L (Int64.divu i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false)","proofString":"constructor."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.modls v w = Some u) : vmatch u (modls x y).","conclusion":"vmatch u (modls x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.modls v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int64.eq i0 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some u) : vmatch u (modls x y).","conclusion":"vmatch u (modls x y)","hypotheses":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some u)","proofString":"destruct (Int64.eq i0 Int64.zero         || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.mods i i0)) (modls x y).","conclusion":"vmatch (Vlong (Int64.mods i i0)) (modls x y)","hypotheses":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"inv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.mods i i0)) (modls (L i) (L i0)).","conclusion":"vmatch (Vlong (Int64.mods i i0)) (modls (L i) (L i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"simpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.mods i i0))\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.mods i i0)).","conclusion":"vmatch (Vlong (Int64.mods i i0))\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.mods i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"rewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false) : vmatch (Vlong (Int64.mods i i0)) (L (Int64.mods i i0)).","conclusion":"vmatch (Vlong (Int64.mods i i0)) (L (Int64.mods i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero\n|| Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone = false)","proofString":"constructor."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.modlu v w = Some u) : vmatch u (modlu x y).","conclusion":"vmatch u (modlu x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.modlu v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int64.eq i0 Int64.zero) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome u) : vmatch u (modlu x y).","conclusion":"vmatch u (modlu x y)","hypotheses":"(i i0 : int64) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (H1 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome u)","proofString":"destruct (Int64.eq i0 Int64.zero) eqn:E; inv H1.\ninv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.modu i i0)) (modlu x y).","conclusion":"vmatch (Vlong (Int64.modu i i0)) (modlu x y)","hypotheses":"(i i0 : int64) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vlong i0) y) (E : Int64.eq i0 Int64.zero = false)","proofString":"inv H; inv H0; auto with va.\nsimpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.modu i i0)) (modlu (L i) (L i0)).","conclusion":"vmatch (Vlong (Int64.modu i i0)) (modlu (L i) (L i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false)","proofString":"simpl.\nrewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.modu i i0))\n  (if Int64.eq i0 Int64.zero\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.modu i i0)).","conclusion":"vmatch (Vlong (Int64.modu i i0))\n  (if Int64.eq i0 Int64.zero\n   then if va_strict tt then Vbot else ntop\n   else L (Int64.modu i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false)","proofString":"rewrite E.\nconstructor."},{"statement":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false) : vmatch (Vlong (Int64.modu i i0)) (L (Int64.modu i i0)).","conclusion":"vmatch (Vlong (Int64.modu i i0)) (L (Int64.modu i i0))","hypotheses":"(i i0 : int64) (E : Int64.eq i0 Int64.zero = false)","proofString":"constructor."},{"statement":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.shrxl v w = Some u) : vmatch u (shrxl x y).","conclusion":"vmatch u (shrxl x y)","hypotheses":"(v w u : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (H1 : Val.shrxl v w = Some u)","proofString":"destruct v; destruct w; try discriminate; simpl in H1.\ndestruct (Int.ltu i0 (Int.repr 63)) eqn:LTU; inv H1.\nunfold shrxl; inv H; auto with va; inv H0; auto with va.\nrewrite LTU; auto with va."},{"statement":"(i : int64) (i0 : int) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.ltu i0 (Int.repr 63) then Some (Vlong (Int64.shrx' i i0)) else None) =\nSome u) : vmatch u (shrxl x y).","conclusion":"vmatch u (shrxl x y)","hypotheses":"(i : int64) (i0 : int) (u : val) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vint i0) y) (H1 : (if Int.ltu i0 (Int.repr 63) then Some (Vlong (Int64.shrx' i i0)) else None) =\nSome u)","proofString":"destruct (Int.ltu i0 (Int.repr 63)) eqn:LTU; inv H1.\nunfold shrxl; inv H; auto with va; inv H0; auto with va.\nrewrite LTU; auto with va."},{"statement":"(i : int64) (i0 : int) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vint i0) y) (LTU : Int.ltu i0 (Int.repr 63) = true) : vmatch (Vlong (Int64.shrx' i i0)) (shrxl x y).","conclusion":"vmatch (Vlong (Int64.shrx' i i0)) (shrxl x y)","hypotheses":"(i : int64) (i0 : int) (x y : aval) (H : vmatch (Vlong i) x) (H0 : vmatch (Vint i0) y) (LTU : Int.ltu i0 (Int.repr 63) = true)","proofString":"unfold shrxl; inv H; auto with va; inv H0; auto with va.\nrewrite LTU; auto with va."},{"statement":"(i : int64) (i0 : int) (LTU : Int.ltu i0 (Int.repr 63) = true) : vmatch (Vlong (Int64.shrx' i i0))\n  (if Int.ltu i0 (Int.repr 63) then L (Int64.shrx' i i0) else ntop).","conclusion":"vmatch (Vlong (Int64.shrx' i i0))\n  (if Int.ltu i0 (Int.repr 63) then L (Int64.shrx' i i0) else ntop)","hypotheses":"(i : int64) (i0 : int) (LTU : Int.ltu i0 (Int.repr 63) = true)","proofString":"rewrite LTU; auto with va."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : vmatch (Val.rolml v amount mask) (rolml x amount mask).","conclusion":"vmatch (Val.rolml v amount mask) (rolml x amount mask)","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"replace (Val.rolml v amount mask) with (Val.andl (Val.roll v (Vint amount)) (Vlong mask)).\napply andl_sound.\napply roll_sound.\nauto.\nconstructor.\nconstructor.\ndestruct v; auto."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : vmatch (Val.andl (Val.roll v (Vint amount)) (Vlong mask))\n  (rolml x amount mask).","conclusion":"vmatch (Val.andl (Val.roll v (Vint amount)) (Vlong mask))\n  (rolml x amount mask)","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"apply andl_sound.\napply roll_sound.\nauto.\nconstructor.\nconstructor."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : vmatch (Val.roll v (Vint amount)) (roll x (I amount)).","conclusion":"vmatch (Val.roll v (Vint amount)) (roll x (I amount))","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"apply roll_sound.\nauto.\nconstructor."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : vmatch v x.","conclusion":"vmatch v x","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"auto."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : vmatch (Vint amount) (I amount).","conclusion":"vmatch (Vint amount) (I amount)","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"constructor."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : vmatch (Vlong mask) (L mask).","conclusion":"vmatch (Vlong mask) (L mask)","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"constructor."},{"statement":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x) : Val.andl (Val.roll v (Vint amount)) (Vlong mask) = Val.rolml v amount mask.","conclusion":"Val.andl (Val.roll v (Vint amount)) (Vlong mask) = Val.rolml v amount mask","hypotheses":"(v : val) (x : aval) (amount : int) (mask : int64) (H : vmatch v x)","proofString":"destruct v; auto."},{"statement":"(v : val) (x : aval) (n : ptrofs) (H : vmatch v x) : vmatch (Val.offset_ptr v n) (offset_ptr x n).","conclusion":"vmatch (Val.offset_ptr v n) (offset_ptr x n)","hypotheses":"(v : val) (x : aval) (n : ptrofs) (H : vmatch v x)","proofString":"unfold Val.offset_ptr, offset_ptr.\ninv H; constructor; apply padd_sound; assumption."},{"statement":"(v : val) (x : aval) (n : ptrofs) (H : vmatch v x) : vmatch\n  match v with\n  | Vptr b ofs => Vptr b (Ptrofs.add ofs n)\n  | _ => Vundef\n  end\n  match x with\n  | Ptr p => Ptr (padd p n)\n  | Ifptr p => Ifptr (padd p n)\n  | _ => ntop1 x\n  end.","conclusion":"vmatch\n  match v with\n  | Vptr b ofs => Vptr b (Ptrofs.add ofs n)\n  | _ => Vundef\n  end\n  match x with\n  | Ptr p => Ptr (padd p n)\n  | Ifptr p => Ifptr (padd p n)\n  | _ => ntop1 x\n  end","hypotheses":"(v : val) (x : aval) (n : ptrofs) (H : vmatch v x)","proofString":"inv H; constructor; apply padd_sound; assumption."},{"statement":"forall (nbits : Z) (i : int), is_uns nbits (Int.zero_ext nbits i).","conclusion":"forall (nbits : Z) (i : int), is_uns nbits (Int.zero_ext nbits i)","hypotheses":"","proofString":"intros; red; intros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; auto."},{"statement":"(nbits : Z) (i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= nbits) : Int.testbit (Int.zero_ext nbits i) m = false.","conclusion":"Int.testbit (Int.zero_ext nbits i) m = false","hypotheses":"(nbits : Z) (i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= nbits)","proofString":"rewrite Int.bits_zero_ext by lia.\napply zlt_false; auto."},{"statement":"(nbits : Z) (i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= nbits) : (if zlt m nbits then Int.testbit i m else false) = false.","conclusion":"(if zlt m nbits then Int.testbit i m else false) = false","hypotheses":"(nbits : Z) (i : int) (m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= nbits)","proofString":"apply zlt_false; auto."},{"statement":"(DFL : forall (nbits : Z) (i : int), is_uns nbits (Int.zero_ext nbits i)) : forall (nbits : Z) (v : val) (x : aval),\nvmatch v x -> vmatch (Val.zero_ext nbits v) (zero_ext nbits x).","conclusion":"forall (nbits : Z) (v : val) (x : aval),\nvmatch v x -> vmatch (Val.zero_ext nbits v) (zero_ext nbits x)","hypotheses":"(DFL : forall (nbits : Z) (i : int), is_uns nbits (Int.zero_ext nbits i))","proofString":"intros.\ninv H; simpl; auto with va.\napply vmatch_uns.\nred; intros.\nzify.\nrewrite Int.bits_zero_ext by lia.\ndestruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i : int), is_uns nbits0 (Int.zero_ext nbits0 i)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) : vmatch (Val.zero_ext nbits v) (zero_ext nbits x).","conclusion":"vmatch (Val.zero_ext nbits v) (zero_ext nbits x)","hypotheses":"(DFL : forall (nbits0 : Z) (i : int), is_uns nbits0 (Int.zero_ext nbits0 i)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x)","proofString":"inv H; simpl; auto with va.\napply vmatch_uns.\nred; intros.\nzify.\nrewrite Int.bits_zero_ext by lia.\ndestruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) : vmatch (Vint (Int.zero_ext nbits i)) (uns p (Z.min n nbits)).","conclusion":"vmatch (Vint (Int.zero_ext nbits i)) (uns p (Z.min n nbits))","hypotheses":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i)","proofString":"apply vmatch_uns.\nred; intros.\nzify.\nrewrite Int.bits_zero_ext by lia.\ndestruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) : is_uns (Z.min n nbits) (Int.zero_ext nbits i).","conclusion":"is_uns (Z.min n nbits) (Int.zero_ext nbits i)","hypotheses":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i)","proofString":"red; intros.\nzify.\nrewrite Int.bits_zero_ext by lia.\ndestruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.min n nbits) : Int.testbit (Int.zero_ext nbits i) m = false.","conclusion":"Int.testbit (Int.zero_ext nbits i) m = false","hypotheses":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (H2 : m >= Z.min n nbits)","proofString":"zify.\nrewrite Int.bits_zero_ext by lia.\ndestruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : n < nbits /\\ z3 = n \\/ nbits <= n /\\ z3 = nbits) : Int.testbit (Int.zero_ext nbits i) m = false.","conclusion":"Int.testbit (Int.zero_ext nbits i) m = false","hypotheses":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : n < nbits /\\ z3 = n \\/ nbits <= n /\\ z3 = nbits)","proofString":"rewrite Int.bits_zero_ext by lia.\ndestruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : n < nbits /\\ z3 = n \\/ nbits <= n /\\ z3 = nbits) : (if zlt m nbits then Int.testbit i m else false) = false.","conclusion":"(if zlt m nbits then Int.testbit i m else false) = false","hypotheses":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : n < nbits /\\ z3 = n \\/ nbits <= n /\\ z3 = nbits)","proofString":"destruct (zlt m nbits); auto.\napply H1; lia."},{"statement":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : n < nbits /\\ z3 = n \\/ nbits <= n /\\ z3 = nbits) (l : m < nbits) : Int.testbit i m = false.","conclusion":"Int.testbit i m = false","hypotheses":"(DFL : forall (nbits0 : Z) (i0 : int), is_uns nbits0 (Int.zero_ext nbits0 i0)) (nbits : Z) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (m : Z) (H : 0 <= m < Int.zwordsize) (z3 : Z) (H2 : m >= z3) (H3 : n < nbits /\\ z3 = n \\/ nbits <= n /\\ z3 = nbits) (l : m < nbits)","proofString":"apply H1; lia."},{"statement":"forall (p : aptr) (nbits : Z) (i : int),\n0 < nbits -> vmatch (Vint (Int.sign_ext nbits i)) (sgn p nbits).","conclusion":"forall (p : aptr) (nbits : Z) (i : int),\n0 < nbits -> vmatch (Vint (Int.sign_ext nbits i)) (sgn p nbits)","hypotheses":"","proofString":"intros.\napply vmatch_sgn.\napply is_sign_ext_sgn; auto with va."},{"statement":"(p : aptr) (nbits : Z) (i : int) (H : 0 < nbits) : vmatch (Vint (Int.sign_ext nbits i)) (sgn p nbits).","conclusion":"vmatch (Vint (Int.sign_ext nbits i)) (sgn p nbits)","hypotheses":"(p : aptr) (nbits : Z) (i : int) (H : 0 < nbits)","proofString":"apply vmatch_sgn.\napply is_sign_ext_sgn; auto with va."},{"statement":"(p : aptr) (nbits : Z) (i : int) (H : 0 < nbits) : is_sgn nbits (Int.sign_ext nbits i).","conclusion":"is_sgn nbits (Int.sign_ext nbits i)","hypotheses":"(p : aptr) (nbits : Z) (i : int) (H : 0 < nbits)","proofString":"apply is_sign_ext_sgn; auto with va."},{"statement":"(DFL : forall (p : aptr) (nbits : Z) (i : int),\n0 < nbits -> vmatch (Vint (Int.sign_ext nbits i)) (sgn p nbits)) : forall (nbits : Z) (v : val) (x : aval),\nvmatch v x -> vmatch (Val.sign_ext nbits v) (sign_ext nbits x).","conclusion":"forall (nbits : Z) (v : val) (x : aval),\nvmatch v x -> vmatch (Val.sign_ext nbits v) (sign_ext nbits x)","hypotheses":"(DFL : forall (p : aptr) (nbits : Z) (i : int),\n0 < nbits -> vmatch (Vint (Int.sign_ext nbits i)) (sgn p nbits))","proofString":"intros.\nunfold sign_ext.\ndestruct (zle nbits 0).\ndestruct v; simpl; auto with va.\nconstructor.\nlia.\nrewrite Int.sign_ext_below by auto.\nred; intros; apply Int.bits_zero.\ninv H; simpl; auto with va.\ndestruct (zlt n nbits); eauto with va.\nconstructor; auto.\neapply is_sign_ext_uns; eauto with va.\ndestruct (zlt n nbits); auto with va.\napply vmatch_sgn.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) : vmatch (Val.sign_ext nbits v) (sign_ext nbits x).","conclusion":"vmatch (Val.sign_ext nbits v) (sign_ext nbits x)","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x)","proofString":"unfold sign_ext.\ndestruct (zle nbits 0).\ndestruct v; simpl; auto with va.\nconstructor.\nlia.\nrewrite Int.sign_ext_below by auto.\nred; intros; apply Int.bits_zero.\ninv H; simpl; auto with va.\ndestruct (zlt n nbits); eauto with va.\nconstructor; auto.\neapply is_sign_ext_uns; eauto with va.\ndestruct (zlt n nbits); auto with va.\napply vmatch_sgn.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) : vmatch (Val.sign_ext nbits v)\n  (if zle nbits 0\n   then Uns (provenance x) 0\n   else\n    match x with\n    | I i => I (Int.sign_ext nbits i)\n    | IU i => IU (Int.sign_ext nbits i)\n    | Uns p n => if zlt n nbits then Uns p n else sgn p nbits\n    | Sgn p n => sgn p (Z.min n nbits)\n    | _ => sgn (provenance x) nbits\n    end).","conclusion":"vmatch (Val.sign_ext nbits v)\n  (if zle nbits 0\n   then Uns (provenance x) 0\n   else\n    match x with\n    | I i => I (Int.sign_ext nbits i)\n    | IU i => IU (Int.sign_ext nbits i)\n    | Uns p n => if zlt n nbits then Uns p n else sgn p nbits\n    | Sgn p n => sgn p (Z.min n nbits)\n    | _ => sgn (provenance x) nbits\n    end)","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x)","proofString":"destruct (zle nbits 0).\ndestruct v; simpl; auto with va.\nconstructor.\nlia.\nrewrite Int.sign_ext_below by auto.\nred; intros; apply Int.bits_zero.\ninv H; simpl; auto with va.\ndestruct (zlt n nbits); eauto with va.\nconstructor; auto.\neapply is_sign_ext_uns; eauto with va.\ndestruct (zlt n nbits); auto with va.\napply vmatch_sgn.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) (l : nbits <= 0) : vmatch (Val.sign_ext nbits v) (Uns (provenance x) 0).","conclusion":"vmatch (Val.sign_ext nbits v) (Uns (provenance x) 0)","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) (l : nbits <= 0)","proofString":"destruct v; simpl; auto with va.\nconstructor.\nlia.\nrewrite Int.sign_ext_below by auto.\nred; intros; apply Int.bits_zero."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0) : vmatch (Vint (Int.sign_ext nbits i)) (Uns (provenance x) 0).","conclusion":"vmatch (Vint (Int.sign_ext nbits i)) (Uns (provenance x) 0)","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0)","proofString":"constructor.\nlia.\nrewrite Int.sign_ext_below by auto.\nred; intros; apply Int.bits_zero."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0) : 0 <= 0.","conclusion":"0 <= 0","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0)","proofString":"lia."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0) : is_uns 0 (Int.sign_ext nbits i).","conclusion":"is_uns 0 (Int.sign_ext nbits i)","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0)","proofString":"rewrite Int.sign_ext_below by auto.\nred; intros; apply Int.bits_zero."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0) : is_uns 0 Int.zero.","conclusion":"is_uns 0 Int.zero","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p nbits0)) (nbits : Z) (i : int) (x : aval) (H : vmatch (Vint i) x) (l : nbits <= 0)","proofString":"red; intros; apply Int.bits_zero."},{"statement":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) (g : nbits > 0) : vmatch (Val.sign_ext nbits v)\n  match x with\n  | I i => I (Int.sign_ext nbits i)\n  | IU i => IU (Int.sign_ext nbits i)\n  | Uns p n => if zlt n nbits then Uns p n else sgn p nbits\n  | Sgn p n => sgn p (Z.min n nbits)\n  | _ => sgn (provenance x) nbits\n  end.","conclusion":"vmatch (Val.sign_ext nbits v)\n  match x with\n  | I i => I (Int.sign_ext nbits i)\n  | IU i => IU (Int.sign_ext nbits i)\n  | Uns p n => if zlt n nbits then Uns p n else sgn p nbits\n  | Sgn p n => sgn p (Z.min n nbits)\n  | _ => sgn (provenance x) nbits\n  end","hypotheses":"(DFL : forall (p : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p nbits0)) (nbits : Z) (v : val) (x : aval) (H : vmatch v x) (g : nbits > 0)","proofString":"inv H; simpl; auto with va.\ndestruct (zlt n nbits); eauto with va.\nconstructor; auto.\neapply is_sign_ext_uns; eauto with va.\ndestruct (zlt n nbits); auto with va.\napply vmatch_sgn.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) : vmatch (Vint (Int.sign_ext nbits i))\n  (if zlt n nbits then Uns p n else sgn p nbits).","conclusion":"vmatch (Vint (Int.sign_ext nbits i))\n  (if zlt n nbits then Uns p n else sgn p nbits)","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i)","proofString":"destruct (zlt n nbits); eauto with va.\nconstructor; auto.\neapply is_sign_ext_uns; eauto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (l : n < nbits) : vmatch (Vint (Int.sign_ext nbits i)) (Uns p n).","conclusion":"vmatch (Vint (Int.sign_ext nbits i)) (Uns p n)","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (l : n < nbits)","proofString":"constructor; auto.\neapply is_sign_ext_uns; eauto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (l : n < nbits) : is_uns n (Int.sign_ext nbits i).","conclusion":"is_uns n (Int.sign_ext nbits i)","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (l : n < nbits)","proofString":"eapply is_sign_ext_uns; eauto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (n : Z) : vmatch Vundef (if zlt n nbits then Uns p n else sgn p nbits).","conclusion":"vmatch Vundef (if zlt n nbits then Uns p n else sgn p nbits)","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (n : Z)","proofString":"destruct (zlt n nbits); auto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 < n) (H1 : is_sgn n i) : vmatch (Vint (Int.sign_ext nbits i)) (sgn p (Z.min n nbits)).","conclusion":"vmatch (Vint (Int.sign_ext nbits i)) (sgn p (Z.min n nbits))","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 < n) (H1 : is_sgn n i)","proofString":"apply vmatch_sgn.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 < n) (H1 : is_sgn n i) : is_sgn (Z.min n nbits) (Int.sign_ext nbits i).","conclusion":"is_sgn (Z.min n nbits) (Int.sign_ext nbits i)","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 < n) (H1 : is_sgn n i)","proofString":"apply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 < n) (H1 : is_sgn n i) : is_sgn (Z.min n nbits) i \\/ nbits <= Z.min n nbits.","conclusion":"is_sgn (Z.min n nbits) i \\/ nbits <= Z.min n nbits","hypotheses":"(DFL : forall (p0 : aptr) (nbits0 : Z) (i0 : int),\n0 < nbits0 -> vmatch (Vint (Int.sign_ext nbits0 i0)) (sgn p0 nbits0)) (nbits : Z) (g : nbits > 0) (p : aptr) (i : int) (n : Z) (H0 : 0 < n) (H1 : is_sgn n i)","proofString":"apply Z.min_case; auto with va."},{"statement":"(s : Z) : forall (v : val) (x : aval),\nvmatch v x -> vmatch (Val.zero_ext_l s v) (zero_ext_l s x).","conclusion":"forall (v : val) (x : aval),\nvmatch v x -> vmatch (Val.zero_ext_l s v) (zero_ext_l s x)","hypotheses":"(s : Z)","proofString":"exact (unop_long_sound (Int64.zero_ext s))."},{"statement":"(s : Z) : forall (v : val) (x : aval),\nvmatch v x -> vmatch (Val.sign_ext_l s v) (sign_ext_l s x).","conclusion":"forall (v : val) (x : aval),\nvmatch v x -> vmatch (Val.sign_ext_l s v) (sign_ext_l s x)","hypotheses":"(s : Z)","proofString":"exact (unop_long_sound (Int64.sign_ext s))."},{"statement":"(v : val) (x : aval) (H : vmatch v x) : vmatch (Val.singleoffloat v) (singleoffloat x).","conclusion":"vmatch (Val.singleoffloat v) (singleoffloat x)","hypotheses":"(v : val) (x : aval) (H : vmatch v x)","proofString":"assert (DEFAULT: vmatch (Val.singleoffloat v) (ntop1 x)).\ndestruct v; constructor.\ndestruct x; auto.\ninv H.\nconstructor."},{"statement":"(v : val) (x : aval) (H : vmatch v x) : vmatch (Val.singleoffloat v) (ntop1 x).","conclusion":"vmatch (Val.singleoffloat v) (ntop1 x)","hypotheses":"(v : val) (x : aval) (H : vmatch v x)","proofString":"destruct v; constructor."},{"statement":"(v : val) (x : aval) (H : vmatch v x) (DEFAULT : vmatch (Val.singleoffloat v) (ntop1 x)) : vmatch (Val.singleoffloat v) (singleoffloat x).","conclusion":"vmatch (Val.singleoffloat v) (singleoffloat x)","hypotheses":"(v : val) (x : aval) (H : vmatch v x) (DEFAULT : vmatch (Val.singleoffloat v) (ntop1 x))","proofString":"destruct x; auto.\ninv H.\nconstructor."},{"statement":"(v : val) (f : float) (H : vmatch v (F f)) (DEFAULT : vmatch (Val.singleoffloat v) (ntop1 (F f))) : vmatch (Val.singleoffloat v) (singleoffloat (F f)).","conclusion":"vmatch (Val.singleoffloat v) (singleoffloat (F f))","hypotheses":"(v : val) (f : float) (H : vmatch v (F f)) (DEFAULT : vmatch (Val.singleoffloat v) (ntop1 (F f)))","proofString":"inv H.\nconstructor."},{"statement":"(f : float) (DEFAULT : vmatch (Val.singleoffloat (Vfloat f)) (ntop1 (F f))) : vmatch (Val.singleoffloat (Vfloat f)) (singleoffloat (F f)).","conclusion":"vmatch (Val.singleoffloat (Vfloat f)) (singleoffloat (F f))","hypotheses":"(f : float) (DEFAULT : vmatch (Val.singleoffloat (Vfloat f)) (ntop1 (F f)))","proofString":"constructor."},{"statement":"(v : val) (x : aval) (H : vmatch v x) : vmatch (Val.floatofsingle v) (floatofsingle x).","conclusion":"vmatch (Val.floatofsingle v) (floatofsingle x)","hypotheses":"(v : val) (x : aval) (H : vmatch v x)","proofString":"assert (DEFAULT: vmatch (Val.floatofsingle v) (ntop1 x)).\ndestruct v; constructor.\ndestruct x; auto.\ninv H.\nconstructor."},{"statement":"(v : val) (x : aval) (H : vmatch v x) : vmatch (Val.floatofsingle v) (ntop1 x).","conclusion":"vmatch (Val.floatofsingle v) (ntop1 x)","hypotheses":"(v : val) (x : aval) (H : vmatch v x)","proofString":"destruct v; constructor."},{"statement":"(v : val) (x : aval) (H : vmatch v x) (DEFAULT : vmatch (Val.floatofsingle v) (ntop1 x)) : vmatch (Val.floatofsingle v) (floatofsingle x).","conclusion":"vmatch (Val.floatofsingle v) (floatofsingle x)","hypotheses":"(v : val) (x : aval) (H : vmatch v x) (DEFAULT : vmatch (Val.floatofsingle v) (ntop1 x))","proofString":"destruct x; auto.\ninv H.\nconstructor."},{"statement":"(v : val) (f : float32) (H : vmatch v (FS f)) (DEFAULT : vmatch (Val.floatofsingle v) (ntop1 (FS f))) : vmatch (Val.floatofsingle v) (floatofsingle (FS f)).","conclusion":"vmatch (Val.floatofsingle v) (floatofsingle (FS f))","hypotheses":"(v : val) (f : float32) (H : vmatch v (FS f)) (DEFAULT : vmatch (Val.floatofsingle v) (ntop1 (FS f)))","proofString":"inv H.\nconstructor."},{"statement":"(f : float32) (DEFAULT : vmatch (Val.floatofsingle (Vsingle f)) (ntop1 (FS f))) : vmatch (Val.floatofsingle (Vsingle f)) (floatofsingle (FS f)).","conclusion":"vmatch (Val.floatofsingle (Vsingle f)) (floatofsingle (FS f))","hypotheses":"(f : float32) (DEFAULT : vmatch (Val.floatofsingle (Vsingle f)) (ntop1 (FS f)))","proofString":"constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vint (Float.to_int f)\n| _ => None\nend = Some w) : vmatch w (intoffloat x).","conclusion":"vmatch w (intoffloat x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vint (Float.to_int f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float.to_int f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vint (Float.to_int f) = Some w) : vmatch w (intoffloat x).","conclusion":"vmatch w (intoffloat x)","hypotheses":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vint (Float.to_int f) = Some w)","proofString":"destruct (Float.to_int f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int) (E : Float.to_int f = Some i) : vmatch (Vint i) (intoffloat x).","conclusion":"vmatch (Vint i) (intoffloat x)","hypotheses":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int) (E : Float.to_int f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (i : int) (E : Float.to_int f = Some i) : vmatch (Vint i)\n  match Float.to_int f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vint i)\n  match Float.to_int f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float) (i : int) (E : Float.to_int f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vint (Float.to_intu f)\n| _ => None\nend = Some w) : vmatch w (intuoffloat x).","conclusion":"vmatch w (intuoffloat x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vint (Float.to_intu f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float.to_intu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vint (Float.to_intu f) = Some w) : vmatch w (intuoffloat x).","conclusion":"vmatch w (intuoffloat x)","hypotheses":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vint (Float.to_intu f) = Some w)","proofString":"destruct (Float.to_intu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int) (E : Float.to_intu f = Some i) : vmatch (Vint i) (intuoffloat x).","conclusion":"vmatch (Vint i) (intuoffloat x)","hypotheses":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int) (E : Float.to_intu f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (i : int) (E : Float.to_intu f = Some i) : vmatch (Vint i)\n  match Float.to_intu f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vint i)\n  match Float.to_intu f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float) (i : int) (E : Float.to_intu f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vfloat (Float.of_int n))\n| _ => None\nend = Some w) : vmatch w (floatofint x).","conclusion":"vmatch w (floatofint x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vfloat (Float.of_int n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int) (x : aval) (H : vmatch (Vint i) x) : vmatch (Vfloat (Float.of_int i)) (floatofint x).","conclusion":"vmatch (Vfloat (Float.of_int i)) (floatofint x)","hypotheses":"(i : int) (x : aval) (H : vmatch (Vint i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vfloat (Float.of_intu n))\n| _ => None\nend = Some w) : vmatch w (floatofintu x).","conclusion":"vmatch w (floatofintu x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vfloat (Float.of_intu n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int) (x : aval) (H : vmatch (Vint i) x) : vmatch (Vfloat (Float.of_intu i)) (floatofintu x).","conclusion":"vmatch (Vfloat (Float.of_intu i)) (floatofintu x)","hypotheses":"(i : int) (x : aval) (H : vmatch (Vint i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vint (Float32.to_int f)\n| _ => None\nend = Some w) : vmatch w (intofsingle x).","conclusion":"vmatch w (intofsingle x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vint (Float32.to_int f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float32.to_int f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vint (Float32.to_int f) = Some w) : vmatch w (intofsingle x).","conclusion":"vmatch w (intofsingle x)","hypotheses":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vint (Float32.to_int f) = Some w)","proofString":"destruct (Float32.to_int f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int) (E : Float32.to_int f = Some i) : vmatch (Vint i) (intofsingle x).","conclusion":"vmatch (Vint i) (intofsingle x)","hypotheses":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int) (E : Float32.to_int f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (i : int) (E : Float32.to_int f = Some i) : vmatch (Vint i)\n  match Float32.to_int f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vint i)\n  match Float32.to_int f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float32) (i : int) (E : Float32.to_int f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vint (Float32.to_intu f)\n| _ => None\nend = Some w) : vmatch w (intuofsingle x).","conclusion":"vmatch w (intuofsingle x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vint (Float32.to_intu f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float32.to_intu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vint (Float32.to_intu f) = Some w) : vmatch w (intuofsingle x).","conclusion":"vmatch w (intuofsingle x)","hypotheses":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vint (Float32.to_intu f) = Some w)","proofString":"destruct (Float32.to_intu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int) (E : Float32.to_intu f = Some i) : vmatch (Vint i) (intuofsingle x).","conclusion":"vmatch (Vint i) (intuofsingle x)","hypotheses":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int) (E : Float32.to_intu f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (i : int) (E : Float32.to_intu f = Some i) : vmatch (Vint i)\n  match Float32.to_intu f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vint i)\n  match Float32.to_intu f with\n  | Some i0 => I i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float32) (i : int) (E : Float32.to_intu f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vsingle (Float32.of_int n))\n| _ => None\nend = Some w) : vmatch w (singleofint x).","conclusion":"vmatch w (singleofint x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vsingle (Float32.of_int n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int) (x : aval) (H : vmatch (Vint i) x) : vmatch (Vsingle (Float32.of_int i)) (singleofint x).","conclusion":"vmatch (Vsingle (Float32.of_int i)) (singleofint x)","hypotheses":"(i : int) (x : aval) (H : vmatch (Vint i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vsingle (Float32.of_intu n))\n| _ => None\nend = Some w) : vmatch w (singleofintu x).","conclusion":"vmatch w (singleofintu x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vint n => Some (Vsingle (Float32.of_intu n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int) (x : aval) (H : vmatch (Vint i) x) : vmatch (Vsingle (Float32.of_intu i)) (singleofintu x).","conclusion":"vmatch (Vsingle (Float32.of_intu i)) (singleofintu x)","hypotheses":"(i : int) (x : aval) (H : vmatch (Vint i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vlong (Float.to_long f)\n| _ => None\nend = Some w) : vmatch w (longoffloat x).","conclusion":"vmatch w (longoffloat x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vlong (Float.to_long f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float.to_long f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vlong (Float.to_long f) = Some w) : vmatch w (longoffloat x).","conclusion":"vmatch w (longoffloat x)","hypotheses":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vlong (Float.to_long f) = Some w)","proofString":"destruct (Float.to_long f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int64) (E : Float.to_long f = Some i) : vmatch (Vlong i) (longoffloat x).","conclusion":"vmatch (Vlong i) (longoffloat x)","hypotheses":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int64) (E : Float.to_long f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (i : int64) (E : Float.to_long f = Some i) : vmatch (Vlong i)\n  match Float.to_long f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vlong i)\n  match Float.to_long f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float) (i : int64) (E : Float.to_long f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vlong (Float.to_longu f)\n| _ => None\nend = Some w) : vmatch w (longuoffloat x).","conclusion":"vmatch w (longuoffloat x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vfloat f => option_map Vlong (Float.to_longu f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float.to_longu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vlong (Float.to_longu f) = Some w) : vmatch w (longuoffloat x).","conclusion":"vmatch w (longuoffloat x)","hypotheses":"(f : float) (x : aval) (w : val) (H : vmatch (Vfloat f) x) (H0 : option_map Vlong (Float.to_longu f) = Some w)","proofString":"destruct (Float.to_longu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int64) (E : Float.to_longu f = Some i) : vmatch (Vlong i) (longuoffloat x).","conclusion":"vmatch (Vlong i) (longuoffloat x)","hypotheses":"(f : float) (x : aval) (H : vmatch (Vfloat f) x) (i : int64) (E : Float.to_longu f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float) (i : int64) (E : Float.to_longu f = Some i) : vmatch (Vlong i)\n  match Float.to_longu f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vlong i)\n  match Float.to_longu f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float) (i : int64) (E : Float.to_longu f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vfloat (Float.of_long n))\n| _ => None\nend = Some w) : vmatch w (floatoflong x).","conclusion":"vmatch w (floatoflong x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vfloat (Float.of_long n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int64) (x : aval) (H : vmatch (Vlong i) x) : vmatch (Vfloat (Float.of_long i)) (floatoflong x).","conclusion":"vmatch (Vfloat (Float.of_long i)) (floatoflong x)","hypotheses":"(i : int64) (x : aval) (H : vmatch (Vlong i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vfloat (Float.of_longu n))\n| _ => None\nend = Some w) : vmatch w (floatoflongu x).","conclusion":"vmatch w (floatoflongu x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vfloat (Float.of_longu n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int64) (x : aval) (H : vmatch (Vlong i) x) : vmatch (Vfloat (Float.of_longu i)) (floatoflongu x).","conclusion":"vmatch (Vfloat (Float.of_longu i)) (floatoflongu x)","hypotheses":"(i : int64) (x : aval) (H : vmatch (Vlong i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vlong (Float32.to_long f)\n| _ => None\nend = Some w) : vmatch w (longofsingle x).","conclusion":"vmatch w (longofsingle x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vlong (Float32.to_long f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float32.to_long f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vlong (Float32.to_long f) = Some w) : vmatch w (longofsingle x).","conclusion":"vmatch w (longofsingle x)","hypotheses":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vlong (Float32.to_long f) = Some w)","proofString":"destruct (Float32.to_long f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int64) (E : Float32.to_long f = Some i) : vmatch (Vlong i) (longofsingle x).","conclusion":"vmatch (Vlong i) (longofsingle x)","hypotheses":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int64) (E : Float32.to_long f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (i : int64) (E : Float32.to_long f = Some i) : vmatch (Vlong i)\n  match Float32.to_long f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vlong i)\n  match Float32.to_long f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float32) (i : int64) (E : Float32.to_long f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vlong (Float32.to_longu f)\n| _ => None\nend = Some w) : vmatch w (longuofsingle x).","conclusion":"vmatch w (longuofsingle x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vsingle f => option_map Vlong (Float32.to_longu f)\n| _ => None\nend = Some w)","proofString":"destruct v; try discriminate.\ndestruct (Float32.to_longu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vlong (Float32.to_longu f) = Some w) : vmatch w (longuofsingle x).","conclusion":"vmatch w (longuofsingle x)","hypotheses":"(f : float32) (x : aval) (w : val) (H : vmatch (Vsingle f) x) (H0 : option_map Vlong (Float32.to_longu f) = Some w)","proofString":"destruct (Float32.to_longu f) as [i|] eqn:E; simpl in H0; inv H0.\ninv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int64) (E : Float32.to_longu f = Some i) : vmatch (Vlong i) (longuofsingle x).","conclusion":"vmatch (Vlong i) (longuofsingle x)","hypotheses":"(f : float32) (x : aval) (H : vmatch (Vsingle f) x) (i : int64) (E : Float32.to_longu f = Some i)","proofString":"inv H; simpl; auto with va.\nrewrite E; constructor."},{"statement":"(f : float32) (i : int64) (E : Float32.to_longu f = Some i) : vmatch (Vlong i)\n  match Float32.to_longu f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end.","conclusion":"vmatch (Vlong i)\n  match Float32.to_longu f with\n  | Some i0 => L i0\n  | None => if va_strict tt then Vbot else ntop\n  end","hypotheses":"(f : float32) (i : int64) (E : Float32.to_longu f = Some i)","proofString":"rewrite E; constructor."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vsingle (Float32.of_long n))\n| _ => None\nend = Some w) : vmatch w (singleoflong x).","conclusion":"vmatch w (singleoflong x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vsingle (Float32.of_long n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int64) (x : aval) (H : vmatch (Vlong i) x) : vmatch (Vsingle (Float32.of_long i)) (singleoflong x).","conclusion":"vmatch (Vsingle (Float32.of_long i)) (singleoflong x)","hypotheses":"(i : int64) (x : aval) (H : vmatch (Vlong i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vsingle (Float32.of_longu n))\n| _ => None\nend = Some w) : vmatch w (singleoflongu x).","conclusion":"vmatch w (singleoflongu x)","hypotheses":"(v : val) (x : aval) (w : val) (H : vmatch v x) (H0 : match v with\n| Vlong n => Some (Vsingle (Float32.of_longu n))\n| _ => None\nend = Some w)","proofString":"destruct v; inv H0.\ninv H; simpl; auto with va."},{"statement":"(i : int64) (x : aval) (H : vmatch (Vlong i) x) : vmatch (Vsingle (Float32.of_longu i)) (singleoflongu x).","conclusion":"vmatch (Vsingle (Float32.of_longu i)) (singleoflongu x)","hypotheses":"(i : int64) (x : aval) (H : vmatch (Vlong i) x)","proofString":"inv H; simpl; auto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.floatofwords v w) (floatofwords x y).","conclusion":"vmatch (Val.floatofwords v w) (floatofwords x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold floatofwords; inv H; simpl; auto with va; inv H0; auto with va."},{"statement":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : vmatch (Val.longofwords v w) (longofwords x y).","conclusion":"vmatch (Val.longofwords v w) (longofwords x y)","hypotheses":"(v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold longofwords; inv H0; inv H; simpl; auto with va."},{"statement":"(c : comparison) (lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (zcmp c x n))\n  match c with\n  | Ceq => if zlt n lo || zlt hi n then Maybe false else Btop\n  | Cne => if zlt n lo || zlt hi n then Maybe true else Btop\n  | Clt =>\n      if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop\n  | Cle =>\n      if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop\n  | Cgt =>\n      if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop\n  | Cge =>\n      if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop\n  end.","conclusion":"cmatch (Some (zcmp c x n))\n  match c with\n  | Ceq => if zlt n lo || zlt hi n then Maybe false else Btop\n  | Cne => if zlt n lo || zlt hi n then Maybe true else Btop\n  | Clt =>\n      if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop\n  | Cle =>\n      if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop\n  | Cgt =>\n      if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop\n  | Cge =>\n      if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop\n  end","hypotheses":"(c : comparison) (lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct c; unfold zcmp, proj_sumbool.\ndestruct (zlt n lo).\nrewrite zeq_false by lia.\nconstructor.\ndestruct (zlt hi n).\nrewrite zeq_false by lia.\nconstructor.\nconstructor.\ndestruct (zlt n lo).\nrewrite zeq_false by lia.\nconstructor.\ndestruct (zlt hi n).\nrewrite zeq_false by lia.\nconstructor.\nconstructor.\ndestruct (zlt hi n).\nrewrite zlt_true by lia.\nconstructor.\ndestruct (zle n lo).\nrewrite zlt_false by lia.\nconstructor.\nconstructor.\ndestruct (zle hi n).\nrewrite zle_true by lia.\nconstructor.\ndestruct (zlt n lo).\nrewrite zle_false by lia.\nconstructor.\nconstructor.\ndestruct (zlt n lo).\nrewrite zlt_true by lia.\nconstructor.\ndestruct (zle hi n).\nrewrite zlt_false by lia.\nconstructor.\nconstructor.\ndestruct (zle n lo).\nrewrite zle_true by lia.\nconstructor.\ndestruct (zlt hi n).\nrewrite zle_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (if zeq x n then true else false))\n  (if\n    (if zlt n lo then true else false) || (if zlt hi n then true else false)\n   then Maybe false\n   else Btop).","conclusion":"cmatch (Some (if zeq x n then true else false))\n  (if\n    (if zlt n lo then true else false) || (if zlt hi n then true else false)\n   then Maybe false\n   else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct (zlt n lo).\nrewrite zeq_false by lia.\nconstructor.\ndestruct (zlt hi n).\nrewrite zeq_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo) : cmatch (Some (if zeq x n then true else false))\n  (if true || (if zlt hi n then true else false) then Maybe false else Btop).","conclusion":"cmatch (Some (if zeq x n then true else false))\n  (if true || (if zlt hi n then true else false) then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo)","proofString":"rewrite zeq_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo) : cmatch (Some false)\n  (if true || (if zlt hi n then true else false) then Maybe false else Btop).","conclusion":"cmatch (Some false)\n  (if true || (if zlt hi n then true else false) then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) : cmatch (Some (if zeq x n then true else false))\n  (if false || (if zlt hi n then true else false) then Maybe false else Btop).","conclusion":"cmatch (Some (if zeq x n then true else false))\n  (if false || (if zlt hi n then true else false) then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo)","proofString":"destruct (zlt hi n).\nrewrite zeq_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n) : cmatch (Some (if zeq x n then true else false))\n  (if false || true then Maybe false else Btop).","conclusion":"cmatch (Some (if zeq x n then true else false))\n  (if false || true then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n)","proofString":"rewrite zeq_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n) : cmatch (Some false) (if false || true then Maybe false else Btop).","conclusion":"cmatch (Some false) (if false || true then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (g0 : hi >= n) : cmatch (Some (if zeq x n then true else false))\n  (if false || false then Maybe false else Btop).","conclusion":"cmatch (Some (if zeq x n then true else false))\n  (if false || false then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (g0 : hi >= n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (negb (if zeq x n then true else false)))\n  (if\n    (if zlt n lo then true else false) || (if zlt hi n then true else false)\n   then Maybe true\n   else Btop).","conclusion":"cmatch (Some (negb (if zeq x n then true else false)))\n  (if\n    (if zlt n lo then true else false) || (if zlt hi n then true else false)\n   then Maybe true\n   else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct (zlt n lo).\nrewrite zeq_false by lia.\nconstructor.\ndestruct (zlt hi n).\nrewrite zeq_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo) : cmatch (Some (negb (if zeq x n then true else false)))\n  (if true || (if zlt hi n then true else false) then Maybe true else Btop).","conclusion":"cmatch (Some (negb (if zeq x n then true else false)))\n  (if true || (if zlt hi n then true else false) then Maybe true else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo)","proofString":"rewrite zeq_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo) : cmatch (Some (negb false))\n  (if true || (if zlt hi n then true else false) then Maybe true else Btop).","conclusion":"cmatch (Some (negb false))\n  (if true || (if zlt hi n then true else false) then Maybe true else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) : cmatch (Some (negb (if zeq x n then true else false)))\n  (if false || (if zlt hi n then true else false) then Maybe true else Btop).","conclusion":"cmatch (Some (negb (if zeq x n then true else false)))\n  (if false || (if zlt hi n then true else false) then Maybe true else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo)","proofString":"destruct (zlt hi n).\nrewrite zeq_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n) : cmatch (Some (negb (if zeq x n then true else false)))\n  (if false || true then Maybe true else Btop).","conclusion":"cmatch (Some (negb (if zeq x n then true else false)))\n  (if false || true then Maybe true else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n)","proofString":"rewrite zeq_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n) : cmatch (Some (negb false)) (if false || true then Maybe true else Btop).","conclusion":"cmatch (Some (negb false)) (if false || true then Maybe true else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi < n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (g0 : hi >= n) : cmatch (Some (negb (if zeq x n then true else false)))\n  (if false || false then Maybe true else Btop).","conclusion":"cmatch (Some (negb (if zeq x n then true else false)))\n  (if false || false then Maybe true else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (g0 : hi >= n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (if zlt x n then true else false))\n  (if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop).","conclusion":"cmatch (Some (if zlt x n then true else false))\n  (if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct (zlt hi n).\nrewrite zlt_true by lia.\nconstructor.\ndestruct (zle n lo).\nrewrite zlt_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi < n) : cmatch (Some (if zlt x n then true else false)) (Maybe true).","conclusion":"cmatch (Some (if zlt x n then true else false)) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi < n)","proofString":"rewrite zlt_true by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi < n) : cmatch (Some true) (Maybe true).","conclusion":"cmatch (Some true) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi < n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) : cmatch (Some (if zlt x n then true else false))\n  (if zle n lo then Maybe false else Btop).","conclusion":"cmatch (Some (if zlt x n then true else false))\n  (if zle n lo then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n)","proofString":"destruct (zle n lo).\nrewrite zlt_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) (l : n <= lo) : cmatch (Some (if zlt x n then true else false)) (Maybe false).","conclusion":"cmatch (Some (if zlt x n then true else false)) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) (l : n <= lo)","proofString":"rewrite zlt_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) (l : n <= lo) : cmatch (Some false) (Maybe false).","conclusion":"cmatch (Some false) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) (l : n <= lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) (g0 : n > lo) : cmatch (Some (if zlt x n then true else false)) Btop.","conclusion":"cmatch (Some (if zlt x n then true else false)) Btop","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi >= n) (g0 : n > lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (if zle x n then true else false))\n  (if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop).","conclusion":"cmatch (Some (if zle x n then true else false))\n  (if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct (zle hi n).\nrewrite zle_true by lia.\nconstructor.\ndestruct (zlt n lo).\nrewrite zle_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi <= n) : cmatch (Some (if zle x n then true else false)) (Maybe true).","conclusion":"cmatch (Some (if zle x n then true else false)) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi <= n)","proofString":"rewrite zle_true by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi <= n) : cmatch (Some true) (Maybe true).","conclusion":"cmatch (Some true) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : hi <= n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) : cmatch (Some (if zle x n then true else false))\n  (if zlt n lo then Maybe false else Btop).","conclusion":"cmatch (Some (if zle x n then true else false))\n  (if zlt n lo then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n)","proofString":"destruct (zlt n lo).\nrewrite zle_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) (l : n < lo) : cmatch (Some (if zle x n then true else false)) (Maybe false).","conclusion":"cmatch (Some (if zle x n then true else false)) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) (l : n < lo)","proofString":"rewrite zle_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) (l : n < lo) : cmatch (Some false) (Maybe false).","conclusion":"cmatch (Some false) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) (l : n < lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) (g0 : n >= lo) : cmatch (Some (if zle x n then true else false)) Btop.","conclusion":"cmatch (Some (if zle x n then true else false)) Btop","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : hi > n) (g0 : n >= lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (if zlt n x then true else false))\n  (if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop).","conclusion":"cmatch (Some (if zlt n x then true else false))\n  (if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct (zlt n lo).\nrewrite zlt_true by lia.\nconstructor.\ndestruct (zle hi n).\nrewrite zlt_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo) : cmatch (Some (if zlt n x then true else false)) (Maybe true).","conclusion":"cmatch (Some (if zlt n x then true else false)) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo)","proofString":"rewrite zlt_true by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo) : cmatch (Some true) (Maybe true).","conclusion":"cmatch (Some true) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n < lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) : cmatch (Some (if zlt n x then true else false))\n  (if zle hi n then Maybe false else Btop).","conclusion":"cmatch (Some (if zlt n x then true else false))\n  (if zle hi n then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo)","proofString":"destruct (zle hi n).\nrewrite zlt_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi <= n) : cmatch (Some (if zlt n x then true else false)) (Maybe false).","conclusion":"cmatch (Some (if zlt n x then true else false)) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi <= n)","proofString":"rewrite zlt_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi <= n) : cmatch (Some false) (Maybe false).","conclusion":"cmatch (Some false) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (l : hi <= n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (g0 : hi > n) : cmatch (Some (if zlt n x then true else false)) Btop.","conclusion":"cmatch (Some (if zlt n x then true else false)) Btop","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n >= lo) (g0 : hi > n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) : cmatch (Some (if zle n x then true else false))\n  (if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop).","conclusion":"cmatch (Some (if zle n x then true else false))\n  (if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi)","proofString":"destruct (zle n lo).\nrewrite zle_true by lia.\nconstructor.\ndestruct (zlt hi n).\nrewrite zle_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n <= lo) : cmatch (Some (if zle n x then true else false)) (Maybe true).","conclusion":"cmatch (Some (if zle n x then true else false)) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n <= lo)","proofString":"rewrite zle_true by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n <= lo) : cmatch (Some true) (Maybe true).","conclusion":"cmatch (Some true) (Maybe true)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (l : n <= lo)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) : cmatch (Some (if zle n x then true else false))\n  (if zlt hi n then Maybe false else Btop).","conclusion":"cmatch (Some (if zle n x then true else false))\n  (if zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo)","proofString":"destruct (zlt hi n).\nrewrite zle_false by lia.\nconstructor.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) (l : hi < n) : cmatch (Some (if zle n x then true else false)) (Maybe false).","conclusion":"cmatch (Some (if zle n x then true else false)) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) (l : hi < n)","proofString":"rewrite zle_false by lia.\nconstructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) (l : hi < n) : cmatch (Some false) (Maybe false).","conclusion":"cmatch (Some false) (Maybe false)","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) (l : hi < n)","proofString":"constructor."},{"statement":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) (g0 : hi >= n) : cmatch (Some (if zle n x then true else false)) Btop.","conclusion":"cmatch (Some (if zle n x then true else false)) Btop","hypotheses":"(lo hi x n : Z) (R : lo <= x <= hi) (g : n > lo) (g0 : hi >= n)","proofString":"constructor."},{"statement":"(c : comparison) (i : Z * Z) (n : Z) : cmatch None\n  (let (lo, hi) := i in\n   match c with\n   | Ceq => if zlt n lo || zlt hi n then Maybe false else Btop\n   | Cne => if zlt n lo || zlt hi n then Maybe true else Btop\n   | Clt =>\n       if zlt hi n\n       then Maybe true\n       else if zle n lo then Maybe false else Btop\n   | Cle =>\n       if zle hi n\n       then Maybe true\n       else if zlt n lo then Maybe false else Btop\n   | Cgt =>\n       if zlt n lo\n       then Maybe true\n       else if zle hi n then Maybe false else Btop\n   | Cge =>\n       if zle n lo\n       then Maybe true\n       else if zlt hi n then Maybe false else Btop\n   end).","conclusion":"cmatch None\n  (let (lo, hi) := i in\n   match c with\n   | Ceq => if zlt n lo || zlt hi n then Maybe false else Btop\n   | Cne => if zlt n lo || zlt hi n then Maybe true else Btop\n   | Clt =>\n       if zlt hi n\n       then Maybe true\n       else if zle n lo then Maybe false else Btop\n   | Cle =>\n       if zle hi n\n       then Maybe true\n       else if zlt n lo then Maybe false else Btop\n   | Cgt =>\n       if zlt n lo\n       then Maybe true\n       else if zle hi n then Maybe false else Btop\n   | Cge =>\n       if zle n lo\n       then Maybe true\n       else if zlt hi n then Maybe false else Btop\n   end)","hypotheses":"(c : comparison) (i : Z * Z) (n : Z)","proofString":"destruct i as [lo hi].\ndestruct c.\ndestruct (zlt n lo).\nconstructor.\ndestruct (zlt hi n); constructor.\ndestruct (zlt n lo).\nconstructor.\ndestruct (zlt hi n); constructor.\ndestruct (zlt hi n).\nconstructor.\ndestruct (zle n lo); constructor.\ndestruct (zle hi n).\nconstructor.\ndestruct (zlt n lo); constructor.\ndestruct (zlt n lo).\nconstructor.\ndestruct (zle hi n); constructor.\ndestruct (zle n lo).\nconstructor.\ndestruct (zlt hi n); constructor."},{"statement":"(c : comparison) (lo hi n : Z) : cmatch None\n  match c with\n  | Ceq => if zlt n lo || zlt hi n then Maybe false else Btop\n  | Cne => if zlt n lo || zlt hi n then Maybe true else Btop\n  | Clt =>\n      if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop\n  | Cle =>\n      if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop\n  | Cgt =>\n      if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop\n  | Cge =>\n      if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop\n  end.","conclusion":"cmatch None\n  match c with\n  | Ceq => if zlt n lo || zlt hi n then Maybe false else Btop\n  | Cne => if zlt n lo || zlt hi n then Maybe true else Btop\n  | Clt =>\n      if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop\n  | Cle =>\n      if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop\n  | Cgt =>\n      if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop\n  | Cge =>\n      if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop\n  end","hypotheses":"(c : comparison) (lo hi n : Z)","proofString":"destruct c.\ndestruct (zlt n lo).\nconstructor.\ndestruct (zlt hi n); constructor.\ndestruct (zlt n lo).\nconstructor.\ndestruct (zlt hi n); constructor.\ndestruct (zlt hi n).\nconstructor.\ndestruct (zle n lo); constructor.\ndestruct (zle hi n).\nconstructor.\ndestruct (zlt n lo); constructor.\ndestruct (zlt n lo).\nconstructor.\ndestruct (zle hi n); constructor.\ndestruct (zle n lo).\nconstructor.\ndestruct (zlt hi n); constructor."},{"statement":"(lo hi n : Z) : cmatch None (if zlt n lo || zlt hi n then Maybe false else Btop).","conclusion":"cmatch None (if zlt n lo || zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct (zlt n lo).\nconstructor.\ndestruct (zlt hi n); constructor."},{"statement":"(lo hi n : Z) : cmatch None (if zlt n lo || zlt hi n then Maybe true else Btop).","conclusion":"cmatch None (if zlt n lo || zlt hi n then Maybe true else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct (zlt n lo).\nconstructor.\ndestruct (zlt hi n); constructor."},{"statement":"(lo hi n : Z) : cmatch None\n  (if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop).","conclusion":"cmatch None\n  (if zlt hi n then Maybe true else if zle n lo then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct (zlt hi n).\nconstructor.\ndestruct (zle n lo); constructor."},{"statement":"(lo hi n : Z) (l : hi < n) : cmatch None (Maybe true).","conclusion":"cmatch None (Maybe true)","hypotheses":"(lo hi n : Z) (l : hi < n)","proofString":"constructor."},{"statement":"(lo hi n : Z) (g : hi >= n) : cmatch None (if zle n lo then Maybe false else Btop).","conclusion":"cmatch None (if zle n lo then Maybe false else Btop)","hypotheses":"(lo hi n : Z) (g : hi >= n)","proofString":"destruct (zle n lo); constructor."},{"statement":"(lo hi n : Z) : cmatch None\n  (if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop).","conclusion":"cmatch None\n  (if zle hi n then Maybe true else if zlt n lo then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct (zle hi n).\nconstructor.\ndestruct (zlt n lo); constructor."},{"statement":"(lo hi n : Z) (l : hi <= n) : cmatch None (Maybe true).","conclusion":"cmatch None (Maybe true)","hypotheses":"(lo hi n : Z) (l : hi <= n)","proofString":"constructor."},{"statement":"(lo hi n : Z) (g : hi > n) : cmatch None (if zlt n lo then Maybe false else Btop).","conclusion":"cmatch None (if zlt n lo then Maybe false else Btop)","hypotheses":"(lo hi n : Z) (g : hi > n)","proofString":"destruct (zlt n lo); constructor."},{"statement":"(lo hi n : Z) : cmatch None\n  (if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop).","conclusion":"cmatch None\n  (if zlt n lo then Maybe true else if zle hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct (zlt n lo).\nconstructor.\ndestruct (zle hi n); constructor."},{"statement":"(lo hi n : Z) (l : n < lo) : cmatch None (Maybe true).","conclusion":"cmatch None (Maybe true)","hypotheses":"(lo hi n : Z) (l : n < lo)","proofString":"constructor."},{"statement":"(lo hi n : Z) (g : n >= lo) : cmatch None (if zle hi n then Maybe false else Btop).","conclusion":"cmatch None (if zle hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z) (g : n >= lo)","proofString":"destruct (zle hi n); constructor."},{"statement":"(lo hi n : Z) : cmatch None\n  (if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop).","conclusion":"cmatch None\n  (if zle n lo then Maybe true else if zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct (zle n lo).\nconstructor.\ndestruct (zlt hi n); constructor."},{"statement":"(lo hi n : Z) (l : n <= lo) : cmatch None (Maybe true).","conclusion":"cmatch None (Maybe true)","hypotheses":"(lo hi n : Z) (l : n <= lo)","proofString":"constructor."},{"statement":"(lo hi n : Z) (g : n > lo) : cmatch None (if zlt hi n then Maybe false else Btop).","conclusion":"cmatch None (if zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z) (g : n > lo)","proofString":"destruct (zlt hi n); constructor."},{"statement":"(c : comparison) (lo hi n : Z) : cmatch match c with\n       | Ceq => Some false\n       | Cne => Some true\n       | _ => None\n       end (cmp_intv c (lo, hi) n).","conclusion":"cmatch match c with\n       | Ceq => Some false\n       | Cne => Some true\n       | _ => None\n       end (cmp_intv c (lo, hi) n)","hypotheses":"(c : comparison) (lo hi n : Z)","proofString":"destruct c; auto using cmp_intv_None; simpl.\ndestruct orb; constructor.\ndestruct orb; constructor."},{"statement":"(lo hi n : Z) : cmatch (Some false) (if zlt n lo || zlt hi n then Maybe false else Btop).","conclusion":"cmatch (Some false) (if zlt n lo || zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct orb; constructor."},{"statement":"(lo hi n : Z) : cmatch (Some true) (if zlt n lo || zlt hi n then Maybe true else Btop).","conclusion":"cmatch (Some true) (if zlt n lo || zlt hi n then Maybe true else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct orb; constructor."},{"statement":"(c : comparison) (lo hi n : Z) : cmatch match c with\n       | Ceq => Some false\n       | Cne => Some true\n       | _ => None\n       end (cmp_intv (swap_comparison c) (lo, hi) n).","conclusion":"cmatch match c with\n       | Ceq => Some false\n       | Cne => Some true\n       | _ => None\n       end (cmp_intv (swap_comparison c) (lo, hi) n)","hypotheses":"(c : comparison) (lo hi n : Z)","proofString":"destruct c; auto using cmp_intv_None; simpl.\ndestruct orb; constructor.\ndestruct orb; constructor."},{"statement":"(lo hi n : Z) : cmatch (Some false) (if zlt n lo || zlt hi n then Maybe false else Btop).","conclusion":"cmatch (Some false) (if zlt n lo || zlt hi n then Maybe false else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct orb; constructor."},{"statement":"(lo hi n : Z) : cmatch (Some true) (if zlt n lo || zlt hi n then Maybe true else Btop).","conclusion":"cmatch (Some true) (if zlt n lo || zlt hi n then Maybe true else Btop)","hypotheses":"(lo hi n : Z)","proofString":"destruct orb; constructor."},{"statement":"(n : int) (v : aval) (H : vmatch (Vint n) v) : fst (uintv v) <= Int.unsigned n <= snd (uintv v).","conclusion":"fst (uintv v) <= Int.unsigned n <= snd (uintv v)","hypotheses":"(n : int) (v : aval) (H : vmatch (Vint n) v)","proofString":"inv H; simpl; try (apply Int.unsigned_range_2).\nlia.\ndestruct (zlt n0 Int.zwordsize); simpl.\nrewrite is_uns_zero_ext in H2.\nrewrite <- H2.\nrewrite Int.zero_ext_mod by lia.\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nlia.\napply Int.unsigned_range_2."},{"statement":"(n : int) : Int.unsigned n <= Int.unsigned n <= Int.unsigned n.","conclusion":"Int.unsigned n <= Int.unsigned n <= Int.unsigned n","hypotheses":"(n : int)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) : fst\n  (if zlt n0 Int.zwordsize then (0, two_p n0 - 1) else (0, Int.max_unsigned)) <=\nInt.unsigned n <=\nsnd\n  (if zlt n0 Int.zwordsize then (0, two_p n0 - 1) else (0, Int.max_unsigned)).","conclusion":"fst\n  (if zlt n0 Int.zwordsize then (0, two_p n0 - 1) else (0, Int.max_unsigned)) <=\nInt.unsigned n <=\nsnd\n  (if zlt n0 Int.zwordsize then (0, two_p n0 - 1) else (0, Int.max_unsigned))","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n)","proofString":"destruct (zlt n0 Int.zwordsize); simpl.\nrewrite is_uns_zero_ext in H2.\nrewrite <- H2.\nrewrite Int.zero_ext_mod by lia.\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nlia.\napply Int.unsigned_range_2."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (l : n0 < Int.zwordsize) : 0 <= Int.unsigned n <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned n <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (l : n0 < Int.zwordsize)","proofString":"rewrite is_uns_zero_ext in H2.\nrewrite <- H2.\nrewrite Int.zero_ext_mod by lia.\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 <= Int.unsigned n <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned n <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"rewrite <- H2.\nrewrite Int.zero_ext_mod by lia.\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 <= Int.unsigned (Int.zero_ext n0 n) <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned (Int.zero_ext n0 n) <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"rewrite Int.zero_ext_mod by lia.\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 <= Int.unsigned n mod two_p n0 <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned n mod two_p n0 <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"exploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : two_p n0 > 0.","conclusion":"two_p n0 > 0","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"apply two_p_gt_ZERO; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 <= Int.unsigned n mod two_p n0 < two_p n0 ->\n0 <= Int.unsigned n mod two_p n0 <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned n mod two_p n0 < two_p n0 ->\n0 <= Int.unsigned n mod two_p n0 <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (g : n0 >= Int.zwordsize) : 0 <= Int.unsigned n <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned n <= Int.max_unsigned","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (g : n0 >= Int.zwordsize)","proofString":"apply Int.unsigned_range_2."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Val.cmpu_bool valid c (Vint n1) (Vint n2))\n  (cmp_intv c (uintv v1) (Int.unsigned n2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint n1) (Vint n2))\n  (cmp_intv c (uintv v1) (Int.unsigned n2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"simpl.\nreplace (Int.cmpu c n1 n2) with (zcmp c (Int.unsigned n1) (Int.unsigned n2)).\napply zcmp_intv_sound; apply uintv_sound; auto.\ndestruct c; simpl; auto.\nunfold Int.ltu.\ndestruct (zle (Int.unsigned n1) (Int.unsigned n2)); [rewrite zlt_false|rewrite zlt_true]; auto; lia.\nunfold Int.ltu.\ndestruct (zle (Int.unsigned n2) (Int.unsigned n1)); [rewrite zlt_false|rewrite zlt_true]; auto; lia."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Some (Int.cmpu c n1 n2)) (cmp_intv c (uintv v1) (Int.unsigned n2)).","conclusion":"cmatch (Some (Int.cmpu c n1 n2)) (cmp_intv c (uintv v1) (Int.unsigned n2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"replace (Int.cmpu c n1 n2) with (zcmp c (Int.unsigned n1) (Int.unsigned n2)).\napply zcmp_intv_sound; apply uintv_sound; auto.\ndestruct c; simpl; auto.\nunfold Int.ltu.\ndestruct (zle (Int.unsigned n1) (Int.unsigned n2)); [rewrite zlt_false|rewrite zlt_true]; auto; lia.\nunfold Int.ltu.\ndestruct (zle (Int.unsigned n2) (Int.unsigned n1)); [rewrite zlt_false|rewrite zlt_true]; auto; lia."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Some (zcmp c (Int.unsigned n1) (Int.unsigned n2)))\n  (cmp_intv c (uintv v1) (Int.unsigned n2)).","conclusion":"cmatch (Some (zcmp c (Int.unsigned n1) (Int.unsigned n2)))\n  (cmp_intv c (uintv v1) (Int.unsigned n2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"apply zcmp_intv_sound; apply uintv_sound; auto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : zcmp c (Int.unsigned n1) (Int.unsigned n2) = Int.cmpu c n1 n2.","conclusion":"zcmp c (Int.unsigned n1) (Int.unsigned n2) = Int.cmpu c n1 n2","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"destruct c; simpl; auto.\nunfold Int.ltu.\ndestruct (zle (Int.unsigned n1) (Int.unsigned n2)); [rewrite zlt_false|rewrite zlt_true]; auto; lia.\nunfold Int.ltu.\ndestruct (zle (Int.unsigned n2) (Int.unsigned n1)); [rewrite zlt_false|rewrite zlt_true]; auto; lia."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Val.cmpu_bool valid c (Vint n2) (Vint n1))\n  (cmp_intv (swap_comparison c) (uintv v1) (Int.unsigned n2)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint n2) (Vint n1))\n  (cmp_intv (swap_comparison c) (uintv v1) (Int.unsigned n2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"rewrite <- Val.swap_cmpu_bool.\napply cmpu_intv_sound; auto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Val.cmpu_bool valid (swap_comparison c) (Vint n1) (Vint n2))\n  (cmp_intv (swap_comparison c) (uintv v1) (Int.unsigned n2)).","conclusion":"cmatch (Val.cmpu_bool valid (swap_comparison c) (Vint n1) (Vint n2))\n  (cmp_intv (swap_comparison c) (uintv v1) (Int.unsigned n2))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"apply cmpu_intv_sound; auto."},{"statement":"(n : int) (v : aval) (H : vmatch (Vint n) v) : fst (sintv v) <= Int.signed n <= snd (sintv v).","conclusion":"fst (sintv v) <= Int.signed n <= snd (sintv v)","hypotheses":"(n : int) (v : aval) (H : vmatch (Vint n) v)","proofString":"inv H; simpl; try (apply Int.signed_range).\nlia.\ndestruct (zlt n0 Int.zwordsize); simpl.\nrewrite is_uns_zero_ext in H2.\nrewrite <- H2.\nassert (Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) by (apply Int.zero_ext_mod; lia).\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nintros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia.\napply Int.signed_range.\ndestruct (zlt n0 (Int.zwordsize)); simpl.\nrewrite is_sgn_sign_ext in H2 by auto.\nrewrite <- H2.\nexploit (Int.sign_ext_range n0 n).\nlia.\nlia.\napply Int.signed_range."},{"statement":"(n : int) : Int.signed n <= Int.signed n <= Int.signed n.","conclusion":"Int.signed n <= Int.signed n <= Int.signed n","hypotheses":"(n : int)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) : fst\n  (if zlt n0 Int.zwordsize\n   then (0, two_p n0 - 1)\n   else (Int.min_signed, Int.max_signed)) <= Int.signed n <=\nsnd\n  (if zlt n0 Int.zwordsize\n   then (0, two_p n0 - 1)\n   else (Int.min_signed, Int.max_signed)).","conclusion":"fst\n  (if zlt n0 Int.zwordsize\n   then (0, two_p n0 - 1)\n   else (Int.min_signed, Int.max_signed)) <= Int.signed n <=\nsnd\n  (if zlt n0 Int.zwordsize\n   then (0, two_p n0 - 1)\n   else (Int.min_signed, Int.max_signed))","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n)","proofString":"destruct (zlt n0 Int.zwordsize); simpl.\nrewrite is_uns_zero_ext in H2.\nrewrite <- H2.\nassert (Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) by (apply Int.zero_ext_mod; lia).\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nintros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia.\napply Int.signed_range."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (l : n0 < Int.zwordsize) : 0 <= Int.signed n <= two_p n0 - 1.","conclusion":"0 <= Int.signed n <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (l : n0 < Int.zwordsize)","proofString":"rewrite is_uns_zero_ext in H2.\nrewrite <- H2.\nassert (Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) by (apply Int.zero_ext_mod; lia).\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nintros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 <= Int.signed n <= two_p n0 - 1.","conclusion":"0 <= Int.signed n <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"rewrite <- H2.\nassert (Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) by (apply Int.zero_ext_mod; lia).\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nintros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1.","conclusion":"0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"assert (Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) by (apply Int.zero_ext_mod; lia).\nexploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nintros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) : 0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1.","conclusion":"0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0)","proofString":"exploit (Z_mod_lt (Int.unsigned n) (two_p n0)).\napply two_p_gt_ZERO; auto.\nintros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) : two_p n0 > 0.","conclusion":"two_p n0 > 0","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0)","proofString":"apply two_p_gt_ZERO; auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) : 0 <= Int.unsigned n mod two_p n0 < two_p n0 ->\n0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned n mod two_p n0 < two_p n0 ->\n0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0)","proofString":"intros.\nreplace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : 0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1.","conclusion":"0 <= Int.signed (Int.zero_ext n0 n) <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"replace (Int.signed (Int.zero_ext n0 n)) with (Int.unsigned (Int.zero_ext n0 n)).\nrewrite H.\nlia.\nunfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : 0 <= Int.unsigned (Int.zero_ext n0 n) <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned (Int.zero_ext n0 n) <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"rewrite H.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : 0 <= Int.unsigned n mod two_p n0 <= two_p n0 - 1.","conclusion":"0 <= Int.unsigned n mod two_p n0 <= two_p n0 - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : Int.unsigned (Int.zero_ext n0 n) = Int.signed (Int.zero_ext n0 n).","conclusion":"Int.unsigned (Int.zero_ext n0 n) = Int.signed (Int.zero_ext n0 n)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"unfold Int.signed.\nrewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : Int.unsigned (Int.zero_ext n0 n) =\n(if zlt (Int.unsigned (Int.zero_ext n0 n)) Int.half_modulus\n then Int.unsigned (Int.zero_ext n0 n)\n else Int.unsigned (Int.zero_ext n0 n) - Int.modulus).","conclusion":"Int.unsigned (Int.zero_ext n0 n) =\n(if zlt (Int.unsigned (Int.zero_ext n0 n)) Int.half_modulus\n then Int.unsigned (Int.zero_ext n0 n)\n else Int.unsigned (Int.zero_ext n0 n) - Int.modulus)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"rewrite zlt_true.\nauto.\nassert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned (Int.zero_ext n0 n).","conclusion":"Int.unsigned (Int.zero_ext n0 n) = Int.unsigned (Int.zero_ext n0 n)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"auto."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : Int.unsigned (Int.zero_ext n0 n) < Int.half_modulus.","conclusion":"Int.unsigned (Int.zero_ext n0 n) < Int.half_modulus","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"assert (two_p n0 <= Int.half_modulus).\nchange Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : two_p n0 <= Int.half_modulus.","conclusion":"two_p n0 <= Int.half_modulus","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"change Int.half_modulus with (two_p (Int.zwordsize - 1)).\napply two_p_monotone.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : two_p n0 <= two_p (Int.zwordsize - 1).","conclusion":"two_p n0 <= two_p (Int.zwordsize - 1)","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"apply two_p_monotone.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) : 0 <= n0 <= Int.zwordsize - 1.","conclusion":"0 <= n0 <= Int.zwordsize - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) (H3 : two_p n0 <= Int.half_modulus) : Int.unsigned (Int.zero_ext n0 n) < Int.half_modulus.","conclusion":"Int.unsigned (Int.zero_ext n0 n) < Int.half_modulus","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : Int.zero_ext n0 n = n) (l : n0 < Int.zwordsize) (H : Int.unsigned (Int.zero_ext n0 n) = Int.unsigned n mod two_p n0) (H0 : 0 <= Int.unsigned n mod two_p n0 < two_p n0) (H3 : two_p n0 <= Int.half_modulus)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (g : n0 >= Int.zwordsize) : Int.min_signed <= Int.signed n <= Int.max_signed.","conclusion":"Int.min_signed <= Int.signed n <= Int.max_signed","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 <= n0) (H2 : is_uns n0 n) (g : n0 >= Int.zwordsize)","proofString":"apply Int.signed_range."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : is_sgn n0 n) : fst\n  (if zlt n0 Int.zwordsize\n   then (- two_p (n0 - 1), two_p (n0 - 1) - 1)\n   else (Int.min_signed, Int.max_signed)) <= Int.signed n <=\nsnd\n  (if zlt n0 Int.zwordsize\n   then (- two_p (n0 - 1), two_p (n0 - 1) - 1)\n   else (Int.min_signed, Int.max_signed)).","conclusion":"fst\n  (if zlt n0 Int.zwordsize\n   then (- two_p (n0 - 1), two_p (n0 - 1) - 1)\n   else (Int.min_signed, Int.max_signed)) <= Int.signed n <=\nsnd\n  (if zlt n0 Int.zwordsize\n   then (- two_p (n0 - 1), two_p (n0 - 1) - 1)\n   else (Int.min_signed, Int.max_signed))","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : is_sgn n0 n)","proofString":"destruct (zlt n0 (Int.zwordsize)); simpl.\nrewrite is_sgn_sign_ext in H2 by auto.\nrewrite <- H2.\nexploit (Int.sign_ext_range n0 n).\nlia.\nlia.\napply Int.signed_range."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : is_sgn n0 n) (l : n0 < Int.zwordsize) : - two_p (n0 - 1) <= Int.signed n <= two_p (n0 - 1) - 1.","conclusion":"- two_p (n0 - 1) <= Int.signed n <= two_p (n0 - 1) - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : is_sgn n0 n) (l : n0 < Int.zwordsize)","proofString":"rewrite is_sgn_sign_ext in H2 by auto.\nrewrite <- H2.\nexploit (Int.sign_ext_range n0 n).\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize) : - two_p (n0 - 1) <= Int.signed n <= two_p (n0 - 1) - 1.","conclusion":"- two_p (n0 - 1) <= Int.signed n <= two_p (n0 - 1) - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"rewrite <- H2.\nexploit (Int.sign_ext_range n0 n).\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize) : - two_p (n0 - 1) <= Int.signed (Int.sign_ext n0 n) <= two_p (n0 - 1) - 1.","conclusion":"- two_p (n0 - 1) <= Int.signed (Int.sign_ext n0 n) <= two_p (n0 - 1) - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"exploit (Int.sign_ext_range n0 n).\nlia.\nlia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize) : 0 < n0 < Int.zwordsize.","conclusion":"0 < n0 < Int.zwordsize","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize) : - two_p (n0 - 1) <= Int.signed (Int.sign_ext n0 n) < two_p (n0 - 1) ->\n- two_p (n0 - 1) <= Int.signed (Int.sign_ext n0 n) <= two_p (n0 - 1) - 1.","conclusion":"- two_p (n0 - 1) <= Int.signed (Int.sign_ext n0 n) < two_p (n0 - 1) ->\n- two_p (n0 - 1) <= Int.signed (Int.sign_ext n0 n) <= two_p (n0 - 1) - 1","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : Int.sign_ext n0 n = n) (l : n0 < Int.zwordsize)","proofString":"lia."},{"statement":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : is_sgn n0 n) (g : n0 >= Int.zwordsize) : Int.min_signed <= Int.signed n <= Int.max_signed.","conclusion":"Int.min_signed <= Int.signed n <= Int.max_signed","hypotheses":"(n : int) (p : aptr) (n0 : Z) (H1 : 0 < n0) (H2 : is_sgn n0 n) (g : n0 >= Int.zwordsize)","proofString":"apply Int.signed_range."},{"statement":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Val.cmp_bool c (Vint n1) (Vint n2))\n  (cmp_intv c (sintv v1) (Int.signed n2)).","conclusion":"cmatch (Val.cmp_bool c (Vint n1) (Vint n2))\n  (cmp_intv c (sintv v1) (Int.signed n2))","hypotheses":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"simpl.\nreplace (Int.cmp c n1 n2) with (zcmp c (Int.signed n1) (Int.signed n2)).\napply zcmp_intv_sound; apply sintv_sound; auto.\ndestruct c; simpl; rewrite ? Int.eq_signed; auto.\nunfold Int.lt.\ndestruct (zle (Int.signed n1) (Int.signed n2)); [rewrite zlt_false|rewrite zlt_true]; auto; lia.\nunfold Int.lt.\ndestruct (zle (Int.signed n2) (Int.signed n1)); [rewrite zlt_false|rewrite zlt_true]; auto; lia."},{"statement":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Some (Int.cmp c n1 n2)) (cmp_intv c (sintv v1) (Int.signed n2)).","conclusion":"cmatch (Some (Int.cmp c n1 n2)) (cmp_intv c (sintv v1) (Int.signed n2))","hypotheses":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"replace (Int.cmp c n1 n2) with (zcmp c (Int.signed n1) (Int.signed n2)).\napply zcmp_intv_sound; apply sintv_sound; auto.\ndestruct c; simpl; rewrite ? Int.eq_signed; auto.\nunfold Int.lt.\ndestruct (zle (Int.signed n1) (Int.signed n2)); [rewrite zlt_false|rewrite zlt_true]; auto; lia.\nunfold Int.lt.\ndestruct (zle (Int.signed n2) (Int.signed n1)); [rewrite zlt_false|rewrite zlt_true]; auto; lia."},{"statement":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Some (zcmp c (Int.signed n1) (Int.signed n2)))\n  (cmp_intv c (sintv v1) (Int.signed n2)).","conclusion":"cmatch (Some (zcmp c (Int.signed n1) (Int.signed n2)))\n  (cmp_intv c (sintv v1) (Int.signed n2))","hypotheses":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"apply zcmp_intv_sound; apply sintv_sound; auto."},{"statement":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : zcmp c (Int.signed n1) (Int.signed n2) = Int.cmp c n1 n2.","conclusion":"zcmp c (Int.signed n1) (Int.signed n2) = Int.cmp c n1 n2","hypotheses":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"destruct c; simpl; rewrite ? Int.eq_signed; auto.\nunfold Int.lt.\ndestruct (zle (Int.signed n1) (Int.signed n2)); [rewrite zlt_false|rewrite zlt_true]; auto; lia.\nunfold Int.lt.\ndestruct (zle (Int.signed n2) (Int.signed n1)); [rewrite zlt_false|rewrite zlt_true]; auto; lia."},{"statement":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Val.cmp_bool c (Vint n2) (Vint n1))\n  (cmp_intv (swap_comparison c) (sintv v1) (Int.signed n2)).","conclusion":"cmatch (Val.cmp_bool c (Vint n2) (Vint n1))\n  (cmp_intv (swap_comparison c) (sintv v1) (Int.signed n2))","hypotheses":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"rewrite <- Val.swap_cmp_bool.\napply cmp_intv_sound; auto."},{"statement":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1) : cmatch (Val.cmp_bool (swap_comparison c) (Vint n1) (Vint n2))\n  (cmp_intv (swap_comparison c) (sintv v1) (Int.signed n2)).","conclusion":"cmatch (Val.cmp_bool (swap_comparison c) (Vint n1) (Vint n2))\n  (cmp_intv (swap_comparison c) (sintv v1) (Int.signed n2))","hypotheses":"(c : comparison) (n1 : int) (v1 : aval) (n2 : int) (H : vmatch (Vint n1) v1)","proofString":"apply cmp_intv_sound; auto."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y).","conclusion":"cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (IP: forall i b ofs,    cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none.\nassert (PI: forall i b ofs,    cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none.\nassert (IP2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_intv (swap_comparison c) itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None.\nassert (PI2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_intv c itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None.\nunfold cmpu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none, pcmp_sound,             cmpu_intv_sound, cmpu_intv_sound_2, cmp_intv_None.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c).","conclusion":"forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"intros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int) (b : block) (ofs : ptrofs) : cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int) (b : block) (ofs : ptrofs)","proofString":"simpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int) (b : block) (ofs : ptrofs) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int) (b : block) (ofs : ptrofs)","proofString":"destruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int) (b : block) (ofs : ptrofs) : cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int) (b : block) (ofs : ptrofs)","proofString":"destruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) : cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y).","conclusion":"cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c))","proofString":"assert (PI: forall i b ofs,    cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none.\nassert (IP2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_intv (swap_comparison c) itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None.\nassert (PI2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_intv c itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None.\nunfold cmpu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none, pcmp_sound,             cmpu_intv_sound, cmpu_intv_sound_2, cmp_intv_None.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c).","conclusion":"forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c))","proofString":"intros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) : cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs)","proofString":"simpl.\ndestruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs)","proofString":"destruct Archi.ptr64; auto using cmp_different_blocks_none.\ndestruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) : cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs)","proofString":"destruct andb; auto using cmp_different_blocks_sound, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) : cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y).","conclusion":"cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c))","proofString":"assert (IP2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_intv (swap_comparison c) itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None.\nassert (PI2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_intv c itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None.\nunfold cmpu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none, pcmp_sound,             cmpu_intv_sound, cmpu_intv_sound_2, cmp_intv_None.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i)).","conclusion":"forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c))","proofString":"intros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z) : cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z)","proofString":"simpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_intv (swap_comparison c) itv (Int.unsigned i)).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_intv (swap_comparison c) itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z)","proofString":"destruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z) : cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_intv (swap_comparison c) itv (Int.unsigned i)).","conclusion":"cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_intv (swap_comparison c) itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z)","proofString":"destruct andb; auto using cmp_intv_different_blocks_2, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) (IP2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i))) : cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y).","conclusion":"cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) (IP2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i)))","proofString":"assert (PI2: forall i b ofs itv,    cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_intv c itv (Int.unsigned i))).\nintros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None.\nunfold cmpu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none, pcmp_sound,             cmpu_intv_sound, cmpu_intv_sound_2, cmp_intv_None.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) (IP2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i))) : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (cmp_intv c itv (Int.unsigned i)).","conclusion":"forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (cmp_intv c itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) (IP2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i)))","proofString":"intros.\nsimpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv0 : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv0 (Int.unsigned i0))) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z) : cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (cmp_intv c itv (Int.unsigned i)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (cmp_intv c itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv0 : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv0 (Int.unsigned i0))) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z)","proofString":"simpl.\ndestruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv0 : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv0 (Int.unsigned i0))) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z) : cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_intv c itv (Int.unsigned i)).","conclusion":"cmatch\n  (if Archi.ptr64\n   then None\n   else\n    if\n     Int.eq i Int.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_intv c itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv0 : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv0 (Int.unsigned i0))) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z)","proofString":"destruct Archi.ptr64; auto using cmp_intv_None.\ndestruct andb; auto using cmp_intv_different_blocks, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv0 : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv0 (Int.unsigned i0))) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z) : cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_intv c itv (Int.unsigned i)).","conclusion":"cmatch\n  (if\n    Int.eq i Int.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_intv c itv (Int.unsigned i))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv0 : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv0 (Int.unsigned i0))) (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z)","proofString":"destruct andb; auto using cmp_intv_different_blocks, cmp_intv_None."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) (IP2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i))) (PI2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (cmp_intv c itv (Int.unsigned i))) : cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y).","conclusion":"cmatch (Val.cmpu_bool valid c v w) (cmpu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_blocks c)) (PI : forall (i : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i)) (cmp_different_blocks c)) (IP2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i))) (PI2 : forall (i : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (cmp_intv c itv (Int.unsigned i)))","proofString":"unfold cmpu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none, pcmp_sound,             cmpu_intv_sound, cmpu_intv_sound_2, cmp_intv_None.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\ndestruct (Int.eq i Int.zero); auto using cmatch_top.\nsimpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (i0 : int) (H0 : vmatch (Vint i0) (I i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Just (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Just (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (i0 : int) (H0 : vmatch (Vint i0) (I i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (i0 : int) (H0 : vmatch (Vint i0) (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (i0 : int) (H0 : vmatch (Vint i0) (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (i0 : int) (H0 : vmatch Vundef (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c (Vint i) Vundef) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) Vundef) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (i0 : int) (H0 : vmatch Vundef (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (b : block) (ofs : ptrofs) (p : aptr) (H0 : vmatch (Vptr b ofs) (Ptr p)) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0))) (H1 : pmatch b ofs p) : cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs))\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (b : block) (ofs : ptrofs) (p : aptr) (H0 : vmatch (Vptr b ofs) (Ptr p)) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0))) (H1 : pmatch b ofs p)","proofString":"destruct (Int.eq i Int.zero); auto using cmatch_top."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (p : aptr) (H0 : vmatch Vundef (Ptr p)) (IP : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0))) : cmatch (Val.cmpu_bool valid c (Vint i) Vundef)\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) Vundef)\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (I i)) (p : aptr) (H0 : vmatch Vundef (Ptr p)) (IP : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0)))","proofString":"simpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (I i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (I i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) (Vint i0)) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (IU i)) (i0 : int) (H0 : vmatch Vundef (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c (Vint i) Vundef) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c (Vint i) Vundef) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch (Vint i) (IU i)) (i0 : int) (H0 : vmatch Vundef (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch Vundef (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (I i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c Vundef (Vint i0)) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c Vundef (Vint i0)) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch Vundef (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (I i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch Vundef (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c Vundef (Vint i0)) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c Vundef (Vint i0)) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch Vundef (IU i)) (i0 : int) (H0 : vmatch (Vint i0) (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch Vundef (IU i)) (i0 : int) (H0 : vmatch Vundef (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1))) : cmatch (Val.cmpu_bool valid c Vundef Vundef) (Maybe (Int.cmpu c i i0)).","conclusion":"cmatch (Val.cmpu_bool valid c Vundef Vundef) (Maybe (Int.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int) (H : vmatch Vundef (IU i)) (i0 : int) (H0 : vmatch Vundef (IU i0)) (IP : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_different_blocks c)) (IP2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i1) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i1))) (PI2 : forall (i1 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i1))\n  (cmp_intv c itv (Int.unsigned i1)))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b : block) (ofs : ptrofs) (p : aptr) (H : vmatch (Vptr b ofs) (Ptr p)) (i : int) (H0 : vmatch (Vint i) (I i)) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0))) (H1 : pmatch b ofs p) : cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i))\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b : block) (ofs : ptrofs) (p : aptr) (H : vmatch (Vptr b ofs) (Ptr p)) (i : int) (H0 : vmatch (Vint i) (I i)) (IP : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b0 ofs0))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b0 : block) (ofs0 : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b0 ofs0) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0))) (H1 : pmatch b ofs p)","proofString":"destruct (Int.eq i Int.zero); auto using cmatch_top."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (p : aptr) (H : vmatch Vundef (Ptr p)) (i : int) (H0 : vmatch (Vint i) (I i)) (IP : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0))) : cmatch (Val.cmpu_bool valid c Vundef (Vint i))\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmpu_bool valid c Vundef (Vint i))\n  (if Int.eq i Int.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (p : aptr) (H : vmatch Vundef (Ptr p)) (i : int) (H0 : vmatch (Vint i) (I i)) (IP : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int) (b : block) (ofs : ptrofs),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_different_blocks c)) (IP2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vint i0) (Vptr b ofs))\n  (cmp_intv (swap_comparison c) itv (Int.unsigned i0))) (PI2 : forall (i0 : int) (b : block) (ofs : ptrofs) (itv : Z * Z),\ncmatch (Val.cmpu_bool valid c (Vptr b ofs) (Vint i0))\n  (cmp_intv c itv (Int.unsigned i0)))","proofString":"simpl; destruct (Int.eq i Int.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : cmatch (Val.cmp_bool c v w) (cmp_bool c x y).","conclusion":"cmatch (Val.cmp_bool c v w) (cmp_bool c x y)","hypotheses":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold cmp_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_intv_sound, cmp_intv_sound_2, cmp_intv_None;  constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : cmatch (Val.cmplu_bool valid c v w) (cmplu_bool c x y).","conclusion":"cmatch (Val.cmplu_bool valid c v w) (cmplu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"assert (IP: forall i b ofs,    cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs)) (cmp_different_blocks c)).\nintros.\nsimpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none.\nassert (PI: forall i b ofs,    cmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i)) (cmp_different_blocks c)).\nintros.\nsimpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none.\nunfold cmplu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none,             cmatch_lub_l, cmatch_lub_r, pcmp_sound_64.\nconstructor.\ndestruct (Int64.eq i Int64.zero); auto using cmatch_top.\nsimpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none.\ndestruct (Int64.eq i Int64.zero); auto using cmatch_top.\nsimpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c).","conclusion":"forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"intros.\nsimpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs) : cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c).","conclusion":"cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs)","proofString":"simpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs) : cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq i Int64.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq i Int64.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs)","proofString":"destruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs) : cmatch\n  (if\n    Int64.eq i Int64.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if\n    Int64.eq i Int64.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs)","proofString":"destruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs) : cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c).","conclusion":"cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs)","proofString":"apply cmp_different_blocks_sound."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (i : int64) (b : block) (ofs : ptrofs)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c)) : cmatch (Val.cmplu_bool valid c v w) (cmplu_bool c x y).","conclusion":"cmatch (Val.cmplu_bool valid c v w) (cmplu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c))","proofString":"assert (PI: forall i b ofs,    cmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i)) (cmp_different_blocks c)).\nintros.\nsimpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none.\nunfold cmplu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none,             cmatch_lub_l, cmatch_lub_r, pcmp_sound_64.\nconstructor.\ndestruct (Int64.eq i Int64.zero); auto using cmatch_top.\nsimpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none.\ndestruct (Int64.eq i Int64.zero); auto using cmatch_top.\nsimpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c)) : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (cmp_different_blocks c).","conclusion":"forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c))","proofString":"intros.\nsimpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs) : cmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (cmp_different_blocks c).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs)","proofString":"simpl.\ndestruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs) : cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq i Int64.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if negb Archi.ptr64\n   then None\n   else\n    if\n     Int64.eq i Int64.zero &&\n     (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n    then Val.cmp_different_blocks c\n    else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs)","proofString":"destruct Archi.ptr64; simpl.\ndestruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs) : cmatch\n  (if\n    Int64.eq i Int64.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c).","conclusion":"cmatch\n  (if\n    Int64.eq i Int64.zero &&\n    (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))\n   then Val.cmp_different_blocks c\n   else None) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs)","proofString":"destruct (Int64.eq i Int64.zero && (valid b (Ptrofs.unsigned ofs) || valid b (Ptrofs.unsigned ofs - 1))).\napply cmp_different_blocks_sound.\napply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs) : cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c).","conclusion":"cmatch (Val.cmp_different_blocks c) (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs)","proofString":"apply cmp_different_blocks_sound."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs) : cmatch None (cmp_different_blocks c).","conclusion":"cmatch None (cmp_different_blocks c)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (i : int64) (b : block) (ofs : ptrofs)","proofString":"apply cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (cmp_different_blocks c)) : cmatch (Val.cmplu_bool valid c v w) (cmplu_bool c x y).","conclusion":"cmatch (Val.cmplu_bool valid c v w) (cmplu_bool c x y)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) (IP : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (cmp_different_blocks c))","proofString":"unfold cmplu_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top, cmp_different_blocks_none, pcmp_none,             cmatch_lub_l, cmatch_lub_r, pcmp_sound_64.\nconstructor.\ndestruct (Int64.eq i Int64.zero); auto using cmatch_top.\nsimpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none.\ndestruct (Int64.eq i Int64.zero); auto using cmatch_top.\nsimpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (i0 : int64) (H0 : vmatch (Vlong i0) (L i0)) (IP : forall (i1 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i1))\n  (cmp_different_blocks c)) : cmatch (Val.cmplu_bool valid c (Vlong i) (Vlong i0))\n  (Just (Int64.cmpu c i i0)).","conclusion":"cmatch (Val.cmplu_bool valid c (Vlong i) (Vlong i0))\n  (Just (Int64.cmpu c i i0))","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (i0 : int64) (H0 : vmatch (Vlong i0) (L i0)) (IP : forall (i1 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i1) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i1 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i1))\n  (cmp_different_blocks c))","proofString":"constructor."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (b : block) (ofs : ptrofs) (p : aptr) (H0 : vmatch (Vptr b ofs) (Ptr p)) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b0 ofs0) (Vlong i0))\n  (cmp_different_blocks c)) (H1 : pmatch b ofs p) : cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs))\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (b : block) (ofs : ptrofs) (p : aptr) (H0 : vmatch (Vptr b ofs) (Ptr p)) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b0 ofs0) (Vlong i0))\n  (cmp_different_blocks c)) (H1 : pmatch b ofs p)","proofString":"destruct (Int64.eq i Int64.zero); auto using cmatch_top."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (p : aptr) (H0 : vmatch Vundef (Ptr p)) (IP : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i0))\n  (cmp_different_blocks c)) : cmatch (Val.cmplu_bool valid c (Vlong i) Vundef)\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmplu_bool valid c (Vlong i) Vundef)\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (p : aptr) (H0 : vmatch Vundef (Ptr p)) (IP : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i0))\n  (cmp_different_blocks c))","proofString":"simpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (b : block) (ofs : ptrofs) (p : aptr) (H : vmatch (Vptr b ofs) (Ptr p)) (i : int64) (H0 : vmatch (Vlong i) (L i)) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b0 ofs0) (Vlong i0))\n  (cmp_different_blocks c)) (H1 : pmatch b ofs p) : cmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i))\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (b : block) (ofs : ptrofs) (p : aptr) (H : vmatch (Vptr b ofs) (Ptr p)) (i : int64) (H0 : vmatch (Vlong i) (L i)) (IP : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b0 ofs0))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b0 : block) (ofs0 : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b0 ofs0) (Vlong i0))\n  (cmp_different_blocks c)) (H1 : pmatch b ofs p)","proofString":"destruct (Int64.eq i Int64.zero); auto using cmatch_top."},{"statement":"(valid : block -> Z -> bool) (c : comparison) (p : aptr) (H : vmatch Vundef (Ptr p)) (i : int64) (H0 : vmatch (Vlong i) (L i)) (IP : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i0))\n  (cmp_different_blocks c)) : cmatch (Val.cmplu_bool valid c Vundef (Vlong i))\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop).","conclusion":"cmatch (Val.cmplu_bool valid c Vundef (Vlong i))\n  (if Int64.eq i Int64.zero then cmp_different_blocks c else Btop)","hypotheses":"(valid : block -> Z -> bool) (c : comparison) (p : aptr) (H : vmatch Vundef (Ptr p)) (i : int64) (H0 : vmatch (Vlong i) (L i)) (IP : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vlong i0) (Vptr b ofs))\n  (cmp_different_blocks c)) (PI : forall (i0 : int64) (b : block) (ofs : ptrofs),\ncmatch (Val.cmplu_bool valid c (Vptr b ofs) (Vlong i0))\n  (cmp_different_blocks c))","proofString":"simpl; destruct (Int64.eq i Int64.zero); auto using cmatch_top, cmp_different_blocks_none."},{"statement":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : cmatch (Val.cmpl_bool c v w) (cmpl_bool c x y).","conclusion":"cmatch (Val.cmpl_bool c v w) (cmpl_bool c x y)","hypotheses":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"unfold cmpl_bool; inversion H; subst; inversion H0; subst;  auto using cmatch_top.\nconstructor."},{"statement":"(c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (i0 : int64) (H0 : vmatch (Vlong i0) (L i0)) : cmatch (Val.cmpl_bool c (Vlong i) (Vlong i0)) (Just (Int64.cmp c i i0)).","conclusion":"cmatch (Val.cmpl_bool c (Vlong i) (Vlong i0)) (Just (Int64.cmp c i i0))","hypotheses":"(c : comparison) (i : int64) (H : vmatch (Vlong i) (L i)) (i0 : int64) (H0 : vmatch (Vlong i0) (L i0))","proofString":"constructor."},{"statement":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : cmatch (Val.cmpf_bool c v w) (cmpf_bool c x y).","conclusion":"cmatch (Val.cmpf_bool c v w) (cmpf_bool c x y)","hypotheses":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; try constructor; inv H0; constructor."},{"statement":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y) : cmatch (Val.cmpfs_bool c v w) (cmpfs_bool c x y).","conclusion":"cmatch (Val.cmpfs_bool c v w) (cmpfs_bool c x y)","hypotheses":"(c : comparison) (v w : val) (x y : aval) (H : vmatch v x) (H0 : vmatch w y)","proofString":"inv H; try constructor; inv H0; constructor."},{"statement":"(mask : int) (v : val) (x : aval) (H : vmatch v x) : cmatch (Val.maskzero_bool v mask) (maskzero x mask).","conclusion":"cmatch (Val.maskzero_bool v mask) (maskzero x mask)","hypotheses":"(mask : int) (v : val) (x : aval) (H : vmatch v x)","proofString":"inv H; simpl; auto with va.\npredSpec Int.eq Int.eq_spec (Int.zero_ext n mask) Int.zero; auto with va.\nreplace (Int.and i mask) with Int.zero.\nrewrite Int.eq_true.\nconstructor.\nrewrite is_uns_zero_ext in H1.\nrewrite Int.zero_ext_and in * by auto.\nrewrite <- H1.\nrewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto.\ndestruct (Int.eq (Int.zero_ext n mask) Int.zero); constructor."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) : cmatch (Some (Int.eq (Int.and i mask) Int.zero))\n  (if Int.eq (Int.zero_ext n mask) Int.zero then Maybe true else Btop).","conclusion":"cmatch (Some (Int.eq (Int.and i mask) Int.zero))\n  (if Int.eq (Int.zero_ext n mask) Int.zero then Maybe true else Btop)","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i)","proofString":"predSpec Int.eq Int.eq_spec (Int.zero_ext n mask) Int.zero; auto with va.\nreplace (Int.and i mask) with Int.zero.\nrewrite Int.eq_true.\nconstructor.\nrewrite is_uns_zero_ext in H1.\nrewrite Int.zero_ext_and in * by auto.\nrewrite <- H1.\nrewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero) : cmatch (Some (Int.eq (Int.and i mask) Int.zero)) (Maybe true).","conclusion":"cmatch (Some (Int.eq (Int.and i mask) Int.zero)) (Maybe true)","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero)","proofString":"replace (Int.and i mask) with Int.zero.\nrewrite Int.eq_true.\nconstructor.\nrewrite is_uns_zero_ext in H1.\nrewrite Int.zero_ext_and in * by auto.\nrewrite <- H1.\nrewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero) : cmatch (Some (Int.eq Int.zero Int.zero)) (Maybe true).","conclusion":"cmatch (Some (Int.eq Int.zero Int.zero)) (Maybe true)","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero)","proofString":"rewrite Int.eq_true.\nconstructor."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero) : cmatch (Some true) (Maybe true).","conclusion":"cmatch (Some true) (Maybe true)","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero)","proofString":"constructor."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero) : Int.zero = Int.and i mask.","conclusion":"Int.zero = Int.and i mask","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : is_uns n i) (H : Int.zero_ext n mask = Int.zero)","proofString":"rewrite is_uns_zero_ext in H1.\nrewrite Int.zero_ext_and in * by auto.\nrewrite <- H1.\nrewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.zero_ext n i = i) (H : Int.zero_ext n mask = Int.zero) : Int.zero = Int.and i mask.","conclusion":"Int.zero = Int.and i mask","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.zero_ext n i = i) (H : Int.zero_ext n mask = Int.zero)","proofString":"rewrite Int.zero_ext_and in * by auto.\nrewrite <- H1.\nrewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and mask (Int.repr (two_p n - 1)) = Int.zero) : Int.zero = Int.and i mask.","conclusion":"Int.zero = Int.and i mask","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and mask (Int.repr (two_p n - 1)) = Int.zero)","proofString":"rewrite <- H1.\nrewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and mask (Int.repr (two_p n - 1)) = Int.zero) : Int.zero = Int.and (Int.and i (Int.repr (two_p n - 1))) mask.","conclusion":"Int.zero = Int.and (Int.and i (Int.repr (two_p n - 1))) mask","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and mask (Int.repr (two_p n - 1)) = Int.zero)","proofString":"rewrite Int.and_assoc.\nrewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and mask (Int.repr (two_p n - 1)) = Int.zero) : Int.zero = Int.and i (Int.and (Int.repr (two_p n - 1)) mask).","conclusion":"Int.zero = Int.and i (Int.and (Int.repr (two_p n - 1)) mask)","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and mask (Int.repr (two_p n - 1)) = Int.zero)","proofString":"rewrite Int.and_commut in H.\nrewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and (Int.repr (two_p n - 1)) mask = Int.zero) : Int.zero = Int.and i (Int.and (Int.repr (two_p n - 1)) mask).","conclusion":"Int.zero = Int.and i (Int.and (Int.repr (two_p n - 1)) mask)","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and (Int.repr (two_p n - 1)) mask = Int.zero)","proofString":"rewrite H.\nrewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and (Int.repr (two_p n - 1)) mask = Int.zero) : Int.zero = Int.and i Int.zero.","conclusion":"Int.zero = Int.and i Int.zero","hypotheses":"(mask : int) (p : aptr) (i : int) (n : Z) (H0 : 0 <= n) (H1 : Int.and i (Int.repr (two_p n - 1)) = i) (H : Int.and (Int.repr (two_p n - 1)) mask = Int.zero)","proofString":"rewrite Int.and_zero; auto."},{"statement":"(mask : int) (p : aptr) (n : Z) : cmatch None\n  (if Int.eq (Int.zero_ext n mask) Int.zero then Maybe true else Btop).","conclusion":"cmatch None\n  (if Int.eq (Int.zero_ext n mask) Int.zero then Maybe true else Btop)","hypotheses":"(mask : int) (p : aptr) (n : Z)","proofString":"destruct (Int.eq (Int.zero_ext n mask) Int.zero); constructor."},{"statement":"(ob : option bool) (ab : abool) (H : cmatch ob ab) : vmatch (Val.of_optbool ob) (of_optbool ab).","conclusion":"vmatch (Val.of_optbool ob) (of_optbool ab)","hypotheses":"(ob : option bool) (ab : abool) (H : cmatch ob ab)","proofString":"inv H; simpl; auto with va.\ndestruct b; constructor.\ndestruct b; constructor.\ndestruct ob; simpl; auto with va.\ndestruct b; constructor; try lia.\nchange 1 with (usize Int.one).\napply is_uns_usize.\nred; intros.\napply Int.bits_zero."},{"statement":"(b : bool) : vmatch (if b then Vtrue else Vfalse) (I (if b then Int.one else Int.zero)).","conclusion":"vmatch (if b then Vtrue else Vfalse) (I (if b then Int.one else Int.zero))","hypotheses":"(b : bool)","proofString":"destruct b; constructor."},{"statement":"(b : bool) : vmatch (if b then Vtrue else Vfalse) (IU (if b then Int.one else Int.zero)).","conclusion":"vmatch (if b then Vtrue else Vfalse) (IU (if b then Int.one else Int.zero))","hypotheses":"(b : bool)","proofString":"destruct b; constructor."},{"statement":"(ob : option bool) : vmatch (Val.of_optbool ob) (Uns Pbot 1).","conclusion":"vmatch (Val.of_optbool ob) (Uns Pbot 1)","hypotheses":"(ob : option bool)","proofString":"destruct ob; simpl; auto with va.\ndestruct b; constructor; try lia.\nchange 1 with (usize Int.one).\napply is_uns_usize.\nred; intros.\napply Int.bits_zero."},{"statement":"(b : bool) : vmatch (if b then Vtrue else Vfalse) (Uns Pbot 1).","conclusion":"vmatch (if b then Vtrue else Vfalse) (Uns Pbot 1)","hypotheses":"(b : bool)","proofString":"destruct b; constructor; try lia.\nchange 1 with (usize Int.one).\napply is_uns_usize.\nred; intros.\napply Int.bits_zero."},{"statement":"is_uns 1 Int.one.","conclusion":"is_uns 1 Int.one","hypotheses":"","proofString":"change 1 with (usize Int.one).\napply is_uns_usize."},{"statement":"is_uns (usize Int.one) Int.one.","conclusion":"is_uns (usize Int.one) Int.one","hypotheses":"","proofString":"apply is_uns_usize."},{"statement":"is_uns 1 Int.zero.","conclusion":"is_uns 1 Int.zero","hypotheses":"","proofString":"red; intros.\napply Int.bits_zero."},{"statement":"(m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= 1) : Int.testbit Int.zero m = false.","conclusion":"Int.testbit Int.zero m = false","hypotheses":"(m : Z) (H : 0 <= m < Int.zwordsize) (H0 : m >= 1)","proofString":"apply Int.bits_zero."},{"statement":"(b : bool) (ab : abool) (b' : bool) (H : cmatch (Some b) ab) (H0 : resolve_branch ab = Some b') : b' = b.","conclusion":"b' = b","hypotheses":"(b : bool) (ab : abool) (b' : bool) (H : cmatch (Some b) ab) (H0 : resolve_branch ab = Some b')","proofString":"inv H; simpl in H0; congruence."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) : vmatch (Val.normalize v ty) (vnormalize_type ty x).","conclusion":"vmatch (Val.normalize v ty) (vnormalize_type ty x)","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x)","proofString":"assert (A: Val.has_type v ty /\\ vnormalize_type ty x = x          \\/ vnormalize_type ty x = add_undef x).\nunfold vnormalize_type, Val.has_type; inv H; destruct ty; auto.\ndestruct A as [[A B] | A].\nrewrite B, Val.normalize_idem by auto.\nauto.\nrewrite A.\ndestruct (Val.lessdef_normalize v ty);  auto using add_undef_sound, add_undef_undef."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) : Val.has_type v ty /\\ vnormalize_type ty x = x \\/\nvnormalize_type ty x = add_undef x.","conclusion":"Val.has_type v ty /\\ vnormalize_type ty x = x \\/\nvnormalize_type ty x = add_undef x","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x)","proofString":"unfold vnormalize_type, Val.has_type; inv H; destruct ty; auto."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : Val.has_type v ty /\\ vnormalize_type ty x = x \\/\nvnormalize_type ty x = add_undef x) : vmatch (Val.normalize v ty) (vnormalize_type ty x).","conclusion":"vmatch (Val.normalize v ty) (vnormalize_type ty x)","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : Val.has_type v ty /\\ vnormalize_type ty x = x \\/\nvnormalize_type ty x = add_undef x)","proofString":"destruct A as [[A B] | A].\nrewrite B, Val.normalize_idem by auto.\nauto.\nrewrite A.\ndestruct (Val.lessdef_normalize v ty);  auto using add_undef_sound, add_undef_undef."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : Val.has_type v ty) (B : vnormalize_type ty x = x) : vmatch (Val.normalize v ty) (vnormalize_type ty x).","conclusion":"vmatch (Val.normalize v ty) (vnormalize_type ty x)","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : Val.has_type v ty) (B : vnormalize_type ty x = x)","proofString":"rewrite B, Val.normalize_idem by auto.\nauto."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : Val.has_type v ty) (B : vnormalize_type ty x = x) : vmatch v x.","conclusion":"vmatch v x","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : Val.has_type v ty) (B : vnormalize_type ty x = x)","proofString":"auto."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : vnormalize_type ty x = add_undef x) : vmatch (Val.normalize v ty) (vnormalize_type ty x).","conclusion":"vmatch (Val.normalize v ty) (vnormalize_type ty x)","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : vnormalize_type ty x = add_undef x)","proofString":"rewrite A.\ndestruct (Val.lessdef_normalize v ty);  auto using add_undef_sound, add_undef_undef."},{"statement":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : vnormalize_type ty x = add_undef x) : vmatch (Val.normalize v ty) (add_undef x).","conclusion":"vmatch (Val.normalize v ty) (add_undef x)","hypotheses":"(v : val) (x : aval) (ty : typ) (H : vmatch v x) (A : vnormalize_type ty x = add_undef x)","proofString":"destruct (Val.lessdef_normalize v ty);  auto using add_undef_sound, add_undef_undef."},{"statement":"(ob : option bool) (v w : val) (ab : abool) (x y : aval) (ty : typ) (H : cmatch ob ab) (H0 : vmatch v x) (H1 : vmatch w y) : vmatch\n  match ob with\n  | Some b => Val.normalize (if b then v else w) ty\n  | None => Vundef\n  end\n  match ab with\n  | Bnone => ntop\n  | Just b => vnormalize_type ty (if b then x else y)\n  | Maybe b => add_undef (vnormalize_type ty (if b then x else y))\n  | Btop => add_undef (vnormalize_type ty (vlub x y))\n  end.","conclusion":"vmatch\n  match ob with\n  | Some b => Val.normalize (if b then v else w) ty\n  | None => Vundef\n  end\n  match ab with\n  | Bnone => ntop\n  | Just b => vnormalize_type ty (if b then x else y)\n  | Maybe b => add_undef (vnormalize_type ty (if b then x else y))\n  | Btop => add_undef (vnormalize_type ty (vlub x y))\n  end","hypotheses":"(ob : option bool) (v w : val) (ab : abool) (x y : aval) (ty : typ) (H : cmatch ob ab) (H0 : vmatch v x) (H1 : vmatch w y)","proofString":"inv H.\nauto with va.\napply vnormalize_type_sound; destruct b; auto.\napply add_undef_undef.\napply add_undef_sound; apply vnormalize_type_sound; destruct b; auto.\ndestruct ob as [b|].\napply add_undef_sound; apply vnormalize_type_sound.\ndestruct b; [apply vmatch_lub_l|apply vmatch_lub_r]; auto.\napply add_undef_undef."},{"statement":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) : vmatch Vundef ntop.","conclusion":"vmatch Vundef ntop","hypotheses":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y)","proofString":"auto with va."},{"statement":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) (b : bool) : vmatch (Val.normalize (if b then v else w) ty)\n  (vnormalize_type ty (if b then x else y)).","conclusion":"vmatch (Val.normalize (if b then v else w) ty)\n  (vnormalize_type ty (if b then x else y))","hypotheses":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) (b : bool)","proofString":"apply vnormalize_type_sound; destruct b; auto."},{"statement":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) (b : bool) : vmatch Vundef (add_undef (vnormalize_type ty (if b then x else y))).","conclusion":"vmatch Vundef (add_undef (vnormalize_type ty (if b then x else y)))","hypotheses":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) (b : bool)","proofString":"apply add_undef_undef."},{"statement":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) (b : bool) : vmatch (Val.normalize (if b then v else w) ty)\n  (add_undef (vnormalize_type ty (if b then x else y))).","conclusion":"vmatch (Val.normalize (if b then v else w) ty)\n  (add_undef (vnormalize_type ty (if b then x else y)))","hypotheses":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) (b : bool)","proofString":"apply add_undef_sound; apply vnormalize_type_sound; destruct b; auto."},{"statement":"(ob : option bool) (v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) : vmatch\n  match ob with\n  | Some b => Val.normalize (if b then v else w) ty\n  | None => Vundef\n  end (add_undef (vnormalize_type ty (vlub x y))).","conclusion":"vmatch\n  match ob with\n  | Some b => Val.normalize (if b then v else w) ty\n  | None => Vundef\n  end (add_undef (vnormalize_type ty (vlub x y)))","hypotheses":"(ob : option bool) (v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y)","proofString":"destruct ob as [b|].\napply add_undef_sound; apply vnormalize_type_sound.\ndestruct b; [apply vmatch_lub_l|apply vmatch_lub_r]; auto.\napply add_undef_undef."},{"statement":"(b : bool) (v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) : vmatch (Val.normalize (if b then v else w) ty)\n  (add_undef (vnormalize_type ty (vlub x y))).","conclusion":"vmatch (Val.normalize (if b then v else w) ty)\n  (add_undef (vnormalize_type ty (vlub x y)))","hypotheses":"(b : bool) (v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y)","proofString":"apply add_undef_sound; apply vnormalize_type_sound.\ndestruct b; [apply vmatch_lub_l|apply vmatch_lub_r]; auto."},{"statement":"(b : bool) (v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) : vmatch (if b then v else w) (vlub x y).","conclusion":"vmatch (if b then v else w) (vlub x y)","hypotheses":"(b : bool) (v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y)","proofString":"destruct b; [apply vmatch_lub_l|apply vmatch_lub_r]; auto."},{"statement":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y) : vmatch Vundef (add_undef (vnormalize_type ty (vlub x y))).","conclusion":"vmatch Vundef (add_undef (vnormalize_type ty (vlub x y)))","hypotheses":"(v w : val) (x y : aval) (ty : typ) (H0 : vmatch v x) (H1 : vmatch w y)","proofString":"apply add_undef_undef."},{"statement":"(ptr64 : bool) (i : int) : vmatch (Val.norm_bool (Vint (Int.zero_ext 8 i)))\n  (if Int.eq (Int.zero_ext 8 i) Int.zero || Int.eq (Int.zero_ext 8 i) Int.one\n   then I (Int.zero_ext 8 i)\n   else Uns Pbot 1).","conclusion":"vmatch (Val.norm_bool (Vint (Int.zero_ext 8 i)))\n  (if Int.eq (Int.zero_ext 8 i) Int.zero || Int.eq (Int.zero_ext 8 i) Int.one\n   then I (Int.zero_ext 8 i)\n   else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int)","proofString":"set (j := Int.zero_ext 8 i).\nunfold Val.norm_bool, Val.is_bool.\npredSpec Int.eq Int.eq_spec j Int.zero.\nrewrite H.\napply vmatch_i.\npredSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_i.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) : vmatch (Val.norm_bool (Vint j))\n  (if Int.eq j Int.zero || Int.eq j Int.one then I j else Uns Pbot 1).","conclusion":"vmatch (Val.norm_bool (Vint j))\n  (if Int.eq j Int.zero || Int.eq j Int.one then I j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int)","proofString":"unfold Val.norm_bool, Val.is_bool.\npredSpec Int.eq Int.eq_spec j Int.zero.\nrewrite H.\napply vmatch_i.\npredSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_i.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if Int.eq j Int.zero || Int.eq j Int.one then I j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if Int.eq j Int.zero || Int.eq j Int.one then I j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int)","proofString":"predSpec Int.eq Int.eq_spec j Int.zero.\nrewrite H.\napply vmatch_i.\npredSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_i.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if true || Int.eq j Int.one then I j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if true || Int.eq j Int.one then I j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero)","proofString":"rewrite H.\napply vmatch_i."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero) : vmatch\n  (if Val.eq (Vint Int.zero) Vtrue || Val.eq (Vint Int.zero) Vfalse\n   then Vint Int.zero\n   else Vundef)\n  (if true || Int.eq Int.zero Int.one then I Int.zero else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint Int.zero) Vtrue || Val.eq (Vint Int.zero) Vfalse\n   then Vint Int.zero\n   else Vundef)\n  (if true || Int.eq Int.zero Int.one then I Int.zero else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero)","proofString":"apply vmatch_i."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || Int.eq j Int.one then I j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || Int.eq j Int.one then I j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero)","proofString":"predSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_i.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || true then I j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || true then I j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one)","proofString":"rewrite H0.\napply vmatch_i."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one) : vmatch\n  (if Val.eq (Vint Int.one) Vtrue || Val.eq (Vint Int.one) Vfalse\n   then Vint Int.one\n   else Vundef) (if false || true then I Int.one else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint Int.one) Vtrue || Val.eq (Vint Int.one) Vfalse\n   then Vint Int.one\n   else Vundef) (if false || true then I Int.one else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one)","proofString":"apply vmatch_i."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || false then I j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || false then I j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"simpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"unfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch\n  (if\n    (if Val.eq (Vint j) (Vint Int.one) then true else false)\n    || (if Val.eq (Vint j) (Vint Int.zero) then true else false)\n   then Vint j\n   else Vundef) (Uns Pbot 1).","conclusion":"vmatch\n  (if\n    (if Val.eq (Vint j) (Vint Int.one) then true else false)\n    || (if Val.eq (Vint j) (Vint Int.zero) then true else false)\n   then Vint j\n   else Vundef) (Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"rewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch (if false || false then Vint j else Vundef) (Uns Pbot 1).","conclusion":"vmatch (if false || false then Vint j else Vundef) (Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"apply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) : vmatch (Val.norm_bool (Vint (Int.zero_ext 8 i)))\n  (if Int.eq (Int.zero_ext 8 i) Int.zero || Int.eq (Int.zero_ext 8 i) Int.one\n   then IU (Int.zero_ext 8 i)\n   else Uns Pbot 1).","conclusion":"vmatch (Val.norm_bool (Vint (Int.zero_ext 8 i)))\n  (if Int.eq (Int.zero_ext 8 i) Int.zero || Int.eq (Int.zero_ext 8 i) Int.one\n   then IU (Int.zero_ext 8 i)\n   else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int)","proofString":"set (j := Int.zero_ext 8 i).\nunfold Val.norm_bool, Val.is_bool.\npredSpec Int.eq Int.eq_spec j Int.zero.\nrewrite H.\napply vmatch_iu.\npredSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_iu.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) : vmatch (Val.norm_bool (Vint j))\n  (if Int.eq j Int.zero || Int.eq j Int.one then IU j else Uns Pbot 1).","conclusion":"vmatch (Val.norm_bool (Vint j))\n  (if Int.eq j Int.zero || Int.eq j Int.one then IU j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int)","proofString":"unfold Val.norm_bool, Val.is_bool.\npredSpec Int.eq Int.eq_spec j Int.zero.\nrewrite H.\napply vmatch_iu.\npredSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_iu.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if Int.eq j Int.zero || Int.eq j Int.one then IU j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if Int.eq j Int.zero || Int.eq j Int.one then IU j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int)","proofString":"predSpec Int.eq Int.eq_spec j Int.zero.\nrewrite H.\napply vmatch_iu.\npredSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_iu.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if true || Int.eq j Int.one then IU j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if true || Int.eq j Int.one then IU j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero)","proofString":"rewrite H.\napply vmatch_iu."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero) : vmatch\n  (if Val.eq (Vint Int.zero) Vtrue || Val.eq (Vint Int.zero) Vfalse\n   then Vint Int.zero\n   else Vundef)\n  (if true || Int.eq Int.zero Int.one then IU Int.zero else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint Int.zero) Vtrue || Val.eq (Vint Int.zero) Vfalse\n   then Vint Int.zero\n   else Vundef)\n  (if true || Int.eq Int.zero Int.one then IU Int.zero else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j = Int.zero)","proofString":"apply vmatch_iu."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || Int.eq j Int.one then IU j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || Int.eq j Int.one then IU j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero)","proofString":"predSpec Int.eq Int.eq_spec j Int.one.\nrewrite H0.\napply vmatch_iu.\nsimpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || true then IU j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || true then IU j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one)","proofString":"rewrite H0.\napply vmatch_iu."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one) : vmatch\n  (if Val.eq (Vint Int.one) Vtrue || Val.eq (Vint Int.one) Vfalse\n   then Vint Int.one\n   else Vundef) (if false || true then IU Int.one else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint Int.one) Vtrue || Val.eq (Vint Int.one) Vfalse\n   then Vint Int.one\n   else Vundef) (if false || true then IU Int.one else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j = Int.one)","proofString":"apply vmatch_iu."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || false then IU j else Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (if false || false then IU j else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"simpl.\nunfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (Uns Pbot 1).","conclusion":"vmatch\n  (if Val.eq (Vint j) Vtrue || Val.eq (Vint j) Vfalse then Vint j else Vundef)\n  (Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"unfold proj_sumbool, Vtrue, Vfalse.\nrewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch\n  (if\n    (if Val.eq (Vint j) (Vint Int.one) then true else false)\n    || (if Val.eq (Vint j) (Vint Int.zero) then true else false)\n   then Vint j\n   else Vundef) (Uns Pbot 1).","conclusion":"vmatch\n  (if\n    (if Val.eq (Vint j) (Vint Int.one) then true else false)\n    || (if Val.eq (Vint j) (Vint Int.zero) then true else false)\n   then Vint j\n   else Vundef) (Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"rewrite ! dec_eq_false by congruence.\napply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one) : vmatch (if false || false then Vint j else Vundef) (Uns Pbot 1).","conclusion":"vmatch (if false || false then Vint j else Vundef) (Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int) (j : int) (H : j <> Int.zero) (H0 : j <> Int.one)","proofString":"apply vmatch_Uns_undef."},{"statement":"(ptr64 : bool) (i : int) : vmatch Vundef\n  (if Int.eq (Int.zero_ext 8 i) Int.zero || Int.eq (Int.zero_ext 8 i) Int.one\n   then IU (Int.zero_ext 8 i)\n   else Uns Pbot 1).","conclusion":"vmatch Vundef\n  (if Int.eq (Int.zero_ext 8 i) Int.zero || Int.eq (Int.zero_ext 8 i) Int.one\n   then IU (Int.zero_ext 8 i)\n   else Uns Pbot 1)","hypotheses":"(ptr64 : bool) (i : int)","proofString":"destruct orb; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : vmatch (Vint (Int.sign_ext 8 i))\n  (if zlt n 8\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 8).","conclusion":"vmatch (Vint (Int.sign_ext 8 i))\n  (if zlt n 8\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 8)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"destruct (zlt n 8); constructor; auto with va.\napply is_sign_ext_uns; auto.\napply is_sign_ext_sgn; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (l : n < 8) : is_uns n (Int.sign_ext 8 i).","conclusion":"is_uns n (Int.sign_ext 8 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (l : n < 8)","proofString":"apply is_sign_ext_uns; auto."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= 8) : is_sgn 8 (Int.sign_ext 8 i).","conclusion":"is_sgn 8 (Int.sign_ext 8 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= 8)","proofString":"apply is_sign_ext_sgn; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : vmatch (Vint (Int.zero_ext 8 i)) (Uns (provenance (Uns p n)) (Z.min n 8)).","conclusion":"vmatch (Vint (Int.zero_ext 8 i)) (Uns (provenance (Uns p n)) (Z.min n 8))","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"constructor.\nlia.\napply is_zero_ext_uns.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : 0 <= Z.min n 8.","conclusion":"0 <= Z.min n 8","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"lia."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : is_uns (Z.min n 8) (Int.zero_ext 8 i).","conclusion":"is_uns (Z.min n 8) (Int.zero_ext 8 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply is_zero_ext_uns.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : is_uns (Z.min n 8) i \\/ 8 <= Z.min n 8.","conclusion":"is_uns (Z.min n 8) i \\/ 8 <= Z.min n 8","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : vmatch (Vint (Int.sign_ext 16 i))\n  (if zlt n 16\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 16).","conclusion":"vmatch (Vint (Int.sign_ext 16 i))\n  (if zlt n 16\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 16)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"destruct (zlt n 16); constructor; auto with va.\napply is_sign_ext_uns; auto.\napply is_sign_ext_sgn; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (l : n < 16) : is_uns n (Int.sign_ext 16 i).","conclusion":"is_uns n (Int.sign_ext 16 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (l : n < 16)","proofString":"apply is_sign_ext_uns; auto."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= 16) : is_sgn 16 (Int.sign_ext 16 i).","conclusion":"is_sgn 16 (Int.sign_ext 16 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) (g : n >= 16)","proofString":"apply is_sign_ext_sgn; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : vmatch (Vint (Int.zero_ext 16 i)) (Uns (provenance (Uns p n)) (Z.min n 16)).","conclusion":"vmatch (Vint (Int.zero_ext 16 i)) (Uns (provenance (Uns p n)) (Z.min n 16))","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"constructor.\nextlia.\napply is_zero_ext_uns.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : 0 <= Z.min n 16.","conclusion":"0 <= Z.min n 16","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"extlia."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : is_uns (Z.min n 16) (Int.zero_ext 16 i).","conclusion":"is_uns (Z.min n 16) (Int.zero_ext 16 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply is_zero_ext_uns.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i) : is_uns (Z.min n 16) i \\/ 16 <= Z.min n 16.","conclusion":"is_uns (Z.min n 16) i \\/ 16 <= Z.min n 16","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 <= n) (H0 : is_uns n i)","proofString":"apply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (n : Z) : vmatch Vundef\n  (if zlt n 8\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 8).","conclusion":"vmatch Vundef\n  (if zlt n 8\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 8)","hypotheses":"(ptr64 : bool) (p : aptr) (n : Z)","proofString":"destruct (zlt n 8); auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (n : Z) : vmatch Vundef\n  (if zlt n 16\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 16).","conclusion":"vmatch Vundef\n  (if zlt n 16\n   then Uns (provenance (Uns p n)) n\n   else Sgn (provenance (Uns p n)) 16)","hypotheses":"(ptr64 : bool) (p : aptr) (n : Z)","proofString":"destruct (zlt n 16); auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : vmatch (Vint (Int.sign_ext 8 i)) (Sgn (provenance (Sgn p n)) (Z.min n 8)).","conclusion":"vmatch (Vint (Int.sign_ext 8 i)) (Sgn (provenance (Sgn p n)) (Z.min n 8))","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : 0 < Z.min n 8.","conclusion":"0 < Z.min n 8","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"lia."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : is_sgn (Z.min n 8) (Int.sign_ext 8 i).","conclusion":"is_sgn (Z.min n 8) (Int.sign_ext 8 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : is_sgn (Z.min n 8) i \\/ 8 <= Z.min n 8.","conclusion":"is_sgn (Z.min n 8) i \\/ 8 <= Z.min n 8","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : vmatch (Vint (Int.sign_ext 16 i)) (Sgn (provenance (Sgn p n)) (Z.min n 16)).","conclusion":"vmatch (Vint (Int.sign_ext 16 i)) (Sgn (provenance (Sgn p n)) (Z.min n 16))","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : 0 < Z.min n 16.","conclusion":"0 < Z.min n 16","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"lia."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : is_sgn (Z.min n 16) (Int.sign_ext 16 i).","conclusion":"is_sgn (Z.min n 16) (Int.sign_ext 16 i)","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply is_sign_ext_sgn; auto with va.\napply Z.min_case; auto with va."},{"statement":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i) : is_sgn (Z.min n 16) i \\/ 16 <= Z.min n 16.","conclusion":"is_sgn (Z.min n 16) i \\/ 16 <= Z.min n 16","hypotheses":"(ptr64 : bool) (p : aptr) (i : int) (n : Z) (H : 0 < n) (H0 : is_sgn n i)","proofString":"apply Z.min_case; auto with va."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load chunk m b ofs = Some v) (H0 : vmatch v (Ifptr p)) : vmatch v (vnormalize chunk (Ifptr p)).","conclusion":"vmatch v (vnormalize chunk (Ifptr p))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load chunk m b ofs = Some v) (H0 : vmatch v (Ifptr p))","proofString":"exploit Mem.load_cast; eauto.\nexploit Mem.load_type; eauto.\ndestruct chunk; simpl; intros.\nrewrite H2.\nauto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\ndestruct v; try contradiction; constructor.\ndestruct v; try contradiction; constructor.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load chunk m b ofs = Some v) (H0 : vmatch v (Ifptr p)) : match chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend -> vmatch v (vnormalize chunk (Ifptr p)).","conclusion":"match chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend -> vmatch v (vnormalize chunk (Ifptr p))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load chunk m b ofs = Some v) (H0 : vmatch v (Ifptr p))","proofString":"exploit Mem.load_type; eauto.\ndestruct chunk; simpl; intros.\nrewrite H2.\nauto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\ndestruct v; try contradiction; constructor.\ndestruct v; try contradiction; constructor.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load chunk m b ofs = Some v) (H0 : vmatch v (Ifptr p)) : Val.has_type v (type_of_chunk chunk) ->\nmatch chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend -> vmatch v (vnormalize chunk (Ifptr p)).","conclusion":"Val.has_type v (type_of_chunk chunk) ->\nmatch chunk with\n| Mbool => v = Val.norm_bool v\n| Mint8signed => v = Val.sign_ext 8 v\n| Mint8unsigned => v = Val.zero_ext 8 v\n| Mint16signed => v = Val.sign_ext 16 v\n| Mint16unsigned => v = Val.zero_ext 16 v\n| _ => True\nend -> vmatch v (vnormalize chunk (Ifptr p))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load chunk m b ofs = Some v) (H0 : vmatch v (Ifptr p))","proofString":"destruct chunk; simpl; intros.\nrewrite H2.\nauto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va.\nrewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\ndestruct v; try contradiction; constructor.\ndestruct v; try contradiction; constructor.\nred in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mbool m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.norm_bool v) : vmatch v (Uns (poffset p) 1).","conclusion":"vmatch v (Uns (poffset p) 1)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mbool m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.norm_bool v)","proofString":"rewrite H2.\nauto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mbool m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.norm_bool v) : vmatch (Val.norm_bool v) (Uns (poffset p) 1).","conclusion":"vmatch (Val.norm_bool v) (Uns (poffset p) 1)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mbool m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.norm_bool v)","proofString":"auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 8 v) : vmatch v (Sgn (poffset p) 8).","conclusion":"vmatch v (Sgn (poffset p) 8)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 8 v)","proofString":"rewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 8 v) : vmatch (Val.sign_ext 8 v) (Sgn (poffset p) 8).","conclusion":"vmatch (Val.sign_ext 8 v) (Sgn (poffset p) 8)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 8 v)","proofString":"destruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 8 (Vint i)) : 0 < 8.","conclusion":"0 < 8","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 8 (Vint i))","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 8 (Vint i)) : is_sgn 8 (Int.sign_ext 8 i).","conclusion":"is_sgn 8 (Int.sign_ext 8 i)","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 8 (Vint i))","proofString":"apply is_sign_ext_sgn; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 8 v) : vmatch v (Uns (poffset p) 8).","conclusion":"vmatch v (Uns (poffset p) 8)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 8 v)","proofString":"rewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 8 v) : vmatch (Val.zero_ext 8 v) (Uns (poffset p) 8).","conclusion":"vmatch (Val.zero_ext 8 v) (Uns (poffset p) 8)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 8 v)","proofString":"destruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 8 (Vint i)) : 0 <= 8.","conclusion":"0 <= 8","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 8 (Vint i))","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 8 (Vint i)) : is_uns 8 (Int.zero_ext 8 i).","conclusion":"is_uns 8 (Int.zero_ext 8 i)","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint8unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 8 (Vint i))","proofString":"apply is_zero_ext_uns; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 16 v) : vmatch v (Sgn (poffset p) 16).","conclusion":"vmatch v (Sgn (poffset p) 16)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 16 v)","proofString":"rewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 16 v) : vmatch (Val.sign_ext 16 v) (Sgn (poffset p) 16).","conclusion":"vmatch (Val.sign_ext 16 v) (Sgn (poffset p) 16)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.sign_ext 16 v)","proofString":"destruct v; simpl; constructor.\nlia.\napply is_sign_ext_sgn; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 16 (Vint i)) : 0 < 16.","conclusion":"0 < 16","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 16 (Vint i))","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 16 (Vint i)) : is_sgn 16 (Int.sign_ext 16 i).","conclusion":"is_sgn 16 (Int.sign_ext 16 i)","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16signed m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.sign_ext 16 (Vint i))","proofString":"apply is_sign_ext_sgn; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 16 v) : vmatch v (Uns (poffset p) 16).","conclusion":"vmatch v (Uns (poffset p) 16)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 16 v)","proofString":"rewrite H2.\ndestruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 16 v) : vmatch (Val.zero_ext 16 v) (Uns (poffset p) 16).","conclusion":"vmatch (Val.zero_ext 16 v) (Uns (poffset p) 16)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : v = Val.zero_ext 16 v)","proofString":"destruct v; simpl; constructor.\nlia.\napply is_zero_ext_uns; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 16 (Vint i)) : 0 <= 16.","conclusion":"0 <= 16","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 16 (Vint i))","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 16 (Vint i)) : is_uns 16 (Int.zero_ext 16 i).","conclusion":"is_uns 16 (Int.zero_ext 16 i)","hypotheses":"(m : mem) (b : block) (ofs : Z) (i : int) (p : aptr) (H : Mem.load Mint16unsigned m b ofs = Some (Vint i)) (H0 : vmatch (Vint i) (Ifptr p)) (H1 : Val.has_type (Vint i) Tint) (H2 : Vint i = Val.zero_ext 16 (Vint i))","proofString":"apply is_zero_ext_uns; auto with va."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : True) : vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p).","conclusion":"vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tint) (H2 : True)","proofString":"red in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend) (H2 : True) : vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p).","conclusion":"vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend) (H2 : True)","proofString":"destruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vint _ => True\n| Vptr _ _ => true = false\n| _ => False\nend) (H2 : True) : vmatch v (Num (poffset p)).","conclusion":"vmatch v (Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vint _ => True\n| Vptr _ _ => true = false\n| _ => False\nend) (H2 : True)","proofString":"destruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tlong) (H2 : True) : vmatch v (if Archi.ptr64 then Ifptr p else Num (poffset p)).","conclusion":"vmatch v (if Archi.ptr64 then Ifptr p else Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tlong) (H2 : True)","proofString":"red in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend) (H2 : True) : vmatch v (if Archi.ptr64 then Ifptr p else Num (poffset p)).","conclusion":"vmatch v (if Archi.ptr64 then Ifptr p else Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend) (H2 : True)","proofString":"destruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => false = true\n| _ => False\nend) (H2 : True) : vmatch v (Num (poffset p)).","conclusion":"vmatch v (Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mint64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => false = true\n| _ => False\nend) (H2 : True)","proofString":"destruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mfloat32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tsingle) (H2 : True) : vmatch v (Num (poffset p)).","conclusion":"vmatch v (Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mfloat32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tsingle) (H2 : True)","proofString":"destruct v; try contradiction; constructor."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mfloat64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tfloat) (H2 : True) : vmatch v (Num (poffset p)).","conclusion":"vmatch v (Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Mfloat64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tfloat) (H2 : True)","proofString":"destruct v; try contradiction; constructor."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tany32) (H2 : True) : vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p).","conclusion":"vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tany32) (H2 : True)","proofString":"red in H1.\ndestruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vlong _ | Vfloat _ => False\n| Vptr _ _ => Archi.ptr64 = false\n| _ => True\nend) (H2 : True) : vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p).","conclusion":"vmatch v (if Archi.ptr64 then Num (poffset p) else Ifptr p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vlong _ | Vfloat _ => False\n| Vptr _ _ => Archi.ptr64 = false\n| _ => True\nend) (H2 : True)","proofString":"destruct Archi.ptr64; auto.\ndestruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vlong _ | Vfloat _ => False\n| Vptr _ _ => true = false\n| _ => True\nend) (H2 : True) : vmatch v (Num (poffset p)).","conclusion":"vmatch v (Num (poffset p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many32 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : match v with\n| Vlong _ | Vfloat _ => False\n| Vptr _ _ => true = false\n| _ => True\nend) (H2 : True)","proofString":"destruct v; constructor || discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tany64) (H2 : True) : vmatch v (Ifptr p).","conclusion":"vmatch v (Ifptr p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (v : val) (p : aptr) (H : Mem.load Many64 m b ofs = Some v) (H0 : vmatch v (Ifptr p)) (H1 : Val.has_type v Tany64) (H2 : True)","proofString":"auto."},{"statement":"(p q : aptr) (H : pge p q) : pge (provenance (Ifptr p)) q.","conclusion":"pge (provenance (Ifptr p)) q","hypotheses":"(p q : aptr) (H : pge p q)","proofString":"simpl.\napply pge_trans with p; auto.\napply poffset_ge."},{"statement":"(p q : aptr) (H : pge p q) : pge (poffset p) q.","conclusion":"pge (poffset p) q","hypotheses":"(p q : aptr) (H : pge p q)","proofString":"apply pge_trans with p; auto.\napply poffset_ge."},{"statement":"(p q : aptr) (H : pge p q) : pge (poffset p) p.","conclusion":"pge (poffset p) p","hypotheses":"(p q : aptr) (H : pge p q)","proofString":"apply poffset_ge."},{"statement":"(v : val) (x : xtype) (p : aptr) (H : Val.has_argtype v x) (H0 : vmatch v (Ifptr p)) : vmatch v (of_xtype x p).","conclusion":"vmatch v (of_xtype x p)","hypotheses":"(v : val) (x : xtype) (p : aptr) (H : Val.has_argtype v x) (H0 : vmatch v (Ifptr p))","proofString":"destruct x, v; simpl in *; try contradiction; auto with va.\nconstructor.\nlia.\napply is_uns_zero_ext.\ndestruct H; subst i; auto.\nconstructor.\nlia.\napply is_sgn_sign_ext.\nlia.\nauto.\nconstructor.\nlia.\napply is_uns_zero_ext.\nauto.\nconstructor.\nlia.\napply is_sgn_sign_ext.\nlia.\nauto.\nconstructor.\nlia.\napply is_uns_zero_ext.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p)) : vmatch (Vint i) (Uns p 1).","conclusion":"vmatch (Vint i) (Uns p 1)","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"constructor.\nlia.\napply is_uns_zero_ext.\ndestruct H; subst i; auto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p)) : 0 <= 1.","conclusion":"0 <= 1","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p)) : is_uns 1 i.","conclusion":"is_uns 1 i","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"apply is_uns_zero_ext.\ndestruct H; subst i; auto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p)) : Int.zero_ext 1 i = i.","conclusion":"Int.zero_ext 1 i = i","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero \\/ i = Int.one) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"destruct H; subst i; auto."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : vmatch (Vint i) (Sgn p 8).","conclusion":"vmatch (Vint i) (Sgn p 8)","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"constructor.\nlia.\napply is_sgn_sign_ext.\nlia.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : 0 < 8.","conclusion":"0 < 8","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : is_sgn 8 i.","conclusion":"is_sgn 8 i","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"apply is_sgn_sign_ext.\nlia.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : 0 < 8.","conclusion":"0 < 8","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : Int.sign_ext 8 i = i.","conclusion":"Int.sign_ext 8 i = i","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"auto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : vmatch (Vint i) (Uns p 8).","conclusion":"vmatch (Vint i) (Uns p 8)","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"constructor.\nlia.\napply is_uns_zero_ext.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : 0 <= 8.","conclusion":"0 <= 8","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : is_uns 8 i.","conclusion":"is_uns 8 i","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"apply is_uns_zero_ext.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p)) : Int.zero_ext 8 i = i.","conclusion":"Int.zero_ext 8 i = i","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 8 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"auto."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : vmatch (Vint i) (Sgn p 16).","conclusion":"vmatch (Vint i) (Sgn p 16)","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"constructor.\nlia.\napply is_sgn_sign_ext.\nlia.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : 0 < 16.","conclusion":"0 < 16","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : is_sgn 16 i.","conclusion":"is_sgn 16 i","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"apply is_sgn_sign_ext.\nlia.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : 0 < 16.","conclusion":"0 < 16","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : Int.sign_ext 16 i = i.","conclusion":"Int.sign_ext 16 i = i","hypotheses":"(i : int) (p : aptr) (H : i = Int.sign_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"auto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : vmatch (Vint i) (Uns p 16).","conclusion":"vmatch (Vint i) (Uns p 16)","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"constructor.\nlia.\napply is_uns_zero_ext.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : 0 <= 16.","conclusion":"0 <= 16","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"lia."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : is_uns 16 i.","conclusion":"is_uns 16 i","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"apply is_uns_zero_ext.\nauto."},{"statement":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p)) : Int.zero_ext 16 i = i.","conclusion":"Int.zero_ext 16 i = i","hypotheses":"(i : int) (p : aptr) (H : i = Int.zero_ext 16 i) (H0 : vmatch (Vint i) (Ifptr p))","proofString":"auto."},{"statement":"(c1 c2 : acontent) : {c1 = c2} + {c1 <> c2}.","conclusion":"{c1 = c2} + {c1 <> c2}","hypotheses":"(c1 c2 : acontent)","proofString":"generalize chunk_eq eq_aval.\ndecide equality."},{"statement":"(c1 c2 : acontent) : (forall c3 c4 : memory_chunk, {c3 = c4} + {c3 <> c4}) ->\n(forall v1 v2 : aval, {v1 = v2} + {v1 <> v2}) -> {c1 = c2} + {c1 <> c2}.","conclusion":"(forall c3 c4 : memory_chunk, {c3 = c4} + {c3 <> c4}) ->\n(forall v1 v2 : aval, {v1 = v2} + {v1 <> v2}) -> {c1 = c2} + {c1 <> c2}","hypotheses":"(c1 c2 : acontent)","proofString":"decide equality."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) : Mem.load chunk m b ofs = Some v.","conclusion":"Mem.load chunk m b ofs = Some v","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v)","proofString":"exploit Mem.load_loadbytes; eauto.\nintros [bytes [A B]].\nexploit Mem.load_valid_access; eauto.\nintros [C D].\nsubst v.\napply Mem.loadbytes_load; auto.\napply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) : (exists bytes : list memval,\n   Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes /\\\n   v = decode_val chunk bytes) -> Mem.load chunk m b ofs = Some v.","conclusion":"(exists bytes : list memval,\n   Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes /\\\n   v = decode_val chunk bytes) -> Mem.load chunk m b ofs = Some v","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v)","proofString":"intros [bytes [A B]].\nexploit Mem.load_valid_access; eauto.\nintros [C D].\nsubst v.\napply Mem.loadbytes_load; auto.\napply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (bytes : list memval) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (B : v = decode_val chunk bytes) : Mem.load chunk m b ofs = Some v.","conclusion":"Mem.load chunk m b ofs = Some v","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (bytes : list memval) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (B : v = decode_val chunk bytes)","proofString":"exploit Mem.load_valid_access; eauto.\nintros [C D].\nsubst v.\napply Mem.loadbytes_load; auto.\napply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (bytes : list memval) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (B : v = decode_val chunk bytes) : Mem.valid_access m' chunk b ofs Readable -> Mem.load chunk m b ofs = Some v.","conclusion":"Mem.valid_access m' chunk b ofs Readable -> Mem.load chunk m b ofs = Some v","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (bytes : list memval) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (B : v = decode_val chunk bytes)","proofString":"intros [C D].\nsubst v.\napply Mem.loadbytes_load; auto.\napply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (bytes : list memval) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (B : v = decode_val chunk bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs)) : Mem.load chunk m b ofs = Some v.","conclusion":"Mem.load chunk m b ofs = Some v","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m' b ofs = Some v) (bytes : list memval) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (B : v = decode_val chunk bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs))","proofString":"subst v.\napply Mem.loadbytes_load; auto.\napply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (bytes : list memval) (H0 : Mem.load chunk m' b ofs = Some (decode_val chunk bytes)) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs)) : Mem.load chunk m b ofs = Some (decode_val chunk bytes).","conclusion":"Mem.load chunk m b ofs = Some (decode_val chunk bytes)","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (bytes : list memval) (H0 : Mem.load chunk m' b ofs = Some (decode_val chunk bytes)) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs))","proofString":"apply Mem.loadbytes_load; auto.\napply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (bytes : list memval) (H0 : Mem.load chunk m' b ofs = Some (decode_val chunk bytes)) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs)) : Mem.loadbytes m b ofs (size_chunk chunk) = Some bytes.","conclusion":"Mem.loadbytes m b ofs (size_chunk chunk) = Some bytes","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (bytes : list memval) (H0 : Mem.load chunk m' b ofs = Some (decode_val chunk bytes)) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs))","proofString":"apply H; auto.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (bytes : list memval) (H0 : Mem.load chunk m' b ofs = Some (decode_val chunk bytes)) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs)) : size_chunk chunk >= 0.","conclusion":"size_chunk chunk >= 0","hypotheses":"(b : block) (m m' : mem) (H : forall (ofs0 n : Z) (bytes0 : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes0 ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes0) (chunk : memory_chunk) (ofs : Z) (bytes : list memval) (H0 : Mem.load chunk m' b ofs = Some (decode_val chunk bytes)) (A : Mem.loadbytes m' b ofs (size_chunk chunk) = Some bytes) (C : Mem.range_perm m' b ofs (ofs + size_chunk chunk) Cur Readable) (D : (align_chunk chunk | ofs))","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes) : smatch m' b p.","conclusion":"smatch m' b p","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes)","proofString":"destruct H.\nsplit; intros.\neapply H; eauto.\neapply loadbytes_load_ext; eauto.\neapply H1; eauto.\napply H0; eauto.\nlia."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr p)) (H1 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' p) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes) : smatch m' b p.","conclusion":"smatch m' b p","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr p)) (H1 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' p) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes)","proofString":"split; intros.\neapply H; eauto.\neapply loadbytes_load_ext; eauto.\neapply H1; eauto.\napply H0; eauto.\nlia."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (H1 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' p) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H2 : Mem.load chunk m' b ofs = Some v) : vmatch v (Ifptr p).","conclusion":"vmatch v (Ifptr p)","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (H1 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' p) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H2 : Mem.load chunk m' b ofs = Some v)","proofString":"eapply H; eauto.\neapply loadbytes_load_ext; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch b'0 ofs'0 p) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H2 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch b' ofs' p.","conclusion":"pmatch b' ofs' p","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch b'0 ofs'0 p) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H2 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil))","proofString":"eapply H1; eauto.\napply H0; eauto.\nlia."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch b'0 ofs'0 p) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H2 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : 1 >= 0.","conclusion":"1 >= 0","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch b'0 ofs'0 p) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H2 : Mem.loadbytes m' b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil))","proofString":"lia."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : smatch m' b p.","conclusion":"smatch m' b p","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)","proofString":"eapply smatch_ext; eauto.\nintros.\nrewrite <- H0; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes.","conclusion":"forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)","proofString":"intros.\nrewrite <- H0; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall ofs0 n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b ofs0 n0 = Mem.loadbytes m b ofs0 n0) (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' b ofs n = Some bytes) (H2 : n >= 0) : Mem.loadbytes m b ofs n = Some bytes.","conclusion":"Mem.loadbytes m b ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (p : aptr) (m' : mem) (H : smatch m b p) (H0 : forall ofs0 n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b ofs0 n0 = Mem.loadbytes m b ofs0 n0) (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' b ofs n = Some bytes) (H2 : n >= 0)","proofString":"rewrite <- H0; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (H : smatch m b p) (H0 : pge q p) : smatch m b q.","conclusion":"smatch m b q","hypotheses":"(m : mem) (b : block) (p q : aptr) (H : smatch m b p) (H0 : pge q p)","proofString":"destruct H as [A B].\nsplit; intros.\napply vmatch_ge with (Ifptr p); eauto with va.\napply pmatch_ge with p; eauto with va."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (H0 : pge q p) : smatch m b q.","conclusion":"smatch m b q","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (H0 : pge q p)","proofString":"split; intros.\napply vmatch_ge with (Ifptr p); eauto with va.\napply pmatch_ge with p; eauto with va."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (H0 : pge q p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (Ifptr q).","conclusion":"vmatch v (Ifptr q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (H0 : pge q p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"apply vmatch_ge with (Ifptr p); eauto with va."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 p) (H0 : pge q p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil)) : pmatch b' ofs' q.","conclusion":"pmatch b' ofs' q","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 p) (H0 : pge q p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil))","proofString":"apply pmatch_ge with p; eauto with va."},{"statement":"(m : mem) (b : block) (byte : memval) (n : Z) : forall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs n = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + n /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"forall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs n = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + n /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n : Z)","proofString":"pattern n.\napply well_founded_ind with (R := Zwf 0).\napply Zwf_well_founded.\nintros sz REC ofs bytes LOAD IN.\ndestruct (zle sz 0).\nrewrite (Mem.loadbytes_empty m b ofs sz) in LOAD by auto.\ninv LOAD.\ncontradiction.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD1 & LOAD2 & CONCAT).\nsubst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n : Z) : (fun z : Z =>\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs z = Some bytes ->\n In byte bytes ->\n exists ofs' : Z,\n   ofs <= ofs' < ofs + z /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) n.","conclusion":"(fun z : Z =>\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs z = Some bytes ->\n In byte bytes ->\n exists ofs' : Z,\n   ofs <= ofs' < ofs + z /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) n","hypotheses":"(m : mem) (b : block) (byte : memval) (n : Z)","proofString":"apply well_founded_ind with (R := Zwf 0).\napply Zwf_well_founded.\nintros sz REC ofs bytes LOAD IN.\ndestruct (zle sz 0).\nrewrite (Mem.loadbytes_empty m b ofs sz) in LOAD by auto.\ninv LOAD.\ncontradiction.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD1 & LOAD2 & CONCAT).\nsubst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n : Z) : well_founded (Zwf 0).","conclusion":"well_founded (Zwf 0)","hypotheses":"(m : mem) (b : block) (byte : memval) (n : Z)","proofString":"apply Zwf_well_founded."},{"statement":"(m : mem) (b : block) (byte : memval) (n : Z) : forall x : Z,\n(forall y : Z,\n Zwf 0 y x ->\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs y = Some bytes ->\n In byte bytes ->\n exists ofs' : Z,\n   ofs <= ofs' < ofs + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) ->\nforall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs x = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + x /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"forall x : Z,\n(forall y : Z,\n Zwf 0 y x ->\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs y = Some bytes ->\n In byte bytes ->\n exists ofs' : Z,\n   ofs <= ofs' < ofs + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) ->\nforall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs x = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + x /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n : Z)","proofString":"intros sz REC ofs bytes LOAD IN.\ndestruct (zle sz 0).\nrewrite (Mem.loadbytes_empty m b ofs sz) in LOAD by auto.\ninv LOAD.\ncontradiction.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD1 & LOAD2 & CONCAT).\nsubst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes)","proofString":"destruct (zle sz 0).\nrewrite (Mem.loadbytes_empty m b ofs sz) in LOAD by auto.\ninv LOAD.\ncontradiction.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD1 & LOAD2 & CONCAT).\nsubst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (l : sz <= 0) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (l : sz <= 0)","proofString":"rewrite (Mem.loadbytes_empty m b ofs sz) in LOAD by auto.\ninv LOAD.\ncontradiction."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Some nil = Some bytes) (IN : In byte bytes) (l : sz <= 0) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Some nil = Some bytes) (IN : In byte bytes) (l : sz <= 0)","proofString":"inv LOAD.\ncontradiction."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (IN : In byte nil) (l : sz <= 0) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (IN : In byte nil) (l : sz <= 0)","proofString":"contradiction."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0)","proofString":"exploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD1 & LOAD2 & CONCAT).\nsubst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) : Mem.loadbytes m b ofs (1 + (sz - 1)) = Some bytes.","conclusion":"Mem.loadbytes m b ofs (1 + (sz - 1)) = Some bytes","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0)","proofString":"replace (1 + (sz - 1)) with sz by lia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) : Mem.loadbytes m b ofs sz = Some bytes.","conclusion":"Mem.loadbytes m b ofs sz = Some bytes","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0)","proofString":"auto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) : 1 >= 0.","conclusion":"1 >= 0","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0)","proofString":"lia."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) : sz - 1 >= 0.","conclusion":"sz - 1 >= 0","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0)","proofString":"lia."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) : (exists bytes1 bytes2 : list memval,\n   Mem.loadbytes m b ofs 1 = Some bytes1 /\\\n   Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2 /\\\n   bytes = bytes1 ++ bytes2) ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"(exists bytes1 bytes2 : list memval,\n   Mem.loadbytes m b ofs 1 = Some bytes1 /\\\n   Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2 /\\\n   bytes = bytes1 ++ bytes2) ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0)","proofString":"intros (bytes1 & bytes2 & LOAD1 & LOAD2 & CONCAT).\nsubst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) (bytes1 bytes2 : list memval) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (CONCAT : bytes = bytes1 ++ bytes2) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nIn byte bytes0 ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (IN : In byte bytes) (g : sz > 0) (bytes1 bytes2 : list memval) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (CONCAT : bytes = bytes1 ++ bytes2)","proofString":"subst bytes.\nexploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte (bytes1 ++ bytes2)) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte (bytes1 ++ bytes2)) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2)","proofString":"exploit Mem.loadbytes_length.\neexact LOAD1.\nchange (Z.to_nat 1) with 1%nat.\nintros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte (bytes1 ++ bytes2)) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) : Datatypes.length bytes1 = 1%nat ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"Datatypes.length bytes1 = 1%nat ->\nexists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte (bytes1 ++ bytes2)) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2)","proofString":"intros LENGTH1.\nrewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte (bytes1 ++ bytes2)) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte (bytes1 ++ bytes2)) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat)","proofString":"rewrite in_app_iff in IN.\ndestruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte bytes1 \\/ In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (IN : In byte bytes1 \\/ In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat)","proofString":"destruct IN.\ndestruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto.\nexploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes1) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes1) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat)","proofString":"destruct bytes1; try discriminate.\ndestruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes1 bytes2 : list memval) (H : In byte (m0 :: bytes1)) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: bytes1) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: bytes1)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: bytes1) = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes1 bytes2 : list memval) (H : In byte (m0 :: bytes1)) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: bytes1) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: bytes1)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: bytes1) = 1%nat)","proofString":"destruct bytes1; try discriminate.\nsimpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes2 : list memval) (H : In byte (m0 :: nil)) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: nil) = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes2 : list memval) (H : In byte (m0 :: nil)) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: nil) = 1%nat)","proofString":"simpl in H.\ndestruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes2 : list memval) (H : m0 = byte \\/ False) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: nil) = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes2 : list memval) (H : m0 = byte \\/ False) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: nil) = 1%nat)","proofString":"destruct H; try contradiction.\nsubst m0.\nexists ofs; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes2 : list memval) (H : m0 = byte) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: nil) = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (m0 : memval) (bytes2 : list memval) (H : m0 = byte) (LOAD : Mem.loadbytes m b ofs sz = Some ((m0 :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (m0 :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (m0 :: nil) = 1%nat)","proofString":"subst m0.\nexists ofs; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (byte :: nil) = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (byte :: nil) = 1%nat)","proofString":"exists ofs; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (byte :: nil) = 1%nat) : ofs <= ofs < ofs + sz.","conclusion":"ofs <= ofs < ofs + sz","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (byte :: nil) = 1%nat)","proofString":"lia."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (byte :: nil) = 1%nat) : Mem.loadbytes m b ofs 1 = Some (byte :: nil).","conclusion":"Mem.loadbytes m b ofs 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length (byte :: nil) = 1%nat)","proofString":"auto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) : exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"exists ofs' : Z,\n  ofs <= ofs' < ofs + sz /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat)","proofString":"exploit (REC (sz - 1)).\nred; lia.\neexact LOAD2.\nauto.\nintros (ofs' & A & B).\nexists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) : Zwf 0 (sz - 1) sz.","conclusion":"Zwf 0 (sz - 1) sz","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs' : Z,\n  ofs0 <= ofs' < ofs0 + y /\\ Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat)","proofString":"red; lia."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs'0 : Z,\n  ofs0 <= ofs'0 < ofs0 + y /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) (ofs' : Z) (A : ofs + 1 <= ofs' < ofs + 1 + (sz - 1)) (B : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) : exists ofs'0 : Z,\n  ofs <= ofs'0 < ofs + sz /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil).","conclusion":"exists ofs'0 : Z,\n  ofs <= ofs'0 < ofs + sz /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs'0 : Z,\n  ofs0 <= ofs'0 < ofs0 + y /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) (ofs' : Z) (A : ofs + 1 <= ofs' < ofs + 1 + (sz - 1)) (B : Mem.loadbytes m b ofs' 1 = Some (byte :: nil))","proofString":"exists ofs'; split.\nlia.\nauto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs'0 : Z,\n  ofs0 <= ofs'0 < ofs0 + y /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) (ofs' : Z) (A : ofs + 1 <= ofs' < ofs + 1 + (sz - 1)) (B : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) : ofs <= ofs' < ofs + sz.","conclusion":"ofs <= ofs' < ofs + sz","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs'0 : Z,\n  ofs0 <= ofs'0 < ofs0 + y /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) (ofs' : Z) (A : ofs + 1 <= ofs' < ofs + 1 + (sz - 1)) (B : Mem.loadbytes m b ofs' 1 = Some (byte :: nil))","proofString":"lia."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs'0 : Z,\n  ofs0 <= ofs'0 < ofs0 + y /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) (ofs' : Z) (A : ofs + 1 <= ofs' < ofs + 1 + (sz - 1)) (B : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) : Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nIn byte bytes ->\nexists ofs'0 : Z,\n  ofs0 <= ofs'0 < ofs0 + y /\\ Mem.loadbytes m b ofs'0 1 = Some (byte :: nil)) (ofs : Z) (bytes1 bytes2 : list memval) (H : In byte bytes2) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (g : sz > 0) (LOAD1 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD2 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (LENGTH1 : Datatypes.length bytes1 = 1%nat) (ofs' : Z) (A : ofs + 1 <= ofs' < ofs + 1 + (sz - 1)) (B : Mem.loadbytes m b ofs' 1 = Some (byte :: nil))","proofString":"auto."},{"statement":"(m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b p) (H1 : In (Fragment (Vptr b' ofs') q i) bytes) : pmatch b' ofs' p.","conclusion":"pmatch b' ofs' p","hypotheses":"(m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b p) (H1 : In (Fragment (Vptr b' ofs') q i) bytes)","proofString":"exploit In_loadbytes; eauto.\nintros (ofs1 & A & B).\neapply H0; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b p) (H1 : In (Fragment (Vptr b' ofs') q i) bytes) : (exists ofs'0 : Z,\n   ofs <= ofs'0 < ofs + n /\\\n   Mem.loadbytes m b ofs'0 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) ->\npmatch b' ofs' p.","conclusion":"(exists ofs'0 : Z,\n   ofs <= ofs'0 < ofs + n /\\\n   Mem.loadbytes m b ofs'0 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) ->\npmatch b' ofs' p","hypotheses":"(m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b p) (H1 : In (Fragment (Vptr b' ofs') q i) bytes)","proofString":"intros (ofs1 & A & B).\neapply H0; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b p) (H1 : In (Fragment (Vptr b' ofs') q i) bytes) (ofs1 : Z) (A : ofs <= ofs1 < ofs + n) (B : Mem.loadbytes m b ofs1 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch b' ofs' p.","conclusion":"pmatch b' ofs' p","hypotheses":"(m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b p) (H1 : In (Fragment (Vptr b' ofs') q i) bytes) (ofs1 : Z) (A : ofs <= ofs1 < ofs + n) (B : Mem.loadbytes m b ofs1 1 = Some (Fragment (Vptr b' ofs') q i :: nil))","proofString":"eapply H0; eauto."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z) : forall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs n = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs <= ofs' < ofs + n -> In byte bytes.","conclusion":"forall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs n = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs <= ofs' < ofs + n -> In byte bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z)","proofString":"pattern n.\napply well_founded_ind with (R := Zwf 0).\napply Zwf_well_founded.\nintros sz REC ofs bytes LOAD LOAD1 IN.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD3 & LOAD4 & CONCAT).\nsubst bytes.\nrewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z) : (fun z : Z =>\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs z = Some bytes ->\n Mem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\n ofs <= ofs' < ofs + z -> In byte bytes) n.","conclusion":"(fun z : Z =>\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs z = Some bytes ->\n Mem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\n ofs <= ofs' < ofs + z -> In byte bytes) n","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z)","proofString":"apply well_founded_ind with (R := Zwf 0).\napply Zwf_well_founded.\nintros sz REC ofs bytes LOAD LOAD1 IN.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD3 & LOAD4 & CONCAT).\nsubst bytes.\nrewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z) : well_founded (Zwf 0).","conclusion":"well_founded (Zwf 0)","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z)","proofString":"apply Zwf_well_founded."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z) : forall x : Z,\n(forall y : Z,\n Zwf 0 y x ->\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs y = Some bytes ->\n Mem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\n ofs <= ofs' < ofs + y -> In byte bytes) ->\nforall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs x = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs <= ofs' < ofs + x -> In byte bytes.","conclusion":"forall x : Z,\n(forall y : Z,\n Zwf 0 y x ->\n forall (ofs : Z) (bytes : list memval),\n Mem.loadbytes m b ofs y = Some bytes ->\n Mem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\n ofs <= ofs' < ofs + y -> In byte bytes) ->\nforall (ofs : Z) (bytes : list memval),\nMem.loadbytes m b ofs x = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs <= ofs' < ofs + x -> In byte bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n : Z)","proofString":"intros sz REC ofs bytes LOAD LOAD1 IN.\nexploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD3 & LOAD4 & CONCAT).\nsubst bytes.\nrewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) : In byte bytes.","conclusion":"In byte bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz)","proofString":"exploit (Mem.loadbytes_split m b ofs 1 (sz - 1) bytes).\nreplace (1 + (sz - 1)) with sz by lia.\nauto.\nlia.\nlia.\nintros (bytes1 & bytes2 & LOAD3 & LOAD4 & CONCAT).\nsubst bytes.\nrewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) : Mem.loadbytes m b ofs (1 + (sz - 1)) = Some bytes.","conclusion":"Mem.loadbytes m b ofs (1 + (sz - 1)) = Some bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz)","proofString":"replace (1 + (sz - 1)) with sz by lia.\nauto."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) : Mem.loadbytes m b ofs sz = Some bytes.","conclusion":"Mem.loadbytes m b ofs sz = Some bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz)","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) : 1 >= 0.","conclusion":"1 >= 0","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz)","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) : sz - 1 >= 0.","conclusion":"sz - 1 >= 0","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz)","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) : (exists bytes1 bytes2 : list memval,\n   Mem.loadbytes m b ofs 1 = Some bytes1 /\\\n   Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2 /\\\n   bytes = bytes1 ++ bytes2) -> In byte bytes.","conclusion":"(exists bytes1 bytes2 : list memval,\n   Mem.loadbytes m b ofs 1 = Some bytes1 /\\\n   Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2 /\\\n   bytes = bytes1 ++ bytes2) -> In byte bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz)","proofString":"intros (bytes1 & bytes2 & LOAD3 & LOAD4 & CONCAT).\nsubst bytes.\nrewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (bytes1 bytes2 : list memval) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (CONCAT : bytes = bytes1 ++ bytes2) : In byte bytes.","conclusion":"In byte bytes","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes0 : list memval),\nMem.loadbytes m b ofs0 y = Some bytes0 ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes0) (ofs : Z) (bytes : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some bytes) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (bytes1 bytes2 : list memval) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (CONCAT : bytes = bytes1 ++ bytes2)","proofString":"subst bytes.\nrewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) : In byte (bytes1 ++ bytes2).","conclusion":"In byte (bytes1 ++ bytes2)","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2)","proofString":"rewrite in_app_iff.\ndestruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) : In byte bytes1 \\/ In byte bytes2.","conclusion":"In byte bytes1 \\/ In byte bytes2","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2)","proofString":"destruct (zeq ofs ofs').\nsubst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto.\nright.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (e : ofs = ofs') : In byte bytes1 \\/ In byte bytes2.","conclusion":"In byte bytes1 \\/ In byte bytes2","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (e : ofs = ofs')","proofString":"subst ofs'.\nrewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz ofs : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs 1 = Some (byte :: nil) ->\nofs0 <= ofs < ofs0 + y -> In byte bytes) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (IN : ofs <= ofs < ofs + sz) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) : In byte bytes1 \\/ In byte bytes2.","conclusion":"In byte bytes1 \\/ In byte bytes2","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz ofs : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs 1 = Some (byte :: nil) ->\nofs0 <= ofs < ofs0 + y -> In byte bytes) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (IN : ofs <= ofs < ofs + sz) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2)","proofString":"rewrite LOAD1 in LOAD3; inv LOAD3.\nleft; simpl; auto."},{"statement":"(m : mem) (b : block) (byte : memval) (n sz ofs : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs 1 = Some (byte :: nil) ->\nofs0 <= ofs < ofs0 + y -> In byte bytes) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (IN : ofs <= ofs < ofs + sz) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) : In byte (byte :: nil) \\/ In byte bytes2.","conclusion":"In byte (byte :: nil) \\/ In byte bytes2","hypotheses":"(m : mem) (b : block) (byte : memval) (n sz ofs : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs 1 = Some (byte :: nil) ->\nofs0 <= ofs < ofs0 + y -> In byte bytes) (bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some ((byte :: nil) ++ bytes2)) (IN : ofs <= ofs < ofs + sz) (LOAD1 : Mem.loadbytes m b ofs 1 = Some (byte :: nil)) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2)","proofString":"left; simpl; auto."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs') : In byte bytes1 \\/ In byte bytes2.","conclusion":"In byte bytes1 \\/ In byte bytes2","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs')","proofString":"right.\neapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs') : In byte bytes2.","conclusion":"In byte bytes2","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs')","proofString":"eapply (REC (sz - 1)).\nred; lia.\neexact LOAD4.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs') : Zwf 0 (sz - 1) sz.","conclusion":"Zwf 0 (sz - 1) sz","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs')","proofString":"red; lia."},{"statement":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs') : Mem.loadbytes m b ofs' 1 = Some (byte :: nil).","conclusion":"Mem.loadbytes m b ofs' 1 = Some (byte :: nil)","hypotheses":"(m : mem) (b : block) (ofs' : Z) (byte : memval) (n sz : Z) (REC : forall y : Z,\nZwf 0 y sz ->\nforall (ofs0 : Z) (bytes : list memval),\nMem.loadbytes m b ofs0 y = Some bytes ->\nMem.loadbytes m b ofs' 1 = Some (byte :: nil) ->\nofs0 <= ofs' < ofs0 + y -> In byte bytes) (ofs : Z) (bytes1 bytes2 : list memval) (LOAD : Mem.loadbytes m b ofs sz = Some (bytes1 ++ bytes2)) (LOAD1 : Mem.loadbytes m b ofs' 1 = Some (byte :: nil)) (IN : ofs <= ofs' < ofs + sz) (LOAD3 : Mem.loadbytes m b ofs 1 = Some bytes1) (LOAD4 : Mem.loadbytes m b (ofs + 1) (sz - 1) = Some bytes2) (n0 : ofs <> ofs')","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) : In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil))","proofString":"assert (EITHER:            (b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (length bytes) <= ofs')         \\/ (b' = b /\\ ofs <= ofs' < ofs + Z.of_nat (length bytes))).\ndestruct (eq_block b' b); auto.\ndestruct (zle (ofs' + 1) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes)) ofs'); auto.\nright.\nsplit.\nauto.\nlia.\ndestruct EITHER as [A | (A & B)].\nright.\nrewrite <- H0.\nsymmetry.\neapply Mem.loadbytes_storebytes_other; eauto.\nlia.\nsubst b'.\nleft.\neapply loadbytes_provenance; eauto.\neapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) : (b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes).","conclusion":"(b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil))","proofString":"destruct (eq_block b' b); auto.\ndestruct (zle (ofs' + 1) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes)) ofs'); auto.\nright.\nsplit.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) : (b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes).","conclusion":"(b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b)","proofString":"destruct (zle (ofs' + 1) ofs); auto.\ndestruct (zle (ofs + Z.of_nat (length bytes)) ofs'); auto.\nright.\nsplit.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) : (b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes).","conclusion":"(b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs)","proofString":"destruct (zle (ofs + Z.of_nat (length bytes)) ofs'); auto.\nright.\nsplit.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs') : (b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes).","conclusion":"(b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs')","proofString":"right.\nsplit.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs') : b' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes).","conclusion":"b' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs')","proofString":"split.\nauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs') : b' = b.","conclusion":"b' = b","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs')","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs') : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes).","conclusion":"ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (e : b' = b) (g : ofs' + 1 > ofs) (g0 : ofs + Z.of_nat (Datatypes.length bytes) > ofs')","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (EITHER : (b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)) : In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (EITHER : (b' <> b \\/\n ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') \\/\nb' = b /\\ ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"destruct EITHER as [A | (A & B)].\nright.\nrewrite <- H0.\nsymmetry.\neapply Mem.loadbytes_storebytes_other; eauto.\nlia.\nsubst b'.\nleft.\neapply loadbytes_provenance; eauto.\neapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs')","proofString":"right.\nrewrite <- H0.\nsymmetry.\neapply Mem.loadbytes_storebytes_other; eauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : Mem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"Mem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs')","proofString":"rewrite <- H0.\nsymmetry.\neapply Mem.loadbytes_storebytes_other; eauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : Mem.loadbytes m b' ofs' 1 = Mem.loadbytes m' b' ofs' 1.","conclusion":"Mem.loadbytes m b' ofs' 1 = Mem.loadbytes m' b' ofs' 1","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs')","proofString":"symmetry.\neapply Mem.loadbytes_storebytes_other; eauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : Mem.loadbytes m' b' ofs' 1 = Mem.loadbytes m b' ofs' 1.","conclusion":"Mem.loadbytes m' b' ofs' 1 = Mem.loadbytes m b' ofs' 1","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs')","proofString":"eapply Mem.loadbytes_storebytes_other; eauto.\nlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs') : 1 >= 0.","conclusion":"1 >= 0","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' <> b \\/ ofs' + 1 <= ofs \\/ ofs + Z.of_nat (Datatypes.length bytes) <= ofs')","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' = b) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)) : In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : b' = b) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"subst b'.\nleft.\neapply loadbytes_provenance; eauto.\neapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)) : In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"In (Fragment (Vptr b'' ofs'') q i) bytes \\/\nMem.loadbytes m b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"left.\neapply loadbytes_provenance; eauto.\neapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)) : In (Fragment (Vptr b'' ofs'') q i) bytes.","conclusion":"In (Fragment (Vptr b'' ofs'') q i) bytes","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"eapply loadbytes_provenance; eauto.\neapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes)) : Mem.loadbytes m' b ofs (Z.of_nat (Datatypes.length bytes)) = Some bytes.","conclusion":"Mem.loadbytes m' b ofs (Z.of_nat (Datatypes.length bytes)) = Some bytes","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : Mem.loadbytes m' b ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (B : ofs <= ofs' < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"eapply Mem.loadbytes_storebytes_same; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil))","proofString":"exploit storebytes_provenance; eauto.\neapply Mem.store_storebytes; eauto.\nintros [A|A]; auto.\nleft.\ngeneralize (encode_val_shape chunk v).\nintros ENC; inv ENC.\nsplit; auto.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H5; eauto.\nintros (j & P & Q); congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H3; eauto.\nintros [byte P]; congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) \\/\nMem.loadbytes m b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v))","proofString":"left.\ngeneralize (encode_val_shape chunk v).\nintros ENC; inv ENC.\nsplit; auto.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H5; eauto.\nintros (j & P & Q); congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H3; eauto.\nintros [byte P]; congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v))","proofString":"generalize (encode_val_shape chunk v).\nintros ENC; inv ENC.\nsplit; auto.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H5; eauto.\nintros (j & P & Q); congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H3; eauto.\nintros [byte P]; congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) : shape_encoding chunk v (encode_val chunk v) ->\nv = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"shape_encoding chunk v (encode_val chunk v) ->\nv = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v))","proofString":"intros ENC; inv ENC.\nsplit; auto.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H5; eauto.\nintros (j & P & Q); congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H3; eauto.\nintros [byte P]; congruence.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (i0 : nat) (mvl : list memval) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk)) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (i0 : nat) (mvl : list memval) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk))","proofString":"split; auto.\nrewrite <- H1 in A; destruct A.\ncongruence.\nexploit H5; eauto.\nintros (j & P & Q); congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (i0 : nat) (mvl : list memval) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk)) : v = Vptr b'' ofs''.","conclusion":"v = Vptr b'' ofs''","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (i0 : nat) (mvl : list memval) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk))","proofString":"rewrite <- H1 in A; destruct A.\ncongruence.\nexploit H5; eauto.\nintros (j & P & Q); congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (i0 : nat) (mvl : list memval) (H3 : Fragment v (quantity_chunk chunk) i0 = Fragment (Vptr b'' ofs'') q i) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk)) : v = Vptr b'' ofs''.","conclusion":"v = Vptr b'' ofs''","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (i0 : nat) (mvl : list memval) (H3 : Fragment v (quantity_chunk chunk) i0 = Fragment (Vptr b'' ofs'') q i) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk))","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (i0 : nat) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk)) : v = Vptr b'' ofs''.","conclusion":"v = Vptr b'' ofs''","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (i0 : nat) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk))","proofString":"exploit H5; eauto.\nintros (j & P & Q); congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (i0 : nat) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk)) : (exists j : nat,\n   Fragment (Vptr b'' ofs'') q i = Fragment v (quantity_chunk chunk) j /\\\n   S j <> size_quantity_nat (quantity_chunk chunk)) -> \nv = Vptr b'' ofs''.","conclusion":"(exists j : nat,\n   Fragment (Vptr b'' ofs'') q i = Fragment v (quantity_chunk chunk) j /\\\n   S j <> size_quantity_nat (quantity_chunk chunk)) -> \nv = Vptr b'' ofs''","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (i0 : nat) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H1 : Fragment v (quantity_chunk chunk) i0 :: mvl = encode_val chunk v) (H5 : forall mv : memval,\nIn mv mvl ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H4 : S i0 = size_quantity_nat (quantity_chunk chunk))","proofString":"intros (j & P & Q); congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (b0 : byte) (mvl : list memval) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (b0 : byte) (mvl : list memval) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v)","proofString":"rewrite <- H1 in A; destruct A.\ncongruence.\nexploit H3; eauto.\nintros [byte P]; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (b0 : byte) (mvl : list memval) (H4 : Byte b0 = Fragment (Vptr b'' ofs'') q i) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (b0 : byte) (mvl : list memval) (H4 : Byte b0 = Fragment (Vptr b'' ofs'') q i) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (b0 : byte) (mvl : list memval) (H4 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (b0 : byte) (mvl : list memval) (H4 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v)","proofString":"exploit H3; eauto.\nintros [byte P]; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (b0 : byte) (mvl : list memval) (H4 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v) : (exists b'0 : byte, Fragment (Vptr b'' ofs'') q i = Byte b'0) ->\nv = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"(exists b'0 : byte, Fragment (Vptr b'' ofs'') q i = Byte b'0) ->\nv = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (b0 : byte) (mvl : list memval) (H4 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : match v with\n| Vundef | Vptr _ _ => False\n| _ => True\nend) (H3 : forall mv : memval, In mv mvl -> exists b'0 : byte, mv = Byte b'0) (H1 : Byte b0 :: mvl = encode_val chunk v)","proofString":"intros [byte P]; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (mvl : list memval) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (A : In (Fragment (Vptr b'' ofs'') q i) (encode_val chunk v)) (mvl : list memval) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v)","proofString":"rewrite <- H1 in A; destruct A.\ncongruence.\nexploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (mvl : list memval) (H3 : Undef = Fragment (Vptr b'' ofs'') q i) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (mvl : list memval) (H3 : Undef = Fragment (Vptr b'' ofs'') q i) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v) : v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"v = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v)","proofString":"exploit H2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v) : Fragment (Vptr b'' ofs'') q i = Undef ->\nv = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64).","conclusion":"Fragment (Vptr b'' ofs'') q i = Undef ->\nv = Vptr b'' ofs'' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ofs' : Z) (b'' : block) (ofs'' : ptrofs) (q : quantity) (i : nat) (H : Mem.store chunk m b ofs v = Some m') (H0 : Mem.loadbytes m' b' ofs' 1 = Some (Fragment (Vptr b'' ofs'') q i :: nil)) (mvl : list memval) (H3 : In (Fragment (Vptr b'' ofs'') q i) mvl) (H2 : forall mv : memval, In mv mvl -> mv = Undef) (H1 : Undef :: mvl = encode_val chunk v)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (H0 : smatch m b' p) (H1 : vmatch v av) : smatch m' b' (vplub av p).","conclusion":"smatch m' b' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (H0 : smatch m b' p) (H1 : vmatch v av)","proofString":"destruct H0 as [A B].\nsplit.\nintros chunk' ofs' v' LOAD.\ndestruct v'; auto with va.\nexploit Mem.load_pointer_store; eauto.\nintros [(P & Q & R & S) | DISJ].\nsubst.\napply vmatch_vplub_l.\nauto.\napply vmatch_vplub_r.\napply A with (chunk := chunk') (ofs := ofs').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nintros.\nexploit store_provenance; eauto.\nintros [[P Q] | P].\nsubst.\nassert (V: vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))).\napply vmatch_vplub_l.\nauto.\ninv V; auto.\napply pmatch_vplub.\neapply B; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (P : v = Vptr b0 i) (Q : Mem.compat_pointer_chunks chunk chunk') (R : b' = b) (S : ofs' = ofs) : vmatch (Vptr b0 i) (Ifptr (vplub av p)).","conclusion":"vmatch (Vptr b0 i) (Ifptr (vplub av p))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (P : v = Vptr b0 i) (Q : Mem.compat_pointer_chunks chunk chunk') (R : b' = b) (S : ofs' = ofs)","proofString":"subst.\napply vmatch_vplub_l.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (p : aptr) (av : aval) (b0 : block) (i : ptrofs) (H : Mem.store chunk m b ofs (Vptr b0 i) = Some m') (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i0 :: nil) ->\npmatch b' ofs' p) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : vmatch (Vptr b0 i) av) (chunk' : memory_chunk) (LOAD : Mem.load chunk' m' b ofs = Some (Vptr b0 i)) (Q : Mem.compat_pointer_chunks chunk chunk') : vmatch (Vptr b0 i) (Ifptr (vplub av p)).","conclusion":"vmatch (Vptr b0 i) (Ifptr (vplub av p))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (p : aptr) (av : aval) (b0 : block) (i : ptrofs) (H : Mem.store chunk m b ofs (Vptr b0 i) = Some m') (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i0 :: nil) ->\npmatch b' ofs' p) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : vmatch (Vptr b0 i) av) (chunk' : memory_chunk) (LOAD : Mem.load chunk' m' b ofs = Some (Vptr b0 i)) (Q : Mem.compat_pointer_chunks chunk chunk')","proofString":"apply vmatch_vplub_l.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (p : aptr) (av : aval) (b0 : block) (i : ptrofs) (H : Mem.store chunk m b ofs (Vptr b0 i) = Some m') (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i0 :: nil) ->\npmatch b' ofs' p) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : vmatch (Vptr b0 i) av) (chunk' : memory_chunk) (LOAD : Mem.load chunk' m' b ofs = Some (Vptr b0 i)) (Q : Mem.compat_pointer_chunks chunk chunk') : vmatch (Vptr b0 i) av.","conclusion":"vmatch (Vptr b0 i) av","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (p : aptr) (av : aval) (b0 : block) (i : ptrofs) (H : Mem.store chunk m b ofs (Vptr b0 i) = Some m') (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i0 :: nil) ->\npmatch b' ofs' p) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (Ifptr p)) (H1 : vmatch (Vptr b0 i) av) (chunk' : memory_chunk) (LOAD : Mem.load chunk' m' b ofs = Some (Vptr b0 i)) (Q : Mem.compat_pointer_chunks chunk chunk')","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (DISJ : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : Mem.load chunk' m b' ofs' = Some (Vptr b0 i).","conclusion":"Mem.load chunk' m b' ofs' = Some (Vptr b0 i)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (DISJ : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"rewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (DISJ : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : Mem.load chunk' m b' ofs' = Mem.load chunk' m' b' ofs'.","conclusion":"Mem.load chunk' m b' ofs' = Mem.load chunk' m' b' ofs'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (DISJ : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"symmetry.\neapply Mem.load_store_other; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (DISJ : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs') : Mem.load chunk' m' b' ofs' = Mem.load chunk' m b' ofs'.","conclusion":"Mem.load chunk' m' b' ofs' = Mem.load chunk' m b' ofs'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (b0 : block) (i : ptrofs) (LOAD : Mem.load chunk' m' b' ofs' = Some (Vptr b0 i)) (DISJ : b' <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"eapply Mem.load_store_other; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : vmatch v av) : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (vplub av p).","conclusion":"forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : vmatch v av)","proofString":"intros.\nexploit store_provenance; eauto.\nintros [[P Q] | P].\nsubst.\nassert (V: vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))).\napply vmatch_vplub_l.\nauto.\ninv V; auto.\napply pmatch_vplub.\neapply B; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : pmatch b'0 ofs' (vplub av p).","conclusion":"pmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"exploit store_provenance; eauto.\nintros [[P Q] | P].\nsubst.\nassert (V: vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))).\napply vmatch_vplub_l.\nauto.\ninv V; auto.\napply pmatch_vplub.\neapply B; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : v = Vptr b'0 ofs' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) \\/\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (vplub av p).","conclusion":"v = Vptr b'0 ofs' /\\\n(chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) \\/\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"intros [[P Q] | P].\nsubst.\nassert (V: vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))).\napply vmatch_vplub_l.\nauto.\ninv V; auto.\napply pmatch_vplub.\neapply B; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (P : v = Vptr b'0 ofs') (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : pmatch b'0 ofs' (vplub av p).","conclusion":"pmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (P : v = Vptr b'0 ofs') (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"subst.\nassert (V: vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))).\napply vmatch_vplub_l.\nauto.\ninv V; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : pmatch b'0 ofs' (vplub av p).","conclusion":"pmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"assert (V: vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))).\napply vmatch_vplub_l.\nauto.\ninv V; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : vmatch (Vptr b'0 ofs') (Ifptr (vplub av p)).","conclusion":"vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"apply vmatch_vplub_l.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : vmatch (Vptr b'0 ofs') av.","conclusion":"vmatch (Vptr b'0 ofs') av","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (V : vmatch (Vptr b'0 ofs') (Ifptr (vplub av p))) : pmatch b'0 ofs' (vplub av p).","conclusion":"pmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (b' : block) (p : aptr) (av : aval) (b'0 : block) (ofs' : ptrofs) (H : Mem.store chunk m b ofs (Vptr b'0 ofs') = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch (Vptr b'0 ofs') av) (ofs0 : Z) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Q : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (V : vmatch (Vptr b'0 ofs') (Ifptr (vplub av p)))","proofString":"inv V; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (P : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : pmatch b'0 ofs' (vplub av p).","conclusion":"pmatch b'0 ofs' (vplub av p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (P : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"apply pmatch_vplub.\neapply B; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (P : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : pmatch b'0 ofs' p.","conclusion":"pmatch b'0 ofs' p","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : vmatch v av) (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (P : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"eapply B; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : smatch m b' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') : smatch m' b' (plub p' p).","conclusion":"smatch m' b' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : smatch m b' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p')","proofString":"destruct H0 as [A B].\nsplit.\nintros.\napply vmatch_ifptr.\nintros bx ofsx EQ; subst v.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto.\nintros.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') : smatch m' b' (plub p' p).","conclusion":"smatch m' b' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p')","proofString":"split.\nintros.\napply vmatch_ifptr.\nintros bx ofsx EQ; subst v.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto.\nintros.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m' b' ofs0 = Some v -> vmatch v (Ifptr (plub p' p)).","conclusion":"forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m' b' ofs0 = Some v -> vmatch v (Ifptr (plub p' p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p')","proofString":"intros.\napply vmatch_ifptr.\nintros bx ofsx EQ; subst v.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (v : val) (H0 : Mem.load chunk m' b' ofs0 = Some v) : vmatch v (Ifptr (plub p' p)).","conclusion":"vmatch v (Ifptr (plub p' p))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (v : val) (H0 : Mem.load chunk m' b' ofs0 = Some v)","proofString":"apply vmatch_ifptr.\nintros bx ofsx EQ; subst v.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (v : val) (H0 : Mem.load chunk m' b' ofs0 = Some v) : forall (b0 : block) (ofs1 : ptrofs),\nv = Vptr b0 ofs1 -> pmatch b0 ofs1 (plub p' p).","conclusion":"forall (b0 : block) (ofs1 : ptrofs),\nv = Vptr b0 ofs1 -> pmatch b0 ofs1 (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (v : val) (H0 : Mem.load chunk m' b' ofs0 = Some v)","proofString":"intros bx ofsx EQ; subst v.\nexploit Mem.load_loadbytes; eauto.\nintros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx))","proofString":"exploit Mem.load_loadbytes; eauto.\nintros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) : (exists bytes0 : list memval,\n   Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some bytes0 /\\\n   Vptr bx ofsx = decode_val chunk bytes0) -> pmatch bx ofsx (plub p' p).","conclusion":"(exists bytes0 : list memval,\n   Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some bytes0 /\\\n   Vptr bx ofsx = decode_val chunk bytes0) -> pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx))","proofString":"intros (bytes' & P & Q).\ndestruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some bytes') (Q : Vptr bx ofsx = decode_val chunk bytes') : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some bytes') (Q : Vptr bx ofsx = decode_val chunk bytes')","proofString":"destruct bytes' as [ | byte1' bytes'].\nexploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate.\ngeneralize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some nil) (Q : Vptr bx ofsx = decode_val chunk nil) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some nil) (Q : Vptr bx ofsx = decode_val chunk nil)","proofString":"exploit Mem.loadbytes_length; eauto.\nintros.\ndestruct chunk; discriminate."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (byte1' : memval) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some (byte1' :: bytes')) (Q : Vptr bx ofsx = decode_val chunk (byte1' :: bytes')) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (byte1' : memval) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some (byte1' :: bytes')) (Q : Vptr bx ofsx = decode_val chunk (byte1' :: bytes'))","proofString":"generalize (decode_val_shape chunk byte1' bytes').\nrewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (byte1' : memval) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some (byte1' :: bytes')) (Q : Vptr bx ofsx = decode_val chunk (byte1' :: bytes')) : shape_decoding chunk (byte1' :: bytes') (decode_val chunk (byte1' :: bytes')) ->\npmatch bx ofsx (plub p' p).","conclusion":"shape_decoding chunk (byte1' :: bytes') (decode_val chunk (byte1' :: bytes')) ->\npmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (byte1' : memval) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some (byte1' :: bytes')) (Q : Vptr bx ofsx = decode_val chunk (byte1' :: bytes'))","proofString":"rewrite <- Q.\nintros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (byte1' : memval) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some (byte1' :: bytes')) (Q : Vptr bx ofsx = decode_val chunk (byte1' :: bytes')) : shape_decoding chunk (byte1' :: bytes') (Vptr bx ofsx) ->\npmatch bx ofsx (plub p' p).","conclusion":"shape_decoding chunk (byte1' :: bytes') (Vptr bx ofsx) ->\npmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (byte1' : memval) (bytes' : list memval) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) = Some (byte1' :: bytes')) (Q : Vptr bx ofsx = decode_val chunk (byte1' :: bytes'))","proofString":"intros DEC; inv DEC; try contradiction.\nassert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i0 :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs') q i0) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i0 :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs') q i0) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx)","proofString":"assert (v = Vptr bx ofsx).\ndestruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence.\nexploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i0 :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs') q i0) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx) : v = Vptr bx ofsx.","conclusion":"v = Vptr bx ofsx","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i0 :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs') q i0) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx)","proofString":"destruct H5 as [E|[E|[E|E]]]; rewrite E in H4; destruct v; simpl in H4;    try congruence; destruct Archi.ptr64; congruence."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i0 :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs') q i0) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx) (H2 : v = Vptr bx ofsx) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs') q i0 :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs') q i0) bytes -> pmatch b'0 ofs' p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx) (H2 : v = Vptr bx ofsx)","proofString":"exploit In_loadbytes; eauto.\neauto with coqlib.\nintros (ofs' & X & Y).\nsubst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx) (H2 : v = Vptr bx ofsx) (ofs' : Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment v (quantity_chunk chunk) i :: nil)) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v0 : val),\nMem.load chunk0 m b' ofs1 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (v : val) (i : nat) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment v (quantity_chunk chunk) i :: bytes')) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment v (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment v (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk v = Vptr bx ofsx) (H2 : v = Vptr bx ofsx) (ofs' : Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment v (quantity_chunk chunk) i :: nil))","proofString":"subst v.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil))","proofString":"exploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) : In (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i) bytes \\/\nMem.loadbytes m b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil) ->\npmatch bx ofsx (plub p' p).","conclusion":"In (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i) bytes \\/\nMem.loadbytes m b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil) ->\npmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil))","proofString":"intros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : In (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i) bytes) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : In (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i) bytes)","proofString":"apply pmatch_lub_l.\neauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : In (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i) bytes) : pmatch bx ofsx p'.","conclusion":"pmatch bx ofsx p'","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : In (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i) bytes)","proofString":"eauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : Mem.loadbytes m b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) : pmatch bx ofsx (plub p' p).","conclusion":"pmatch bx ofsx (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : Mem.loadbytes m b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil))","proofString":"apply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : Mem.loadbytes m b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) : pmatch bx ofsx p.","conclusion":"pmatch bx ofsx p","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk0 : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk0 m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'0 : block) (ofs'0 : ptrofs) \n  (q : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'0 ofs'0) q i0 :: nil) ->\npmatch b'0 ofs'0 p) (H1 : forall (b'0 : block) (ofs'0 : ptrofs) (q : quantity) (i0 : nat),\nIn (Fragment (Vptr b'0 ofs'0) q i0) bytes -> pmatch b'0 ofs'0 p') (chunk : memory_chunk) (ofs0 : BinNums.Z) (bx : block) (ofsx : ptrofs) (H0 : Mem.load chunk m' b' ofs0 = Some (Vptr bx ofsx)) (bytes' : list memval) (i : nat) (P : Mem.loadbytes m' b' ofs0 (size_chunk chunk) =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (Q : Vptr bx ofsx =\ndecode_val chunk (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: bytes')) (H5 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (H8 : forall mv : memval,\nIn mv bytes' ->\nexists j : nat,\n  mv = Fragment (Vptr bx ofsx) (quantity_chunk chunk) j /\\\n  S j <> size_quantity_nat (quantity_chunk chunk)) (H7 : S i = size_quantity_nat (quantity_chunk chunk)) (H4 : Val.load_result chunk (Vptr bx ofsx) = Vptr bx ofsx) (ofs' : BinNums.Z) (X : ofs0 <= ofs' < ofs0 + size_chunk chunk) (Y : Mem.loadbytes m' b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil)) (Z : Mem.loadbytes m b' ofs' 1 =\nSome (Fragment (Vptr bx ofsx) (quantity_chunk chunk) i :: nil))","proofString":"eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p') : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (plub p' p).","conclusion":"forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' p) (H1 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p')","proofString":"intros.\nexploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : pmatch b'0 ofs' (plub p' p).","conclusion":"pmatch b'0 ofs' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"exploit storebytes_provenance; eauto.\nintros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : In (Fragment (Vptr b'0 ofs') q i) bytes \\/\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (plub p' p).","conclusion":"In (Fragment (Vptr b'0 ofs') q i) bytes \\/\nMem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil) ->\npmatch b'0 ofs' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : Z) (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"intros [Z | Z].\napply pmatch_lub_l.\neauto.\napply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : In (Fragment (Vptr b'0 ofs') q i) bytes) : pmatch b'0 ofs' (plub p' p).","conclusion":"pmatch b'0 ofs' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : In (Fragment (Vptr b'0 ofs') q i) bytes)","proofString":"apply pmatch_lub_l.\neauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : In (Fragment (Vptr b'0 ofs') q i) bytes) : pmatch b'0 ofs' p'.","conclusion":"pmatch b'0 ofs' p'","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : In (Fragment (Vptr b'0 ofs') q i) bytes)","proofString":"eauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : pmatch b'0 ofs' (plub p' p).","conclusion":"pmatch b'0 ofs' (plub p' p)","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"apply pmatch_lub_r.\neauto."},{"statement":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) : pmatch b'0 ofs' p.","conclusion":"pmatch b'0 ofs' p","hypotheses":"(m : mem) (b : block) (ofs : BinNums.Z) (bytes : list memval) (m' : mem) (b' : block) (p p' : aptr) (H : Mem.storebytes m b ofs bytes = Some m') (A : forall (chunk : memory_chunk) (ofs1 : BinNums.Z) (v : val),\nMem.load chunk m b' ofs1 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs1 : BinNums.Z) (b'1 : block) (ofs'0 : ptrofs) \n  (q0 : quantity) (i0 : nat),\nMem.loadbytes m b' ofs1 1 = Some (Fragment (Vptr b'1 ofs'0) q0 i0 :: nil) ->\npmatch b'1 ofs'0 p) (H1 : forall (b'1 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nIn (Fragment (Vptr b'1 ofs'0) q0 i0) bytes -> pmatch b'1 ofs'0 p') (ofs0 : BinNums.Z) (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H0 : Mem.loadbytes m' b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil)) (Z : Mem.loadbytes m b' ofs0 1 = Some (Fragment (Vptr b'0 ofs') q i :: nil))","proofString":"eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes) : bmatch m' b ab.","conclusion":"bmatch m' b ab","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes)","proofString":"destruct H as [A B].\nsplit; intros.\napply smatch_ext with m; auto.\neapply B; eauto.\neapply loadbytes_load_ext; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab ofs)) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes) : bmatch m' b ab.","conclusion":"bmatch m' b ab","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab ofs)) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes)","proofString":"split; intros.\napply smatch_ext with m; auto.\neapply B; eauto.\neapply loadbytes_load_ext; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab ofs)) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes) : smatch m' b (ab_summary ab).","conclusion":"smatch m' b (ab_summary ab)","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab ofs)) (H0 : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes)","proofString":"apply smatch_ext with m; auto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' b ofs = Some v) : vmatch v (ablock_load chunk ab ofs).","conclusion":"vmatch v (ablock_load chunk ab ofs)","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' b ofs = Some v)","proofString":"eapply B; eauto.\neapply loadbytes_load_ext; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' b ofs = Some v) : Mem.load chunk m b ofs = Some v.","conclusion":"Mem.load chunk m b ofs = Some v","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (A : smatch m b (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H0 : forall (ofs0 n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs0 n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs0 n = Some bytes) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m' b ofs = Some v)","proofString":"eapply loadbytes_load_ext; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : bmatch m' b ab.","conclusion":"bmatch m' b ab","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)","proofString":"eapply bmatch_ext; eauto.\nintros.\nrewrite <- H0; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes.","conclusion":"forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall ofs n : Z,\nn >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n)","proofString":"intros.\nrewrite <- H0; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall ofs0 n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b ofs0 n0 = Mem.loadbytes m b ofs0 n0) (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' b ofs n = Some bytes) (H2 : n >= 0) : Mem.loadbytes m b ofs n = Some bytes.","conclusion":"Mem.loadbytes m b ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (ab : ablock) (m' : mem) (H : bmatch m b ab) (H0 : forall ofs0 n0 : Z,\nn0 >= 0 -> Mem.loadbytes m' b ofs0 n0 = Mem.loadbytes m b ofs0 n0) (ofs n : Z) (bytes : list memval) (H1 : Mem.loadbytes m' b ofs n = Some bytes) (H2 : n >= 0)","proofString":"rewrite <- H0; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : bmatch m b ab) : vmatch v (ablock_load chunk ab ofs).","conclusion":"vmatch v (ablock_load chunk ab ofs)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : bmatch m b ab)","proofString":"destruct H0.\neauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : smatch m b (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) : vmatch v (ablock_load chunk ab ofs).","conclusion":"vmatch v (ablock_load chunk ab ofs)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : smatch m b (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0))","proofString":"eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : bmatch m b ab) : vmatch v (ablock_load_anywhere chunk ab).","conclusion":"vmatch v (ablock_load_anywhere chunk ab)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : bmatch m b ab)","proofString":"destruct H0.\ndestruct H0.\nunfold ablock_load_anywhere.\neapply vnormalize_cast; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : smatch m b (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) : vmatch v (ablock_load_anywhere chunk ab).","conclusion":"vmatch v (ablock_load_anywhere chunk ab)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : smatch m b (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0))","proofString":"destruct H0.\nunfold ablock_load_anywhere.\neapply vnormalize_cast; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr (ab_summary ab))) (H2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) : vmatch v (ablock_load_anywhere chunk ab).","conclusion":"vmatch v (ablock_load_anywhere chunk ab)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr (ab_summary ab))) (H2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0))","proofString":"unfold ablock_load_anywhere.\neapply vnormalize_cast; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr (ab_summary ab))) (H2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) : vmatch v (vnormalize chunk (Ifptr (ab_summary ab))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (ab_summary ab)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (ab : ablock) (H : Mem.load chunk m b ofs = Some v) (H0 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr (ab_summary ab))) (H2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch b' ofs' (ab_summary ab)) (H1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0))","proofString":"eapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (H : smatch m b p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch v (ablock_load chunk (ablock_init p) ofs).","conclusion":"vmatch v (ablock_load chunk (ablock_init p) ofs)","hypotheses":"(m : mem) (b : block) (p : aptr) (H : smatch m b p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v)","proofString":"unfold ablock_load, ablock_init; simpl.\neapply vnormalize_cast; eauto.\neapply H; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (H : smatch m b p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch v (vnormalize chunk (Ifptr p)).","conclusion":"vmatch v (vnormalize chunk (Ifptr p))","hypotheses":"(m : mem) (b : block) (p : aptr) (H : smatch m b p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v)","proofString":"eapply vnormalize_cast; eauto.\neapply H; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (H : smatch m b p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch v (Ifptr p).","conclusion":"vmatch v (Ifptr p)","hypotheses":"(m : mem) (b : block) (p : aptr) (H : smatch m b p) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v)","proofString":"eapply H; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (H0 : bmatch m b' ab) (H1 : vmatch v av) : bmatch m' b' (ablock_store_anywhere chunk ab av).","conclusion":"bmatch m' b' (ablock_store_anywhere chunk ab av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (H0 : bmatch m b' ab) (H1 : vmatch v av)","proofString":"destruct H0 as [A B].\nunfold ablock_store_anywhere.\napply ablock_init_sound.\neapply smatch_store; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : smatch m b' (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H1 : vmatch v av) : bmatch m' b' (ablock_store_anywhere chunk ab av).","conclusion":"bmatch m' b' (ablock_store_anywhere chunk ab av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : smatch m b' (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H1 : vmatch v av)","proofString":"unfold ablock_store_anywhere.\napply ablock_init_sound.\neapply smatch_store; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : smatch m b' (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H1 : vmatch v av) : bmatch m' b' (ablock_init (vplub av (ab_summary ab))).","conclusion":"bmatch m' b' (ablock_init (vplub av (ab_summary ab)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : smatch m b' (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H1 : vmatch v av)","proofString":"apply ablock_init_sound.\neapply smatch_store; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : smatch m b' (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H1 : vmatch v av) : smatch m' b' (vplub av (ab_summary ab)).","conclusion":"smatch m' b' (vplub av (ab_summary ab))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (ab : ablock) (av : aval) (H : Mem.store chunk m b ofs v = Some m') (A : smatch m b' (ab_summary ab)) (B : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b' ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (H1 : vmatch v av)","proofString":"eapply smatch_store; eauto."},{"statement":"(i lo hi : Z) (c : ZTree.t acontent) : i < lo \\/ i > hi -> (inval_after lo hi c) ## i = c ## i.","conclusion":"i < lo \\/ i > hi -> (inval_after lo hi c) ## i = c ## i","hypotheses":"(i lo hi : Z) (c : ZTree.t acontent)","proofString":"functional induction (inval_after lo hi c); intros.\nrewrite IHt by lia.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia.\nauto."},{"statement":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : i < lo \\/ i > hi - 1 ->\n(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = (ZTree.remove hi c) ## i) (H : i < lo \\/ i > hi) : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = c ## i.","conclusion":"(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = c ## i","hypotheses":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : i < lo \\/ i > hi - 1 ->\n(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = (ZTree.remove hi c) ## i) (H : i < lo \\/ i > hi)","proofString":"rewrite IHt by lia.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : i < lo \\/ i > hi - 1 ->\n(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = (ZTree.remove hi c) ## i) (H : i < lo \\/ i > hi) : (ZTree.remove hi c) ## i = c ## i.","conclusion":"(ZTree.remove hi c) ## i = c ## i","hypotheses":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : i < lo \\/ i > hi - 1 ->\n(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = (ZTree.remove hi c) ## i) (H : i < lo \\/ i > hi)","proofString":"apply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : i < lo \\/ i > hi - 1 ->\n(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = (ZTree.remove hi c) ## i) (H : i < lo \\/ i > hi) : i <> hi.","conclusion":"i <> hi","hypotheses":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : i < lo \\/ i > hi - 1 ->\n(inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = (ZTree.remove hi c) ## i) (H : i < lo \\/ i > hi)","proofString":"unfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : i < lo \\/ i > hi) : c ## i = c ## i.","conclusion":"c ## i = c ## i","hypotheses":"(i lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : i < lo \\/ i > hi)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) : (inval_after lo hi c) ## i = Some (ACval chunk av) ->\nc ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"(inval_after lo hi c) ## i = Some (ACval chunk av) ->\nc ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent)","proofString":"functional induction (inval_after lo hi c); intros.\ndestruct (zeq i hi).\nsubst i.\nrewrite inval_after_outside in H by lia.\nrewrite ZTree.grs in H.\ndiscriminate.\nexploit IHt; eauto.\nintros [A B].\nrewrite ZTree.gro in A by auto.\nsplit.\nauto.\nlia.\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) : c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av))","proofString":"destruct (zeq i hi).\nsubst i.\nrewrite inval_after_outside in H by lia.\nrewrite ZTree.grs in H.\ndiscriminate.\nexploit IHt; eauto.\nintros [A B].\nrewrite ZTree.gro in A by auto.\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (e0 : i = hi) : c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (e0 : i = hi)","proofString":"subst i.\nrewrite inval_after_outside in H by lia.\nrewrite ZTree.grs in H.\ndiscriminate."},{"statement":"(chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av)) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi - 1)) : c ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi).","conclusion":"c ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av)) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi - 1))","proofString":"rewrite inval_after_outside in H by lia.\nrewrite ZTree.grs in H.\ndiscriminate."},{"statement":"(chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (H : (ZTree.remove hi c) ## hi = Some (ACval chunk av)) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi - 1)) : c ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi).","conclusion":"c ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (H : (ZTree.remove hi c) ## hi = Some (ACval chunk av)) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi - 1))","proofString":"rewrite ZTree.grs in H.\ndiscriminate."},{"statement":"(chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (H : None = Some (ACval chunk av)) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi - 1)) : c ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi).","conclusion":"c ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (H : None = Some (ACval chunk av)) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## hi = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## hi = Some (ACval chunk av) /\\ (hi < lo \\/ hi > hi - 1))","proofString":"discriminate."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) : c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi)","proofString":"exploit IHt; eauto.\nintros [A B].\nrewrite ZTree.gro in A by auto.\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) : (ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1) ->\nc ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1) ->\nc ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi)","proofString":"intros [A B].\nrewrite ZTree.gro in A by auto.\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : (ZTree.remove hi c) ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1) : c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : (ZTree.remove hi c) ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1)","proofString":"rewrite ZTree.gro in A by auto.\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : c ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1) : c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : c ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1)","proofString":"split.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : c ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1) : c ## i = Some (ACval chunk av).","conclusion":"c ## i = Some (ACval chunk av)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : c ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : c ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1) : i < lo \\/ i > hi.","conclusion":"i < lo \\/ i > hi","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo <= hi) (e : zle lo hi = left _x) (IHt : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av) ->\n(ZTree.remove hi c) ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi - 1)) (H : (inval_after lo (hi - 1) (ZTree.remove hi c)) ## i = Some (ACval chunk av)) (n : i <> hi) (A : c ## i = Some (ACval chunk av)) (B : i < lo \\/ i > hi - 1)","proofString":"lia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : c ## i = Some (ACval chunk av)) : c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).","conclusion":"c ## i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : c ## i = Some (ACval chunk av))","proofString":"split.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : c ## i = Some (ACval chunk av)) : c ## i = Some (ACval chunk av).","conclusion":"c ## i = Some (ACval chunk av)","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : c ## i = Some (ACval chunk av))","proofString":"auto."},{"statement":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : c ## i = Some (ACval chunk av)) : i < lo \\/ i > hi.","conclusion":"i < lo \\/ i > hi","hypotheses":"(chunk : memory_chunk) (av : aval) (i : ZTree.elt) (lo hi : Z) (c : ZTree.t acontent) (_x : lo > hi) (e : zle lo hi = right _x) (H : c ## i = Some (ACval chunk av))","proofString":"lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) : i < lo \\/ i >= hi -> (inval_before hi lo c) ## i = c ## i.","conclusion":"i < lo \\/ i >= hi -> (inval_before hi lo c) ## i = c ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent)","proofString":"functional induction (inval_before hi lo c); intros.\nrewrite IHt by lia.\nunfold inval_if.\ndestruct (c##lo) as [[chunk av]|]; auto.\ndestruct (zle (lo + size_chunk chunk) hi); auto.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia.\nauto."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = c ## i.","conclusion":"(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = c ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi)","proofString":"rewrite IHt by lia.\nunfold inval_if.\ndestruct (c##lo) as [[chunk av]|]; auto.\ndestruct (zle (lo + size_chunk chunk) hi); auto.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) : (inval_if hi lo c) ## i = c ## i.","conclusion":"(inval_if hi lo c) ## i = c ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi)","proofString":"unfold inval_if.\ndestruct (c##lo) as [[chunk av]|]; auto.\ndestruct (zle (lo + size_chunk chunk) hi); auto.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) : match c ## lo with\n| Some (ACval chunk _) =>\n    if zle (lo + size_chunk chunk) hi then c else ZTree.remove lo c\n| None => c\nend ## i = c ## i.","conclusion":"match c ## lo with\n| Some (ACval chunk _) =>\n    if zle (lo + size_chunk chunk) hi then c else ZTree.remove lo c\n| None => c\nend ## i = c ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi)","proofString":"destruct (c##lo) as [[chunk av]|]; auto.\ndestruct (zle (lo + size_chunk chunk) hi); auto.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) (chunk : memory_chunk) (av : aval) : (if zle (lo + size_chunk chunk) hi then c else ZTree.remove lo c) ## i =\nc ## i.","conclusion":"(if zle (lo + size_chunk chunk) hi then c else ZTree.remove lo c) ## i =\nc ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) (chunk : memory_chunk) (av : aval)","proofString":"destruct (zle (lo + size_chunk chunk) hi); auto.\napply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) (chunk : memory_chunk) (av : aval) (g : lo + size_chunk chunk > hi) : (ZTree.remove lo c) ## i = c ## i.","conclusion":"(ZTree.remove lo c) ## i = c ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) (chunk : memory_chunk) (av : aval) (g : lo + size_chunk chunk > hi)","proofString":"apply ZTree.gro.\nunfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) (chunk : memory_chunk) (av : aval) (g : lo + size_chunk chunk > hi) : i <> lo.","conclusion":"i <> lo","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : i < lo + 1 \\/ i >= hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = (inval_if hi lo c) ## i) (H : i < lo \\/ i >= hi) (chunk : memory_chunk) (av : aval) (g : lo + size_chunk chunk > hi)","proofString":"unfold ZTree.elt, ZIndexed.t; lia."},{"statement":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo >= hi) (e : zlt lo hi = right _x) (H : i < lo \\/ i >= hi) : c ## i = c ## i.","conclusion":"c ## i = c ## i","hypotheses":"(i hi lo : Z) (c : ZTree.t acontent) (_x : lo >= hi) (e : zlt lo hi = right _x) (H : i < lo \\/ i >= hi)","proofString":"auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent) : lo <= i < hi ->\n(inval_before hi lo c) ## i = Some (ACval chunk av) ->\nc ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi.","conclusion":"lo <= i < hi ->\n(inval_before hi lo c) ## i = Some (ACval chunk av) ->\nc ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (lo hi : Z) (c : ZTree.t acontent)","proofString":"functional induction (inval_before hi lo c); intros.\ndestruct (zeq lo i).\nsubst i.\nrewrite inval_before_outside in H0 by lia.\nunfold inval_if in H0.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; try congruence.\ndestruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence.\nexploit IHt.\nlia.\nauto.\nintros [A B]; split; auto.\nunfold inval_if in A.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; auto.\ndestruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto.\nextlia."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) : c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi.","conclusion":"c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av))","proofString":"destruct (zeq lo i).\nsubst i.\nrewrite inval_before_outside in H0 by lia.\nunfold inval_if in H0.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; try congruence.\ndestruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence.\nexploit IHt.\nlia.\nauto.\nintros [A B]; split; auto.\nunfold inval_if in A.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; auto.\ndestruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (e0 : lo = i) : c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi.","conclusion":"c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (e0 : lo = i)","proofString":"subst i.\nrewrite inval_before_outside in H0 by lia.\nunfold inval_if in H0.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; try congruence.\ndestruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : c ## lo = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"c ## lo = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"rewrite inval_before_outside in H0 by lia.\nunfold inval_if in H0.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; try congruence.\ndestruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (H0 : (inval_if hi lo c) ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : c ## lo = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"c ## lo = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (H0 : (inval_if hi lo c) ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"unfold inval_if in H0.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; try congruence.\ndestruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (H0 : match c ## lo with\n| Some (ACval chunk0 _) =>\n    if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c\n| None => c\nend ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : c ## lo = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"c ## lo = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (H0 : match c ## lo with\n| Some (ACval chunk0 _) =>\n    if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c\n| None => c\nend ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"destruct (c##lo) as [[chunk0 v0]|] eqn:C; try congruence.\ndestruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (H0 : (if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c) ## lo =\nSome (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (H0 : (if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c) ## lo =\nSome (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"destruct (zle (lo + size_chunk chunk0) hi).\nrewrite C in H0; inv H0.\nauto.\nrewrite ZTree.grs in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (l : lo + size_chunk chunk0 <= hi) (H0 : c ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (l : lo + size_chunk chunk0 <= hi) (H0 : c ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"rewrite C in H0; inv H0.\nauto."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (l : lo + size_chunk chunk <= hi) (C : c ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : Some (ACval chunk av) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"Some (ACval chunk av) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (l : lo + size_chunk chunk <= hi) (C : c ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (g : lo + size_chunk chunk0 > hi) (H0 : (ZTree.remove lo c) ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (g : lo + size_chunk chunk0 > hi) (H0 : (ZTree.remove lo c) ## lo = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"rewrite ZTree.grs in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (g : lo + size_chunk chunk0 > hi) (H0 : None = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi) : Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi.","conclusion":"Some (ACval chunk0 v0) = Some (ACval chunk av) /\\ lo + size_chunk chunk <= hi","hypotheses":"(chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (g : lo + size_chunk chunk0 > hi) (H0 : None = Some (ACval chunk av)) (H : lo <= lo < hi) (IHt : lo + 1 <= lo < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## lo = Some (ACval chunk av) ->\n(inval_if hi lo c) ## lo = Some (ACval chunk av) /\\\nlo + size_chunk chunk <= hi)","proofString":"congruence."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) : c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi.","conclusion":"c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i)","proofString":"exploit IHt.\nlia.\nauto.\nintros [A B]; split; auto.\nunfold inval_if in A.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; auto.\ndestruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) : lo + 1 <= i < hi.","conclusion":"lo + 1 <= i < hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i)","proofString":"lia."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av).","conclusion":"(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i)","proofString":"auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) : (inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi ->\nc ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi.","conclusion":"(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi ->\nc ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i)","proofString":"intros [A B]; split; auto.\nunfold inval_if in A.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; auto.\ndestruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (A : (inval_if hi lo c) ## i = Some (ACval chunk av)) (B : i + size_chunk chunk <= hi) : c ## i = Some (ACval chunk av).","conclusion":"c ## i = Some (ACval chunk av)","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (A : (inval_if hi lo c) ## i = Some (ACval chunk av)) (B : i + size_chunk chunk <= hi)","proofString":"unfold inval_if in A.\ndestruct (c##lo) as [[chunk0 v0]|] eqn:C; auto.\ndestruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (A : match c ## lo with\n| Some (ACval chunk0 _) =>\n    if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c\n| None => c\nend ## i = Some (ACval chunk av)) (B : i + size_chunk chunk <= hi) : c ## i = Some (ACval chunk av).","conclusion":"c ## i = Some (ACval chunk av)","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (A : match c ## lo with\n| Some (ACval chunk0 _) =>\n    if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c\n| None => c\nend ## i = Some (ACval chunk av)) (B : i + size_chunk chunk <= hi)","proofString":"destruct (c##lo) as [[chunk0 v0]|] eqn:C; auto.\ndestruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (A : (if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c) ## i =\nSome (ACval chunk av)) (B : i + size_chunk chunk <= hi) : c ## i = Some (ACval chunk av).","conclusion":"c ## i = Some (ACval chunk av)","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (A : (if zle (lo + size_chunk chunk0) hi then c else ZTree.remove lo c) ## i =\nSome (ACval chunk av)) (B : i + size_chunk chunk <= hi)","proofString":"destruct (zle (lo + size_chunk chunk0) hi); auto.\nrewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (g : lo + size_chunk chunk0 > hi) (A : (ZTree.remove lo c) ## i = Some (ACval chunk av)) (B : i + size_chunk chunk <= hi) : c ## i = Some (ACval chunk av).","conclusion":"c ## i = Some (ACval chunk av)","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo < hi) (e : zlt lo hi = left _x) (IHt : lo + 1 <= i < hi ->\n(inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av) ->\n(inval_if hi lo c) ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi) (H : lo <= i < hi) (H0 : (inval_before hi (lo + 1) (inval_if hi lo c)) ## i = Some (ACval chunk av)) (n : lo <> i) (chunk0 : memory_chunk) (v0 : aval) (C : c ## lo = Some (ACval chunk0 v0)) (g : lo + size_chunk chunk0 > hi) (A : (ZTree.remove lo c) ## i = Some (ACval chunk av)) (B : i + size_chunk chunk <= hi)","proofString":"rewrite ZTree.gro in A; auto."},{"statement":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo >= hi) (e : zlt lo hi = right _x) (H : lo <= i < hi) (H0 : c ## i = Some (ACval chunk av)) : c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi.","conclusion":"c ## i = Some (ACval chunk av) /\\ i + size_chunk chunk <= hi","hypotheses":"(i : Z) (chunk : memory_chunk) (av : aval) (hi lo : Z) (c : ZTree.t acontent) (_x : lo >= hi) (e : zlt lo hi = right _x) (H : lo <= i < hi) (H0 : c ## i = Some (ACval chunk av))","proofString":"extlia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av'))","proofString":"destruct (zlt j (i - 7)).\nrewrite inval_before_outside in H by lia.\nsplit.\nauto.\nleft.\ngeneralize (max_size_chunk chunk'); lia.\ndestruct (zlt j i).\nexploit inval_before_contents_1; eauto.\nlia.\ntauto.\nrewrite inval_before_outside in H by lia.\nsplit.\nauto.\nlia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (l : j < i - 7) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (l : j < i - 7)","proofString":"rewrite inval_before_outside in H by lia.\nsplit.\nauto.\nleft.\ngeneralize (max_size_chunk chunk'); lia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7)","proofString":"split.\nauto.\nleft.\ngeneralize (max_size_chunk chunk'); lia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7) : c ## j = Some (ACval chunk' av').","conclusion":"c ## j = Some (ACval chunk' av')","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7)","proofString":"auto."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7) : j + size_chunk chunk' <= i \\/ i <= j.","conclusion":"j + size_chunk chunk' <= i \\/ i <= j","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7)","proofString":"left.\ngeneralize (max_size_chunk chunk'); lia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7) : j + size_chunk chunk' <= i.","conclusion":"j + size_chunk chunk' <= i","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (l : j < i - 7)","proofString":"generalize (max_size_chunk chunk'); lia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7)","proofString":"destruct (zlt j i).\nexploit inval_before_contents_1; eauto.\nlia.\ntauto.\nrewrite inval_before_outside in H by lia.\nsplit.\nauto.\nlia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (l : j < i) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (l : j < i)","proofString":"exploit inval_before_contents_1; eauto.\nlia.\ntauto."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (l : j < i) : i - 7 <= j < i.","conclusion":"i - 7 <= j < i","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (l : j < i)","proofString":"lia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (l : j < i) : c ## j = Some (ACval chunk' av') /\\ j + size_chunk chunk' <= i ->\nc ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ j + size_chunk chunk' <= i ->\nc ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (l : j < i)","proofString":"tauto."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : (inval_before i (i - 7) c) ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i)","proofString":"rewrite inval_before_outside in H by lia.\nsplit.\nauto.\nlia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i) : c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).","conclusion":"c ## j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j)","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i)","proofString":"split.\nauto.\nlia."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i) : c ## j = Some (ACval chunk' av').","conclusion":"c ## j = Some (ACval chunk' av')","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i)","proofString":"auto."},{"statement":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i) : j + size_chunk chunk' <= i \\/ i <= j.","conclusion":"j + size_chunk chunk' <= i \\/ i <= j","hypotheses":"(i : Z) (c : ZTree.t acontent) (chunk' : memory_chunk) (av' : aval) (j : ZTree.elt) (H : c ## j = Some (ACval chunk' av')) (g : j >= i - 7) (g0 : j >= i)","proofString":"lia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) : i = j /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"i = j /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av'))","proofString":"destruct (zeq i j).\nsubst j.\nrewrite ZTree.gss in H.\ninv H; auto.\nright.\nrewrite ZTree.gso in H by auto.\nexploit inval_before_contents; eauto.\nintros [A B].\nexploit inval_after_contents; eauto.\nintros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) (e : i = j) : i = j /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"i = j /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) (e : i = j)","proofString":"subst j.\nrewrite ZTree.gss in H.\ninv H; auto."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## i = Some (ACval chunk' av')) : i = i /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## i = Some (ACval chunk' av') /\\\n(i + size_chunk chunk' <= i \\/ i + size_chunk chunk <= i).","conclusion":"i = i /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## i = Some (ACval chunk' av') /\\\n(i + size_chunk chunk' <= i \\/ i + size_chunk chunk <= i)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## i = Some (ACval chunk' av'))","proofString":"rewrite ZTree.gss in H.\ninv H; auto."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (chunk' : memory_chunk) (av' : aval) (H : Some (ACval chunk av) = Some (ACval chunk' av')) : i = i /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## i = Some (ACval chunk' av') /\\\n(i + size_chunk chunk' <= i \\/ i + size_chunk chunk <= i).","conclusion":"i = i /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## i = Some (ACval chunk' av') /\\\n(i + size_chunk chunk' <= i \\/ i + size_chunk chunk <= i)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (chunk' : memory_chunk) (av' : aval) (H : Some (ACval chunk av) = Some (ACval chunk' av'))","proofString":"inv H; auto."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) (n : i <> j) : i = j /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"i = j /\\ chunk' = chunk /\\ av' = av \\/\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) (n : i <> j)","proofString":"right.\nrewrite ZTree.gso in H by auto.\nexploit inval_before_contents; eauto.\nintros [A B].\nexploit inval_after_contents; eauto.\nintros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) (n : i <> j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (ZTree.set i (ACval chunk av)\n   (inval_before i (i - 7)\n      (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))))\n## j = Some (ACval chunk' av')) (n : i <> j)","proofString":"rewrite ZTree.gso in H by auto.\nexploit inval_before_contents; eauto.\nintros [A B].\nexploit inval_after_contents; eauto.\nintros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j)","proofString":"exploit inval_before_contents; eauto.\nintros [A B].\nexploit inval_after_contents; eauto.\nintros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"(inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j)","proofString":"intros [A B].\nexploit inval_after_contents; eauto.\nintros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j)","proofString":"exploit inval_after_contents; eauto.\nintros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j < i + 1 \\/ j > i + size_chunk chunk - 1) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j < i + 1 \\/ j > i + size_chunk chunk - 1) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j)","proofString":"intros [C D].\nsplit.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i + 1 \\/ j > i + size_chunk chunk - 1) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j)","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i + 1 \\/ j > i + size_chunk chunk - 1)","proofString":"split.\nauto.\nlia."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i + 1 \\/ j > i + size_chunk chunk - 1) : (ab_contents ab) ## j = Some (ACval chunk' av').","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av')","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i + 1 \\/ j > i + size_chunk chunk - 1)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i + 1 \\/ j > i + size_chunk chunk - 1) : j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j.","conclusion":"j + size_chunk chunk' <= i \\/ i + size_chunk chunk <= j","hypotheses":"(chunk : memory_chunk) (ab : ablock) (i : Z) (av : aval) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7)\n   (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) (n : i <> j) (A : (inval_after (i + 1) (i + size_chunk chunk - 1) (ab_contents ab)) ## j =\nSome (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i + 1 \\/ j > i + size_chunk chunk - 1)","proofString":"lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN : bmatch m b ab) (VIN : vmatch v av) : bmatch m' b (ablock_store chunk ab ofs av).","conclusion":"bmatch m' b (ablock_store chunk ab ofs av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN : bmatch m b ab) (VIN : vmatch v av)","proofString":"destruct BIN as [BIN1 BIN2].\nsplit.\neapply smatch_store; eauto.\nintros chunk' ofs' v' LOAD.\nassert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (vplub av ab.(ab_summary))))).\nexploit smatch_store; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) : bmatch m' b (ablock_store chunk ab ofs av).","conclusion":"bmatch m' b (ablock_store chunk ab ofs av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av)","proofString":"split.\neapply smatch_store; eauto.\nintros chunk' ofs' v' LOAD.\nassert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (vplub av ab.(ab_summary))))).\nexploit smatch_store; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) : smatch m' b (ab_summary (ablock_store chunk ab ofs av)).","conclusion":"smatch m' b (ab_summary (ablock_store chunk ab ofs av))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av)","proofString":"eapply smatch_store; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m' b ofs0 = Some v0 ->\nvmatch v0 (ablock_load chunk0 (ablock_store chunk ab ofs av) ofs0).","conclusion":"forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m' b ofs0 = Some v0 ->\nvmatch v0 (ablock_load chunk0 (ablock_store chunk ab ofs av) ofs0)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av)","proofString":"intros chunk' ofs' v' LOAD.\nassert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (vplub av ab.(ab_summary))))).\nexploit smatch_store; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') : vmatch v' (ablock_load chunk' (ablock_store chunk ab ofs av) ofs').","conclusion":"vmatch v' (ablock_load chunk' (ablock_store chunk ab ofs av) ofs')","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v')","proofString":"assert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (vplub av ab.(ab_summary))))).\nexploit smatch_store; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab)))).","conclusion":"vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v')","proofString":"exploit smatch_store; eauto.\nintros [A B].\neapply vnormalize_cast; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') : smatch m' b (vplub av (ab_summary ab)) ->\nvmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab)))).","conclusion":"smatch m' b (vplub av (ab_summary ab)) ->\nvmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v')","proofString":"intros [A B].\neapply vnormalize_cast; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m' b ofs0 = Some v0 ->\nvmatch v0 (Ifptr (vplub av (ab_summary ab)))) (B : forall (ofs0 : Z) (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b ofs0 1 = Some (Fragment (Vptr b' ofs'0) q i :: nil) ->\npmatch b' ofs'0 (vplub av (ab_summary ab))) : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab)))).","conclusion":"vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m' b ofs0 = Some v0 ->\nvmatch v0 (Ifptr (vplub av (ab_summary ab)))) (B : forall (ofs0 : Z) (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b ofs0 1 = Some (Fragment (Vptr b' ofs'0) q i :: nil) ->\npmatch b' ofs'0 (vplub av (ab_summary ab)))","proofString":"eapply vnormalize_cast; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) : vmatch v' (ablock_load chunk' (ablock_store chunk ab ofs av) ofs').","conclusion":"vmatch v' (ablock_load chunk' (ablock_store chunk ab ofs av) ofs')","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab)))))","proofString":"unfold ablock_load.\ndestruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) : vmatch v'\n  match (ab_contents (ablock_store chunk ab ofs av)) ## ofs' with\n  | Some (ACval chunk'0 av0) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av0\n      else\n       vnormalize chunk' (Ifptr (ab_summary (ablock_store chunk ab ofs av)))\n  | None =>\n      vnormalize chunk' (Ifptr (ab_summary (ablock_store chunk ab ofs av)))\n  end.","conclusion":"vmatch v'\n  match (ab_contents (ablock_store chunk ab ofs av)) ## ofs' with\n  | Some (ACval chunk'0 av0) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av0\n      else\n       vnormalize chunk' (Ifptr (ab_summary (ablock_store chunk ab ofs av)))\n  | None =>\n      vnormalize chunk' (Ifptr (ab_summary (ablock_store chunk ab ofs av)))\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab)))))","proofString":"destruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) : vmatch v'\n  (if chunk_compat chunk' chunk1\n   then vnormalize chunk' av1\n   else vnormalize chunk' (Ifptr (ab_summary (ablock_store chunk ab ofs av)))).","conclusion":"vmatch v'\n  (if chunk_compat chunk' chunk1\n   then vnormalize chunk' av1\n   else vnormalize chunk' (Ifptr (ab_summary (ablock_store chunk ab ofs av))))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1))","proofString":"destruct (chunk_compat chunk' chunk1) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) : vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true)","proofString":"exploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) : size_chunk chunk' = size_chunk chunk1 /\\\nalign_chunk chunk' <= align_chunk chunk1 /\\\ntype_of_chunk chunk' = type_of_chunk chunk1 ->\nvmatch v' (vnormalize chunk' av1).","conclusion":"size_chunk chunk' = size_chunk chunk1 /\\\nalign_chunk chunk' <= align_chunk chunk1 /\\\ntype_of_chunk chunk' = type_of_chunk chunk1 ->\nvmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true)","proofString":"intros (U & V & W).\nexploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) : vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1)","proofString":"exploit ablock_store_contents; eauto.\nintros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) : ofs = ofs' /\\ chunk1 = chunk /\\ av1 = av \\/\n(ab_contents ab) ## ofs' = Some (ACval chunk1 av1) /\\\n(ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') ->\nvmatch v' (vnormalize chunk' av1).","conclusion":"ofs = ofs' /\\ chunk1 = chunk /\\ av1 = av \\/\n(ab_contents ab) ## ofs' = Some (ACval chunk1 av1) /\\\n(ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') ->\nvmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1)","proofString":"intros [(P & Q & R) | (P & Q)].\nsubst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto.\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : ofs = ofs') (Q : chunk1 = chunk) (R : av1 = av) : vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : ofs = ofs') (Q : chunk1 = chunk) (R : av1 = av)","proofString":"subst.\nassert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av)) : vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av))","proofString":"assert (v' = Val.load_result chunk' v).\nexploit Mem.load_store_similar_2; eauto.\ncongruence.\nsubst v'.\napply vnormalize_sound; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av)) : v' = Val.load_result chunk' v.","conclusion":"v' = Val.load_result chunk' v","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av))","proofString":"exploit Mem.load_store_similar_2; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av)) : Mem.load chunk' m' b ofs' = Some (Val.load_result chunk' v) ->\nv' = Val.load_result chunk' v.","conclusion":"Mem.load chunk' m' b ofs' = Some (Val.load_result chunk' v) ->\nv' = Val.load_result chunk' v","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av))","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av)) (H : v' = Val.load_result chunk' v) : vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av)) (H : v' = Val.load_result chunk' v)","proofString":"subst v'.\napply vnormalize_sound; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (SUMMARY : vmatch (Val.load_result chunk' v)\n  (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (LOAD : Mem.load chunk' m' b ofs' = Some (Val.load_result chunk' v)) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av)) : vmatch (Val.load_result chunk' v) (vnormalize chunk' av).","conclusion":"vmatch (Val.load_result chunk' v) (vnormalize chunk' av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (v : val) (m' : mem) (ab : ablock) (av : aval) (ofs' : Z) (STORE : Mem.store chunk m b ofs' v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs : Z) (v0 : val),\nMem.load chunk0 m b ofs = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs)) (VIN : vmatch v av) (chunk' : memory_chunk) (SUMMARY : vmatch (Val.load_result chunk' v)\n  (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (LOAD : Mem.load chunk' m' b ofs' = Some (Val.load_result chunk' v)) (W : type_of_chunk chunk' = type_of_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (U : size_chunk chunk' = size_chunk chunk) (COMPAT : chunk_compat chunk' chunk = true) (C : (ab_contents (ablock_store chunk ab ofs' av)) ## ofs' = Some (ACval chunk av))","proofString":"apply vnormalize_sound; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') : vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"assert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto.\nexploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') : Mem.load chunk' m b ofs' = Some v'.","conclusion":"Mem.load chunk' m b ofs' = Some v'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"rewrite <- LOAD.\nsymmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') : Mem.load chunk' m b ofs' = Mem.load chunk' m' b ofs'.","conclusion":"Mem.load chunk' m b ofs' = Mem.load chunk' m' b ofs'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"symmetry.\neapply Mem.load_store_other; eauto.\nrewrite U.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') : Mem.load chunk' m' b ofs' = Mem.load chunk' m b ofs'.","conclusion":"Mem.load chunk' m' b ofs' = Mem.load chunk' m b ofs'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"eapply Mem.load_store_other; eauto.\nrewrite U.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') : b <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'.","conclusion":"b <> b \\/ ofs' + size_chunk chunk' <= ofs \\/ ofs + size_chunk chunk <= ofs'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"rewrite U.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') : b <> b \\/ ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs'.","conclusion":"b <> b \\/ ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs'","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs')","proofString":"auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"exploit BIN2; eauto.\nunfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v' (ablock_load chunk' ab ofs') -> vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (ablock_load chunk' ab ofs') -> vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"unfold ablock_load.\nrewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v'\n  match (ab_contents ab) ## ofs' with\n  | Some (ACval chunk'0 av0) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av0\n      else vnormalize chunk' (Ifptr (ab_summary ab))\n  | None => vnormalize chunk' (Ifptr (ab_summary ab))\n  end -> vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v'\n  match (ab_contents ab) ## ofs' with\n  | Some (ACval chunk'0 av0) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av0\n      else vnormalize chunk' (Ifptr (ab_summary ab))\n  | None => vnormalize chunk' (Ifptr (ab_summary ab))\n  end -> vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"rewrite P.\nrewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v'\n  (if chunk_compat chunk' chunk1\n   then vnormalize chunk' av1\n   else vnormalize chunk' (Ifptr (ab_summary ab))) ->\nvmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v'\n  (if chunk_compat chunk' chunk1\n   then vnormalize chunk' av1\n   else vnormalize chunk' (Ifptr (ab_summary ab))) ->\nvmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"rewrite COMPAT.\nauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v' (vnormalize chunk' av1) -> vmatch v' (vnormalize chunk' av1).","conclusion":"vmatch v' (vnormalize chunk' av1) -> vmatch v' (vnormalize chunk' av1)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (ab : ablock) (av : aval) (STORE : Mem.store chunk m b ofs v = Some m') (BIN1 : smatch m b (ab_summary ab)) (BIN2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab ofs0)) (VIN : vmatch v av) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (vplub av (ab_summary ab))))) (chunk1 : memory_chunk) (av1 : aval) (C : (ab_contents (ablock_store chunk ab ofs av)) ## ofs' =\nSome (ACval chunk1 av1)) (COMPAT : chunk_compat chunk' chunk1 = true) (U : size_chunk chunk' = size_chunk chunk1) (V : align_chunk chunk' <= align_chunk chunk1) (W : type_of_chunk chunk' = type_of_chunk chunk1) (P : (ab_contents ab) ## ofs' = Some (ACval chunk1 av1)) (Q : ofs' + size_chunk chunk1 <= ofs \\/ ofs + size_chunk chunk <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"auto."},{"statement":"(m : mem) (b : block) (ab : ablock) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : bmatch m b ab) (H1 : In (Fragment (Vptr b' ofs') q i) bytes) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ab : ablock) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : bmatch m b ab) (H1 : In (Fragment (Vptr b' ofs') q i) bytes)","proofString":"destruct H0.\neapply smatch_loadbytes; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b (ab_summary ab)) (H2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (H1 : In (Fragment (Vptr b' ofs') q i) bytes) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ab : ablock) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (n ofs : Z) (bytes : list memval) (H : Mem.loadbytes m b ofs n = Some bytes) (H0 : smatch m b (ab_summary ab)) (H2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (H1 : In (Fragment (Vptr b' ofs') q i) bytes)","proofString":"eapply smatch_loadbytes; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (p : aptr) (m' : mem) (b' : block) (ab : ablock) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p) (H1 : bmatch m b' ab) : bmatch m' b' (ablock_storebytes_anywhere ab p).","conclusion":"bmatch m' b' (ablock_storebytes_anywhere ab p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (p : aptr) (m' : mem) (b' : block) (ab : ablock) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p) (H1 : bmatch m b' ab)","proofString":"destruct H1 as [A B].\napply ablock_init_sound.\neapply smatch_storebytes; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (p : aptr) (m' : mem) (b' : block) (ab : ablock) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p) (A : smatch m b' (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) : bmatch m' b' (ablock_storebytes_anywhere ab p).","conclusion":"bmatch m' b' (ablock_storebytes_anywhere ab p)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (p : aptr) (m' : mem) (b' : block) (ab : ablock) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p) (A : smatch m b' (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0))","proofString":"apply ablock_init_sound.\neapply smatch_storebytes; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (p : aptr) (m' : mem) (b' : block) (ab : ablock) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p) (A : smatch m b' (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) : smatch m' b' (plub p (ab_summary ab)).","conclusion":"smatch m' b' (plub p (ab_summary ab))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (p : aptr) (m' : mem) (b' : block) (ab : ablock) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : forall (b'0 : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') q i) bytes -> pmatch b'0 ofs' p) (A : smatch m b' (ab_summary ab)) (B : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b' ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0))","proofString":"eapply smatch_storebytes; eauto."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7) (inval_after i (i + sz - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7) (inval_after i (i + sz - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av'))","proofString":"exploit inval_before_contents; eauto.\nclear H.\nintros [A B].\nexploit inval_after_contents; eauto.\nclear A.\nintros [C D].\nsplit.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7) (inval_after i (i + sz - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av')) : (inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i <= j) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i <= j) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (H : (inval_before i (i - 7) (inval_after i (i + sz - 1) (ab_contents ab))) ## j =\nSome (ACval chunk' av'))","proofString":"clear H.\nintros [A B].\nexploit inval_after_contents; eauto.\nclear A.\nintros [C D].\nsplit.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) : (inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i <= j) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i <= j) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval)","proofString":"intros [A B].\nexploit inval_after_contents; eauto.\nclear A.\nintros [C D].\nsplit.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (A : (inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (A : (inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j)","proofString":"exploit inval_after_contents; eauto.\nclear A.\nintros [C D].\nsplit.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (A : (inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\ (j < i \\/ j > i + sz - 1) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\ (j < i \\/ j > i + sz - 1) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (A : (inval_after i (i + sz - 1) (ab_contents ab)) ## j = Some (ACval chunk' av')) (B : j + size_chunk chunk' <= i \\/ i <= j)","proofString":"clear A.\nintros [C D].\nsplit.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\ (j < i \\/ j > i + sz - 1) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\ (j < i \\/ j > i + sz - 1) ->\n(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j)","proofString":"intros [C D].\nsplit.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i \\/ j > i + sz - 1) : (ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av') /\\\n(j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j)","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i \\/ j > i + sz - 1)","proofString":"split.\nauto.\nextlia."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i \\/ j > i + sz - 1) : (ab_contents ab) ## j = Some (ACval chunk' av').","conclusion":"(ab_contents ab) ## j = Some (ACval chunk' av')","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i \\/ j > i + sz - 1)","proofString":"auto."},{"statement":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i \\/ j > i + sz - 1) : j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j.","conclusion":"j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j","hypotheses":"(ab : ablock) (p : aptr) (i sz : Z) (j : ZTree.elt) (chunk' : memory_chunk) (av' : aval) (B : j + size_chunk chunk' <= i \\/ i <= j) (C : (ab_contents ab) ## j = Some (ACval chunk' av')) (D : j < i \\/ j > i + sz - 1)","proofString":"extlia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM : bmatch m b ab) : bmatch m' b (ablock_storebytes ab p ofs sz).","conclusion":"bmatch m' b (ablock_storebytes ab p ofs sz)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM : bmatch m b ab)","proofString":"destruct BM as [BM1 BM2].\nsplit.\neapply smatch_storebytes; eauto.\nintros chunk' ofs' v' LOAD'.\nassert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (plub p ab.(ab_summary))))).\nexploit smatch_storebytes; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs' as [[chunk av]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) : bmatch m' b (ablock_storebytes ab p ofs sz).","conclusion":"bmatch m' b (ablock_storebytes ab p ofs sz)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0))","proofString":"split.\neapply smatch_storebytes; eauto.\nintros chunk' ofs' v' LOAD'.\nassert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (plub p ab.(ab_summary))))).\nexploit smatch_storebytes; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs' as [[chunk av]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) : smatch m' b (ab_summary (ablock_storebytes ab p ofs sz)).","conclusion":"smatch m' b (ab_summary (ablock_storebytes ab p ofs sz))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0))","proofString":"eapply smatch_storebytes; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m' b ofs0 = Some v ->\nvmatch v (ablock_load chunk (ablock_storebytes ab p ofs sz) ofs0).","conclusion":"forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m' b ofs0 = Some v ->\nvmatch v (ablock_load chunk (ablock_storebytes ab p ofs sz) ofs0)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') q i) bytes -> pmatch b' ofs' p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0))","proofString":"intros chunk' ofs' v' LOAD'.\nassert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (plub p ab.(ab_summary))))).\nexploit smatch_storebytes; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs' as [[chunk av]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') : vmatch v' (ablock_load chunk' (ablock_storebytes ab p ofs sz) ofs').","conclusion":"vmatch v' (ablock_load chunk' (ablock_storebytes ab p ofs sz) ofs')","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v')","proofString":"assert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (plub p ab.(ab_summary))))).\nexploit smatch_storebytes; eauto.\nintros [A B].\neapply vnormalize_cast; eauto.\nunfold ablock_load.\ndestruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs' as [[chunk av]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab)))).","conclusion":"vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v')","proofString":"exploit smatch_storebytes; eauto.\nintros [A B].\neapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') : smatch m' b (plub p (ab_summary ab)) ->\nvmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab)))).","conclusion":"smatch m' b (plub p (ab_summary ab)) ->\nvmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v')","proofString":"intros [A B].\neapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m' b ofs0 = Some v ->\nvmatch v (Ifptr (plub p (ab_summary ab)))) (B : forall (ofs0 : Z) (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b ofs0 1 = Some (Fragment (Vptr b' ofs'0) q i :: nil) ->\npmatch b' ofs'0 (plub p (ab_summary ab))) : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab)))).","conclusion":"vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m' b ofs0 = Some v ->\nvmatch v (Ifptr (plub p (ab_summary ab)))) (B : forall (ofs0 : Z) (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m' b ofs0 1 = Some (Fragment (Vptr b' ofs'0) q i :: nil) ->\npmatch b' ofs'0 (plub p (ab_summary ab)))","proofString":"eapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) : vmatch v' (ablock_load chunk' (ablock_storebytes ab p ofs sz) ofs').","conclusion":"vmatch v' (ablock_load chunk' (ablock_storebytes ab p ofs sz) ofs')","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab)))))","proofString":"unfold ablock_load.\ndestruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs' as [[chunk av]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) : vmatch v'\n  match (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' with\n  | Some (ACval chunk'0 av) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av\n      else\n       vnormalize chunk' (Ifptr (ab_summary (ablock_storebytes ab p ofs sz)))\n  | None =>\n      vnormalize chunk' (Ifptr (ab_summary (ablock_storebytes ab p ofs sz)))\n  end.","conclusion":"vmatch v'\n  match (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' with\n  | Some (ACval chunk'0 av) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av\n      else\n       vnormalize chunk' (Ifptr (ab_summary (ablock_storebytes ab p ofs sz)))\n  | None =>\n      vnormalize chunk' (Ifptr (ab_summary (ablock_storebytes ab p ofs sz)))\n  end","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (ablock_load chunk ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab)))))","proofString":"destruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs' as [[chunk av]|] eqn:C; auto.\ndestruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) : vmatch v'\n  (if chunk_compat chunk' chunk\n   then vnormalize chunk' av\n   else\n    vnormalize chunk' (Ifptr (ab_summary (ablock_storebytes ab p ofs sz)))).","conclusion":"vmatch v'\n  (if chunk_compat chunk' chunk\n   then vnormalize chunk' av\n   else\n    vnormalize chunk' (Ifptr (ab_summary (ablock_storebytes ab p ofs sz))))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av))","proofString":"destruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.\nexploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) : vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true)","proofString":"exploit chunk_compat_true; eauto.\nintros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) : size_chunk chunk' = size_chunk chunk /\\\nalign_chunk chunk' <= align_chunk chunk /\\\ntype_of_chunk chunk' = type_of_chunk chunk ->\nvmatch v' (vnormalize chunk' av).","conclusion":"size_chunk chunk' = size_chunk chunk /\\\nalign_chunk chunk' <= align_chunk chunk /\\\ntype_of_chunk chunk' = type_of_chunk chunk ->\nvmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true)","proofString":"intros (U & V & W).\nexploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) : vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk)","proofString":"exploit ablock_storebytes_contents; eauto.\nintros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) : (ab_contents ab) ## ofs' = Some (ACval chunk av) /\\\n(ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') ->\nvmatch v' (vnormalize chunk' av).","conclusion":"(ab_contents ab) ## ofs' = Some (ACval chunk av) /\\\n(ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') ->\nvmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk)","proofString":"intros [A B].\nassert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"assert (Mem.load chunk' m b ofs' = Some v').\nrewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia.\nexploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : Mem.load chunk' m b ofs' = Some v'.","conclusion":"Mem.load chunk' m b ofs' = Some v'","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"rewrite <- LOAD'; symmetry.\neapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : Mem.load chunk' m' b ofs' = Mem.load chunk' m b ofs'.","conclusion":"Mem.load chunk' m' b ofs' = Mem.load chunk' m b ofs'","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"eapply Mem.load_storebytes_other; eauto.\nrewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : b <> b \\/\nofs' + size_chunk chunk' <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs'.","conclusion":"b <> b \\/\nofs' + size_chunk chunk' <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs'","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"rewrite U.\nrewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : b <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs'.","conclusion":"b <> b \\/\nofs' + size_chunk chunk <= ofs \\/\nofs + Z.of_nat (Datatypes.length bytes) <= ofs'","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"rewrite LENGTH.\nrewrite Z_to_nat_max.\nright; lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : b <> b \\/\nofs' + size_chunk chunk <= ofs \\/ ofs + Z.of_nat (Z.to_nat sz) <= ofs'.","conclusion":"b <> b \\/\nofs' + size_chunk chunk <= ofs \\/ ofs + Z.of_nat (Z.to_nat sz) <= ofs'","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"rewrite Z_to_nat_max.\nright; lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') : b <> b \\/ ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs'.","conclusion":"b <> b \\/ ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs'","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs')","proofString":"right; lia."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"exploit BM2; eauto.\nunfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v' (ablock_load chunk' ab ofs') -> vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (ablock_load chunk' ab ofs') -> vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"unfold ablock_load.\nrewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v'\n  match (ab_contents ab) ## ofs' with\n  | Some (ACval chunk'0 av0) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av0\n      else vnormalize chunk' (Ifptr (ab_summary ab))\n  | None => vnormalize chunk' (Ifptr (ab_summary ab))\n  end -> vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v'\n  match (ab_contents ab) ## ofs' with\n  | Some (ACval chunk'0 av0) =>\n      if chunk_compat chunk' chunk'0\n      then vnormalize chunk' av0\n      else vnormalize chunk' (Ifptr (ab_summary ab))\n  | None => vnormalize chunk' (Ifptr (ab_summary ab))\n  end -> vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"rewrite A.\nrewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v'\n  (if chunk_compat chunk' chunk\n   then vnormalize chunk' av\n   else vnormalize chunk' (Ifptr (ab_summary ab))) ->\nvmatch v' (vnormalize chunk' av).","conclusion":"vmatch v'\n  (if chunk_compat chunk' chunk\n   then vnormalize chunk' av\n   else vnormalize chunk' (Ifptr (ab_summary ab))) ->\nvmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"rewrite COMPAT.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v') : vmatch v' (vnormalize chunk' av) -> vmatch v' (vnormalize chunk' av).","conclusion":"vmatch v' (vnormalize chunk' av) -> vmatch v' (vnormalize chunk' av)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (p : aptr) (ab : ablock) (sz : Z) (STORE : Mem.storebytes m b ofs bytes = Some m') (LENGTH : Datatypes.length bytes = Z.to_nat sz) (CONTENTS : forall (b' : block) (ofs'0 : ptrofs) (q : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs'0) q i) bytes -> pmatch b' ofs'0 p) (BM1 : smatch m b (ab_summary ab)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk0 m b ofs0 = Some v -> vmatch v (ablock_load chunk0 ab ofs0)) (chunk' : memory_chunk) (ofs' : Z) (v' : val) (LOAD' : Mem.load chunk' m' b ofs' = Some v') (SUMMARY : vmatch v' (vnormalize chunk' (Ifptr (plub p (ab_summary ab))))) (chunk : memory_chunk) (av : aval) (C : (ab_contents (ablock_storebytes ab p ofs sz)) ## ofs' = Some (ACval chunk av)) (COMPAT : chunk_compat chunk' chunk = true) (U : size_chunk chunk' = size_chunk chunk) (V : align_chunk chunk' <= align_chunk chunk) (W : type_of_chunk chunk' = type_of_chunk chunk) (A : (ab_contents ab) ## ofs' = Some (ACval chunk av)) (B : ofs' + size_chunk chunk <= ofs \\/ ofs + Z.max sz 0 <= ofs') (H : Mem.load chunk' m b ofs' = Some v')","proofString":"auto."},{"statement":"(ab1 ab2 : ablock) (H : eq_aptr (ab_summary ab1) (ab_summary ab2) &&\nZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) : ab_summary ab1 = ab_summary ab2 /\\\n(forall (chunk : memory_chunk) (i : Z),\n ablock_load chunk ab1 i = ablock_load chunk ab2 i).","conclusion":"ab_summary ab1 = ab_summary ab2 /\\\n(forall (chunk : memory_chunk) (i : Z),\n ablock_load chunk ab1 i = ablock_load chunk ab2 i)","hypotheses":"(ab1 ab2 : ablock) (H : eq_aptr (ab_summary ab1) (ab_summary ab2) &&\nZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true)","proofString":"InvBooleans.\nsplit.\nunfold ablock_load_anywhere; intros; congruence.\nassert (A: forall i, ZTree.get i (ab_contents ab1) = ZTree.get i (ab_contents ab2)).\nintros.\nexploit ZTree.beq_sound; eauto.\ninstantiate (1 := i).\ndestruct (ab_contents ab1)##i, (ab_contents ab2)##i; intros; try contradiction.\nInvBooleans; subst; auto.\nauto.\nintros.\nunfold ablock_load.\nrewrite A, H.\ndestruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) : ab_summary ab1 = ab_summary ab2 /\\\n(forall (chunk : memory_chunk) (i : Z),\n ablock_load chunk ab1 i = ablock_load chunk ab2 i).","conclusion":"ab_summary ab1 = ab_summary ab2 /\\\n(forall (chunk : memory_chunk) (i : Z),\n ablock_load chunk ab1 i = ablock_load chunk ab2 i)","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2)","proofString":"split.\nunfold ablock_load_anywhere; intros; congruence.\nassert (A: forall i, ZTree.get i (ab_contents ab1) = ZTree.get i (ab_contents ab2)).\nintros.\nexploit ZTree.beq_sound; eauto.\ninstantiate (1 := i).\ndestruct (ab_contents ab1)##i, (ab_contents ab2)##i; intros; try contradiction.\nInvBooleans; subst; auto.\nauto.\nintros.\nunfold ablock_load.\nrewrite A, H.\ndestruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) : ab_summary ab1 = ab_summary ab2.","conclusion":"ab_summary ab1 = ab_summary ab2","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2)","proofString":"unfold ablock_load_anywhere; intros; congruence."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i.","conclusion":"forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2)","proofString":"assert (A: forall i, ZTree.get i (ab_contents ab1) = ZTree.get i (ab_contents ab2)).\nintros.\nexploit ZTree.beq_sound; eauto.\ninstantiate (1 := i).\ndestruct (ab_contents ab1)##i, (ab_contents ab2)##i; intros; try contradiction.\nInvBooleans; subst; auto.\nauto.\nintros.\nunfold ablock_load.\nrewrite A, H.\ndestruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) : forall i : ZTree.elt, (ab_contents ab1) ## i = (ab_contents ab2) ## i.","conclusion":"forall i : ZTree.elt, (ab_contents ab1) ## i = (ab_contents ab2) ## i","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2)","proofString":"intros.\nexploit ZTree.beq_sound; eauto.\ninstantiate (1 := i).\ndestruct (ab_contents ab1)##i, (ab_contents ab2)##i; intros; try contradiction.\nInvBooleans; subst; auto.\nauto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (i : ZTree.elt) : (ab_contents ab1) ## i = (ab_contents ab2) ## i.","conclusion":"(ab_contents ab1) ## i = (ab_contents ab2) ## i","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (i : ZTree.elt)","proofString":"exploit ZTree.beq_sound; eauto.\ninstantiate (1 := i).\ndestruct (ab_contents ab1)##i, (ab_contents ab2)##i; intros; try contradiction.\nInvBooleans; subst; auto.\nauto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (i : ZTree.elt) : match (ab_contents ab1) ## i with\n| Some y1 =>\n    match (ab_contents ab2) ## i with\n    | Some y2 =>\n        (fun c1 c2 : acontent => proj_sumbool (eq_acontent c1 c2)) y1 y2 =\n        true\n    | None => False\n    end\n| None =>\n    match (ab_contents ab2) ## i with\n    | Some _ => False\n    | None => True\n    end\nend -> (ab_contents ab1) ## i = (ab_contents ab2) ## i.","conclusion":"match (ab_contents ab1) ## i with\n| Some y1 =>\n    match (ab_contents ab2) ## i with\n    | Some y2 =>\n        (fun c1 c2 : acontent => proj_sumbool (eq_acontent c1 c2)) y1 y2 =\n        true\n    | None => False\n    end\n| None =>\n    match (ab_contents ab2) ## i with\n    | Some _ => False\n    | None => True\n    end\nend -> (ab_contents ab1) ## i = (ab_contents ab2) ## i","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (i : ZTree.elt)","proofString":"destruct (ab_contents ab1)##i, (ab_contents ab2)##i; intros; try contradiction.\nInvBooleans; subst; auto.\nauto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i : ZTree.elt, (ab_contents ab1) ## i = (ab_contents ab2) ## i) : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i.","conclusion":"forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i : ZTree.elt, (ab_contents ab1) ## i = (ab_contents ab2) ## i)","proofString":"intros.\nunfold ablock_load.\nrewrite A, H.\ndestruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i0 : ZTree.elt, (ab_contents ab1) ## i0 = (ab_contents ab2) ## i0) (chunk : memory_chunk) (i : Z) : ablock_load chunk ab1 i = ablock_load chunk ab2 i.","conclusion":"ablock_load chunk ab1 i = ablock_load chunk ab2 i","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i0 : ZTree.elt, (ab_contents ab1) ## i0 = (ab_contents ab2) ## i0) (chunk : memory_chunk) (i : Z)","proofString":"unfold ablock_load.\nrewrite A, H.\ndestruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i0 : ZTree.elt, (ab_contents ab1) ## i0 = (ab_contents ab2) ## i0) (chunk : memory_chunk) (i : Z) : match (ab_contents ab1) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab1))\n| None => vnormalize chunk (Ifptr (ab_summary ab1))\nend =\nmatch (ab_contents ab2) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab2))\n| None => vnormalize chunk (Ifptr (ab_summary ab2))\nend.","conclusion":"match (ab_contents ab1) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab1))\n| None => vnormalize chunk (Ifptr (ab_summary ab1))\nend =\nmatch (ab_contents ab2) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab2))\n| None => vnormalize chunk (Ifptr (ab_summary ab2))\nend","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i0 : ZTree.elt, (ab_contents ab1) ## i0 = (ab_contents ab2) ## i0) (chunk : memory_chunk) (i : Z)","proofString":"rewrite A, H.\ndestruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i0 : ZTree.elt, (ab_contents ab1) ## i0 = (ab_contents ab2) ## i0) (chunk : memory_chunk) (i : Z) : match (ab_contents ab2) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab2))\n| None => vnormalize chunk (Ifptr (ab_summary ab2))\nend =\nmatch (ab_contents ab2) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab2))\n| None => vnormalize chunk (Ifptr (ab_summary ab2))\nend.","conclusion":"match (ab_contents ab2) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab2))\n| None => vnormalize chunk (Ifptr (ab_summary ab2))\nend =\nmatch (ab_contents ab2) ## i with\n| Some (ACval chunk' av) =>\n    if chunk_compat chunk chunk'\n    then vnormalize chunk av\n    else vnormalize chunk (Ifptr (ab_summary ab2))\n| None => vnormalize chunk (Ifptr (ab_summary ab2))\nend","hypotheses":"(ab1 ab2 : ablock) (H1 : ZTree.beq (fun c1 c2 : acontent => eq_acontent c1 c2) \n  (ab_contents ab1) (ab_contents ab2) = true) (H : ab_summary ab1 = ab_summary ab2) (A : forall i0 : ZTree.elt, (ab_contents ab1) ## i0 = (ab_contents ab2) ## i0) (chunk : memory_chunk) (i : Z)","proofString":"destruct (ab_contents ab2)##i; auto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) : bmatch m b ab1 <-> bmatch m b ab2.","conclusion":"bmatch m b ab1 <-> bmatch m b ab2","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block)","proofString":"exploit bbeq_load; eauto.\nintros [A B].\nunfold bmatch.\nrewrite A.\nintuition.\nrewrite <- B; eauto.\nrewrite B; eauto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) : ab_summary ab1 = ab_summary ab2 /\\\n(forall (chunk : memory_chunk) (i : Z),\n ablock_load chunk ab1 i = ablock_load chunk ab2 i) ->\nbmatch m b ab1 <-> bmatch m b ab2.","conclusion":"ab_summary ab1 = ab_summary ab2 /\\\n(forall (chunk : memory_chunk) (i : Z),\n ablock_load chunk ab1 i = ablock_load chunk ab2 i) ->\nbmatch m b ab1 <-> bmatch m b ab2","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block)","proofString":"intros [A B].\nunfold bmatch.\nrewrite A.\nintuition.\nrewrite <- B; eauto.\nrewrite B; eauto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i) : bmatch m b ab1 <-> bmatch m b ab2.","conclusion":"bmatch m b ab1 <-> bmatch m b ab2","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i)","proofString":"unfold bmatch.\nrewrite A.\nintuition.\nrewrite <- B; eauto.\nrewrite B; eauto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i) : smatch m b (ab_summary ab1) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab1 ofs)) <->\nsmatch m b (ab_summary ab2) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab2 ofs)).","conclusion":"smatch m b (ab_summary ab1) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab1 ofs)) <->\nsmatch m b (ab_summary ab2) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab2 ofs))","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i)","proofString":"rewrite A.\nintuition.\nrewrite <- B; eauto.\nrewrite B; eauto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i) : smatch m b (ab_summary ab2) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab1 ofs)) <->\nsmatch m b (ab_summary ab2) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab2 ofs)).","conclusion":"smatch m b (ab_summary ab2) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab1 ofs)) <->\nsmatch m b (ab_summary ab2) /\\\n(forall (chunk : memory_chunk) (ofs : Z) (v : val),\n Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab2 ofs))","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk : memory_chunk) (i : Z),\nablock_load chunk ab1 i = ablock_load chunk ab2 i)","proofString":"intuition.\nrewrite <- B; eauto.\nrewrite B; eauto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk0 : memory_chunk) (i : Z),\nablock_load chunk0 ab1 i = ablock_load chunk0 ab2 i) (H1 : smatch m b (ab_summary ab2)) (H2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab1 ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch v (ablock_load chunk ab2 ofs).","conclusion":"vmatch v (ablock_load chunk ab2 ofs)","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk0 : memory_chunk) (i : Z),\nablock_load chunk0 ab1 i = ablock_load chunk0 ab2 i) (H1 : smatch m b (ab_summary ab2)) (H2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab1 ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v)","proofString":"rewrite <- B; eauto."},{"statement":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk0 : memory_chunk) (i : Z),\nablock_load chunk0 ab1 i = ablock_load chunk0 ab2 i) (H1 : smatch m b (ab_summary ab2)) (H2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab2 ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v) : vmatch v (ablock_load chunk ab1 ofs).","conclusion":"vmatch v (ablock_load chunk ab1 ofs)","hypotheses":"(ab1 ab2 : ablock) (H : bbeq ab1 ab2 = true) (m : mem) (b : block) (A : ab_summary ab1 = ab_summary ab2) (B : forall (chunk0 : memory_chunk) (i : Z),\nablock_load chunk0 ab1 i = ablock_load chunk0 ab2 i) (H1 : smatch m b (ab_summary ab2)) (H2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 ab2 ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H0 : Mem.load chunk m b ofs = Some v)","proofString":"rewrite B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (H : smatch m b p) : smatch m b (plub p q).","conclusion":"smatch m b (plub p q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (H : smatch m b p)","proofString":"destruct H as [A B].\nsplit; intros.\nchange (vmatch v (vlub (Ifptr p) (Ifptr q))).\napply vmatch_lub_l.\neapply A; eauto.\napply pmatch_lub_l.\neapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) : smatch m b (plub p q).","conclusion":"smatch m b (plub p q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p)","proofString":"split; intros.\nchange (vmatch v (vlub (Ifptr p) (Ifptr q))).\napply vmatch_lub_l.\neapply A; eauto.\napply pmatch_lub_l.\neapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (Ifptr (plub p q)).","conclusion":"vmatch v (Ifptr (plub p q))","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"change (vmatch v (vlub (Ifptr p) (Ifptr q))).\napply vmatch_lub_l.\neapply A; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (vlub (Ifptr p) (Ifptr q)).","conclusion":"vmatch v (vlub (Ifptr p) (Ifptr q))","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"apply vmatch_lub_l.\neapply A; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (Ifptr p).","conclusion":"vmatch v (Ifptr p)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"eapply A; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil)) : pmatch b' ofs' (plub p q).","conclusion":"pmatch b' ofs' (plub p q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil))","proofString":"apply pmatch_lub_l.\neapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil)) : pmatch b' ofs' p.","conclusion":"pmatch b' ofs' p","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil))","proofString":"eapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (H : smatch m b q) : smatch m b (plub p q).","conclusion":"smatch m b (plub p q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (H : smatch m b q)","proofString":"destruct H as [A B].\nsplit; intros.\nchange (vmatch v (vlub (Ifptr p) (Ifptr q))).\napply vmatch_lub_r.\neapply A; eauto.\napply pmatch_lub_r.\neapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr q)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) : smatch m b (plub p q).","conclusion":"smatch m b (plub p q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (Ifptr q)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q)","proofString":"split; intros.\nchange (vmatch v (vlub (Ifptr p) (Ifptr q))).\napply vmatch_lub_r.\neapply A; eauto.\napply pmatch_lub_r.\neapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr q)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (Ifptr (plub p q)).","conclusion":"vmatch v (Ifptr (plub p q))","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr q)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"change (vmatch v (vlub (Ifptr p) (Ifptr q))).\napply vmatch_lub_r.\neapply A; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr q)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (vlub (Ifptr p) (Ifptr q)).","conclusion":"vmatch v (vlub (Ifptr p) (Ifptr q))","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr q)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"apply vmatch_lub_r.\neapply A; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr q)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (Ifptr q).","conclusion":"vmatch v (Ifptr q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (Ifptr q)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil) ->\npmatch b' ofs' q) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"eapply A; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr q)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 q) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil)) : pmatch b' ofs' (plub p q).","conclusion":"pmatch b' ofs' (plub p q)","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr q)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 q) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil))","proofString":"apply pmatch_lub_r.\neapply B; eauto."},{"statement":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr q)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 q) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil)) : pmatch b' ofs' q.","conclusion":"pmatch b' ofs' q","hypotheses":"(m : mem) (b : block) (p q : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch v (Ifptr q)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q1 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q1 i0 :: nil) ->\npmatch b'0 ofs'0 q) (ofs : Z) (b' : block) (ofs' : ptrofs) (q0 : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q0 i :: nil))","proofString":"eapply B; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (H : bmatch m b x) : bmatch m b (blub x y).","conclusion":"bmatch m b (blub x y)","hypotheses":"(m : mem) (b : block) (x y : ablock) (H : bmatch m b x)","proofString":"destruct H as [BM1 BM2].\nsplit; unfold blub; simpl.\napply smatch_lub_l; auto.\nintros.\nassert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_l; eauto.\ninstantiate (1 := ab_summary y).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk x ofs)) : bmatch m b (blub x y).","conclusion":"bmatch m b (blub x y)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk x ofs))","proofString":"split; unfold blub; simpl.\napply smatch_lub_l; auto.\nintros.\nassert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_l; eauto.\ninstantiate (1 := ab_summary y).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk x ofs)) : smatch m b (plub (ab_summary x) (ab_summary y)).","conclusion":"smatch m b (plub (ab_summary x) (ab_summary y))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk x ofs))","proofString":"apply smatch_lub_l; auto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk x ofs)) : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk x ofs))","proofString":"intros.\nassert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_l; eauto.\ninstantiate (1 := ab_summary y).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_l; eauto.\ninstantiate (1 := ab_summary y).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"exploit smatch_lub_l; eauto.\ninstantiate (1 := ab_summary y).\nintros [SUMM _].\neapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : smatch m b (plub (ab_summary x) (ab_summary y)) ->\nvmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"smatch m b (plub (ab_summary x) (ab_summary y)) ->\nvmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"intros [SUMM _].\neapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMM : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch v0 (Ifptr (plub (ab_summary x) (ab_summary y)))) : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMM : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch v0 (Ifptr (plub (ab_summary x) (ab_summary y))))","proofString":"eapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"exploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v (ablock_load chunk x ofs) ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"vmatch v (ablock_load chunk x ofs) ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"unfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v\n  match (ab_contents x) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary x))\n  | None => vnormalize chunk (Ifptr (ab_summary x))\n  end ->\nvmatch v\n  match\n    (ZTree.combine combine_acontents (ab_contents x) (ab_contents y)) ## ofs\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end.","conclusion":"vmatch v\n  match (ab_contents x) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary x))\n  | None => vnormalize chunk (Ifptr (ab_summary x))\n  end ->\nvmatch v\n  match\n    (ZTree.combine combine_acontents (ab_contents x) (ab_contents y)) ## ofs\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"rewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v\n  match (ab_contents x) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary x))\n  | None => vnormalize chunk (Ifptr (ab_summary x))\n  end ->\nvmatch v\n  match combine_acontents (ab_contents x) ## ofs (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end.","conclusion":"vmatch v\n  match (ab_contents x) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary x))\n  | None => vnormalize chunk (Ifptr (ab_summary x))\n  end ->\nvmatch v\n  match combine_acontents (ab_contents x) ## ofs (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"unfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval) : vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avx\n   else vnormalize chunk (Ifptr (ab_summary x))) ->\nvmatch v\n  match\n    (if chunk_eq chunkx chunky\n     then Some (ACval chunkx (vlub avx avy))\n     else None)\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end.","conclusion":"vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avx\n   else vnormalize chunk (Ifptr (ab_summary x))) ->\nvmatch v\n  match\n    (if chunk_eq chunkx chunky\n     then Some (ACval chunkx (vlub avx avy))\n     else None)\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval)","proofString":"destruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval) (e : chunkx = chunky) : vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avx\n   else vnormalize chunk (Ifptr (ab_summary x))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avx\n   else vnormalize chunk (Ifptr (ab_summary x))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval) (e : chunkx = chunky)","proofString":"subst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) : vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avx\n   else vnormalize chunk (Ifptr (ab_summary x))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avx\n   else vnormalize chunk (Ifptr (ab_summary x))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval)","proofString":"destruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) : vmatch v (vnormalize chunk avx) -> vmatch v (vnormalize chunk (vlub avx avy)).","conclusion":"vmatch v (vnormalize chunk avx) -> vmatch v (vnormalize chunk (vlub avx avy))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval)","proofString":"intros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avx)) : vmatch v (vnormalize chunk (vlub avx avy)).","conclusion":"vmatch v (vnormalize chunk (vlub avx avy))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avx))","proofString":"eapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avx)) : vge (vnormalize chunk (vlub avx avy)) (vnormalize chunk avx).","conclusion":"vge (vnormalize chunk (vlub avx avy)) (vnormalize chunk avx)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avx))","proofString":"apply vnormalize_monotone.\napply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avx)) : vge (vlub avx avy) avx.","conclusion":"vge (vlub avx avy) avx","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary x)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 x ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avx))","proofString":"apply vge_lub_l."},{"statement":"(m : mem) (b : block) (x y : ablock) (H : bmatch m b y) : bmatch m b (blub x y).","conclusion":"bmatch m b (blub x y)","hypotheses":"(m : mem) (b : block) (x y : ablock) (H : bmatch m b y)","proofString":"destruct H as [BM1 BM2].\nsplit; unfold blub; simpl.\napply smatch_lub_r; auto.\nintros.\nassert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_r; eauto.\ninstantiate (1 := ab_summary x).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk y ofs)) : bmatch m b (blub x y).","conclusion":"bmatch m b (blub x y)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk y ofs))","proofString":"split; unfold blub; simpl.\napply smatch_lub_r; auto.\nintros.\nassert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_r; eauto.\ninstantiate (1 := ab_summary x).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk y ofs)) : smatch m b (plub (ab_summary x) (ab_summary y)).","conclusion":"smatch m b (plub (ab_summary x) (ab_summary y))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk y ofs))","proofString":"apply smatch_lub_r; auto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk y ofs)) : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk y ofs))","proofString":"intros.\nassert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_r; eauto.\ninstantiate (1 := ab_summary x).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))).\nexploit smatch_lub_r; eauto.\ninstantiate (1 := ab_summary x).\nintros [SUMM _].\neapply vnormalize_cast; eauto.\nexploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"exploit smatch_lub_r; eauto.\ninstantiate (1 := ab_summary x).\nintros [SUMM _].\neapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : smatch m b (plub (ab_summary x) (ab_summary y)) ->\nvmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"smatch m b (plub (ab_summary x) (ab_summary y)) ->\nvmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"intros [SUMM _].\neapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMM : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch v0 (Ifptr (plub (ab_summary x) (ab_summary y)))) : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMM : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch v0 (Ifptr (plub (ab_summary x) (ab_summary y))))","proofString":"eapply vnormalize_cast; eauto."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"vmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"exploit BM2; eauto.\nunfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v (ablock_load chunk y ofs) ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs).","conclusion":"vmatch v (ablock_load chunk y ofs) ->\nvmatch v\n  (ablock_load chunk\n     {|\n       ab_contents :=\n         ZTree.combine combine_acontents (ab_contents x) (ab_contents y);\n       ab_summary := plub (ab_summary x) (ab_summary y)\n     |} ofs)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"unfold ablock_load; simpl.\nrewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v\n  match (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary y))\n  | None => vnormalize chunk (Ifptr (ab_summary y))\n  end ->\nvmatch v\n  match\n    (ZTree.combine combine_acontents (ab_contents x) (ab_contents y)) ## ofs\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end.","conclusion":"vmatch v\n  match (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary y))\n  | None => vnormalize chunk (Ifptr (ab_summary y))\n  end ->\nvmatch v\n  match\n    (ZTree.combine combine_acontents (ab_contents x) (ab_contents y)) ## ofs\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"rewrite ZTree.gcombine by auto.\nunfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) : vmatch v\n  match (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary y))\n  | None => vnormalize chunk (Ifptr (ab_summary y))\n  end ->\nvmatch v\n  match combine_acontents (ab_contents x) ## ofs (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end.","conclusion":"vmatch v\n  match (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (ab_summary y))\n  | None => vnormalize chunk (Ifptr (ab_summary y))\n  end ->\nvmatch v\n  match combine_acontents (ab_contents x) ## ofs (ab_contents y) ## ofs with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))))","proofString":"unfold combine_acontents;  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.\ndestruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval) : vmatch v\n  (if chunk_compat chunk chunky\n   then vnormalize chunk avy\n   else vnormalize chunk (Ifptr (ab_summary y))) ->\nvmatch v\n  match\n    (if chunk_eq chunkx chunky\n     then Some (ACval chunkx (vlub avx avy))\n     else None)\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end.","conclusion":"vmatch v\n  (if chunk_compat chunk chunky\n   then vnormalize chunk avy\n   else vnormalize chunk (Ifptr (ab_summary y))) ->\nvmatch v\n  match\n    (if chunk_eq chunkx chunky\n     then Some (ACval chunkx (vlub avx avy))\n     else None)\n  with\n  | Some (ACval chunk' av) =>\n      if chunk_compat chunk chunk'\n      then vnormalize chunk av\n      else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  | None => vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))\n  end","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval)","proofString":"destruct (chunk_eq chunkx chunky); auto.\nsubst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval) (e : chunkx = chunky) : vmatch v\n  (if chunk_compat chunk chunky\n   then vnormalize chunk avy\n   else vnormalize chunk (Ifptr (ab_summary y))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v\n  (if chunk_compat chunk chunky\n   then vnormalize chunk avy\n   else vnormalize chunk (Ifptr (ab_summary y))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx : aval) (chunky : memory_chunk) (avy : aval) (e : chunkx = chunky)","proofString":"subst chunky.\ndestruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) : vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avy\n   else vnormalize chunk (Ifptr (ab_summary y))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y)))).","conclusion":"vmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk avy\n   else vnormalize chunk (Ifptr (ab_summary y))) ->\nvmatch v\n  (if chunk_compat chunk chunkx\n   then vnormalize chunk (vlub avx avy)\n   else vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval)","proofString":"destruct (chunk_compat chunk chunkx); auto.\nintros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) : vmatch v (vnormalize chunk avy) -> vmatch v (vnormalize chunk (vlub avx avy)).","conclusion":"vmatch v (vnormalize chunk avy) -> vmatch v (vnormalize chunk (vlub avx avy))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval)","proofString":"intros.\neapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avy)) : vmatch v (vnormalize chunk (vlub avx avy)).","conclusion":"vmatch v (vnormalize chunk (vlub avx avy))","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avy))","proofString":"eapply vmatch_ge; eauto.\napply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avy)) : vge (vnormalize chunk (vlub avx avy)) (vnormalize chunk avy).","conclusion":"vge (vnormalize chunk (vlub avx avy)) (vnormalize chunk avy)","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avy))","proofString":"apply vnormalize_monotone.\napply vge_lub_r."},{"statement":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avy)) : vge (vlub avx avy) avy.","conclusion":"vge (vlub avx avy) avy","hypotheses":"(m : mem) (b : block) (x y : ablock) (BM1 : smatch m b (ab_summary y)) (BM2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch v0 (ablock_load chunk0 y ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) (SUMMARY : vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))) (chunkx : memory_chunk) (avx avy : aval) (H0 : vmatch v (vnormalize chunk avy))","proofString":"apply vge_lub_r."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab)","proofString":"exploit H0; eauto.\nintros (A & B & C).\nsplit; auto.\nsplit.\nexploit Mem.store_valid_access_3; eauto.\nintros [P _].\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab)","proofString":"intros (A & B & C).\nsplit; auto.\nsplit.\nexploit Mem.store_valid_access_3; eauto.\nintros [P _].\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"split; auto.\nsplit.\nexploit Mem.store_valid_access_3; eauto.\nintros [P _].\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : bmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"bmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"split.\nexploit Mem.store_valid_access_3; eauto.\nintros [P _].\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : bmatch m' b0 ab.","conclusion":"bmatch m' b0 ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"exploit Mem.store_valid_access_3; eauto.\nintros [P _].\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : Mem.valid_access m chunk b ofs Writable -> bmatch m' b0 ab.","conclusion":"Mem.valid_access m chunk b ofs Writable -> bmatch m' b0 ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"intros [P _].\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) : bmatch m' b0 ab.","conclusion":"bmatch m' b0 ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable)","proofString":"apply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable)","proofString":"intros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"eapply Mem.loadbytes_store_other; eauto.\nleft.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : b0 <> b \\/ n <= 0 \\/ ofs0 + n <= ofs \\/ ofs + size_chunk chunk <= ofs0.","conclusion":"b0 <> b \\/ n <= 0 \\/ ofs0 + n <= ofs \\/ ofs + size_chunk chunk <= ofs0","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"left.\nred; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : b0 <> b.","conclusion":"b0 <> b","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"red; intros; subst b0.\nelim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : False.","conclusion":"False","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"elim (C ofs).\napply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : Mem.perm m b ofs Max Writable.","conclusion":"Mem.perm m b ofs Max Writable","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"apply Mem.perm_cur_max.\napply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : Mem.perm m b ofs Cur Writable.","conclusion":"Mem.perm m b ofs Cur Writable","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"apply P.\ngeneralize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0) : ofs <= ofs < ofs + size_chunk chunk.","conclusion":"ofs <= ofs < ofs + size_chunk chunk","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (P : Mem.range_perm m b ofs (ofs + size_chunk chunk) Cur Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"generalize (size_chunk_pos chunk); lia."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable.","conclusion":"forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"intros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 : Z) (H3 : Mem.perm m' b0 ofs0 Max Writable) : Mem.perm m b0 ofs0 Max Writable.","conclusion":"Mem.perm m b0 ofs0 Max Writable","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : romem) (H : Mem.store chunk m b ofs v = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 : Z) (H3 : Mem.perm m' b0 ofs0 Max Writable)","proofString":"eauto with mem."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab)","proofString":"exploit H0; eauto.\nintros (A & B & C).\nsplit; auto.\nsplit.\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab)","proofString":"intros (A & B & C).\nsplit; auto.\nsplit.\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"split; auto.\nsplit.\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : bmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable).","conclusion":"bmatch m' b0 ab /\\ (forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable)","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"split.\napply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto.\nintros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : bmatch m' b0 ab.","conclusion":"bmatch m' b0 ab","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"apply bmatch_inv with m; auto.\nintros.\neapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"intros.\neapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 n : Z) (H3 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"eapply Mem.loadbytes_storebytes_disjoint; eauto.\ndestruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 n : Z) (H3 : n >= 0) : b0 <> b \\/\nIntv.disjoint (ofs0, ofs0 + n) (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","conclusion":"b0 <> b \\/\nIntv.disjoint (ofs0, ofs0 + n) (ofs, ofs + Z.of_nat (Datatypes.length bytes))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 n : Z) (H3 : n >= 0)","proofString":"destruct (eq_block b0 b); auto.\nsubst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 n : Z) (H3 : n >= 0) (e : b0 = b) : b0 <> b \\/\nIntv.disjoint (ofs0, ofs0 + n) (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","conclusion":"b0 <> b \\/\nIntv.disjoint (ofs0, ofs0 + n) (ofs, ofs + Z.of_nat (Datatypes.length bytes))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 n : Z) (H3 : n >= 0) (e : b0 = b)","proofString":"subst b0.\nright; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) : b <> b \\/\nIntv.disjoint (ofs0, ofs0 + n) (ofs, ofs + Z.of_nat (Datatypes.length bytes)).","conclusion":"b <> b \\/\nIntv.disjoint (ofs0, ofs0 + n) (ofs, ofs + Z.of_nat (Datatypes.length bytes))","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0)","proofString":"right; red; unfold Intv.In; simpl; red; intros.\nelim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) (x : Z) (H4 : ofs0 <= x < ofs0 + n) (H5 : ofs <= x < ofs + Z.of_nat (Datatypes.length bytes)) : False.","conclusion":"False","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) (x : Z) (H4 : ofs0 <= x < ofs0 + n) (H5 : ofs <= x < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"elim (C x).\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) (x : Z) (H4 : ofs0 <= x < ofs0 + n) (H5 : ofs <= x < ofs + Z.of_nat (Datatypes.length bytes)) : Mem.perm m b x Max Writable.","conclusion":"Mem.perm m b x Max Writable","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) (x : Z) (H4 : ofs0 <= x < ofs0 + n) (H5 : ofs <= x < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"apply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) (x : Z) (H4 : ofs0 <= x < ofs0 + n) (H5 : ofs <= x < ofs + Z.of_nat (Datatypes.length bytes)) : Mem.perm m b x Cur Writable.","conclusion":"Mem.perm m b x Cur Writable","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (id : ident) (ab : ablock) (H1 : bc b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (C : forall ofs1 : Z, ~ Mem.perm m b ofs1 Max Writable) (B : bmatch m b ab) (ofs0 n : Z) (H3 : n >= 0) (x : Z) (H4 : ofs0 <= x < ofs0 + n) (H5 : ofs <= x < ofs + Z.of_nat (Datatypes.length bytes))","proofString":"eapply Mem.storebytes_range_perm; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable) : forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable.","conclusion":"forall ofs0 : Z, ~ Mem.perm m' b0 ofs0 Max Writable","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs0 : Z, ~ Mem.perm m b0 ofs0 Max Writable)","proofString":"intros; red; intros; elim (C ofs0).\neauto with mem."},{"statement":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 : Z) (H3 : Mem.perm m' b0 ofs0 Max Writable) : Mem.perm m b0 ofs0 Max Writable.","conclusion":"Mem.perm m b0 ofs0 Max Writable","hypotheses":"(m : mem) (b : block) (ofs : Z) (bytes : list memval) (m' : mem) (rm : romem) (H : Mem.storebytes m b ofs bytes = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ab : ablock) (H1 : bc b0 = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b0 ab) (C : forall ofs1 : Z, ~ Mem.perm m b0 ofs1 Max Writable) (ofs0 : Z) (H3 : Mem.perm m' b0 ofs0 Max Writable)","proofString":"eauto with mem."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable)","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab)","proofString":"exploit H; eauto.\nintros (A & B & C).\nsplit.\nauto.\nsplit.\napply bmatch_ext with m; auto.\nintros.\neapply H0; eauto.\nintros; red; intros.\nelim (C ofs).\neapply H1; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable)","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab)","proofString":"intros (A & B & C).\nsplit.\nauto.\nsplit.\napply bmatch_ext with m; auto.\nintros.\neapply H0; eauto.\nintros; red; intros.\nelim (C ofs).\neapply H1; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : pge Glob (ab_summary ab) /\\\nbmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable)","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"split.\nauto.\nsplit.\napply bmatch_ext with m; auto.\nintros.\neapply H0; eauto.\nintros; red; intros.\nelim (C ofs).\neapply H1; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : pge Glob (ab_summary ab).","conclusion":"pge Glob (ab_summary ab)","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"auto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable).","conclusion":"bmatch m' b ab /\\ (forall ofs : Z, ~ Mem.perm m' b ofs Max Writable)","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"split.\napply bmatch_ext with m; auto.\nintros.\neapply H0; eauto.\nintros; red; intros.\nelim (C ofs).\neapply H1; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch m' b ab.","conclusion":"bmatch m' b ab","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"apply bmatch_ext with m; auto.\nintros.\neapply H0; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes.","conclusion":"forall (ofs n : Z) (bytes : list memval),\nMem.loadbytes m' b ofs n = Some bytes ->\nn >= 0 -> Mem.loadbytes m b ofs n = Some bytes","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"intros.\neapply H0; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs0 n0 : Z) (bytes0 : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H1 : forall (b0 : block) (id0 : ident) (ofs0 : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs0 Max p -> Mem.perm m b0 ofs0 Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs n : Z) (bytes : list memval) (H4 : Mem.loadbytes m' b ofs n = Some bytes) (H5 : n >= 0) : Mem.loadbytes m b ofs n = Some bytes.","conclusion":"Mem.loadbytes m b ofs n = Some bytes","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs0 n0 : Z) (bytes0 : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs0 n0 = Some bytes0 ->\nMem.loadbytes m b0 ofs0 n0 = Some bytes0) (H1 : forall (b0 : block) (id0 : ident) (ofs0 : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs0 Max p -> Mem.perm m b0 ofs0 Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs n : Z) (bytes : list memval) (H4 : Mem.loadbytes m' b ofs n = Some bytes) (H5 : n >= 0)","proofString":"eapply H0; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : forall ofs : Z, ~ Mem.perm m' b ofs Max Writable.","conclusion":"forall ofs : Z, ~ Mem.perm m' b ofs Max Writable","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"intros; red; intros.\nelim (C ofs).\neapply H1; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs0 n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs0 n = Some bytes ->\nMem.loadbytes m b0 ofs0 n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs0 : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs0 Max p -> Mem.perm m b0 ofs0 Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs : Z) (H4 : Mem.perm m' b ofs Max Writable) : False.","conclusion":"False","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs0 n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs0 n = Some bytes ->\nMem.loadbytes m b0 ofs0 n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs0 : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs0 Max p -> Mem.perm m b0 ofs0 Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs : Z) (H4 : Mem.perm m' b ofs Max Writable)","proofString":"elim (C ofs).\neapply H1; eauto."},{"statement":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs0 n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs0 n = Some bytes ->\nMem.loadbytes m b0 ofs0 n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs0 : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs0 Max p -> Mem.perm m b0 ofs0 Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs : Z) (H4 : Mem.perm m' b ofs Max Writable) : Mem.perm m b ofs Max Writable.","conclusion":"Mem.perm m b ofs Max Writable","hypotheses":"(m : mem) (rm : romem) (m' : mem) (H : romatch m rm) (H0 : forall (b0 : block) (id0 : ident) (ofs0 n : Z) (bytes : list memval),\nbc b0 = BCglob id0 ->\nMem.loadbytes m' b0 ofs0 n = Some bytes ->\nMem.loadbytes m b0 ofs0 n = Some bytes) (H1 : forall (b0 : block) (id0 : ident) (ofs0 : Z) (p : permission),\nbc b0 = BCglob id0 -> Mem.perm m' b0 ofs0 Max p -> Mem.perm m b0 ofs0 Max p) (b : block) (id : ident) (ab : ablock) (H2 : bc b = BCglob id) (H3 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (ofs : Z) (H4 : Mem.perm m' b ofs Max Writable)","proofString":"eapply H1; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) : romatch m' rm.","conclusion":"romatch m' rm","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm)","proofString":"apply romatch_ext with m; auto.\nintros.\neapply Mem.loadbytes_free_2; eauto.\nintros.\neauto with mem."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) : forall (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes.","conclusion":"forall (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm)","proofString":"intros.\neapply Mem.loadbytes_free_2; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H1 : bc b0 = BCglob id) (H2 : Mem.loadbytes m' b0 ofs n = Some bytes) : Mem.loadbytes m b0 ofs n = Some bytes.","conclusion":"Mem.loadbytes m b0 ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H1 : bc b0 = BCglob id) (H2 : Mem.loadbytes m' b0 ofs n = Some bytes)","proofString":"eapply Mem.loadbytes_free_2; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) : forall (b0 : block) (id : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p.","conclusion":"forall (b0 : block) (id : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm)","proofString":"intros.\neauto with mem."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H1 : bc b0 = BCglob id) (H2 : Mem.perm m' b0 ofs Max p) : Mem.perm m b0 ofs Max p.","conclusion":"Mem.perm m b0 ofs Max p","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (rm : romem) (H : Mem.free m b lo hi = Some m') (H0 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H1 : bc b0 = BCglob id) (H2 : Mem.perm m' b0 ofs Max p)","proofString":"eauto with mem."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) : romatch m' rm.","conclusion":"romatch m' rm","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm)","proofString":"apply romatch_ext with m; auto.\nintros.\nrewrite <- H3; symmetry.\neapply Mem.loadbytes_alloc_unchanged; eauto.\napply H0.\ncongruence.\nintros.\neapply Mem.perm_alloc_4; eauto.\napply Mem.valid_not_valid_diff with m; eauto with mem.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) : forall (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes.","conclusion":"forall (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval),\nbc b0 = BCglob id ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm)","proofString":"intros.\nrewrite <- H3; symmetry.\neapply Mem.loadbytes_alloc_unchanged; eauto.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes) : Mem.loadbytes m b0 ofs n = Some bytes.","conclusion":"Mem.loadbytes m b0 ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes)","proofString":"rewrite <- H3; symmetry.\neapply Mem.loadbytes_alloc_unchanged; eauto.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes) : Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n.","conclusion":"Mem.loadbytes m' b0 ofs n = Mem.loadbytes m b0 ofs n","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes)","proofString":"eapply Mem.loadbytes_alloc_unchanged; eauto.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes) : Mem.valid_block m b0.","conclusion":"Mem.valid_block m b0","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes)","proofString":"apply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes) : bc b0 <> BCinvalid.","conclusion":"bc b0 <> BCinvalid","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs n : Z) (bytes : list memval) (H2 : bc b0 = BCglob id) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes)","proofString":"congruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) : forall (b0 : block) (id : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p.","conclusion":"forall (b0 : block) (id : ident) (ofs : Z) (p : permission),\nbc b0 = BCglob id -> Mem.perm m' b0 ofs Max p -> Mem.perm m b0 ofs Max p","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm)","proofString":"intros.\neapply Mem.perm_alloc_4; eauto.\napply Mem.valid_not_valid_diff with m; eauto with mem.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p) : Mem.perm m b0 ofs Max p.","conclusion":"Mem.perm m b0 ofs Max p","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p)","proofString":"eapply Mem.perm_alloc_4; eauto.\napply Mem.valid_not_valid_diff with m; eauto with mem.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p) : b0 <> b.","conclusion":"b0 <> b","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p)","proofString":"apply Mem.valid_not_valid_diff with m; eauto with mem.\napply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p) : Mem.valid_block m b0.","conclusion":"Mem.valid_block m b0","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p)","proofString":"apply H0.\ncongruence."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p) : bc b0 <> BCinvalid.","conclusion":"bc b0 <> BCinvalid","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : Mem.mem') (rm : romem) (H : Mem.alloc m lo hi = (m', b)) (H0 : bc_below bc (Mem.nextblock m)) (H1 : romatch m rm) (b0 : block) (id : ident) (ofs : Z) (p : permission) (H2 : bc b0 = BCglob id) (H3 : Mem.perm m' b0 ofs Max p)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (p : aptr) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : pmatch b ofs p) : vmatch v (load chunk rm am p).","conclusion":"vmatch v (load chunk rm am p)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (p : aptr) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : pmatch b ofs p)","proofString":"unfold load.\ninv H2.\ndestruct (rm!id) as [ab|] eqn:RM.\neapply ablock_load_sound; eauto.\neapply H0; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence.\ndestruct (rm!id) as [ab|] eqn:RM.\neapply ablock_load_anywhere_sound; eauto.\neapply H0; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_anywhere_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto.\ncongruence.\ncongruence.\neapply ablock_load_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_load_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_top; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (p : aptr) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : pmatch b ofs p) : vmatch v\n  match p with\n  | Pbot => if va_strict tt then Vbot else Vtop\n  | Gl id ofs0 =>\n      match rm ! id with\n      | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs0)\n      | None =>\n          match (am_glob am) ! id with\n          | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs0)\n          | None => vnormalize chunk (Ifptr (am_nonstack am))\n          end\n      end\n  | Glo id =>\n      match rm ! id with\n      | Some ab => ablock_load_anywhere chunk ab\n      | None =>\n          match (am_glob am) ! id with\n          | Some ab => ablock_load_anywhere chunk ab\n          | None => vnormalize chunk (Ifptr (am_nonstack am))\n          end\n      end\n  | Stk ofs0 => ablock_load chunk (am_stack am) (Ptrofs.unsigned ofs0)\n  | Stack => ablock_load_anywhere chunk (am_stack am)\n  | Ptop => vnormalize chunk (Ifptr (am_top am))\n  | _ => vnormalize chunk (Ifptr (am_nonstack am))\n  end.","conclusion":"vmatch v\n  match p with\n  | Pbot => if va_strict tt then Vbot else Vtop\n  | Gl id ofs0 =>\n      match rm ! id with\n      | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs0)\n      | None =>\n          match (am_glob am) ! id with\n          | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs0)\n          | None => vnormalize chunk (Ifptr (am_nonstack am))\n          end\n      end\n  | Glo id =>\n      match rm ! id with\n      | Some ab => ablock_load_anywhere chunk ab\n      | None =>\n          match (am_glob am) ! id with\n          | Some ab => ablock_load_anywhere chunk ab\n          | None => vnormalize chunk (Ifptr (am_nonstack am))\n          end\n      end\n  | Stk ofs0 => ablock_load chunk (am_stack am) (Ptrofs.unsigned ofs0)\n  | Stack => ablock_load_anywhere chunk (am_stack am)\n  | Ptop => vnormalize chunk (Ifptr (am_top am))\n  | _ => vnormalize chunk (Ifptr (am_nonstack am))\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (p : aptr) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : pmatch b ofs p)","proofString":"inv H2.\ndestruct (rm!id) as [ab|] eqn:RM.\neapply ablock_load_sound; eauto.\neapply H0; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence.\ndestruct (rm!id) as [ab|] eqn:RM.\neapply ablock_load_anywhere_sound; eauto.\neapply H0; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_anywhere_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto.\ncongruence.\ncongruence.\neapply ablock_load_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_load_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_top; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) : vmatch v\n  match rm ! id with\n  | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs)\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs)\n      | None => vnormalize chunk (Ifptr (am_nonstack am))\n      end\n  end.","conclusion":"vmatch v\n  match rm ! id with\n  | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs)\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs)\n      | None => vnormalize chunk (Ifptr (am_nonstack am))\n      end\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id)","proofString":"destruct (rm!id) as [ab|] eqn:RM.\neapply ablock_load_sound; eauto.\neapply H0; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : vmatch v (ablock_load chunk ab (Ptrofs.unsigned ofs)).","conclusion":"vmatch v (ablock_load chunk ab (Ptrofs.unsigned ofs))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"eapply ablock_load_sound; eauto.\neapply H0; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"eapply H0; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) : vmatch v\n  match (am_glob am) ! id with\n  | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs)\n  | None => vnormalize chunk (Ifptr (am_nonstack am))\n  end.","conclusion":"vmatch v\n  match (am_glob am) ! id with\n  | Some ab => ablock_load chunk ab (Ptrofs.unsigned ofs)\n  | None => vnormalize chunk (Ifptr (am_nonstack am))\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None)","proofString":"destruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab) : vmatch v (ablock_load chunk ab (Ptrofs.unsigned ofs)).","conclusion":"vmatch v (ablock_load chunk ab (Ptrofs.unsigned ofs))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab)","proofString":"eapply ablock_load_sound; eauto.\neapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None) : vmatch v (vnormalize chunk (Ifptr (am_nonstack am))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (am_nonstack am)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None)","proofString":"eapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None) : vmatch v (Ifptr (am_nonstack am)).","conclusion":"vmatch v (Ifptr (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) : vmatch v\n  match rm ! id with\n  | Some ab => ablock_load_anywhere chunk ab\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_load_anywhere chunk ab\n      | None => vnormalize chunk (Ifptr (am_nonstack am))\n      end\n  end.","conclusion":"vmatch v\n  match rm ! id with\n  | Some ab => ablock_load_anywhere chunk ab\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_load_anywhere chunk ab\n      | None => vnormalize chunk (Ifptr (am_nonstack am))\n      end\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id)","proofString":"destruct (rm!id) as [ab|] eqn:RM.\neapply ablock_load_anywhere_sound; eauto.\neapply H0; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_anywhere_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : vmatch v (ablock_load_anywhere chunk ab).","conclusion":"vmatch v (ablock_load_anywhere chunk ab)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"eapply ablock_load_anywhere_sound; eauto.\neapply H0; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"eapply H0; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) : vmatch v\n  match (am_glob am) ! id with\n  | Some ab => ablock_load_anywhere chunk ab\n  | None => vnormalize chunk (Ifptr (am_nonstack am))\n  end.","conclusion":"vmatch v\n  match (am_glob am) ! id with\n  | Some ab => ablock_load_anywhere chunk ab\n  | None => vnormalize chunk (Ifptr (am_nonstack am))\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None)","proofString":"destruct (am_glob am)!id as [ab|] eqn:AM.\neapply ablock_load_anywhere_sound; eauto.\neapply mmatch_glob; eauto.\neapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab) : vmatch v (ablock_load_anywhere chunk ab).","conclusion":"vmatch v (ablock_load_anywhere chunk ab)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab)","proofString":"eapply ablock_load_anywhere_sound; eauto.\neapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (AM : (am_glob am) ! id = Some ab)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None) : vmatch v (vnormalize chunk (Ifptr (am_nonstack am))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (am_nonstack am)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None)","proofString":"eapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None) : vmatch v (Ifptr (am_nonstack am)).","conclusion":"vmatch v (Ifptr (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) (RM : rm ! id = None) (AM : (am_glob am) ! id = None)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) : vmatch v (vnormalize chunk (Ifptr (am_nonstack am))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (am_nonstack am)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id)","proofString":"eapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto.\ncongruence.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) : vmatch v (Ifptr (am_nonstack am)).","conclusion":"vmatch v (Ifptr (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id)","proofString":"eapply mmatch_nonstack; eauto.\ncongruence.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) : bc b <> BCstack.","conclusion":"bc b <> BCstack","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id) : bc b <> BCinvalid.","conclusion":"bc b <> BCinvalid","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (id : ident) (H3 : bc b = BCglob id)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack) : vmatch v (ablock_load chunk (am_stack am) (Ptrofs.unsigned ofs)).","conclusion":"vmatch v (ablock_load chunk (am_stack am) (Ptrofs.unsigned ofs))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack)","proofString":"eapply ablock_load_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack) : vmatch v (ablock_load_anywhere chunk (am_stack am)).","conclusion":"vmatch v (ablock_load_anywhere chunk (am_stack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack)","proofString":"eapply ablock_load_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid) : vmatch v (vnormalize chunk (Ifptr (am_nonstack am))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (am_nonstack am)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid)","proofString":"eapply vnormalize_cast; eauto.\neapply mmatch_nonstack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid) : vmatch v (Ifptr (am_nonstack am)).","conclusion":"vmatch v (Ifptr (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid)","proofString":"eapply mmatch_nonstack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCinvalid) : vmatch v (vnormalize chunk (Ifptr (am_top am))).","conclusion":"vmatch v (vnormalize chunk (Ifptr (am_top am)))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCinvalid)","proofString":"eapply vnormalize_cast; eauto.\neapply mmatch_top; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCinvalid) : vmatch v (Ifptr (am_top am)).","conclusion":"vmatch v (Ifptr (am_top am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (rm : romem) (am : amem) (H : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H3 : bc b <> BCinvalid)","proofString":"eapply mmatch_top; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (addr v : val) (rm : romem) (am : amem) (aaddr : aval) (H : Mem.loadv chunk m addr = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : vmatch addr aaddr) : vmatch v (loadv chunk rm am aaddr).","conclusion":"vmatch v (loadv chunk rm am aaddr)","hypotheses":"(chunk : memory_chunk) (m : mem) (addr v : val) (rm : romem) (am : amem) (aaddr : aval) (H : Mem.loadv chunk m addr = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : vmatch addr aaddr)","proofString":"destruct addr; simpl in H; try discriminate.\neapply load_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (rm : romem) (am : amem) (aaddr : aval) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : vmatch (Vptr b i) aaddr) : vmatch v (loadv chunk rm am aaddr).","conclusion":"vmatch v (loadv chunk rm am aaddr)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (rm : romem) (am : amem) (aaddr : aval) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : vmatch (Vptr b i) aaddr)","proofString":"eapply load_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (rm : romem) (am : amem) (aaddr : aval) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : vmatch (Vptr b i) aaddr) : pmatch b i (aptr_of_aval aaddr).","conclusion":"pmatch b i (aptr_of_aval aaddr)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (rm : romem) (am : amem) (aaddr : aval) (H : Mem.load chunk m b (Ptrofs.unsigned i) = Some v) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : vmatch (Vptr b i) aaddr)","proofString":"apply match_aptr_of_aval; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) : mmatch m' (store chunk am p av).","conclusion":"mmatch m' (store chunk am p av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av)","proofString":"unfold store; constructor; simpl; intros.\nassert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).\nintros.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence.\ninv PM; try (apply DFL; congruence).\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_sound; eauto.\neapply mmatch_stack; eauto.\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\nrename b0 into b'.\nassert (DFL: bc b <> BCglob id -> (am_glob am)!id = Some ab ->               bmatch m' b' ab).\nintros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence.\ninv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence.\nassert (DFL: smatch m' b0 (vplub av (am_nonstack am))).\neapply smatch_store; eauto.\neapply mmatch_nonstack; eauto.\nassert (STK: bc b = BCstack -> smatch m' b0 (am_nonstack am)).\nintros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence.\ninv PM; (apply DFL || apply STK; congruence).\neapply smatch_store; eauto.\neapply mmatch_top; eauto.\nerewrite Mem.nextblock_store by eauto.\neapply mmatch_below; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) : bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs0) av\n  | Stack | Ptop => ablock_store_anywhere chunk (am_stack am) av\n  | _ => am_stack am\n  end.","conclusion":"bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs0) av\n  | Stack | Ptop => ablock_store_anywhere chunk (am_stack am) av\n  | _ => am_stack am\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack)","proofString":"assert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).\nintros.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence.\ninv PM; try (apply DFL; congruence).\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_sound; eauto.\neapply mmatch_stack; eauto.\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) : bc b <> BCstack -> bmatch m' b0 (am_stack am).","conclusion":"bc b <> BCstack -> bmatch m' b0 (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack)","proofString":"intros.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) : bmatch m' b0 (am_stack am).","conclusion":"bmatch m' b0 (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack)","proofString":"apply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) : bmatch m b0 (am_stack am).","conclusion":"bmatch m b0 (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack)","proofString":"intros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0)","proofString":"eapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0) : b0 <> b \\/\nn <= 0 \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= ofs0.","conclusion":"b0 <> b \\/\nn <= 0 \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= ofs0","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0)","proofString":"left; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) : bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs0) av\n  | Stack | Ptop => ablock_store_anywhere chunk (am_stack am) av\n  | _ => am_stack am\n  end.","conclusion":"bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs0) av\n  | Stack | Ptop => ablock_store_anywhere chunk (am_stack am) av\n  | _ => am_stack am\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am))","proofString":"inv PM; try (apply DFL; congruence).\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_sound; eauto.\neapply mmatch_stack; eauto.\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) : bmatch m' b0 (ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs) av).","conclusion":"bmatch m' b0 (ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack)","proofString":"assert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b) : bmatch m' b0 (ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs) av).","conclusion":"bmatch m' b0 (ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b)","proofString":"subst b0.\neapply ablock_store_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m' b (ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs) av).","conclusion":"bmatch m' b (ablock_store chunk (am_stack am) (Ptrofs.unsigned ofs) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply ablock_store_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) : bmatch m' b0 (ablock_store_anywhere chunk (am_stack am) av).","conclusion":"bmatch m' b0 (ablock_store_anywhere chunk (am_stack am) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack)","proofString":"assert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b) : bmatch m' b0 (ablock_store_anywhere chunk (am_stack am) av).","conclusion":"bmatch m' b0 (ablock_store_anywhere chunk (am_stack am) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b)","proofString":"subst b0.\neapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m' b (ablock_store_anywhere chunk (am_stack am) av).","conclusion":"bmatch m' b (ablock_store_anywhere chunk (am_stack am) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid) : bmatch m' b0 (ablock_store_anywhere chunk (am_stack am) av).","conclusion":"bmatch m' b0 (ablock_store_anywhere chunk (am_stack am) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid)","proofString":"eapply ablock_store_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid) : bmatch m b0 (am_stack am).","conclusion":"bmatch m b0 (am_stack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b0 : block) (H : bc b0 = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) : bmatch m' b0 ab.","conclusion":"bmatch m' b0 ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b0 : block) (H : bc b0 = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab)","proofString":"rename b0 into b'.\nassert (DFL: bc b <> BCglob id -> (am_glob am)!id = Some ab ->               bmatch m' b' ab).\nintros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence.\ninv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab)","proofString":"assert (DFL: bc b <> BCglob id -> (am_glob am)!id = Some ab ->               bmatch m' b' ab).\nintros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence.\ninv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab.","conclusion":"bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab)","proofString":"intros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"apply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) : bmatch m b' ab.","conclusion":"bmatch m b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"intros.\neapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs1) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0) : Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n.","conclusion":"Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs1) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0)","proofString":"eapply Mem.loadbytes_store_other; eauto.\nleft; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs1) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0) : b' <> b \\/\nn <= 0 \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= ofs0.","conclusion":"b' <> b \\/\nn <= 0 \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= ofs0","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs1) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0)","proofString":"left; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_store chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end (Ptrofs.unsigned ofs0) av) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_store_anywhere chunk\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end av) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab)","proofString":"inv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_store chunk\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end (Ptrofs.unsigned ofs) av) (am_glob am)) ! id = \nSome ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_store chunk\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end (Ptrofs.unsigned ofs) av) (am_glob am)) ! id = \nSome ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_store chunk\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end (Ptrofs.unsigned ofs) av)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_store chunk\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end (Ptrofs.unsigned ofs) av)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_store chunk\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_store chunk\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"subst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H1 : bc b = BCglob id) : bmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av).","conclusion":"bmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H1 : bc b = BCglob id)","proofString":"assert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H1 : bc b = BCglob id) (H0 : b' = b) : bmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av).","conclusion":"bmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b'\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H1 : bc b = BCglob id) (H0 : b' = b)","proofString":"subst b'.\neapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id) : bmatch m' b\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av).","conclusion":"bmatch m' b\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id)","proofString":"eapply ablock_store_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id) : bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end.","conclusion":"bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id)","proofString":"destruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_store chunk ab0 (Ptrofs.unsigned ofs) av) ->\nbmatch m' b (ablock_store chunk ab0 (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id) : bmatch m b ab0.","conclusion":"bmatch m b ab0","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_store chunk ab0 (Ptrofs.unsigned ofs) av) ->\nbmatch m' b (ablock_store chunk ab0 (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id) : bmatch m b (ablock_init (am_nonstack am)).","conclusion":"bmatch m b (ablock_init (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id)","proofString":"apply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av) ->\nbmatch m' b\n  (ablock_store chunk (ablock_init (am_nonstack am)) (Ptrofs.unsigned ofs) av)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_store_anywhere chunk\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end av) (am_glob am)) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_store_anywhere chunk\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end av) (am_glob am)) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_store_anywhere chunk\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end av)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_store_anywhere chunk\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end av)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end av) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end av) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"subst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H1 : bc b = BCglob id) : bmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av).","conclusion":"bmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H1 : bc b = BCglob id)","proofString":"assert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H1 : bc b = BCglob id) (H0 : b' = b) : bmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av).","conclusion":"bmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b'\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H1 : bc b = BCglob id) (H0 : b' = b)","proofString":"subst b'.\neapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H H1 : bc b = BCglob id) : bmatch m' b\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av).","conclusion":"bmatch m' b\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H H1 : bc b = BCglob id)","proofString":"eapply ablock_store_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H H1 : bc b = BCglob id) : bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end.","conclusion":"bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av) ->\nbmatch m' b\n  (ablock_store_anywhere chunk\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end av)) (H H1 : bc b = BCglob id)","proofString":"destruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_store_anywhere chunk ab0 av) ->\nbmatch m' b (ablock_store_anywhere chunk ab0 av)) (H H1 : bc b = BCglob id) : bmatch m b ab0.","conclusion":"bmatch m b ab0","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_store_anywhere chunk ab0 av) ->\nbmatch m' b (ablock_store_anywhere chunk ab0 av)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av) ->\nbmatch m' b (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av)) (H H1 : bc b = BCglob id) : bmatch m b (ablock_init (am_nonstack am)).","conclusion":"bmatch m b (ablock_init (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av) ->\nbmatch m' b (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av)) (H H1 : bc b = BCglob id)","proofString":"apply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av) ->\nbmatch m' b (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av)) (H H1 : bc b = BCglob id) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av) ->\nbmatch m' b (ablock_store_anywhere chunk (ablock_init (am_nonstack am)) av)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (id0 : ident) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (id0 : ident) (H1 : bc b = BCglob id0)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCstack) (H2 : bc b <> BCinvalid) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCstack) (H2 : bc b <> BCinvalid)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCinvalid) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (VM : vmatch v av) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCinvalid)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) : smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => vplub av (am_nonstack am)\n  end.","conclusion":"smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => vplub av (am_nonstack am)\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid)","proofString":"assert (DFL: smatch m' b0 (vplub av (am_nonstack am))).\neapply smatch_store; eauto.\neapply mmatch_nonstack; eauto.\nassert (STK: bc b = BCstack -> smatch m' b0 (am_nonstack am)).\nintros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence.\ninv PM; (apply DFL || apply STK; congruence)."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) : smatch m' b0 (vplub av (am_nonstack am)).","conclusion":"smatch m' b0 (vplub av (am_nonstack am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid)","proofString":"eapply smatch_store; eauto.\neapply mmatch_nonstack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) : smatch m b0 (am_nonstack am).","conclusion":"smatch m b0 (am_nonstack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid)","proofString":"eapply mmatch_nonstack; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) : smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => vplub av (am_nonstack am)\n  end.","conclusion":"smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => vplub av (am_nonstack am)\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am)))","proofString":"assert (STK: bc b = BCstack -> smatch m' b0 (am_nonstack am)).\nintros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence.\ninv PM; (apply DFL || apply STK; congruence)."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) : bc b = BCstack -> smatch m' b0 (am_nonstack am).","conclusion":"bc b = BCstack -> smatch m' b0 (am_nonstack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am)))","proofString":"intros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) : smatch m' b0 (am_nonstack am).","conclusion":"smatch m' b0 (am_nonstack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack)","proofString":"apply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) : smatch m b0 (am_nonstack am).","conclusion":"smatch m b0 (am_nonstack am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack)","proofString":"intros.\neapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0)","proofString":"eapply Mem.loadbytes_store_other; eauto.\nleft.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0) : b0 <> b \\/\nn <= 0 \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= ofs0.","conclusion":"b0 <> b \\/\nn <= 0 \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + size_chunk chunk <= ofs0","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0)","proofString":"left.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0) : b0 <> b.","conclusion":"b0 <> b","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (STK : bc b = BCstack -> smatch m' b0 (am_nonstack am)) : smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => vplub av (am_nonstack am)\n  end.","conclusion":"smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => vplub av (am_nonstack am)\n  end","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (vplub av (am_nonstack am))) (STK : bc b = BCstack -> smatch m' b0 (am_nonstack am))","proofString":"inv PM; (apply DFL || apply STK; congruence)."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCinvalid) : smatch m' b0 (vplub av (am_top am)).","conclusion":"smatch m' b0 (vplub av (am_top am))","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCinvalid)","proofString":"eapply smatch_store; eauto.\neapply mmatch_top; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCinvalid) : smatch m b0 (am_top am).","conclusion":"smatch m b0 (am_top am)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) (b0 : block) (H : bc b0 <> BCinvalid)","proofString":"eapply mmatch_top; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) : bc_below bc (Mem.nextblock m').","conclusion":"bc_below bc (Mem.nextblock m')","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av)","proofString":"erewrite Mem.nextblock_store by eauto.\neapply mmatch_below; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (am : amem) (p : aptr) (av : aval) (STORE : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (VM : vmatch v av)","proofString":"eapply mmatch_below; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (addr v : val) (m' : mem) (am : amem) (aaddr av : aval) (H : Mem.storev chunk m addr v = Some m') (H0 : mmatch m am) (H1 : vmatch addr aaddr) (H2 : vmatch v av) : mmatch m' (storev chunk am aaddr av).","conclusion":"mmatch m' (storev chunk am aaddr av)","hypotheses":"(chunk : memory_chunk) (m : mem) (addr v : val) (m' : mem) (am : amem) (aaddr av : aval) (H : Mem.storev chunk m addr v = Some m') (H0 : mmatch m am) (H1 : vmatch addr aaddr) (H2 : vmatch v av)","proofString":"destruct addr; simpl in H; try discriminate.\neapply store_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (am : amem) (aaddr av : aval) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : mmatch m am) (H1 : vmatch (Vptr b i) aaddr) (H2 : vmatch v av) : mmatch m' (storev chunk am aaddr av).","conclusion":"mmatch m' (storev chunk am aaddr av)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (am : amem) (aaddr av : aval) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : mmatch m am) (H1 : vmatch (Vptr b i) aaddr) (H2 : vmatch v av)","proofString":"eapply store_sound; eauto.\napply match_aptr_of_aval; auto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (am : amem) (aaddr av : aval) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : mmatch m am) (H1 : vmatch (Vptr b i) aaddr) (H2 : vmatch v av) : pmatch b i (aptr_of_aval aaddr).","conclusion":"pmatch b i (aptr_of_aval aaddr)","hypotheses":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (am : amem) (aaddr av : aval) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') (H0 : mmatch m am) (H1 : vmatch (Vptr b i) aaddr) (H2 : vmatch v av)","proofString":"apply match_aptr_of_aval; auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (p : aptr) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : pmatch b ofs p) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) : pmatch b' ofs' (loadbytes am rm p).","conclusion":"pmatch b' ofs' (loadbytes am rm p)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (p : aptr) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (H2 : pmatch b ofs p) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes)","proofString":"unfold loadbytes; inv H2.\ndestruct (rm!id) as [ab|] eqn:RM.\nexploit H0; eauto.\nintros (A & B & C).\neapply ablock_loadbytes_sound; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:GL.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va.\ndestruct (rm!id) as [ab|] eqn:RM.\nexploit H0; eauto.\nintros (A & B & C).\neapply ablock_loadbytes_sound; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:GL.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_stack; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va.\neapply smatch_loadbytes; eauto.\neapply mmatch_top; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) : pmatch b' ofs'\n  match rm ! id with\n  | Some ab => ablock_loadbytes ab\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_loadbytes ab\n      | None => am_nonstack am\n      end\n  end.","conclusion":"pmatch b' ofs'\n  match rm ! id with\n  | Some ab => ablock_loadbytes ab\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_loadbytes ab\n      | None => am_nonstack am\n      end\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id)","proofString":"destruct (rm!id) as [ab|] eqn:RM.\nexploit H0; eauto.\nintros (A & B & C).\neapply ablock_loadbytes_sound; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:GL.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"exploit H0; eauto.\nintros (A & B & C).\neapply ablock_loadbytes_sound; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m b ab /\\ (forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) ->\npmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m b ab /\\ (forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) ->\npmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"intros (A & B & C).\neapply ablock_loadbytes_sound; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable)","proofString":"eapply ablock_loadbytes_sound; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) : pmatch b' ofs'\n  match (am_glob am) ! id with\n  | Some ab => ablock_loadbytes ab\n  | None => am_nonstack am\n  end.","conclusion":"pmatch b' ofs'\n  match (am_glob am) ! id with\n  | Some ab => ablock_loadbytes ab\n  | None => am_nonstack am\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None)","proofString":"destruct (am_glob am)!id as [ab|] eqn:GL.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab)","proofString":"eapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None) : pmatch b' ofs' (am_nonstack am).","conclusion":"pmatch b' ofs' (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None)","proofString":"eapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None)","proofString":"eapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) : pmatch b' ofs'\n  match rm ! id with\n  | Some ab => ablock_loadbytes ab\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_loadbytes ab\n      | None => am_nonstack am\n      end\n  end.","conclusion":"pmatch b' ofs'\n  match rm ! id with\n  | Some ab => ablock_loadbytes ab\n  | None =>\n      match (am_glob am) ! id with\n      | Some ab => ablock_loadbytes ab\n      | None => am_nonstack am\n      end\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id)","proofString":"destruct (rm!id) as [ab|] eqn:RM.\nexploit H0; eauto.\nintros (A & B & C).\neapply ablock_loadbytes_sound; eauto.\ndestruct (am_glob am)!id as [ab|] eqn:GL.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"exploit H0; eauto.\nintros (A & B & C).\neapply ablock_loadbytes_sound; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch m b ab /\\ (forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) ->\npmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch m b ab /\\ (forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) ->\npmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab)","proofString":"intros (A & B & C).\neapply ablock_loadbytes_sound; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (ab : ablock) (RM : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable)","proofString":"eapply ablock_loadbytes_sound; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) : pmatch b' ofs'\n  match (am_glob am) ! id with\n  | Some ab => ablock_loadbytes ab\n  | None => am_nonstack am\n  end.","conclusion":"pmatch b' ofs'\n  match (am_glob am) ! id with\n  | Some ab => ablock_loadbytes ab\n  | None => am_nonstack am\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None)","proofString":"destruct (am_glob am)!id as [ab|] eqn:GL.\neapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto.\neapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab) : pmatch b' ofs' (ablock_loadbytes ab).","conclusion":"pmatch b' ofs' (ablock_loadbytes ab)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab)","proofString":"eapply ablock_loadbytes_sound; eauto.\neapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (ab : ablock) (GL : (am_glob am) ! id = Some ab)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None) : pmatch b' ofs' (am_nonstack am).","conclusion":"pmatch b' ofs' (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None)","proofString":"eapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) (RM : rm ! id = None) (GL : (am_glob am) ! id = None)","proofString":"eapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) : pmatch b' ofs' (am_nonstack am).","conclusion":"pmatch b' ofs' (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id)","proofString":"eapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (id : ident) (H4 : bc b = BCglob id)","proofString":"eapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack) : pmatch b' ofs' (ablock_loadbytes (am_stack am)).","conclusion":"pmatch b' ofs' (ablock_loadbytes (am_stack am))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack)","proofString":"eapply ablock_loadbytes_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack) : pmatch b' ofs' (ablock_loadbytes (am_stack am)).","conclusion":"pmatch b' ofs' (ablock_loadbytes (am_stack am))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack)","proofString":"eapply ablock_loadbytes_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCstack) (H5 : bc b <> BCinvalid) : pmatch b' ofs' (am_nonstack am).","conclusion":"pmatch b' ofs' (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCstack) (H5 : bc b <> BCinvalid)","proofString":"eapply smatch_loadbytes; eauto.\neapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCstack) (H5 : bc b <> BCinvalid) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCstack) (H5 : bc b <> BCinvalid)","proofString":"eapply mmatch_nonstack; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCinvalid) : pmatch b' ofs' (am_top am).","conclusion":"pmatch b' ofs' (am_top am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCinvalid)","proofString":"eapply smatch_loadbytes; eauto.\neapply mmatch_top; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCinvalid) : smatch m b (am_top am).","conclusion":"smatch m b (am_top am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : Z) (bytes : list memval) (am : amem) (rm : romem) (H : Mem.loadbytes m b (Ptrofs.unsigned ofs) sz = Some bytes) (H0 : romatch m rm) (H1 : mmatch m am) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : In (Fragment (Vptr b' ofs') q i) bytes) (H4 : bc b <> BCinvalid)","proofString":"eapply mmatch_top; eauto with va."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) : mmatch m' (storebytes am p sz q).","conclusion":"mmatch m' (storebytes am p sz q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q)","proofString":"unfold storebytes; constructor; simpl; intros.\nassert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).\nintros.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence.\ninv PM; try (apply DFL; congruence).\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_sound; eauto.\neapply mmatch_stack; eauto.\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\nrename b0 into b'.\nassert (DFL: bc b <> BCglob id -> (am_glob am)!id = Some ab ->               bmatch m' b' ab).\nintros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence.\ninv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence.\nassert (DFL: smatch m' b0 (plub q (am_nonstack am))).\neapply smatch_storebytes; eauto.\neapply mmatch_nonstack; eauto.\nassert (STK: bc b = BCstack -> smatch m' b0 (am_nonstack am)).\nintros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence.\ninv PM; (apply DFL || apply STK; congruence).\neapply smatch_storebytes; eauto.\neapply mmatch_top; eauto.\nerewrite Mem.nextblock_storebytes by eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) : bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs0) sz\n  | Stack | Ptop => ablock_storebytes_anywhere (am_stack am) q\n  | _ => am_stack am\n  end.","conclusion":"bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs0) sz\n  | Stack | Ptop => ablock_storebytes_anywhere (am_stack am) q\n  | _ => am_stack am\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack)","proofString":"assert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).\nintros.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence.\ninv PM; try (apply DFL; congruence).\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_sound; eauto.\neapply mmatch_stack; eauto.\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) : bc b <> BCstack -> bmatch m' b0 (am_stack am).","conclusion":"bc b <> BCstack -> bmatch m' b0 (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack)","proofString":"intros.\napply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) : bmatch m' b0 (am_stack am).","conclusion":"bmatch m' b0 (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack)","proofString":"apply bmatch_inv with m.\neapply mmatch_stack; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) : bmatch m b0 (am_stack am).","conclusion":"bmatch m b0 (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack)","proofString":"intros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0)","proofString":"eapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0) : b0 <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0.","conclusion":"b0 <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (H0 : bc b <> BCstack) (ofs0 n : Z) (H1 : n >= 0)","proofString":"left; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) : bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs0) sz\n  | Stack | Ptop => ablock_storebytes_anywhere (am_stack am) q\n  | _ => am_stack am\n  end.","conclusion":"bmatch m' b0\n  match p with\n  | Stk ofs0 => ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs0) sz\n  | Stack | Ptop => ablock_storebytes_anywhere (am_stack am) q\n  | _ => am_stack am\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am))","proofString":"inv PM; try (apply DFL; congruence).\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_sound; eauto.\neapply mmatch_stack; eauto.\nassert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) : bmatch m' b0 (ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs) sz).","conclusion":"bmatch m' b0 (ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs) sz)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack)","proofString":"assert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b) : bmatch m' b0 (ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs) sz).","conclusion":"bmatch m' b0 (ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs) sz)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b)","proofString":"subst b0.\neapply ablock_storebytes_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m' b (ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs) sz).","conclusion":"bmatch m' b (ablock_storebytes (am_stack am) q (Ptrofs.unsigned ofs) sz)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply ablock_storebytes_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) : bmatch m' b0 (ablock_storebytes_anywhere (am_stack am) q).","conclusion":"bmatch m' b0 (ablock_storebytes_anywhere (am_stack am) q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack)","proofString":"assert (b0 = b) by (eapply bc_stack; eauto).\nsubst b0.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b) : bmatch m' b0 (ablock_storebytes_anywhere (am_stack am) q).","conclusion":"bmatch m' b0 (ablock_storebytes_anywhere (am_stack am) q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b = BCstack) (H1 : b0 = b)","proofString":"subst b0.\neapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m' b (ablock_storebytes_anywhere (am_stack am) q).","conclusion":"bmatch m' b (ablock_storebytes_anywhere (am_stack am) q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack) : bmatch m b (am_stack am).","conclusion":"bmatch m b (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (DFL : bc b <> BCstack -> bmatch m' b (am_stack am)) (H H0 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid) : bmatch m' b0 (ablock_storebytes_anywhere (am_stack am) q).","conclusion":"bmatch m' b0 (ablock_storebytes_anywhere (am_stack am) q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid)","proofString":"eapply ablock_storebytes_anywhere_sound; eauto.\neapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid) : bmatch m b0 (am_stack am).","conclusion":"bmatch m b0 (am_stack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 = BCstack) (DFL : bc b <> BCstack -> bmatch m' b0 (am_stack am)) (H0 : bc b <> BCinvalid)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (ab : ablock) (b0 : block) (H : bc b0 = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) : bmatch m' b0 ab.","conclusion":"bmatch m' b0 ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (ab : ablock) (b0 : block) (H : bc b0 = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab)","proofString":"rename b0 into b'.\nassert (DFL: bc b <> BCglob id -> (am_glob am)!id = Some ab ->               bmatch m' b' ab).\nintros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence.\ninv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab)","proofString":"assert (DFL: bc b <> BCglob id -> (am_glob am)!id = Some ab ->               bmatch m' b' ab).\nintros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence.\ninv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab.","conclusion":"bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab)","proofString":"intros.\napply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"apply bmatch_inv with m.\neapply mmatch_glob; eauto.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) : bmatch m b' ab.","conclusion":"bmatch m b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"intros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs1) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0) : Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n.","conclusion":"Mem.loadbytes m' b' ofs0 n = Mem.loadbytes m b' ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs1) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0)","proofString":"eapply Mem.loadbytes_storebytes_other; eauto.\nleft; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs1) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0) : b' <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0.","conclusion":"b' <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs1 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs1) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (H1 : bc b <> BCglob id) (H2 : (am_glob am) ! id = Some ab) (ofs0 n : Z) (H3 : n >= 0)","proofString":"left; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : match p with\n| Gl id0 ofs0 =>\n    PTree.set id0\n      (ablock_storebytes\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q (Ptrofs.unsigned ofs0) sz) (am_glob am)\n| Glo id0 =>\n    PTree.set id0\n      (ablock_storebytes_anywhere\n         match (am_glob am) ! id0 with\n         | Some ab0 => ab0\n         | None => ablock_init (am_nonstack am)\n         end q) (am_glob am)\n| Pbot | Stk _ | Stack => am_glob am\n| _ => PTree.empty ablock\nend ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab)","proofString":"inv PM.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\neapply DFL; eauto.\ncongruence.\neapply DFL; eauto.\ncongruence.\nrewrite PTree.gempty in H0; congruence.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_storebytes\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end q (Ptrofs.unsigned ofs) sz) (am_glob am)) ! id = \nSome ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_storebytes\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end q (Ptrofs.unsigned ofs) sz) (am_glob am)) ! id = \nSome ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_storebytes\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end q (Ptrofs.unsigned ofs) sz)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_storebytes\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end q (Ptrofs.unsigned ofs) sz)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_storebytes\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_storebytes\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"subst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H1 : bc b = BCglob id) : bmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz).","conclusion":"bmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H1 : bc b = BCglob id)","proofString":"assert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H1 : bc b = BCglob id) (H0 : b' = b) : bmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz).","conclusion":"bmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b'\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H1 : bc b = BCglob id) (H0 : b' = b)","proofString":"subst b'.\neapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id) : bmatch m' b\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz).","conclusion":"bmatch m' b\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id)","proofString":"eapply ablock_storebytes_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id) : bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end.","conclusion":"bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id)","proofString":"destruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_storebytes ab0 q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b (ablock_storebytes ab0 q (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id) : bmatch m b ab0.","conclusion":"bmatch m b ab0","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_storebytes ab0 q (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b (ablock_storebytes ab0 q (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id) : bmatch m b (ablock_init (am_nonstack am)).","conclusion":"bmatch m b (ablock_init (am_nonstack am))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id)","proofString":"apply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone =\nSome\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz) ->\nbmatch m' b\n  (ablock_storebytes (ablock_init (am_nonstack am)) q \n     (Ptrofs.unsigned ofs) sz)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_storebytes_anywhere\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end q) (am_glob am)) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (PTree.set id0\n   (ablock_storebytes_anywhere\n      match (am_glob am) ! id0 with\n      | Some ab0 => ab0\n      | None => ablock_init (am_nonstack am)\n      end q) (am_glob am)) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_storebytes_anywhere\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end q)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (H0 : (if peq id id0\n then\n  Some\n    (ablock_storebytes_anywhere\n       match (am_glob am) ! id0 with\n       | Some ab0 => ab0\n       | None => ablock_init (am_nonstack am)\n       end q)\n else (am_glob am) ! id) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence.\neapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end q) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (e : id = id0) (H0 : Some\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id0 with\n     | Some ab0 => ab0\n     | None => ablock_init (am_nonstack am)\n     end q) = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"subst id0; inv H0.\nassert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H1 : bc b = BCglob id) : bmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q).","conclusion":"bmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H1 : bc b = BCglob id)","proofString":"assert (b' = b) by (eapply bc_glob; eauto).\nsubst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H1 : bc b = BCglob id) (H0 : b' = b) : bmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q).","conclusion":"bmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (b' : block) (H : bc b' = BCglob id) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b'\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H1 : bc b = BCglob id) (H0 : b' = b)","proofString":"subst b'.\neapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H H1 : bc b = BCglob id) : bmatch m' b\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q).","conclusion":"bmatch m' b\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H H1 : bc b = BCglob id)","proofString":"eapply ablock_storebytes_anywhere_sound; eauto.\ndestruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H H1 : bc b = BCglob id) : bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end.","conclusion":"bmatch m b\n  match (am_glob am) ! id with\n  | Some ab => ab\n  | None => ablock_init (am_nonstack am)\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (DFL : bc b <> BCglob id ->\n(am_glob am) ! id =\nSome\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q) ->\nbmatch m' b\n  (ablock_storebytes_anywhere\n     match (am_glob am) ! id with\n     | Some ab => ab\n     | None => ablock_init (am_nonstack am)\n     end q)) (H H1 : bc b = BCglob id)","proofString":"destruct (am_glob am)!id as [ab0|] eqn:GL.\neapply mmatch_glob; eauto.\napply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_storebytes_anywhere ab0 q) ->\nbmatch m' b (ablock_storebytes_anywhere ab0 q)) (H H1 : bc b = BCglob id) : bmatch m b ab0.","conclusion":"bmatch m b ab0","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (ab0 : ablock) (GL : (am_glob am) ! id = Some ab0) (DFL : bc b <> BCglob id ->\nSome ab0 = Some (ablock_storebytes_anywhere ab0 q) ->\nbmatch m' b (ablock_storebytes_anywhere ab0 q)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_glob; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q) ->\nbmatch m' b (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q)) (H H1 : bc b = BCglob id) : bmatch m b (ablock_init (am_nonstack am)).","conclusion":"bmatch m b (ablock_init (am_nonstack am))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q) ->\nbmatch m' b (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q)) (H H1 : bc b = BCglob id)","proofString":"apply ablock_init_sound.\neapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q) ->\nbmatch m' b (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q)) (H H1 : bc b = BCglob id) : smatch m b (am_nonstack am).","conclusion":"smatch m b (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (id : ident) (GL : (am_glob am) ! id = None) (DFL : bc b <> BCglob id ->\nNone = Some (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q) ->\nbmatch m' b (ablock_storebytes_anywhere (ablock_init (am_nonstack am)) q)) (H H1 : bc b = BCglob id)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (id0 : ident) (n : id <> id0) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCglob id0)","proofString":"congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (id0 : ident) (H1 : bc b = BCglob id0) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (id0 : ident) (H1 : bc b = BCglob id0)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"eapply DFL; eauto.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack) : bc b <> BCglob id.","conclusion":"bc b <> BCglob id","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (am_glob am) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b = BCstack)","proofString":"congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCstack) (H2 : bc b <> BCinvalid) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCstack) (H2 : bc b <> BCinvalid)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCinvalid) : bmatch m' b' ab.","conclusion":"bmatch m' b' ab","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b'0 : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b'0 ofs') qt i) bytes -> pmatch b'0 ofs' q) (id : ident) (ab : ablock) (b' : block) (H : bc b' = BCglob id) (H0 : (PTree.empty ablock) ! id = Some ab) (DFL : bc b <> BCglob id -> (am_glob am) ! id = Some ab -> bmatch m' b' ab) (H1 : bc b <> BCinvalid)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) : smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => plub q (am_nonstack am)\n  end.","conclusion":"smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => plub q (am_nonstack am)\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid)","proofString":"assert (DFL: smatch m' b0 (plub q (am_nonstack am))).\neapply smatch_storebytes; eauto.\neapply mmatch_nonstack; eauto.\nassert (STK: bc b = BCstack -> smatch m' b0 (am_nonstack am)).\nintros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence.\ninv PM; (apply DFL || apply STK; congruence)."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) : smatch m' b0 (plub q (am_nonstack am)).","conclusion":"smatch m' b0 (plub q (am_nonstack am))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid)","proofString":"eapply smatch_storebytes; eauto.\neapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) : smatch m b0 (am_nonstack am).","conclusion":"smatch m b0 (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid)","proofString":"eapply mmatch_nonstack; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) : smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => plub q (am_nonstack am)\n  end.","conclusion":"smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => plub q (am_nonstack am)\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am)))","proofString":"assert (STK: bc b = BCstack -> smatch m' b0 (am_nonstack am)).\nintros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence.\ninv PM; (apply DFL || apply STK; congruence)."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) : bc b = BCstack -> smatch m' b0 (am_nonstack am).","conclusion":"bc b = BCstack -> smatch m' b0 (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am)))","proofString":"intros.\napply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) : smatch m' b0 (am_nonstack am).","conclusion":"smatch m' b0 (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack)","proofString":"apply smatch_inv with m.\neapply mmatch_nonstack; eauto; congruence.\nintros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) : smatch m b0 (am_nonstack am).","conclusion":"smatch m b0 (am_nonstack am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack)","proofString":"eapply mmatch_nonstack; eauto; congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) : forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"forall ofs0 n : Z,\nn >= 0 -> Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack)","proofString":"intros.\neapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0) : Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n.","conclusion":"Mem.loadbytes m' b0 ofs0 n = Mem.loadbytes m b0 ofs0 n","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0)","proofString":"eapply Mem.loadbytes_storebytes_other; eauto.\nleft.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0) : b0 <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0.","conclusion":"b0 <> b \\/\nofs0 + n <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + Z.of_nat (Datatypes.length bytes) <= ofs0","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0)","proofString":"left.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0) : b0 <> b.","conclusion":"b0 <> b","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (H1 : bc b = BCstack) (ofs0 n : Z) (H2 : n >= 0)","proofString":"congruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (STK : bc b = BCstack -> smatch m' b0 (am_nonstack am)) : smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => plub q (am_nonstack am)\n  end.","conclusion":"smatch m' b0\n  match p with\n  | Pbot | Stk _ | Stack => am_nonstack am\n  | _ => plub q (am_nonstack am)\n  end","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCstack) (H0 : bc b0 <> BCinvalid) (DFL : smatch m' b0 (plub q (am_nonstack am))) (STK : bc b = BCstack -> smatch m' b0 (am_nonstack am))","proofString":"inv PM; (apply DFL || apply STK; congruence)."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCinvalid) : smatch m' b0 (plub q (am_top am)).","conclusion":"smatch m' b0 (plub q (am_top am))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCinvalid)","proofString":"eapply smatch_storebytes; eauto.\neapply mmatch_top; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCinvalid) : smatch m b0 (am_top am).","conclusion":"smatch m b0 (am_top am)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) (b0 : block) (H : bc b0 <> BCinvalid)","proofString":"eapply mmatch_top; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) : bc_below bc (Mem.nextblock m').","conclusion":"bc_below bc (Mem.nextblock m')","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q)","proofString":"erewrite Mem.nextblock_storebytes by eauto.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bytes : list memval) (m' : mem) (am : amem) (p : aptr) (sz : Z) (q : aptr) (STORE : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') (MM : mmatch m am) (PM : pmatch b ofs p) (LENGTH : Datatypes.length bytes = Z.to_nat sz) (BYTES : forall (b' : block) (ofs' : ptrofs) (qt : quantity) (i : nat),\nIn (Fragment (Vptr b' ofs') qt i) bytes -> pmatch b' ofs' q)","proofString":"eapply mmatch_below; eauto."},{"statement":"(m : mem) (am : amem) (m' : mem) (H : mmatch m am) (H0 : forall (b : block) (ofs n : Z) (bytes : list memval),\nbc b <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) : mmatch m' am.","conclusion":"mmatch m' am","hypotheses":"(m : mem) (am : amem) (m' : mem) (H : mmatch m am) (H0 : forall (b : block) (ofs n : Z) (bytes : list memval),\nbc b <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m'))","proofString":"inv H.\nconstructor; intros.\napply bmatch_ext with m; auto with va.\napply bmatch_ext with m; eauto with va.\napply smatch_ext with m; auto with va.\napply smatch_ext with m; auto with va.\nred; intros.\nexploit mmatch_below0; eauto.\nextlia."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b : block) (ofs n : Z) (bytes : list memval),\nbc b <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack am)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : mmatch m' am.","conclusion":"mmatch m' am","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b : block) (ofs n : Z) (bytes : list memval),\nbc b <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack am)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"constructor; intros.\napply bmatch_ext with m; auto with va.\napply bmatch_ext with m; eauto with va.\napply smatch_ext with m; auto with va.\napply smatch_ext with m; auto with va.\nred; intros.\nexploit mmatch_below0; eauto.\nextlia."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack) : bmatch m' b (am_stack am).","conclusion":"bmatch m' b (am_stack am)","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack)","proofString":"apply bmatch_ext with m; auto with va."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob am) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H2 : (am_glob am) ! id = Some ab) : bmatch m' b ab.","conclusion":"bmatch m' b ab","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob am) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H2 : (am_glob am) ! id = Some ab)","proofString":"apply bmatch_ext with m; eauto with va."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H2 : bc b <> BCinvalid) : smatch m' b (am_nonstack am).","conclusion":"smatch m' b (am_nonstack am)","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H2 : bc b <> BCinvalid)","proofString":"apply smatch_ext with m; auto with va."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid) : smatch m' b (am_top am).","conclusion":"smatch m' b (am_top am)","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid)","proofString":"apply smatch_ext with m; auto with va."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b : block) (ofs n : Z) (bytes : list memval),\nbc b <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack am)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : bc_below bc (Mem.nextblock m').","conclusion":"bc_below bc (Mem.nextblock m')","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b : block) (ofs n : Z) (bytes : list memval),\nbc b <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack am)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"red; intros.\nexploit mmatch_below0; eauto.\nextlia."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m').","conclusion":"Plt b (Mem.nextblock m')","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid)","proofString":"exploit mmatch_below0; eauto.\nextlia."},{"statement":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid) : Plt b (Mem.nextblock m) -> Plt b (Mem.nextblock m').","conclusion":"Plt b (Mem.nextblock m) -> Plt b (Mem.nextblock m')","hypotheses":"(m : mem) (am : amem) (m' : mem) (H0 : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes) (H1 : Ple (Mem.nextblock m) (Mem.nextblock m')) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack am)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob am) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack am)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top am)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid)","proofString":"extlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am) : mmatch m' am.","conclusion":"mmatch m' am","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am)","proofString":"apply mmatch_ext with m; auto.\nintros.\neapply Mem.loadbytes_free_2; eauto.\nerewrite <- Mem.nextblock_free by eauto.\nextlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am) : forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes.","conclusion":"forall (b0 : block) (ofs n : Z) (bytes : list memval),\nbc b0 <> BCinvalid ->\nn >= 0 ->\nMem.loadbytes m' b0 ofs n = Some bytes ->\nMem.loadbytes m b0 ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am)","proofString":"intros.\neapply Mem.loadbytes_free_2; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am) (b0 : block) (ofs n : Z) (bytes : list memval) (H1 : bc b0 <> BCinvalid) (H2 : n >= 0) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes) : Mem.loadbytes m b0 ofs n = Some bytes.","conclusion":"Mem.loadbytes m b0 ofs n = Some bytes","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am) (b0 : block) (ofs n : Z) (bytes : list memval) (H1 : bc b0 <> BCinvalid) (H2 : n >= 0) (H3 : Mem.loadbytes m' b0 ofs n = Some bytes)","proofString":"eapply Mem.loadbytes_free_2; eauto."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am) : Ple (Mem.nextblock m) (Mem.nextblock m').","conclusion":"Ple (Mem.nextblock m) (Mem.nextblock m')","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am)","proofString":"erewrite <- Mem.nextblock_free by eauto.\nextlia."},{"statement":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am) : Ple (Mem.nextblock m') (Mem.nextblock m').","conclusion":"Ple (Mem.nextblock m') (Mem.nextblock m')","hypotheses":"(m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amem) (H : Mem.free m b lo hi = Some m') (H0 : mmatch m am)","proofString":"extlia."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) : mmatch m mtop.","conclusion":"mmatch m mtop","hypotheses":"(m : mem) (am : amem) (H : mmatch m am)","proofString":"constructor; simpl; intros.\napply ablock_init_sound.\napply smatch_ge with (ab_summary (am_stack am)).\neapply mmatch_stack; eauto.\nconstructor.\nrewrite PTree.gempty in H1; discriminate.\neapply smatch_ge.\neapply mmatch_nonstack; eauto.\nconstructor.\neapply smatch_ge.\neapply mmatch_top; eauto.\nconstructor.\neapply mmatch_below; eauto."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack) : bmatch m b (ablock_init Ptop).","conclusion":"bmatch m b (ablock_init Ptop)","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack)","proofString":"apply ablock_init_sound.\napply smatch_ge with (ab_summary (am_stack am)).\neapply mmatch_stack; eauto.\nconstructor."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack) : smatch m b Ptop.","conclusion":"smatch m b Ptop","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack)","proofString":"apply smatch_ge with (ab_summary (am_stack am)).\neapply mmatch_stack; eauto.\nconstructor."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack) : smatch m b (ab_summary (am_stack am)).","conclusion":"smatch m b (ab_summary (am_stack am))","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack)","proofString":"eapply mmatch_stack; eauto."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack) : pge Ptop (ab_summary (am_stack am)).","conclusion":"pge Ptop (ab_summary (am_stack am))","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b = BCstack)","proofString":"constructor."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (id : ident) (ab : ablock) (b : block) (H0 : bc b = BCglob id) (H1 : (PTree.empty ablock) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (id : ident) (ab : ablock) (b : block) (H0 : bc b = BCglob id) (H1 : (PTree.empty ablock) ! id = Some ab)","proofString":"rewrite PTree.gempty in H1; discriminate."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b <> BCstack) (H1 : bc b <> BCinvalid) : smatch m b Ptop.","conclusion":"smatch m b Ptop","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b <> BCstack) (H1 : bc b <> BCinvalid)","proofString":"eapply smatch_ge.\neapply mmatch_nonstack; eauto.\nconstructor."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b <> BCinvalid) : smatch m b Ptop.","conclusion":"smatch m b Ptop","hypotheses":"(m : mem) (am : amem) (H : mmatch m am) (b : block) (H0 : bc b <> BCinvalid)","proofString":"eapply smatch_ge.\neapply mmatch_top; eauto.\nconstructor."},{"statement":"(m : mem) (am : amem) (H : mmatch m am) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(m : mem) (am : amem) (H : mmatch m am)","proofString":"eapply mmatch_below; eauto."},{"statement":"(m1 m2 : amem) (H : eq_aptr (am_top m1) (am_top m2) && eq_aptr (am_nonstack m1) (am_nonstack m2) &&\nbbeq (am_stack m1) (am_stack m2) && PTree.beq bbeq (am_glob m1) (am_glob m2) =\ntrue) (m : mem) : mmatch m m1 <-> mmatch m m2.","conclusion":"mmatch m m1 <-> mmatch m m2","hypotheses":"(m1 m2 : amem) (H : eq_aptr (am_top m1) (am_top m2) && eq_aptr (am_nonstack m1) (am_nonstack m2) &&\nbbeq (am_stack m1) (am_stack m2) && PTree.beq bbeq (am_glob m1) (am_glob m2) =\ntrue) (m : mem)","proofString":"InvBooleans.\nrewrite PTree.beq_correct in H1.\nsplit; intros M; inv M; constructor; intros.\nerewrite <- bbeq_sound; eauto.\nspecialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m1)!id eqn:G; try contradiction.\nerewrite <- bbeq_sound; eauto.\nrewrite <- H; eauto.\nrewrite <- H0; eauto.\nauto.\nerewrite bbeq_sound; eauto.\nspecialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m2)!id eqn:G; try contradiction.\nerewrite bbeq_sound; eauto.\nrewrite H; eauto.\nrewrite H0; eauto.\nauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : PTree.beq bbeq (am_glob m1) (am_glob m2) = true) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) : mmatch m m1 <-> mmatch m m2.","conclusion":"mmatch m m1 <-> mmatch m m2","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : PTree.beq bbeq (am_glob m1) (am_glob m2) = true) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2)","proofString":"rewrite PTree.beq_correct in H1.\nsplit; intros M; inv M; constructor; intros.\nerewrite <- bbeq_sound; eauto.\nspecialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m1)!id eqn:G; try contradiction.\nerewrite <- bbeq_sound; eauto.\nrewrite <- H; eauto.\nrewrite <- H0; eauto.\nauto.\nerewrite bbeq_sound; eauto.\nspecialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m2)!id eqn:G; try contradiction.\nerewrite bbeq_sound; eauto.\nrewrite H; eauto.\nrewrite H0; eauto.\nauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) : mmatch m m1 <-> mmatch m m2.","conclusion":"mmatch m m1 <-> mmatch m m2","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2)","proofString":"split; intros M; inv M; constructor; intros.\nerewrite <- bbeq_sound; eauto.\nspecialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m1)!id eqn:G; try contradiction.\nerewrite <- bbeq_sound; eauto.\nrewrite <- H; eauto.\nrewrite <- H0; eauto.\nauto.\nerewrite bbeq_sound; eauto.\nspecialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m2)!id eqn:G; try contradiction.\nerewrite bbeq_sound; eauto.\nrewrite H; eauto.\nrewrite H0; eauto.\nauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCstack) : bmatch m b (am_stack m2).","conclusion":"bmatch m b (am_stack m2)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCstack)","proofString":"erewrite <- bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab)","proofString":"specialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m1)!id eqn:G; try contradiction.\nerewrite <- bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (id : ident) (H1 : match (am_glob m1) ! id with\n| Some y1 =>\n    match (am_glob m2) ! id with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! id with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (id : ident) (H1 : match (am_glob m1) ! id with\n| Some y1 =>\n    match (am_glob m2) ! id with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! id with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab)","proofString":"rewrite H4 in H1.\ndestruct (am_glob m1)!id eqn:G; try contradiction.\nerewrite <- bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (id : ident) (ab : ablock) (H1 : match (am_glob m1) ! id with\n| Some y1 => bbeq y1 ab = true\n| None => False\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (id : ident) (ab : ablock) (H1 : match (am_glob m1) ! id with\n| Some y1 => bbeq y1 ab = true\n| None => False\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab)","proofString":"destruct (am_glob m1)!id eqn:G; try contradiction.\nerewrite <- bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (id : ident) (ab a : ablock) (G : (am_glob m1) ! id = Some a) (H1 : bbeq a ab = true) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (id : ident) (ab a : ablock) (G : (am_glob m1) ! id = Some a) (H1 : bbeq a ab = true) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m1) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m2) ! id = Some ab)","proofString":"erewrite <- bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid) : smatch m b (am_nonstack m2).","conclusion":"smatch m b (am_nonstack m2)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid)","proofString":"rewrite <- H; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCinvalid) : smatch m b (am_top m2).","conclusion":"smatch m b (am_top m2)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m1)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCinvalid)","proofString":"rewrite <- H0; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack m1)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack m1)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob m1) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack m1)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top m1)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"auto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCstack) : bmatch m b (am_stack m1).","conclusion":"bmatch m b (am_stack m1)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCstack)","proofString":"erewrite bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab)","proofString":"specialize (H1 id).\nrewrite H4 in H1.\ndestruct (am_glob m2)!id eqn:G; try contradiction.\nerewrite bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (id : ident) (H1 : match (am_glob m1) ! id with\n| Some y1 =>\n    match (am_glob m2) ! id with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! id with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (id : ident) (H1 : match (am_glob m1) ! id with\n| Some y1 =>\n    match (am_glob m2) ! id with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! id with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (ab : ablock) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab)","proofString":"rewrite H4 in H1.\ndestruct (am_glob m2)!id eqn:G; try contradiction.\nerewrite bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (id : ident) (ab : ablock) (H1 : match (am_glob m2) ! id with\n| Some y2 => bbeq ab y2 = true\n| None => False\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (id : ident) (ab : ablock) (H1 : match (am_glob m2) ! id with\n| Some y2 => bbeq ab y2 = true\n| None => False\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab)","proofString":"destruct (am_glob m2)!id eqn:G; try contradiction.\nerewrite bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (id : ident) (ab a : ablock) (G : (am_glob m2) ! id = Some a) (H1 : bbeq ab a = true) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m1 m2 : amem) (m : mem) (id : ident) (ab a : ablock) (G : (am_glob m2) ! id = Some a) (H1 : bbeq ab a = true) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob m2) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b = BCglob id) (H4 : (am_glob m1) ! id = Some ab)","proofString":"erewrite bbeq_sound; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid) : smatch m b (am_nonstack m1).","conclusion":"smatch m b (am_nonstack m1)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCstack) (H4 : bc b <> BCinvalid)","proofString":"rewrite H; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCinvalid) : smatch m b (am_top m1).","conclusion":"smatch m b (am_top m1)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack m2)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H3 : bc b <> BCinvalid)","proofString":"rewrite H0; eauto."},{"statement":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack m2)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(m1 m2 : amem) (m : mem) (H1 : forall x : PTree.elt,\nmatch (am_glob m1) ! x with\n| Some y1 =>\n    match (am_glob m2) ! x with\n    | Some y2 => bbeq y1 y2 = true\n    | None => False\n    end\n| None => match (am_glob m2) ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (H2 : bbeq (am_stack m1) (am_stack m2) = true) (H : am_nonstack m1 = am_nonstack m2) (H0 : am_top m1 = am_top m2) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack m2)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob m2) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack m2)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top m2)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"auto."},{"statement":"(m : mem) (x y : amem) (H : mmatch m x) : mmatch m (mlub x y).","conclusion":"mmatch m (mlub x y)","hypotheses":"(m : mem) (x y : amem) (H : mmatch m x)","proofString":"inv H.\nconstructor; simpl; intros.\napply bmatch_lub_l; auto.\nrewrite PTree.gcombine in H0 by auto.\nunfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_l; eauto.\napply smatch_lub_l; auto.\napply smatch_lub_l; auto.\nauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack x)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : mmatch m (mlub x y).","conclusion":"mmatch m (mlub x y)","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack x)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"constructor; simpl; intros.\napply bmatch_lub_l; auto.\nrewrite PTree.gcombine in H0 by auto.\nunfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_l; eauto.\napply smatch_lub_l; auto.\napply smatch_lub_l; auto.\nauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack) : bmatch m b (blub (am_stack x) (am_stack y)).","conclusion":"bmatch m b (blub (am_stack x) (am_stack y))","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack)","proofString":"apply bmatch_lub_l; auto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : (PTree.combine combine_ablock (am_glob x) (am_glob y)) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : (PTree.combine combine_ablock (am_glob x) (am_glob y)) ! id = Some ab)","proofString":"rewrite PTree.gcombine in H0 by auto.\nunfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_l; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : combine_ablock (am_glob x) ! id (am_glob y) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : combine_ablock (am_glob x) ! id (am_glob y) ! id = Some ab)","proofString":"unfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_l; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : match (am_glob x) ! id with\n| Some b1 =>\n    match (am_glob y) ! id with\n    | Some b2 => Some (blub b1 b2)\n    | None => None\n    end\n| None => None\nend = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : match (am_glob x) ! id with\n| Some b1 =>\n    match (am_glob y) ! id with\n    | Some b2 => Some (blub b1 b2)\n    | None => None\n    end\n| None => None\nend = Some ab)","proofString":"destruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_l; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (b : block) (H : bc b = BCglob id) (b1 : ablock) (G1 : (am_glob x) ! id = Some b1) (b2 : ablock) (G2 : (am_glob y) ! id = Some b2) : bmatch m b (blub b1 b2).","conclusion":"bmatch m b (blub b1 b2)","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id0 : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob x) ! id0 = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (b : block) (H : bc b = BCglob id) (b1 : ablock) (G1 : (am_glob x) ! id = Some b1) (b2 : ablock) (G2 : (am_glob y) ! id = Some b2)","proofString":"apply bmatch_lub_l; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid) : smatch m b (plub (am_nonstack x) (am_nonstack y)).","conclusion":"smatch m b (plub (am_nonstack x) (am_nonstack y))","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid)","proofString":"apply smatch_lub_l; auto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid) : smatch m b (plub (am_top x) (am_top y)).","conclusion":"smatch m b (plub (am_top x) (am_top y))","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack x)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid)","proofString":"apply smatch_lub_l; auto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack x)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack x)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob x) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack x)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top x)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"auto."},{"statement":"(m : mem) (x y : amem) (H : mmatch m y) : mmatch m (mlub x y).","conclusion":"mmatch m (mlub x y)","hypotheses":"(m : mem) (x y : amem) (H : mmatch m y)","proofString":"inv H.\nconstructor; simpl; intros.\napply bmatch_lub_r; auto.\nrewrite PTree.gcombine in H0 by auto.\nunfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_r; eauto.\napply smatch_lub_r; auto.\napply smatch_lub_r; auto.\nauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack y)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : mmatch m (mlub x y).","conclusion":"mmatch m (mlub x y)","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack y)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"constructor; simpl; intros.\napply bmatch_lub_r; auto.\nrewrite PTree.gcombine in H0 by auto.\nunfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_r; eauto.\napply smatch_lub_r; auto.\napply smatch_lub_r; auto.\nauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack) : bmatch m b (blub (am_stack x) (am_stack y)).","conclusion":"bmatch m b (blub (am_stack x) (am_stack y))","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b = BCstack)","proofString":"apply bmatch_lub_r; auto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : (PTree.combine combine_ablock (am_glob x) (am_glob y)) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : (PTree.combine combine_ablock (am_glob x) (am_glob y)) ! id = Some ab)","proofString":"rewrite PTree.gcombine in H0 by auto.\nunfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_r; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : combine_ablock (am_glob x) ! id (am_glob y) ! id = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : combine_ablock (am_glob x) ! id (am_glob y) ! id = Some ab)","proofString":"unfold combine_ablock in H0.\ndestruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_r; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : match (am_glob x) ! id with\n| Some b1 =>\n    match (am_glob y) ! id with\n    | Some b2 => Some (blub b1 b2)\n    | None => None\n    end\n| None => None\nend = Some ab) : bmatch m b ab.","conclusion":"bmatch m b ab","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab0 : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab0 -> bmatch m b0 ab0) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (ab : ablock) (b : block) (H : bc b = BCglob id) (H0 : match (am_glob x) ! id with\n| Some b1 =>\n    match (am_glob y) ! id with\n    | Some b2 => Some (blub b1 b2)\n    | None => None\n    end\n| None => None\nend = Some ab)","proofString":"destruct (am_glob x)!id as [b1|] eqn:G1;  destruct (am_glob y)!id as [b2|] eqn:G2;  inv H0.\napply bmatch_lub_r; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (b : block) (H : bc b = BCglob id) (b1 : ablock) (G1 : (am_glob x) ! id = Some b1) (b2 : ablock) (G2 : (am_glob y) ! id = Some b2) : bmatch m b (blub b1 b2).","conclusion":"bmatch m b (blub b1 b2)","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id0 : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id0 -> (am_glob y) ! id0 = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (id : ident) (b : block) (H : bc b = BCglob id) (b1 : ablock) (G1 : (am_glob x) ! id = Some b1) (b2 : ablock) (G2 : (am_glob y) ! id = Some b2)","proofString":"apply bmatch_lub_r; eauto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid) : smatch m b (plub (am_nonstack x) (am_nonstack y)).","conclusion":"smatch m b (plub (am_nonstack x) (am_nonstack y))","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCstack) (H0 : bc b <> BCinvalid)","proofString":"apply smatch_lub_r; auto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid) : smatch m b (plub (am_top x) (am_top y)).","conclusion":"smatch m b (plub (am_top x) (am_top y))","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b0 : block, bc b0 = BCstack -> bmatch m b0 (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b0 : block),\nbc b0 = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b0 ab) (mmatch_nonstack0 : forall b0 : block,\nbc b0 <> BCstack -> bc b0 <> BCinvalid -> smatch m b0 (am_nonstack y)) (mmatch_top0 : forall b0 : block, bc b0 <> BCinvalid -> smatch m b0 (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) (b : block) (H : bc b <> BCinvalid)","proofString":"apply smatch_lub_r; auto."},{"statement":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack y)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m)) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(m : mem) (x y : amem) (mmatch_stack0 : forall b : block, bc b = BCstack -> bmatch m b (am_stack y)) (mmatch_glob0 : forall (id : ident) (ab : ablock) (b : block),\nbc b = BCglob id -> (am_glob y) ! id = Some ab -> bmatch m b ab) (mmatch_nonstack0 : forall b : block,\nbc b <> BCstack -> bc b <> BCinvalid -> smatch m b (am_nonstack y)) (mmatch_top0 : forall b : block, bc b <> BCinvalid -> smatch m b (am_top y)) (mmatch_below0 : bc_below bc (Mem.nextblock m))","proofString":"auto."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pdisjoint p1 sz1 p2 sz2 = true) (H0 : pmatch bc b1 ofs1 p1) (H1 : pmatch bc b2 ofs2 p2) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (p2 : aptr) (H : pdisjoint p1 sz1 p2 sz2 = true) (H0 : pmatch bc b1 ofs1 p1) (H1 : pmatch bc b2 ofs2 p2)","proofString":"inv H0; inv H1; simpl in H; try discriminate; try (left; congruence).\ndestruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ H); InvBooleans; auto.\nleft; congruence.\ndestruct (peq id id0); try discriminate.\nleft; congruence.\ndestruct (peq id id0); try discriminate.\nleft; congruence.\ndestruct (peq id id0); try discriminate.\nleft; congruence.\ndestruct (orb_true_elim _ _ H); InvBooleans; auto."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : (if peq id id0\n then\n  zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n  || zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1)\n else true) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : (if peq id id0\n then\n  zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n  || zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1)\n else true) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ H); InvBooleans; auto.\nleft; congruence."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (e : id = id0) (H : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (e : id = id0) (H : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0)","proofString":"subst id0.\ndestruct (orb_true_elim _ _ H); InvBooleans; auto."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id : ident) (H : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id : ident) (H : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id)","proofString":"destruct (orb_true_elim _ _ H); InvBooleans; auto."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (n : id <> id0) (H : true = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (n : id <> id0) (H : true = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0)","proofString":"left; congruence."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : negb (peq id id0) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : negb (peq id id0) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0)","proofString":"destruct (peq id id0); try discriminate.\nleft; congruence."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : negb (peq id id0) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : negb (peq id id0) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0)","proofString":"destruct (peq id id0); try discriminate.\nleft; congruence."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : negb (peq id id0) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (id id0 : ident) (H : negb (peq id id0) = true) (H2 : bc b1 = BCglob id) (H0 : bc b2 = BCglob id0)","proofString":"destruct (peq id id0); try discriminate.\nleft; congruence."},{"statement":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (H : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (H2 : bc b1 = BCstack) (H0 : bc b2 = BCstack) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(bc : block_classification) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (H : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (H2 : bc b1 = BCstack) (H0 : bc b2 = BCstack)","proofString":"destruct (orb_true_elim _ _ H); InvBooleans; auto."},{"statement":"forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2.","conclusion":"forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2","hypotheses":"","proofString":"intros until id2; intros GE1 GE2 EQ1 EQ2 DIFF.\napply GE1 in EQ1; apply GE2 in EQ2.\napply Genv.find_invert_symbol in EQ1; apply Genv.find_invert_symbol in EQ2.\ncongruence."},{"statement":"(bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident) (GE1 : genv_match bc1 ge) (GE2 : genv_match bc2 ge) (EQ1 : bc1 b1 = BCglob id1) (EQ2 : bc2 b2 = BCglob id2) (DIFF : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident) (GE1 : genv_match bc1 ge) (GE2 : genv_match bc2 ge) (EQ1 : bc1 b1 = BCglob id1) (EQ2 : bc2 b2 = BCglob id2) (DIFF : id1 <> id2)","proofString":"apply GE1 in EQ1; apply GE2 in EQ2.\napply Genv.find_invert_symbol in EQ1; apply Genv.find_invert_symbol in EQ2.\ncongruence."},{"statement":"(bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident) (GE1 : genv_match bc1 ge) (GE2 : genv_match bc2 ge) (EQ1 : Genv.find_symbol ge id1 = Some b1) (EQ2 : Genv.find_symbol ge id2 = Some b2) (DIFF : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident) (GE1 : genv_match bc1 ge) (GE2 : genv_match bc2 ge) (EQ1 : Genv.find_symbol ge id1 = Some b1) (EQ2 : Genv.find_symbol ge id2 = Some b2) (DIFF : id1 <> id2)","proofString":"apply Genv.find_invert_symbol in EQ1; apply Genv.find_invert_symbol in EQ2.\ncongruence."},{"statement":"(bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident) (GE1 : genv_match bc1 ge) (GE2 : genv_match bc2 ge) (EQ1 : Genv.invert_symbol ge b1 = Some id1) (EQ2 : Genv.invert_symbol ge b2 = Some id2) (DIFF : id1 <> id2) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident) (GE1 : genv_match bc1 ge) (GE2 : genv_match bc2 ge) (EQ1 : Genv.invert_symbol ge b1 = Some id1) (EQ2 : Genv.invert_symbol ge b2 = Some id2) (DIFF : id1 <> id2)","proofString":"congruence."},{"statement":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) : forall (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification)\n  (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs)\n  (bc2 : block_classification) (p2 : aptr) (ge : genv) \n  (sp : block),\npdisjoint p1 sz1 p2 sz2 = true ->\npmatch bc1 b1 ofs1 p1 ->\npmatch bc2 b2 ofs2 p2 ->\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\ngenv_match bc2 ge ->\nbc2 sp = BCstack ->\nb1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"forall (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification)\n  (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs)\n  (bc2 : block_classification) (p2 : aptr) (ge : genv) \n  (sp : block),\npdisjoint p1 sz1 p2 sz2 = true ->\npmatch bc1 b1 ofs1 p1 ->\npmatch bc2 b2 ofs2 p2 ->\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\ngenv_match bc2 ge ->\nbc2 sp = BCstack ->\nb1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2)","proofString":"assert (GLOB_STACK: forall (bc1 bc2: block_classification) ge sp b1 b2 id,           genv_match bc1 ge -> bc1 sp = BCstack -> bc2 sp = BCstack ->           bc1 b1 = BCglob id -> bc2 b2 = BCstack ->           b1 <> b2).\nintros until id; intros GE1 SP1 SP2 EQ1 EQ2.\napply GE1 in EQ1.\nassert (bc1 b1 <> BCstack) by (apply GE1; eapply (Senv.find_symbol_below ge); eauto).\nassert (b2 = sp) by (eapply bc2.(bc_stack); eauto).\ncongruence.\nassert (STACK_OTHER: forall (bc1 bc2: block_classification) sp b1 b2,           bc1 sp = BCstack -> bc2 sp = BCstack ->           bc1 b1 = BCstack -> bc2 b2 <> BCstack ->           b1 <> b2).\nintros until b2; intros SP1 SP2 EQ1 EQ2.\nassert (b1 = sp) by (eapply bc1.(bc_stack); eauto).\ncongruence.\nintros until sp; intros DISJ PM1 PM2 GE1 SP1 GE2 SP2.\ninv PM1; inv PM2; simpl in DISJ; try discriminate; eauto using not_eq_sym.\ndestruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto.\neauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2.","conclusion":"forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2)","proofString":"intros until id; intros GE1 SP1 SP2 EQ1 EQ2.\napply GE1 in EQ1.\nassert (bc1 b1 <> BCstack) by (apply GE1; eapply (Senv.find_symbol_below ge); eauto).\nassert (b2 = sp) by (eapply bc2.(bc_stack); eauto).\ncongruence."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : bc1 b1 = BCglob id) (EQ2 : bc2 b2 = BCstack) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : bc1 b1 = BCglob id) (EQ2 : bc2 b2 = BCstack)","proofString":"apply GE1 in EQ1.\nassert (bc1 b1 <> BCstack) by (apply GE1; eapply (Senv.find_symbol_below ge); eauto).\nassert (b2 = sp) by (eapply bc2.(bc_stack); eauto).\ncongruence."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : Genv.find_symbol ge id = Some b1) (EQ2 : bc2 b2 = BCstack) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : Genv.find_symbol ge id = Some b1) (EQ2 : bc2 b2 = BCstack)","proofString":"assert (bc1 b1 <> BCstack) by (apply GE1; eapply (Senv.find_symbol_below ge); eauto).\nassert (b2 = sp) by (eapply bc2.(bc_stack); eauto).\ncongruence."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : Genv.find_symbol ge id = Some b1) (EQ2 : bc2 b2 = BCstack) (H : bc1 b1 <> BCstack) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : Genv.find_symbol ge id = Some b1) (EQ2 : bc2 b2 = BCstack) (H : bc1 b1 <> BCstack)","proofString":"assert (b2 = sp) by (eapply bc2.(bc_stack); eauto).\ncongruence."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : Genv.find_symbol ge id = Some b1) (EQ2 : bc2 b2 = BCstack) (H : bc1 b1 <> BCstack) (H0 : b2 = sp) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (bc1 bc2 : block_classification) (ge : genv) (sp b1 b2 : block) (id : ident) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : Genv.find_symbol ge id = Some b1) (EQ2 : bc2 b2 = BCstack) (H : bc1 b1 <> BCstack) (H0 : b2 = sp)","proofString":"congruence."},{"statement":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) (GLOB_STACK : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2) : forall (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification)\n  (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs)\n  (bc2 : block_classification) (p2 : aptr) (ge : genv) \n  (sp : block),\npdisjoint p1 sz1 p2 sz2 = true ->\npmatch bc1 b1 ofs1 p1 ->\npmatch bc2 b2 ofs2 p2 ->\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\ngenv_match bc2 ge ->\nbc2 sp = BCstack ->\nb1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"forall (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification)\n  (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs)\n  (bc2 : block_classification) (p2 : aptr) (ge : genv) \n  (sp : block),\npdisjoint p1 sz1 p2 sz2 = true ->\npmatch bc1 b1 ofs1 p1 ->\npmatch bc2 b2 ofs2 p2 ->\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\ngenv_match bc2 ge ->\nbc2 sp = BCstack ->\nb1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) (GLOB_STACK : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2)","proofString":"assert (STACK_OTHER: forall (bc1 bc2: block_classification) sp b1 b2,           bc1 sp = BCstack -> bc2 sp = BCstack ->           bc1 b1 = BCstack -> bc2 b2 <> BCstack ->           b1 <> b2).\nintros until b2; intros SP1 SP2 EQ1 EQ2.\nassert (b1 = sp) by (eapply bc1.(bc_stack); eauto).\ncongruence.\nintros until sp; intros DISJ PM1 PM2 GE1 SP1 GE2 SP2.\ninv PM1; inv PM2; simpl in DISJ; try discriminate; eauto using not_eq_sym.\ndestruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto.\neauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) (GLOB_STACK : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2) : forall (bc1 bc2 : block_classification) (sp b1 b2 : block),\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCstack -> bc2 b2 <> BCstack -> b1 <> b2.","conclusion":"forall (bc1 bc2 : block_classification) (sp b1 b2 : block),\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCstack -> bc2 b2 <> BCstack -> b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) (GLOB_STACK : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2)","proofString":"intros until b2; intros SP1 SP2 EQ1 EQ2.\nassert (b1 = sp) by (eapply bc1.(bc_stack); eauto).\ncongruence."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge ->\ngenv_match bc3 ge ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (bc1 bc2 : block_classification) (sp b1 b2 : block) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : bc1 b1 = BCstack) (EQ2 : bc2 b2 <> BCstack) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge ->\ngenv_match bc3 ge ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (bc1 bc2 : block_classification) (sp b1 b2 : block) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : bc1 b1 = BCstack) (EQ2 : bc2 b2 <> BCstack)","proofString":"assert (b1 = sp) by (eapply bc1.(bc_stack); eauto).\ncongruence."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge ->\ngenv_match bc3 ge ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (bc1 bc2 : block_classification) (sp b1 b2 : block) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : bc1 b1 = BCstack) (EQ2 : bc2 b2 <> BCstack) (H : b1 = sp) : b1 <> b2.","conclusion":"b1 <> b2","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge ->\ngenv_match bc3 ge ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (bc1 bc2 : block_classification) (sp b1 b2 : block) (SP1 : bc1 sp = BCstack) (SP2 : bc2 sp = BCstack) (EQ1 : bc1 b1 = BCstack) (EQ2 : bc2 b2 <> BCstack) (H : b1 = sp)","proofString":"congruence."},{"statement":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) (GLOB_STACK : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2) (STACK_OTHER : forall (bc1 bc2 : block_classification) (sp b1 b2 : block),\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCstack -> bc2 b2 <> BCstack -> b1 <> b2) : forall (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification)\n  (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs)\n  (bc2 : block_classification) (p2 : aptr) (ge : genv) \n  (sp : block),\npdisjoint p1 sz1 p2 sz2 = true ->\npmatch bc1 b1 ofs1 p1 ->\npmatch bc2 b2 ofs2 p2 ->\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\ngenv_match bc2 ge ->\nbc2 sp = BCstack ->\nb1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"forall (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification)\n  (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs)\n  (bc2 : block_classification) (p2 : aptr) (ge : genv) \n  (sp : block),\npdisjoint p1 sz1 p2 sz2 = true ->\npmatch bc1 b1 ofs1 p1 ->\npmatch bc2 b2 ofs2 p2 ->\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\ngenv_match bc2 ge ->\nbc2 sp = BCstack ->\nb1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc1 bc2 : block_classification) (ge : genv) \n  (b1 b2 : block) (id1 id2 : ident),\ngenv_match bc1 ge ->\ngenv_match bc2 ge ->\nbc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> id1 <> id2 -> b1 <> b2) (GLOB_STACK : forall (bc1 bc2 : block_classification) (ge : genv) \n  (sp b1 b2 : block) (id : ident),\ngenv_match bc1 ge ->\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCglob id -> bc2 b2 = BCstack -> b1 <> b2) (STACK_OTHER : forall (bc1 bc2 : block_classification) (sp b1 b2 : block),\nbc1 sp = BCstack ->\nbc2 sp = BCstack -> bc1 b1 = BCstack -> bc2 b2 <> BCstack -> b1 <> b2)","proofString":"intros until sp; intros DISJ PM1 PM2 GE1 SP1 GE2 SP2.\ninv PM1; inv PM2; simpl in DISJ; try discriminate; eauto using not_eq_sym.\ndestruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto.\neauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (p2 : aptr) (ge : genv) (sp : block) (DISJ : pdisjoint p1 sz1 p2 sz2 = true) (PM1 : pmatch bc1 b1 ofs1 p1) (PM2 : pmatch bc2 b2 ofs2 p2) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (p1 : aptr) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (p2 : aptr) (ge : genv) (sp : block) (DISJ : pdisjoint p1 sz1 p2 sz2 = true) (PM1 : pmatch bc1 b1 ofs1 p1) (PM2 : pmatch bc2 b2 ofs2 p2) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack)","proofString":"inv PM1; inv PM2; simpl in DISJ; try discriminate; eauto using not_eq_sym.\ndestruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto.\neauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (peq id id0); discriminate || eauto.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : (if peq id id0\n then\n  zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n  || zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1)\n else true) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : (if peq id id0\n then\n  zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n  || zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1)\n else true) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0)","proofString":"destruct (peq id id0).\nsubst id0.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto.\neauto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (e : id = id0) (DISJ : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (e : id = id0) (DISJ : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0)","proofString":"subst id0.\ndestruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id0 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id0 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id : ident) (DISJ : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id0 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id0 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id : ident) (DISJ : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id)","proofString":"destruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (n : id <> id0) (DISJ : true = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (n : id <> id0) (DISJ : true = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0)","proofString":"eauto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : negb (peq id id0) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : negb (peq id id0) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0)","proofString":"destruct (peq id id0); discriminate || eauto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : negb (peq id id0) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : negb (peq id id0) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0)","proofString":"destruct (peq id id0); discriminate || eauto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : negb (peq id id0) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id1 : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id1 -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (id id0 : ident) (DISJ : negb (peq id id0) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCglob id) (H0 : bc2 b2 = BCglob id0)","proofString":"destruct (peq id id0); discriminate || eauto."},{"statement":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (DISJ : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCstack) (H0 : bc2 b2 = BCstack) : b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.","conclusion":"b1 <> b2 \\/\nPtrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/\nPtrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1","hypotheses":"(GLOB_GLOB : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (b0 b3 : block) (id1 id2 : ident),\ngenv_match bc0 ge0 ->\ngenv_match bc3 ge0 ->\nbc0 b0 = BCglob id1 -> bc3 b3 = BCglob id2 -> id1 <> id2 -> b0 <> b3) (GLOB_STACK : forall (bc0 bc3 : block_classification) (ge0 : genv) \n  (sp0 b0 b3 : block) (id : ident),\ngenv_match bc0 ge0 ->\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCglob id -> bc3 b3 = BCstack -> b0 <> b3) (STACK_OTHER : forall (bc0 bc3 : block_classification) (sp0 b0 b3 : block),\nbc0 sp0 = BCstack ->\nbc3 sp0 = BCstack -> bc0 b0 = BCstack -> bc3 b3 <> BCstack -> b0 <> b3) (sz1 : Z) (b1 : block) (ofs1 : ptrofs) (bc1 : block_classification) (sz2 : Z) (b2 : block) (ofs2 : ptrofs) (bc2 : block_classification) (ge : genv) (sp : block) (DISJ : zle (Ptrofs.unsigned ofs1 + sz1) (Ptrofs.unsigned ofs2)\n|| zle (Ptrofs.unsigned ofs2 + sz2) (Ptrofs.unsigned ofs1) = true) (GE1 : genv_match bc1 ge) (SP1 : bc1 sp = BCstack) (GE2 : genv_match bc2 ge) (SP2 : bc2 sp = BCstack) (H : bc1 b1 = BCstack) (H0 : bc2 b2 = BCstack)","proofString":"destruct (orb_true_elim _ _ DISJ); InvBooleans; auto."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (H : genv_match bc1 ge) (H0 : forall (b : block) (id : ident), bc1 b = BCglob id <-> bc2 b = BCglob id) (H1 : forall b : block, bc1 b = BCother -> bc2 b = BCother) : genv_match bc2 ge.","conclusion":"genv_match bc2 ge","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (H : genv_match bc1 ge) (H0 : forall (b : block) (id : ident), bc1 b = BCglob id <-> bc2 b = BCglob id) (H1 : forall b : block, bc1 b = BCother -> bc2 b = BCother)","proofString":"destruct H as [A B].\nsplit; intros.\nrewrite <- H0.\neauto.\nexploit B; eauto.\ndestruct (bc1 b) eqn:BC1.\nintuition congruence.\nrewrite H0 in BC1.\nintuition congruence.\nintuition congruence.\nerewrite H1 by eauto.\nintuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc1 b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc1 b <> BCinvalid /\\ bc1 b <> BCstack) (H0 : forall (b : block) (id : ident), bc1 b = BCglob id <-> bc2 b = BCglob id) (H1 : forall b : block, bc1 b = BCother -> bc2 b = BCother) : genv_match bc2 ge.","conclusion":"genv_match bc2 ge","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc1 b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc1 b <> BCinvalid /\\ bc1 b <> BCstack) (H0 : forall (b : block) (id : ident), bc1 b = BCglob id <-> bc2 b = BCglob id) (H1 : forall b : block, bc1 b = BCother -> bc2 b = BCother)","proofString":"split; intros.\nrewrite <- H0.\neauto.\nexploit B; eauto.\ndestruct (bc1 b) eqn:BC1.\nintuition congruence.\nrewrite H0 in BC1.\nintuition congruence.\nintuition congruence.\nerewrite H1 by eauto.\nintuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (id : ident) (b : block) : Genv.find_symbol ge id = Some b <-> bc2 b = BCglob id.","conclusion":"Genv.find_symbol ge id = Some b <-> bc2 b = BCglob id","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (id : ident) (b : block)","proofString":"rewrite <- H0.\neauto."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (id : ident) (b : block) : Genv.find_symbol ge id = Some b <-> bc1 b = BCglob id.","conclusion":"Genv.find_symbol ge id = Some b <-> bc1 b = BCglob id","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (id : ident) (b : block)","proofString":"eauto."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) : bc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"bc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge))","proofString":"exploit B; eauto.\ndestruct (bc1 b) eqn:BC1.\nintuition congruence.\nrewrite H0 in BC1.\nintuition congruence.\nintuition congruence.\nerewrite H1 by eauto.\nintuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) : bc1 b <> BCinvalid /\\ bc1 b <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"bc1 b <> BCinvalid /\\ bc1 b <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge))","proofString":"destruct (bc1 b) eqn:BC1.\nintuition congruence.\nrewrite H0 in BC1.\nintuition congruence.\nintuition congruence.\nerewrite H1 by eauto.\nintuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCinvalid) : BCinvalid <> BCinvalid /\\ BCinvalid <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"BCinvalid <> BCinvalid /\\ BCinvalid <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCinvalid)","proofString":"intuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (id : ident) (BC1 : bc1 b = BCglob id) : BCglob id <> BCinvalid /\\ BCglob id <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"BCglob id <> BCinvalid /\\ BCglob id <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (id : ident) (BC1 : bc1 b = BCglob id)","proofString":"rewrite H0 in BC1.\nintuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (id : ident) (BC1 : bc2 b = BCglob id) : BCglob id <> BCinvalid /\\ BCglob id <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"BCglob id <> BCinvalid /\\ BCglob id <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc1 b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id0 : ident),\nbc1 b0 = BCglob id0 <-> bc2 b0 = BCglob id0) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (id : ident) (BC1 : bc2 b = BCglob id)","proofString":"intuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCstack) : BCstack <> BCinvalid /\\ BCstack <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"BCstack <> BCinvalid /\\ BCstack <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCstack)","proofString":"intuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCother) : BCother <> BCinvalid /\\ BCother <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack.","conclusion":"BCother <> BCinvalid /\\ BCother <> BCstack ->\nbc2 b <> BCinvalid /\\ bc2 b <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCother)","proofString":"erewrite H1 by eauto.\nintuition congruence."},{"statement":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCother) : BCother <> BCinvalid /\\ BCother <> BCstack ->\nBCother <> BCinvalid /\\ BCother <> BCstack.","conclusion":"BCother <> BCinvalid /\\ BCother <> BCstack ->\nBCother <> BCinvalid /\\ BCother <> BCstack","hypotheses":"(ge : genv) (bc1 bc2 : block_classification) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc1 b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc1 b0 <> BCinvalid /\\ bc1 b0 <> BCstack) (H0 : forall (b0 : block) (id : ident), bc1 b0 = BCglob id <-> bc2 b0 = BCglob id) (H1 : forall b0 : block, bc1 b0 = BCother -> bc2 b0 = BCother) (b : positive) (H : Plt b (Genv.genv_next ge)) (BC1 : bc1 b = BCother)","proofString":"intuition congruence."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc2 b = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc2 b = BCglob id) (H2 : rm ! id = Some ab)","proofString":"rewrite H0 in H1.\nexploit H; eauto.\nintros (A & B & C).\nsplit; auto.\nsplit; auto.\nassert (PM: forall b ofs p, pmatch bc1 b ofs p -> pmatch bc1 b ofs (ab_summary ab) -> pmatch bc2 b ofs p).\nintros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va.\nassert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab)","proofString":"exploit H; eauto.\nintros (A & B & C).\nsplit; auto.\nsplit; auto.\nassert (PM: forall b ofs p, pmatch bc1 b ofs p -> pmatch bc1 b ofs (ab_summary ab) -> pmatch bc2 b ofs p).\nintros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va.\nassert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) : pge Glob (ab_summary ab) /\\\nbmatch bc1 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch bc1 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable) ->\npge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab)","proofString":"intros (A & B & C).\nsplit; auto.\nsplit; auto.\nassert (PM: forall b ofs p, pmatch bc1 b ofs p -> pmatch bc1 b ofs (ab_summary ab) -> pmatch bc2 b ofs p).\nintros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va.\nassert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : pge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","conclusion":"pge Glob (ab_summary ab) /\\\nbmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"split; auto.\nsplit; auto.\nassert (PM: forall b ofs p, pmatch bc1 b ofs p -> pmatch bc1 b ofs (ab_summary ab) -> pmatch bc2 b ofs p).\nintros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va.\nassert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable).","conclusion":"bmatch bc2 m b ab /\\ (forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"split; auto.\nassert (PM: forall b ofs p, pmatch bc1 b ofs p -> pmatch bc1 b ofs (ab_summary ab) -> pmatch bc2 b ofs p).\nintros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va.\nassert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : bmatch bc2 m b ab.","conclusion":"bmatch bc2 m b ab","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"assert (PM: forall b ofs p, pmatch bc1 b ofs p -> pmatch bc1 b ofs (ab_summary ab) -> pmatch bc2 b ofs p).\nintros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va.\nassert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p.","conclusion":"forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable)","proofString":"intros.\nassert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id0 : ident),\nbc2 b1 = BCglob id0 <-> bc1 b1 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) : pmatch bc2 b0 ofs p.","conclusion":"pmatch bc2 b0 ofs p","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id0 : ident),\nbc2 b1 = BCglob id0 <-> bc1 b1 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab))","proofString":"assert (pmatch bc1 b0 ofs Glob) by (eapply pmatch_ge; eauto).\ninv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id0 : ident),\nbc2 b1 = BCglob id0 <-> bc1 b1 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) (H5 : pmatch bc1 b0 ofs Glob) : pmatch bc2 b0 ofs p.","conclusion":"pmatch bc2 b0 ofs p","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id0 : ident),\nbc2 b1 = BCglob id0 <-> bc1 b1 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) (H5 : pmatch bc1 b0 ofs Glob)","proofString":"inv H5.\nassert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id1 : ident),\nbc2 b1 = BCglob id1 <-> bc1 b1 = BCglob id1) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) (id0 : ident) (H6 : bc1 b0 = BCglob id0) : pmatch bc2 b0 ofs p.","conclusion":"pmatch bc2 b0 ofs p","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id1 : ident),\nbc2 b1 = BCglob id1 <-> bc1 b1 = BCglob id1) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) (id0 : ident) (H6 : bc1 b0 = BCglob id0)","proofString":"assert (bc2 b0 = BCglob id0) by (rewrite H0; auto).\ninv H3; econstructor; eauto with va."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id1 : ident),\nbc2 b1 = BCglob id1 <-> bc1 b1 = BCglob id1) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) (id0 : ident) (H6 : bc1 b0 = BCglob id0) (H5 : bc2 b0 = BCglob id0) : pmatch bc2 b0 ofs p.","conclusion":"pmatch bc2 b0 ofs p","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b1 : block) (id1 : ident),\nbc2 b1 = BCglob id1 <-> bc1 b1 = BCglob id1) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (b0 : block) (ofs : ptrofs) (p : aptr) (H3 : pmatch bc1 b0 ofs p) (H4 : pmatch bc1 b0 ofs (ab_summary ab)) (id0 : ident) (H6 : bc1 b0 = BCglob id0) (H5 : bc2 b0 = BCglob id0)","proofString":"inv H3; econstructor; eauto with va."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) : bmatch bc2 m b ab.","conclusion":"bmatch bc2 m b ab","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p)","proofString":"assert (VM: forall v x, vmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x).\nintros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto.\ndestruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x.","conclusion":"forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p)","proofString":"intros.\ninv H3; constructor; auto; inv H4; eapply PM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (v : val) (x : aval) (H3 : vmatch bc1 v x) (H4 : vmatch bc1 v (Ifptr (ab_summary ab))) : vmatch bc2 v x.","conclusion":"vmatch bc2 v x","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (v : val) (x : aval) (H3 : vmatch bc1 v x) (H4 : vmatch bc1 v (Ifptr (ab_summary ab)))","proofString":"inv H3; constructor; auto; inv H4; eapply PM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) : bmatch bc2 m b ab.","conclusion":"bmatch bc2 m b ab","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B : bmatch bc1 m b ab) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x)","proofString":"destruct B as [[B1 B2] B3].\nsplit.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) : bmatch bc2 m b ab.","conclusion":"bmatch bc2 m b ab","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x)","proofString":"split.\nsplit.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto.\nintros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) : smatch bc2 m b (ab_summary ab).","conclusion":"smatch bc2 m b (ab_summary ab)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x)","proofString":"split.\nintros.\napply VM; eauto.\nintros.\napply PM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc2 v (Ifptr (ab_summary ab)).","conclusion":"forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc2 v (Ifptr (ab_summary ab))","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x)","proofString":"intros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc1 v0 (Ifptr (ab_summary ab))) (B2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch bc1 v0 (ablock_load chunk0 ab ofs0)) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npmatch bc1 b0 ofs0 p ->\npmatch bc1 b0 ofs0 (ab_summary ab) -> pmatch bc2 b0 ofs0 p) (VM : forall (v0 : val) (x : aval),\nvmatch bc1 v0 x -> vmatch bc1 v0 (Ifptr (ab_summary ab)) -> vmatch bc2 v0 x) (chunk : memory_chunk) (ofs : Z) (v : val) (H3 : Mem.load chunk m b ofs = Some v) : vmatch bc2 v (Ifptr (ab_summary ab)).","conclusion":"vmatch bc2 v (Ifptr (ab_summary ab))","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc1 v0 (Ifptr (ab_summary ab))) (B2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch bc1 v0 (ablock_load chunk0 ab ofs0)) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npmatch bc1 b0 ofs0 p ->\npmatch bc1 b0 ofs0 (ab_summary ab) -> pmatch bc2 b0 ofs0 p) (VM : forall (v0 : val) (x : aval),\nvmatch bc1 v0 x -> vmatch bc1 v0 (Ifptr (ab_summary ab)) -> vmatch bc2 v0 x) (chunk : memory_chunk) (ofs : Z) (v : val) (H3 : Mem.load chunk m b ofs = Some v)","proofString":"apply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc2 b' ofs' (ab_summary ab).","conclusion":"forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc2 b' ofs' (ab_summary ab)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x)","proofString":"intros.\napply PM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc1 b'0 ofs'0 (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc1 v (ablock_load chunk ab ofs0)) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npmatch bc1 b0 ofs0 p ->\npmatch bc1 b0 ofs0 (ab_summary ab) -> pmatch bc2 b0 ofs0 p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc2 b' ofs' (ab_summary ab).","conclusion":"pmatch bc2 b' ofs' (ab_summary ab)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc1 b'0 ofs'0 (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc1 v (ablock_load chunk ab ofs0)) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npmatch bc1 b0 ofs0 p ->\npmatch bc1 b0 ofs0 (ab_summary ab) -> pmatch bc2 b0 ofs0 p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H3 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil))","proofString":"apply PM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x) : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc2 v (ablock_load chunk ab ofs).","conclusion":"forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc2 v (ablock_load chunk ab ofs)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr (ab_summary ab))) (B2 : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) (C : forall ofs : Z, ~ Mem.perm m b ofs Max Writable) (PM : forall (b0 : block) (ofs : ptrofs) (p : aptr),\npmatch bc1 b0 ofs p ->\npmatch bc1 b0 ofs (ab_summary ab) -> pmatch bc2 b0 ofs p) (VM : forall (v : val) (x : aval),\nvmatch bc1 v x -> vmatch bc1 v (Ifptr (ab_summary ab)) -> vmatch bc2 v x)","proofString":"intros.\napply VM; eauto."},{"statement":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc1 v0 (Ifptr (ab_summary ab))) (B2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch bc1 v0 (ablock_load chunk0 ab ofs0)) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npmatch bc1 b0 ofs0 p ->\npmatch bc1 b0 ofs0 (ab_summary ab) -> pmatch bc2 b0 ofs0 p) (VM : forall (v0 : val) (x : aval),\nvmatch bc1 v0 x -> vmatch bc1 v0 (Ifptr (ab_summary ab)) -> vmatch bc2 v0 x) (chunk : memory_chunk) (ofs : Z) (v : val) (H3 : Mem.load chunk m b ofs = Some v) : vmatch bc2 v (ablock_load chunk ab ofs).","conclusion":"vmatch bc2 v (ablock_load chunk ab ofs)","hypotheses":"(bc1 bc2 : block_classification) (m : mem) (rm : romem) (H : romatch bc1 m rm) (H0 : forall (b0 : block) (id0 : ident),\nbc2 b0 = BCglob id0 <-> bc1 b0 = BCglob id0) (b : block) (id : ident) (ab : ablock) (H1 : bc1 b = BCglob id) (H2 : rm ! id = Some ab) (A : pge Glob (ab_summary ab)) (B1 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc1 v0 (Ifptr (ab_summary ab))) (B2 : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' (ab_summary ab)) (B3 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch bc1 v0 (ablock_load chunk0 ab ofs0)) (C : forall ofs0 : Z, ~ Mem.perm m b ofs0 Max Writable) (PM : forall (b0 : block) (ofs0 : ptrofs) (p : aptr),\npmatch bc1 b0 ofs0 p ->\npmatch bc1 b0 ofs0 (ab_summary ab) -> pmatch bc2 b0 ofs0 p) (VM : forall (v0 : val) (x : aval),\nvmatch bc1 v0 x -> vmatch bc1 v0 (Ifptr (ab_summary ab)) -> vmatch bc2 v0 x) (chunk : memory_chunk) (ofs : Z) (v : val) (H3 : Mem.load chunk m b ofs = Some v)","proofString":"apply VM; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (H : smatch bc1 m b p) : smatch bc2 m b p.","conclusion":"smatch bc2 m b p","hypotheses":"(m : mem) (b : block) (p : aptr) (H : smatch bc1 m b p)","proofString":"destruct H as [A B].\nsplit; intros.\napply vmatch_incr; eauto.\napply pmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' p) : smatch bc2 m b p.","conclusion":"smatch bc2 m b p","hypotheses":"(m : mem) (b : block) (p : aptr) (A : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (Ifptr p)) (B : forall (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' p)","proofString":"split; intros.\napply vmatch_incr; eauto.\napply pmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc1 v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch bc2 v (Ifptr p).","conclusion":"vmatch bc2 v (Ifptr p)","hypotheses":"(m : mem) (b : block) (p : aptr) (A : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 -> vmatch bc1 v0 (Ifptr p)) (B : forall (ofs0 : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b' ofs') q i :: nil) ->\npmatch bc1 b' ofs' p) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"apply vmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (p : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc1 v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc1 b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc2 b' ofs' p.","conclusion":"pmatch bc2 b' ofs' p","hypotheses":"(m : mem) (b : block) (p : aptr) (A : forall (chunk : memory_chunk) (ofs0 : Z) (v : val),\nMem.load chunk m b ofs0 = Some v -> vmatch bc1 v (Ifptr p)) (B : forall (ofs0 : Z) (b'0 : block) (ofs'0 : ptrofs) (q0 : quantity) (i0 : nat),\nMem.loadbytes m b ofs0 1 = Some (Fragment (Vptr b'0 ofs'0) q0 i0 :: nil) ->\npmatch bc1 b'0 ofs'0 p) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil))","proofString":"apply pmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (H : bmatch bc1 m b ab) : bmatch bc2 m b ab.","conclusion":"bmatch bc2 m b ab","hypotheses":"(m : mem) (b : block) (ab : ablock) (H : bmatch bc1 m b ab)","proofString":"destruct H as [B1 B2].\nsplit.\napply smatch_incr; auto.\nintros.\napply vmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) : bmatch bc2 m b ab.","conclusion":"bmatch bc2 m b ab","hypotheses":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs))","proofString":"split.\napply smatch_incr; auto.\nintros.\napply vmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) : smatch bc2 m b (ab_summary ab).","conclusion":"smatch bc2 m b (ab_summary ab)","hypotheses":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs))","proofString":"apply smatch_incr; auto."},{"statement":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs)) : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc2 v (ablock_load chunk ab ofs).","conclusion":"forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc2 v (ablock_load chunk ab ofs)","hypotheses":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk : memory_chunk) (ofs : Z) (v : val),\nMem.load chunk m b ofs = Some v -> vmatch bc1 v (ablock_load chunk ab ofs))","proofString":"intros.\napply vmatch_incr; eauto."},{"statement":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch bc1 v0 (ablock_load chunk0 ab ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v) : vmatch bc2 v (ablock_load chunk ab ofs).","conclusion":"vmatch bc2 v (ablock_load chunk ab ofs)","hypotheses":"(m : mem) (b : block) (ab : ablock) (B1 : smatch bc1 m b (ab_summary ab)) (B2 : forall (chunk0 : memory_chunk) (ofs0 : Z) (v0 : val),\nMem.load chunk0 m b ofs0 = Some v0 ->\nvmatch bc1 v0 (ablock_load chunk0 ab ofs0)) (chunk : memory_chunk) (ofs : Z) (v : val) (H : Mem.load chunk m b ofs = Some v)","proofString":"apply vmatch_incr; eauto."},{"statement":"(bc : block_classification) (b : block) (H : bc b <> BCinvalid) : inj_of_bc bc b = Some (b, 0).","conclusion":"inj_of_bc bc b = Some (b, 0)","hypotheses":"(bc : block_classification) (b : block) (H : bc b <> BCinvalid)","proofString":"unfold inj_of_bc.\ndestruct (bc b); congruence."},{"statement":"(bc : block_classification) (b : block) (H : bc b <> BCinvalid) : match bc b with\n| BCinvalid => None\n| _ => Some (b, 0)\nend = Some (b, 0).","conclusion":"match bc b with\n| BCinvalid => None\n| _ => Some (b, 0)\nend = Some (b, 0)","hypotheses":"(bc : block_classification) (b : block) (H : bc b <> BCinvalid)","proofString":"destruct (bc b); congruence."},{"statement":"(bc : block_classification) (b b' : block) (delta : Z) (H : match bc b with\n| BCinvalid => None\n| _ => Some (b, 0)\nend = Some (b', delta)) : bc b <> BCinvalid /\\ b' = b /\\ delta = 0.","conclusion":"bc b <> BCinvalid /\\ b' = b /\\ delta = 0","hypotheses":"(bc : block_classification) (b b' : block) (delta : Z) (H : match bc b with\n| BCinvalid => None\n| _ => Some (b, 0)\nend = Some (b', delta))","proofString":"destruct (bc b); intuition congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (H : pmatch bc b ofs p) : inj_of_bc bc b = Some (b, 0).","conclusion":"inj_of_bc bc b = Some (b, 0)","hypotheses":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (H : pmatch bc b ofs p)","proofString":"apply inj_of_bc_valid.\ninv H; congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (H : pmatch bc b ofs p) : bc b <> BCinvalid.","conclusion":"bc b <> BCinvalid","hypotheses":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (H : pmatch bc b ofs p)","proofString":"inv H; congruence."},{"statement":"(bc : block_classification) (a1 : val) (al : list val) (b1 : aval) (bl : list aval) (H : vmatch bc a1 b1) (H0 : list_forall2 (vmatch bc) al bl) (IHlist_forall2 : Val.inject_list (inj_of_bc bc) al al) : Val.inject (inj_of_bc bc) a1 a1.","conclusion":"Val.inject (inj_of_bc bc) a1 a1","hypotheses":"(bc : block_classification) (a1 : val) (al : list val) (b1 : aval) (bl : list aval) (H : vmatch bc a1 b1) (H0 : list_forall2 (vmatch bc) al bl) (IHlist_forall2 : Val.inject_list (inj_of_bc bc) al al)","proofString":"eapply vmatch_inj; eauto."},{"statement":"(bc : block_classification) (a1 : val) (al : list val) (b1 : aval) (bl : list aval) (H : vmatch bc a1 b1) (H0 : list_forall2 (vmatch bc) al bl) (IHlist_forall2 : Val.inject_list (inj_of_bc bc) al al) : Val.inject_list (inj_of_bc bc) al al.","conclusion":"Val.inject_list (inj_of_bc bc) al al","hypotheses":"(bc : block_classification) (a1 : val) (al : list val) (b1 : aval) (bl : list aval) (H : vmatch bc a1 b1) (H0 : list_forall2 (vmatch bc) al bl) (IHlist_forall2 : Val.inject_list (inj_of_bc bc) al al)","proofString":"auto."},{"statement":"(bc : block_classification) (ge : genv) (H : genv_match bc ge) : meminj_preserves_globals ge (inj_of_bc bc).","conclusion":"meminj_preserves_globals ge (inj_of_bc bc)","hypotheses":"(bc : block_classification) (ge : genv) (H : genv_match bc ge)","proofString":"destruct H as [A B].\nsplit.\nintros.\napply inj_of_bc_valid.\nrewrite A in H.\ncongruence.\nsplit.\nintros.\napply inj_of_bc_valid.\napply B.\nrewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto.\nintros.\nexploit inj_of_bc_inv; eauto.\nintros (P & Q & R).\nauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) : meminj_preserves_globals ge (inj_of_bc bc).","conclusion":"meminj_preserves_globals ge (inj_of_bc bc)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack)","proofString":"split.\nintros.\napply inj_of_bc_valid.\nrewrite A in H.\ncongruence.\nsplit.\nintros.\napply inj_of_bc_valid.\napply B.\nrewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto.\nintros.\nexploit inj_of_bc_inv; eauto.\nintros (P & Q & R).\nauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> inj_of_bc bc b = Some (b, 0).","conclusion":"forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> inj_of_bc bc b = Some (b, 0)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack)","proofString":"intros.\napply inj_of_bc_valid.\nrewrite A in H.\ncongruence."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) : inj_of_bc bc b = Some (b, 0).","conclusion":"inj_of_bc bc b = Some (b, 0)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b)","proofString":"apply inj_of_bc_valid.\nrewrite A in H.\ncongruence."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) : bc b <> BCinvalid.","conclusion":"bc b <> BCinvalid","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b)","proofString":"rewrite A in H.\ncongruence."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (id : ident) (b : block) (H : bc b = BCglob id) : bc b <> BCinvalid.","conclusion":"bc b <> BCinvalid","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 <-> bc b0 = BCglob id0) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (id : ident) (b : block) (H : bc b = BCglob id)","proofString":"congruence."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) : (forall (b : block) (gv : globvar unit),\n Genv.find_var_info ge b = Some gv -> inj_of_bc bc b = Some (b, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv ->\n inj_of_bc bc b1 = Some (b2, delta) -> b2 = b1).","conclusion":"(forall (b : block) (gv : globvar unit),\n Genv.find_var_info ge b = Some gv -> inj_of_bc bc b = Some (b, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv ->\n inj_of_bc bc b1 = Some (b2, delta) -> b2 = b1)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack)","proofString":"split.\nintros.\napply inj_of_bc_valid.\napply B.\nrewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto.\nintros.\nexploit inj_of_bc_inv; eauto.\nintros (P & Q & R).\nauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> inj_of_bc bc b = Some (b, 0).","conclusion":"forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> inj_of_bc bc b = Some (b, 0)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack)","proofString":"intros.\napply inj_of_bc_valid.\napply B.\nrewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv) : inj_of_bc bc b = Some (b, 0).","conclusion":"inj_of_bc bc b = Some (b, 0)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv)","proofString":"apply inj_of_bc_valid.\napply B.\nrewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv) : bc b <> BCinvalid.","conclusion":"bc b <> BCinvalid","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv)","proofString":"apply B.\nrewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv) : Plt b (Genv.genv_next ge).","conclusion":"Plt b (Genv.genv_next ge)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv)","proofString":"rewrite Genv.find_var_info_iff in H.\neapply Genv.genv_defs_range; eauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_def ge b = Some (Gvar gv)) : Plt b (Genv.genv_next ge).","conclusion":"Plt b (Genv.genv_next ge)","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 <-> bc b0 = BCglob id) (B : forall b0 : positive,\nPlt b0 (Genv.genv_next ge) -> bc b0 <> BCinvalid /\\ bc b0 <> BCstack) (b : block) (gv : globvar unit) (H : Genv.find_def ge b = Some (Gvar gv))","proofString":"eapply Genv.genv_defs_range; eauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) : forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\nGenv.find_var_info ge b2 = Some gv ->\ninj_of_bc bc b1 = Some (b2, delta) -> b2 = b1.","conclusion":"forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\nGenv.find_var_info ge b2 = Some gv ->\ninj_of_bc bc b1 = Some (b2, delta) -> b2 = b1","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack)","proofString":"intros.\nexploit inj_of_bc_inv; eauto.\nintros (P & Q & R).\nauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : inj_of_bc bc b1 = Some (b2, delta)) : b2 = b1.","conclusion":"b2 = b1","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : inj_of_bc bc b1 = Some (b2, delta))","proofString":"exploit inj_of_bc_inv; eauto.\nintros (P & Q & R).\nauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : inj_of_bc bc b1 = Some (b2, delta)) : bc b1 <> BCinvalid /\\ b2 = b1 /\\ delta = 0 -> b2 = b1.","conclusion":"bc b1 <> BCinvalid /\\ b2 = b1 /\\ delta = 0 -> b2 = b1","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : inj_of_bc bc b1 = Some (b2, delta))","proofString":"intros (P & Q & R).\nauto."},{"statement":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : inj_of_bc bc b1 = Some (b2, delta)) (P : bc b1 <> BCinvalid) (Q : b2 = b1) (R : delta = 0) : b2 = b1.","conclusion":"b2 = b1","hypotheses":"(bc : block_classification) (ge : genv) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b <-> bc b = BCglob id) (B : forall b : positive,\nPlt b (Genv.genv_next ge) -> bc b <> BCinvalid /\\ bc b <> BCstack) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : inj_of_bc bc b1 = Some (b2, delta)) (P : bc b1 <> BCinvalid) (Q : b2 = b1) (R : delta = 0)","proofString":"auto."},{"statement":"(bc : block_classification) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta)) : pmatch bc b ofs Ptop.","conclusion":"pmatch bc b ofs Ptop","hypotheses":"(bc : block_classification) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta))","proofString":"exploit inj_of_bc_inv; eauto.\nintros (A & B & C).\nconstructor; auto."},{"statement":"(bc : block_classification) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta)) : bc b <> BCinvalid /\\ b' = b /\\ delta = 0 -> pmatch bc b ofs Ptop.","conclusion":"bc b <> BCinvalid /\\ b' = b /\\ delta = 0 -> pmatch bc b ofs Ptop","hypotheses":"(bc : block_classification) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta))","proofString":"intros (A & B & C).\nconstructor; auto."},{"statement":"(bc : block_classification) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta)) (A : bc b <> BCinvalid) (B : b' = b) (C : delta = 0) : pmatch bc b ofs Ptop.","conclusion":"pmatch bc b ofs Ptop","hypotheses":"(bc : block_classification) (b b' : block) (delta : Z) (ofs : ptrofs) (H : inj_of_bc bc b = Some (b', delta)) (A : bc b <> BCinvalid) (B : b' = b) (C : delta = 0)","proofString":"constructor; auto."},{"statement":"(bc : block_classification) (v v' : val) (H : Val.inject (inj_of_bc bc) v v') : vmatch bc v Vtop.","conclusion":"vmatch bc v Vtop","hypotheses":"(bc : block_classification) (v v' : val) (H : Val.inject (inj_of_bc bc) v v')","proofString":"inv H; constructor.\neapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : inj_of_bc bc b1 = Some (b2, delta)) : pmatch bc b1 ofs1 Ptop.","conclusion":"pmatch bc b1 ofs1 Ptop","hypotheses":"(bc : block_classification) (b1 : block) (ofs1 : ptrofs) (b2 : block) (delta : Z) (H0 : inj_of_bc bc b1 = Some (b2, delta))","proofString":"eapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') : mmatch bc m mtop.","conclusion":"mmatch bc m mtop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m')","proofString":"assert (SM: forall b, bc b <> BCinvalid -> smatch bc m b Ptop).\nintros; split; intros.\nexploit Mem.load_inject.\neauto.\neauto.\napply inj_of_bc_valid; auto.\nintros (v' & A & B).\neapply vmatch_inj_top; eauto.\nexploit Mem.loadbytes_inject.\neauto.\neauto.\napply inj_of_bc_valid; auto.\nintros (bytes' & A & B).\ninv B.\ninv H4.\ninv H8.\neapply pmatch_inj_top; eauto.\nconstructor; simpl; intros.\napply ablock_init_sound.\napply SM.\ncongruence.\nrewrite PTree.gempty in H1; discriminate.\napply SM; auto.\napply SM; auto.\nred; intros.\neapply Mem.valid_block_inject_1.\neapply inj_of_bc_valid; eauto.\neauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') : forall b : block, bc b <> BCinvalid -> smatch bc m b Ptop.","conclusion":"forall b : block, bc b <> BCinvalid -> smatch bc m b Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m')","proofString":"intros; split; intros.\nexploit Mem.load_inject.\neauto.\neauto.\napply inj_of_bc_valid; auto.\nintros (v' & A & B).\neapply vmatch_inj_top; eauto.\nexploit Mem.loadbytes_inject.\neauto.\neauto.\napply inj_of_bc_valid; auto.\nintros (bytes' & A & B).\ninv B.\ninv H4.\ninv H8.\neapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v) : vmatch bc v (Ifptr Ptop).","conclusion":"vmatch bc v (Ifptr Ptop)","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v)","proofString":"exploit Mem.load_inject.\neauto.\neauto.\napply inj_of_bc_valid; auto.\nintros (v' & A & B).\neapply vmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v) (v' : val) (A : Mem.load chunk m' b (ofs + 0) = Some v') (B : Val.inject (inj_of_bc bc) v v') : vmatch bc v (Ifptr Ptop).","conclusion":"vmatch bc v (Ifptr Ptop)","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (chunk : memory_chunk) (ofs : Z) (v : val) (H1 : Mem.load chunk m b ofs = Some v) (v' : val) (A : Mem.load chunk m' b (ofs + 0) = Some v') (B : Val.inject (inj_of_bc bc) v v')","proofString":"eapply vmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) : pmatch bc b' ofs' Ptop.","conclusion":"pmatch bc b' ofs' Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil))","proofString":"exploit Mem.loadbytes_inject.\neauto.\neauto.\napply inj_of_bc_valid; auto.\nintros (bytes' & A & B).\ninv B.\ninv H4.\ninv H8.\neapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (bytes' : list memval) (A : Mem.loadbytes m' b (ofs + 0) 1 = Some bytes') (B : list_forall2 (memval_inject (inj_of_bc bc))\n  (Fragment (Vptr b' ofs') q i :: nil) bytes') : pmatch bc b' ofs' Ptop.","conclusion":"pmatch bc b' ofs' Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (bytes' : list memval) (A : Mem.loadbytes m' b (ofs + 0) 1 = Some bytes') (B : list_forall2 (memval_inject (inj_of_bc bc))\n  (Fragment (Vptr b' ofs') q i :: nil) bytes')","proofString":"inv B.\ninv H4.\ninv H8.\neapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b1 : memval) (bl : list memval) (A : Mem.loadbytes m' b (ofs + 0) 1 = Some (b1 :: bl)) (H4 : memval_inject (inj_of_bc bc) (Fragment (Vptr b' ofs') q i) b1) (H6 : list_forall2 (memval_inject (inj_of_bc bc)) nil bl) : pmatch bc b' ofs' Ptop.","conclusion":"pmatch bc b' ofs' Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (b1 : memval) (bl : list memval) (A : Mem.loadbytes m' b (ofs + 0) 1 = Some (b1 :: bl)) (H4 : memval_inject (inj_of_bc bc) (Fragment (Vptr b' ofs') q i) b1) (H6 : list_forall2 (memval_inject (inj_of_bc bc)) nil bl)","proofString":"inv H4.\ninv H8.\neapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (bl : list memval) (v2 : val) (A : Mem.loadbytes m' b (ofs + 0) 1 = Some (Fragment v2 q i :: bl)) (H6 : list_forall2 (memval_inject (inj_of_bc bc)) nil bl) (H8 : Val.inject (inj_of_bc bc) (Vptr b' ofs') v2) : pmatch bc b' ofs' Ptop.","conclusion":"pmatch bc b' ofs' Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (bl : list memval) (v2 : val) (A : Mem.loadbytes m' b (ofs + 0) 1 = Some (Fragment v2 q i :: bl)) (H6 : list_forall2 (memval_inject (inj_of_bc bc)) nil bl) (H8 : Val.inject (inj_of_bc bc) (Vptr b' ofs') v2)","proofString":"inv H8.\neapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (bl : list memval) (b2 : block) (delta : Z) (A : Mem.loadbytes m' b (ofs + 0) 1 =\nSome (Fragment (Vptr b2 (Ptrofs.add ofs' (Ptrofs.repr delta))) q i :: bl)) (H6 : list_forall2 (memval_inject (inj_of_bc bc)) nil bl) (H4 : inj_of_bc bc b' = Some (b2, delta)) : pmatch bc b' ofs' Ptop.","conclusion":"pmatch bc b' ofs' Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (b : block) (H0 : bc b <> BCinvalid) (ofs : Z) (b' : block) (ofs' : ptrofs) (q : quantity) (i : nat) (H1 : Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil)) (bl : list memval) (b2 : block) (delta : Z) (A : Mem.loadbytes m' b (ofs + 0) 1 =\nSome (Fragment (Vptr b2 (Ptrofs.add ofs' (Ptrofs.repr delta))) q i :: bl)) (H6 : list_forall2 (memval_inject (inj_of_bc bc)) nil bl) (H4 : inj_of_bc bc b' = Some (b2, delta))","proofString":"eapply pmatch_inj_top; eauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b : block, bc b <> BCinvalid -> smatch bc m b Ptop) : mmatch bc m mtop.","conclusion":"mmatch bc m mtop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b : block, bc b <> BCinvalid -> smatch bc m b Ptop)","proofString":"constructor; simpl; intros.\napply ablock_init_sound.\napply SM.\ncongruence.\nrewrite PTree.gempty in H1; discriminate.\napply SM; auto.\napply SM; auto.\nred; intros.\neapply Mem.valid_block_inject_1.\neapply inj_of_bc_valid; eauto.\neauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b = BCstack) : bmatch bc m b (ablock_init Ptop).","conclusion":"bmatch bc m b (ablock_init Ptop)","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b = BCstack)","proofString":"apply ablock_init_sound.\napply SM.\ncongruence."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b = BCstack) : smatch bc m b Ptop.","conclusion":"smatch bc m b Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b = BCstack)","proofString":"apply SM.\ncongruence."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b = BCstack) : bc b <> BCinvalid.","conclusion":"bc b <> BCinvalid","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b = BCstack)","proofString":"congruence."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (id : ident) (ab : ablock) (b : block) (H0 : bc b = BCglob id) (H1 : (PTree.empty ablock) ! id = Some ab) : bmatch bc m b ab.","conclusion":"bmatch bc m b ab","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (id : ident) (ab : ablock) (b : block) (H0 : bc b = BCglob id) (H1 : (PTree.empty ablock) ! id = Some ab)","proofString":"rewrite PTree.gempty in H1; discriminate."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b <> BCstack) (H1 : bc b <> BCinvalid) : smatch bc m b Ptop.","conclusion":"smatch bc m b Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b <> BCstack) (H1 : bc b <> BCinvalid)","proofString":"apply SM; auto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b <> BCinvalid) : smatch bc m b Ptop.","conclusion":"smatch bc m b Ptop","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b <> BCinvalid)","proofString":"apply SM; auto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b : block, bc b <> BCinvalid -> smatch bc m b Ptop) : bc_below bc (Mem.nextblock m).","conclusion":"bc_below bc (Mem.nextblock m)","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b : block, bc b <> BCinvalid -> smatch bc m b Ptop)","proofString":"red; intros.\neapply Mem.valid_block_inject_1.\neapply inj_of_bc_valid; eauto.\neauto."},{"statement":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b <> BCinvalid) : Plt b (Mem.nextblock m).","conclusion":"Plt b (Mem.nextblock m)","hypotheses":"(bc : block_classification) (m m' : mem) (H : Mem.inject (inj_of_bc bc) m m') (SM : forall b0 : block, bc b0 <> BCinvalid -> smatch bc m b0 Ptop) (b : block) (H0 : bc b <> BCinvalid)","proofString":"eapply Mem.valid_block_inject_1.\neapply inj_of_bc_valid; eauto.\neauto."},{"statement":"(x y : t) (H : x = y) : eq x y.","conclusion":"eq x y","hypotheses":"(x y : t) (H : x = y)","proofString":"auto."},{"statement":"(x y : t) (H : x = y) : vge x y.","conclusion":"vge x y","hypotheses":"(x y : t) (H : x = y)","proofString":"subst y.\napply vge_refl."},{"statement":"(x : t) : vge x x.","conclusion":"vge x x","hypotheses":"(x : t)","proofString":"apply vge_refl."},{"statement":"(x y z : aval) (H : vge x y) (H0 : vge y z) : vge x z.","conclusion":"vge x z","hypotheses":"(x y z : aval) (H : vge x y) (H0 : vge y z)","proofString":"eapply vge_trans; eauto."},{"statement":"(x : aval) : ge x bot.","conclusion":"ge x bot","hypotheses":"(x : aval)","proofString":"constructor."},{"statement":"(x : aval) : ge top x.","conclusion":"ge top x","hypotheses":"(x : aval)","proofString":"apply vge_top."},{"statement":"(e : regset) (ae1 : aenv) (ae2 : AE.t) (H : ematch e ae1) (H0 : AE.ge ae2 ae1) (r : positive) : vmatch bc e # r (AE.get r ae2).","conclusion":"vmatch bc e # r (AE.get r ae2)","hypotheses":"(e : regset) (ae1 : aenv) (ae2 : AE.t) (H : ematch e ae1) (H0 : AE.ge ae2 ae1) (r : positive)","proofString":"apply vmatch_ge with (AE.get r ae1); auto.\napply H0."},{"statement":"(e : regset) (ae1 : aenv) (ae2 : AE.t) (H : ematch e ae1) (H0 : AE.ge ae2 ae1) (r : positive) : vge (AE.get r ae2) (AE.get r ae1).","conclusion":"vge (AE.get r ae2) (AE.get r ae1)","hypotheses":"(e : regset) (ae1 : aenv) (ae2 : AE.t) (H : ematch e ae1) (H0 : AE.ge ae2 ae1) (r : positive)","proofString":"apply H0."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) : vmatch bc (e # r <- v) # r0 (AE.get r0 (AE.set r av ae)).","conclusion":"vmatch bc (e # r <- v) # r0 (AE.get r0 (AE.set r av ae))","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive)","proofString":"rewrite AE.gsspec.\nrewrite PMap.gsspec.\ndestruct (peq r0 r); auto.\nred; intros.\nspecialize (H xH).\nsubst ae.\nsimpl in H.\ninv H.\nunfold AVal.eq; red; intros.\nsubst av.\ninv H0."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) : vmatch bc (e # r <- v) # r0 (if peq r0 r then av else AE.get r0 ae).","conclusion":"vmatch bc (e # r <- v) # r0 (if peq r0 r then av else AE.get r0 ae)","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive)","proofString":"rewrite PMap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) : vmatch bc (if peq r0 r then v else e # r0)\n  (if peq r0 r then av else AE.get r0 ae).","conclusion":"vmatch bc (if peq r0 r then v else e # r0)\n  (if peq r0 r then av else AE.get r0 ae)","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive)","proofString":"destruct (peq r0 r); auto."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) : ae <> AE.Bot.","conclusion":"ae <> AE.Bot","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive)","proofString":"red; intros.\nspecialize (H xH).\nsubst ae.\nsimpl in H.\ninv H."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) (H1 : ae = AE.Bot) : False.","conclusion":"False","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) (H1 : ae = AE.Bot)","proofString":"specialize (H xH).\nsubst ae.\nsimpl in H.\ninv H."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : vmatch bc e # 1 (AE.get 1 ae)) (H0 : vmatch bc v av) (r0 : positive) (H1 : ae = AE.Bot) : False.","conclusion":"False","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : vmatch bc e # 1 (AE.get 1 ae)) (H0 : vmatch bc v av) (r0 : positive) (H1 : ae = AE.Bot)","proofString":"subst ae.\nsimpl in H.\ninv H."},{"statement":"(e : regset) (v : val) (av : aval) (r : positive) (H : vmatch bc e # 1 (AE.get 1 AE.Bot)) (H0 : vmatch bc v av) (r0 : positive) : False.","conclusion":"False","hypotheses":"(e : regset) (v : val) (av : aval) (r : positive) (H : vmatch bc e # 1 (AE.get 1 AE.Bot)) (H0 : vmatch bc v av) (r0 : positive)","proofString":"simpl in H.\ninv H."},{"statement":"(e : regset) (v : val) (av : aval) (r : positive) (H : vmatch bc e # 1 AVal.bot) (H0 : vmatch bc v av) (r0 : positive) : False.","conclusion":"False","hypotheses":"(e : regset) (v : val) (av : aval) (r : positive) (H : vmatch bc e # 1 AVal.bot) (H0 : vmatch bc v av) (r0 : positive)","proofString":"inv H."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) : ~ AVal.eq av AVal.bot.","conclusion":"~ AVal.eq av AVal.bot","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive)","proofString":"unfold AVal.eq; red; intros.\nsubst av.\ninv H0."},{"statement":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) (H1 : av = AVal.bot) : False.","conclusion":"False","hypotheses":"(e : regset) (ae : aenv) (v : val) (av : aval) (r : positive) (H : ematch e ae) (H0 : vmatch bc v av) (r0 : positive) (H1 : av = AVal.bot)","proofString":"subst av.\ninv H0."},{"statement":"(e : regset) (ae : aenv) (v : val) (r : positive) (H : ematch e ae) (H0 : vmatch bc v AVal.bot) (r0 : positive) : False.","conclusion":"False","hypotheses":"(e : regset) (ae : aenv) (v : val) (r : positive) (H : ematch e ae) (H0 : vmatch bc v AVal.bot) (r0 : positive)","proofString":"inv H0."},{"statement":"(rl : list reg) (ae : aenv) (p : positive) : AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae).","conclusion":"AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)","hypotheses":"(rl : list reg) (ae : aenv) (p : positive)","proofString":"revert rl ae; induction rl; intros; simpl.\napply AVal.ge_refl.\napply AVal.eq_refl.\ndestruct ae.\nunfold AE.get at 2.\napply AVal.ge_bot.\neapply AVal.ge_trans.\napply IHrl.\nrewrite AE.gsspec.\ndestruct (peq p a).\napply AVal.ge_top.\napply AVal.ge_refl.\napply AVal.eq_refl.\ncongruence.\nunfold AVal.eq, Vtop, AVal.bot.\ncongruence."},{"statement":"(p : positive) (ae : aenv) : AVal.ge (AE.get p ae) (AE.get p ae).","conclusion":"AVal.ge (AE.get p ae) (AE.get p ae)","hypotheses":"(p : positive) (ae : aenv)","proofString":"apply AVal.ge_refl.\napply AVal.eq_refl."},{"statement":"(p : positive) (ae : aenv) : AVal.eq (AE.get p ae) (AE.get p ae).","conclusion":"AVal.eq (AE.get p ae) (AE.get p ae)","hypotheses":"(p : positive) (ae : aenv)","proofString":"apply AVal.eq_refl."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae0 : aenv, AVal.ge (AE.get p (eforget rl ae0)) (AE.get p ae0)) (ae : aenv) : AVal.ge (AE.get p (eforget rl (AE.set a Vtop ae))) (AE.get p ae).","conclusion":"AVal.ge (AE.get p (eforget rl (AE.set a Vtop ae))) (AE.get p ae)","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae0 : aenv, AVal.ge (AE.get p (eforget rl ae0)) (AE.get p ae0)) (ae : aenv)","proofString":"destruct ae.\nunfold AE.get at 2.\napply AVal.ge_bot.\neapply AVal.ge_trans.\napply IHrl.\nrewrite AE.gsspec.\ndestruct (peq p a).\napply AVal.ge_top.\napply AVal.ge_refl.\napply AVal.eq_refl.\ncongruence.\nunfold AVal.eq, Vtop, AVal.bot.\ncongruence."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) : AVal.ge (AE.get p (eforget rl (AE.set a Vtop AE.Bot))) (AE.get p AE.Bot).","conclusion":"AVal.ge (AE.get p (eforget rl (AE.set a Vtop AE.Bot))) (AE.get p AE.Bot)","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae))","proofString":"unfold AE.get at 2.\napply AVal.ge_bot."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) : AVal.ge (AE.get p (eforget rl (AE.set a Vtop AE.Bot))) AVal.bot.","conclusion":"AVal.ge (AE.get p (eforget rl (AE.set a Vtop AE.Bot))) AVal.bot","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae))","proofString":"apply AVal.ge_bot."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) : AVal.ge (AE.get p (eforget rl (AE.set a Vtop (AE.Top_except t))))\n  (AE.get p (AE.Top_except t)).","conclusion":"AVal.ge (AE.get p (eforget rl (AE.set a Vtop (AE.Top_except t))))\n  (AE.get p (AE.Top_except t))","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t)","proofString":"eapply AVal.ge_trans.\napply IHrl.\nrewrite AE.gsspec.\ndestruct (peq p a).\napply AVal.ge_top.\napply AVal.ge_refl.\napply AVal.eq_refl.\ncongruence.\nunfold AVal.eq, Vtop, AVal.bot.\ncongruence."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) : AVal.ge (if peq p a then Vtop else AE.get p (AE.Top_except t))\n  (AE.get p (AE.Top_except t)).","conclusion":"AVal.ge (if peq p a then Vtop else AE.get p (AE.Top_except t))\n  (AE.get p (AE.Top_except t))","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t)","proofString":"destruct (peq p a).\napply AVal.ge_top.\napply AVal.ge_refl.\napply AVal.eq_refl."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) (e : p = a) : AVal.ge Vtop (AE.get p (AE.Top_except t)).","conclusion":"AVal.ge Vtop (AE.get p (AE.Top_except t))","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) (e : p = a)","proofString":"apply AVal.ge_top."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) (n : p <> a) : AVal.ge (AE.get p (AE.Top_except t)) (AE.get p (AE.Top_except t)).","conclusion":"AVal.ge (AE.get p (AE.Top_except t)) (AE.get p (AE.Top_except t))","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) (n : p <> a)","proofString":"apply AVal.ge_refl.\napply AVal.eq_refl."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) (n : p <> a) : AVal.eq (AE.get p (AE.Top_except t)) (AE.get p (AE.Top_except t)).","conclusion":"AVal.eq (AE.get p (AE.Top_except t)) (AE.get p (AE.Top_except t))","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) (n : p <> a)","proofString":"apply AVal.eq_refl."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) : AE.Top_except t <> AE.Bot.","conclusion":"AE.Top_except t <> AE.Bot","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t)","proofString":"congruence."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) : ~ AVal.eq Vtop AVal.bot.","conclusion":"~ AVal.eq Vtop AVal.bot","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t)","proofString":"unfold AVal.eq, Vtop, AVal.bot.\ncongruence."},{"statement":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t) : Ifptr Ptop <> Vbot.","conclusion":"Ifptr Ptop <> Vbot","hypotheses":"(p : positive) (a : reg) (rl : list reg) (IHrl : forall ae : aenv, AVal.ge (AE.get p (eforget rl ae)) (AE.get p ae)) (t : PTree.t AVal.t)","proofString":"congruence."},{"statement":"(e : regset) (rl : list reg) (ae : aenv) (H : ematch e ae) : ematch e (eforget rl ae).","conclusion":"ematch e (eforget rl ae)","hypotheses":"(e : regset) (rl : list reg) (ae : aenv) (H : ematch e ae)","proofString":"eapply ematch_ge; eauto.\napply eforget_ge."},{"statement":"(e : regset) (rl : list reg) (ae : aenv) (H : ematch e ae) : AE.ge (eforget rl ae) ae.","conclusion":"AE.ge (eforget rl ae) ae","hypotheses":"(e : regset) (rl : list reg) (ae : aenv) (H : ematch e ae)","proofString":"apply eforget_ge."},{"statement":"(bc bc' : block_classification) (e : regset) (ae : aenv) (H : ematch bc e ae) (H0 : bc_incr bc bc') (r : positive) : vmatch bc' e # r (AE.get r ae).","conclusion":"vmatch bc' e # r (AE.get r ae)","hypotheses":"(bc bc' : block_classification) (e : regset) (ae : aenv) (H : ematch bc e ae) (H0 : bc_incr bc bc') (r : positive)","proofString":"apply vmatch_incr with bc; auto."},{"statement":"True.","conclusion":"True","hypotheses":"","proofString":"auto."},{"statement":"(ae : aenv) (am : amem) : AE.eq ae ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am).","conclusion":"AE.eq ae ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am)","hypotheses":"(ae : aenv) (am : amem)","proofString":"split.\napply AE.eq_refl.\ntauto."},{"statement":"(ae : aenv) (am : amem) : AE.eq ae ae.","conclusion":"AE.eq ae ae","hypotheses":"(ae : aenv) (am : amem)","proofString":"apply AE.eq_refl."},{"statement":"(ae : aenv) (am : amem) : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am.","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am","hypotheses":"(ae : aenv) (am : amem)","proofString":"tauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0) ->\nAE.eq ae0 ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 <-> mmatch bc m am).","conclusion":"AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0) ->\nAE.eq ae0 ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 <-> mmatch bc m am)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"intros [A B].\nsplit.\napply AE.eq_sym; auto.\nintros.\nrewrite B.\ntauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) : AE.eq ae0 ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 <-> mmatch bc m am).","conclusion":"AE.eq ae0 ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 <-> mmatch bc m am)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0)","proofString":"split.\napply AE.eq_sym; auto.\nintros.\nrewrite B.\ntauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) : AE.eq ae0 ae.","conclusion":"AE.eq ae0 ae","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0)","proofString":"apply AE.eq_sym; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 <-> mmatch bc m am.","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am0 <-> mmatch bc m am","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0)","proofString":"intros.\nrewrite B.\ntauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (bc : block_classification) (m : mem) : mmatch bc m am0 <-> mmatch bc m am.","conclusion":"mmatch bc m am0 <-> mmatch bc m am","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (bc : block_classification) (m : mem)","proofString":"rewrite B.\ntauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (bc : block_classification) (m : mem) : mmatch bc m am0 <-> mmatch bc m am0.","conclusion":"mmatch bc m am0 <-> mmatch bc m am0","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (bc : block_classification) (m : mem)","proofString":"tauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) : AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0) ->\nAE.eq ae0 ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 <-> mmatch bc m am1) ->\nAE.eq ae ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am1).","conclusion":"AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0) ->\nAE.eq ae0 ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 <-> mmatch bc m am1) ->\nAE.eq ae ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am1)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem)","proofString":"intros [A B] [C D]; split.\neapply AE.eq_trans; eauto.\nintros.\nrewrite B; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) (C : AE.eq ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 <-> mmatch bc m am1) : AE.eq ae ae1.","conclusion":"AE.eq ae ae1","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) (C : AE.eq ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 <-> mmatch bc m am1)","proofString":"eapply AE.eq_trans; eauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) (C : AE.eq ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 <-> mmatch bc m am1) : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am1.","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am1","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) (C : AE.eq ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 <-> mmatch bc m am1)","proofString":"intros.\nrewrite B; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (C : AE.eq ae0 ae1) (D : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am0 <-> mmatch bc0 m0 am1) (bc : block_classification) (m : mem) : mmatch bc m am <-> mmatch bc m am1.","conclusion":"mmatch bc m am <-> mmatch bc m am1","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (C : AE.eq ae0 ae1) (D : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am0 <-> mmatch bc0 m0 am1) (bc : block_classification) (m : mem)","proofString":"rewrite B; auto."},{"statement":"(H : true = true) : True.","conclusion":"True","hypotheses":"(H : true = true)","proofString":"auto."},{"statement":"(ae : aenv) (am : amem) (H : false = true) : False.","conclusion":"False","hypotheses":"(ae : aenv) (am : amem) (H : false = true)","proofString":"congruence."},{"statement":"(ae : aenv) (am : amem) (H : false = true) : False.","conclusion":"False","hypotheses":"(ae : aenv) (am : amem) (H : false = true)","proofString":"congruence."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H : AE.beq ae ae0 && mbeq am am0 = true) : AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0).","conclusion":"AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H : AE.beq ae ae0 && mbeq am am0 = true)","proofString":"InvBooleans; split.\napply AE.beq_correct; auto.\nintros.\napply mbeq_sound; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H0 : AE.beq ae ae0 = true) (H1 : mbeq am am0 = true) : AE.eq ae ae0.","conclusion":"AE.eq ae ae0","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H0 : AE.beq ae ae0 = true) (H1 : mbeq am am0 = true)","proofString":"apply AE.beq_correct; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H0 : AE.beq ae ae0 = true) (H1 : mbeq am am0 = true) : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0.","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H0 : AE.beq ae ae0 = true) (H1 : mbeq am am0 = true)","proofString":"intros.\napply mbeq_sound; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H0 : AE.beq ae ae0 = true) (H1 : mbeq am am0 = true) (bc : block_classification) (m : mem) : mmatch bc m am <-> mmatch bc m am0.","conclusion":"mmatch bc m am <-> mmatch bc m am0","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (H0 : AE.beq ae ae0 = true) (H1 : mbeq am am0 = true) (bc : block_classification) (m : mem)","proofString":"apply mbeq_sound; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0) ->\nAE.ge ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 -> mmatch bc m am).","conclusion":"AE.eq ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am <-> mmatch bc m am0) ->\nAE.ge ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 -> mmatch bc m am)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"intros [A B]; split.\napply AE.ge_refl; auto.\nintros.\nrewrite B; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) : AE.ge ae ae0.","conclusion":"AE.ge ae ae0","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0)","proofString":"apply AE.ge_refl; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0) : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m am.","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m am","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am <-> mmatch bc m am0)","proofString":"intros.\nrewrite B; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (bc : block_classification) (m : mem) (H : mmatch bc m am0) : mmatch bc m am.","conclusion":"mmatch bc m am","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (A : AE.eq ae ae0) (B : forall (bc0 : block_classification) (m0 : mem),\nmmatch bc0 m0 am <-> mmatch bc0 m0 am0) (bc : block_classification) (m : mem) (H : mmatch bc m am0)","proofString":"rewrite B; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) : AE.ge ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 -> mmatch bc m am) ->\nAE.ge ae0 ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am1 -> mmatch bc m am0) ->\nAE.ge ae ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am1 -> mmatch bc m am).","conclusion":"AE.ge ae ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 -> mmatch bc m am) ->\nAE.ge ae0 ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am1 -> mmatch bc m am0) ->\nAE.ge ae ae1 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am1 -> mmatch bc m am)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem)","proofString":"intros [A B] [C D]; split.\neapply AE.ge_trans; eauto.\neauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.ge ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m am) (C : AE.ge ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am1 -> mmatch bc m am0) : AE.ge ae ae1.","conclusion":"AE.ge ae ae1","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.ge ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m am) (C : AE.ge ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am1 -> mmatch bc m am0)","proofString":"eapply AE.ge_trans; eauto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.ge ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m am) (C : AE.ge ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am1 -> mmatch bc m am0) : forall (bc : block_classification) (m : mem),\nmmatch bc m am1 -> mmatch bc m am.","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am1 -> mmatch bc m am","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) (ae1 : aenv) (am1 : amem) (A : AE.ge ae ae0) (B : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m am) (C : AE.ge ae0 ae1) (D : forall (bc : block_classification) (m : mem),\nmmatch bc m am1 -> mmatch bc m am0)","proofString":"eauto."},{"statement":"ge (lub Bot Bot) Bot.","conclusion":"ge (lub Bot Bot) Bot","hypotheses":"","proofString":"apply ge_refl; apply eq_refl."},{"statement":"(ae : aenv) (am : amem) : ge (lub Bot (State ae am)) Bot.","conclusion":"ge (lub Bot (State ae am)) Bot","hypotheses":"(ae : aenv) (am : amem)","proofString":"simpl.\nauto."},{"statement":"(ae : aenv) (am : amem) : True.","conclusion":"True","hypotheses":"(ae : aenv) (am : amem)","proofString":"auto."},{"statement":"(ae : aenv) (am : amem) : ge (lub (State ae am) Bot) (State ae am).","conclusion":"ge (lub (State ae am) Bot) (State ae am)","hypotheses":"(ae : aenv) (am : amem)","proofString":"apply ge_refl; apply eq_refl."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : ge (lub (State ae am) (State ae0 am0)) (State ae am).","conclusion":"ge (lub (State ae am) (State ae0 am0)) (State ae am)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"simpl.\nsplit.\napply AE.ge_lub_left.\nintros; apply mmatch_lub_l; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : AE.ge (AE.lub ae ae0) ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am -> mmatch bc m (mlub am am0)).","conclusion":"AE.ge (AE.lub ae ae0) ae /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am -> mmatch bc m (mlub am am0))","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"split.\napply AE.ge_lub_left.\nintros; apply mmatch_lub_l; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : AE.ge (AE.lub ae ae0) ae.","conclusion":"AE.ge (AE.lub ae ae0) ae","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"apply AE.ge_lub_left."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : forall (bc : block_classification) (m : mem),\nmmatch bc m am -> mmatch bc m (mlub am am0).","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am -> mmatch bc m (mlub am am0)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"intros; apply mmatch_lub_l; auto."},{"statement":"ge (lub Bot Bot) Bot.","conclusion":"ge (lub Bot Bot) Bot","hypotheses":"","proofString":"apply ge_refl; apply eq_refl."},{"statement":"(ae : aenv) (am : amem) : ge (lub Bot (State ae am)) (State ae am).","conclusion":"ge (lub Bot (State ae am)) (State ae am)","hypotheses":"(ae : aenv) (am : amem)","proofString":"apply ge_refl; apply eq_refl."},{"statement":"(ae : aenv) (am : amem) : ge (lub (State ae am) Bot) Bot.","conclusion":"ge (lub (State ae am) Bot) Bot","hypotheses":"(ae : aenv) (am : amem)","proofString":"simpl.\nauto."},{"statement":"(ae : aenv) (am : amem) : True.","conclusion":"True","hypotheses":"(ae : aenv) (am : amem)","proofString":"auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : ge (lub (State ae am) (State ae0 am0)) (State ae0 am0).","conclusion":"ge (lub (State ae am) (State ae0 am0)) (State ae0 am0)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"simpl.\nsplit.\napply AE.ge_lub_right.\nintros; apply mmatch_lub_r; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : AE.ge (AE.lub ae ae0) ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 -> mmatch bc m (mlub am am0)).","conclusion":"AE.ge (AE.lub ae ae0) ae0 /\\\n(forall (bc : block_classification) (m : mem),\n mmatch bc m am0 -> mmatch bc m (mlub am am0))","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"split.\napply AE.ge_lub_right.\nintros; apply mmatch_lub_r; auto."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : AE.ge (AE.lub ae ae0) ae0.","conclusion":"AE.ge (AE.lub ae ae0) ae0","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"apply AE.ge_lub_right."},{"statement":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem) : forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m (mlub am am0).","conclusion":"forall (bc : block_classification) (m : mem),\nmmatch bc m am0 -> mmatch bc m (mlub am am0)","hypotheses":"(ae : aenv) (am : amem) (ae0 : aenv) (am0 : amem)","proofString":"intros; apply mmatch_lub_r; auto."}]}