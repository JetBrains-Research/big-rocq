{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Constpropproof.v","fileSamples":[{"statement":"(prog : program) : match_prog prog (transf_program prog).","proofString":"eapply match_transform_program_contextual.\nauto."},{"statement":"(prog : program) : forall f : fundef,\ntransf_fundef (romem_for prog) f = transf_fundef (romem_for prog) f.","proofString":"auto."},{"statement":"(v : val) (f : fundef) (H : Genv.find_funct ge v = Some f) : exists cunit : program,\n  Genv.find_funct tge v = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"exploit (Genv.find_funct_match TRANSL); eauto.\nintros (cu & tf & A & B & C).\nsubst tf.\nexists cu; auto."},{"statement":"(v : val) (f : fundef) (H : Genv.find_funct ge v = Some f) : (exists (cunit : AST.program fundef unit) (tf : fundef),\n   Genv.find_funct (Genv.globalenv tprog) v = Some tf /\\\n   tf = transf_fundef (romem_for cunit) f /\\ linkorder cunit prog) ->\nexists cunit : program,\n  Genv.find_funct tge v = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"intros (cu & tf & A & B & C).\nsubst tf.\nexists cu; auto."},{"statement":"(v : val) (f : fundef) (H : Genv.find_funct ge v = Some f) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct (Genv.globalenv tprog) v = Some tf) (B : tf = transf_fundef (romem_for cu) f) (C : linkorder cu prog) : exists cunit : program,\n  Genv.find_funct tge v = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"subst tf.\nexists cu; auto."},{"statement":"(v : val) (f : fundef) (H : Genv.find_funct ge v = Some f) (cu : AST.program fundef unit) (A : Genv.find_funct (Genv.globalenv tprog) v =\nSome (transf_fundef (romem_for cu) f)) (C : linkorder cu prog) : exists cunit : program,\n  Genv.find_funct tge v = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"exists cu; auto."},{"statement":"(b : block) (f : fundef) (H : Genv.find_funct_ptr ge b = Some f) : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"exploit (Genv.find_funct_ptr_match TRANSL); eauto.\nintros (cu & tf & A & B & C).\nsubst tf.\nexists cu; auto."},{"statement":"(b : block) (f : fundef) (H : Genv.find_funct_ptr ge b = Some f) : (exists (cunit : AST.program fundef unit) (tf : fundef),\n   Genv.find_funct_ptr (Genv.globalenv tprog) b = Some tf /\\\n   tf = transf_fundef (romem_for cunit) f /\\ linkorder cunit prog) ->\nexists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"intros (cu & tf & A & B & C).\nsubst tf.\nexists cu; auto."},{"statement":"(b : block) (f : fundef) (H : Genv.find_funct_ptr ge b = Some f) (cu : AST.program fundef unit) (tf : fundef) (A : Genv.find_funct_ptr (Genv.globalenv tprog) b = Some tf) (B : tf = transf_fundef (romem_for cu) f) (C : linkorder cu prog) : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"subst tf.\nexists cu; auto."},{"statement":"(b : block) (f : fundef) (H : Genv.find_funct_ptr ge b = Some f) (cu : AST.program fundef unit) (A : Genv.find_funct_ptr (Genv.globalenv tprog) b =\nSome (transf_fundef (romem_for cu) f)) (C : linkorder cu prog) : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"exists cu; auto."},{"statement":"(rm : romem) (f : fundef) : funsig (transf_fundef rm f) = funsig f.","proofString":"destruct f; reflexivity."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) : regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef).","proofString":"red; intros.\nrewrite Regmap.gi.\nauto."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) (r : positive) : Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) (r : positive) : Val.lessdef Vundef Vundef.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl0 vl3 : list val,\nVal.lessdef_list vl0 vl3 ->\nregs_lessdef (init_regs vl0 rl) (init_regs vl3 rl)) (vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) : regs_lessdef\n  match vl1 with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end\n  match vl2 with\n  | nil => Regmap.init Vundef\n  | v1 :: vs => (init_regs vs rl) # a <- v1\n  end.","proofString":"inv H.\nred; intros.\nrewrite Regmap.gi.\nauto.\napply set_reg_lessdef; auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) : regs_lessdef (Regmap.init Vundef) (Regmap.init Vundef).","proofString":"red; intros.\nrewrite Regmap.gi.\nauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) (r : positive) : Val.lessdef (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) (r : positive) : Val.lessdef Vundef Vundef.","proofString":"auto."},{"statement":"(a : reg) (rl : list reg) (IHrl : forall vl1 vl2 : list val,\nVal.lessdef_list vl1 vl2 ->\nregs_lessdef (init_regs vl1 rl) (init_regs vl2 rl)) (v1 v2 : val) (vl0 vl3 : list val) (H0 : Val.lessdef v1 v2) (H1 : Val.lessdef_list vl0 vl3) : regs_lessdef (init_regs vl0 rl) # a <- v1 (init_regs vl3 rl) # a <- v2.","proofString":"apply set_reg_lessdef; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (ros : reg + ident) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : find_function ge ros rs = Some f) (RLD : regs_lessdef rs rs') : exists cunit : program,\n  find_function tge (transf_ros ae ros) rs' =\n  Some (transf_fundef (romem_for cunit) f) /\\ linkorder cunit prog.","proofString":"destruct ros; simpl in *.\ngeneralize (EM r); fold (areg ae r); intro VM.\ngeneralize (RLD r); intro LD.\nassert (DEFAULT:    exists cunit,       find_function tge (inl _ r) rs' = Some (transf_fundef (romem_for cunit) f)    /\\ linkorder cunit prog).\nsimpl.\ninv LD.\napply functions_translated; auto.\nrewrite <- H0 in FF; discriminate.\ndestruct (areg ae r); auto.\ndestruct p; auto.\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i) as [b|]; try discriminate.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') : exists cunit : program,\n  find_function tge\n    match areg ae r with\n    | Ptr (Gl symb ofs) =>\n        if Ptrofs.eq ofs Ptrofs.zero then inr symb else inl r\n    | _ => inl r\n    end rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"generalize (EM r); fold (areg ae r); intro VM.\ngeneralize (RLD r); intro LD.\nassert (DEFAULT:    exists cunit,       find_function tge (inl _ r) rs' = Some (transf_fundef (romem_for cunit) f)    /\\ linkorder cunit prog).\nsimpl.\ninv LD.\napply functions_translated; auto.\nrewrite <- H0 in FF; discriminate.\ndestruct (areg ae r); auto.\ndestruct p; auto.\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) : exists cunit : program,\n  find_function tge\n    match areg ae r with\n    | Ptr (Gl symb ofs) =>\n        if Ptrofs.eq ofs Ptrofs.zero then inr symb else inl r\n    | _ => inl r\n    end rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"generalize (RLD r); intro LD.\nassert (DEFAULT:    exists cunit,       find_function tge (inl _ r) rs' = Some (transf_fundef (romem_for cunit) f)    /\\ linkorder cunit prog).\nsimpl.\ninv LD.\napply functions_translated; auto.\nrewrite <- H0 in FF; discriminate.\ndestruct (areg ae r); auto.\ndestruct p; auto.\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) (LD : Val.lessdef rs # r rs' # r) : exists cunit : program,\n  find_function tge\n    match areg ae r with\n    | Ptr (Gl symb ofs) =>\n        if Ptrofs.eq ofs Ptrofs.zero then inr symb else inl r\n    | _ => inl r\n    end rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"assert (DEFAULT:    exists cunit,       find_function tge (inl _ r) rs' = Some (transf_fundef (romem_for cunit) f)    /\\ linkorder cunit prog).\nsimpl.\ninv LD.\napply functions_translated; auto.\nrewrite <- H0 in FF; discriminate.\ndestruct (areg ae r); auto.\ndestruct p; auto.\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) (LD : Val.lessdef rs # r rs' # r) : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"simpl.\ninv LD.\napply functions_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) (LD : Val.lessdef rs # r rs' # r) : exists cunit : program,\n  Genv.find_funct tge rs' # r = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"inv LD.\napply functions_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) (H1 : rs # r = rs' # r) : exists cunit : program,\n  Genv.find_funct tge rs # r = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"apply functions_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) (H0 : Vundef = rs # r) : exists cunit : program,\n  Genv.find_funct tge rs' # r = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"rewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (areg ae r)) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) : exists cunit : program,\n  find_function tge\n    match areg ae r with\n    | Ptr (Gl symb ofs) =>\n        if Ptrofs.eq ofs Ptrofs.zero then inr symb else inl r\n    | _ => inl r\n    end rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"destruct (areg ae r); auto.\ndestruct p; auto.\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (p : aptr) (VM : vmatch bc rs # r (Ptr p)) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) : exists cunit : program,\n  find_function tge\n    match p with\n    | Gl symb ofs => if Ptrofs.eq ofs Ptrofs.zero then inr symb else inl r\n    | _ => inl r\n    end rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"destruct p; auto.\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (ofs : ptrofs) (VM : vmatch bc rs # r (Ptr (Gl id ofs))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) : exists cunit : program,\n  find_function tge (if Ptrofs.eq ofs Ptrofs.zero then inr id else inl r) rs' =\n  Some (transf_fundef (romem_for cunit) f) /\\ linkorder cunit prog.","proofString":"predSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.\nsubst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (ofs : ptrofs) (VM : vmatch bc rs # r (Ptr (Gl id ofs))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H : ofs = Ptrofs.zero) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"subst ofs.\nexploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"exploit vmatch_ptr_gl; eauto.\nintros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) : Val.lessdef rs # r (Genv.symbol_address ge id Ptrofs.zero) ->\nexists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"intros LD'.\ninv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (LD' : Val.lessdef rs # r (Genv.symbol_address ge id Ptrofs.zero)) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"inv LD'; try discriminate.\nrewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto.\nrewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"rewrite H1 in FF.\nunfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (FF : Genv.find_funct ge (Genv.symbol_address ge id Ptrofs.zero) = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"unfold Genv.symbol_address in FF.\nsimpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (FF : Genv.find_funct ge\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b Ptrofs.zero\n  | None => Vundef\n  end = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"simpl.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (FF : Genv.find_funct ge\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b Ptrofs.zero\n  | None => Vundef\n  end = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  match Genv.find_symbol tge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some (transf_fundef (romem_for cunit) f) /\\ \n  linkorder cunit prog.","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (FF : Genv.find_funct ge\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b Ptrofs.zero\n  | None => Vundef\n  end = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  match Genv.find_symbol ge id with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some (transf_fundef (romem_for cunit) f) /\\ \n  linkorder cunit prog.","proofString":"destruct (Genv.find_symbol ge id) as [b|]; try discriminate.\nsimpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (b : block) (FF : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"simpl in FF.\nrewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (b : block) (FF : (if Ptrofs.eq_dec Ptrofs.zero Ptrofs.zero\n then Genv.find_funct_ptr ge b\n else None) = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"rewrite dec_eq_true in FF.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (id : ident) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (RLD : regs_lessdef rs rs') (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H1 : rs # r = Genv.symbol_address ge id Ptrofs.zero) : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"apply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (r : reg) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : Genv.find_funct ge rs # r = Some f) (RLD : regs_lessdef rs rs') (id : ident) (VM : vmatch bc rs # r (Ptr (Gl id Ptrofs.zero))) (LD : Val.lessdef rs # r rs' # r) (DEFAULT : exists cunit : program,\n  find_function tge (inl r) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog) (H0 : Vundef = rs # r) : exists cunit : program,\n  find_function tge (inr id) rs' = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"rewrite <- H0 in FF; discriminate."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (i : ident) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) (RLD : regs_lessdef rs rs') : exists cunit : program,\n  match Genv.find_symbol tge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some (transf_fundef (romem_for cunit) f) /\\ \n  linkorder cunit prog.","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i) as [b|]; try discriminate.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (i : ident) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (FF : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) (RLD : regs_lessdef rs rs') : exists cunit : program,\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some (transf_fundef (romem_for cunit) f) /\\ \n  linkorder cunit prog.","proofString":"destruct (Genv.find_symbol ge i) as [b|]; try discriminate.\napply function_ptr_translated; auto."},{"statement":"(bc : block_classification) (rs : regset) (ae : aenv) (i : ident) (f : fundef) (rs' : Regmap.t val) (GE : genv_match bc ge) (EM : ematch bc rs ae) (b : block) (FF : Genv.find_funct_ptr ge b = Some f) (RLD : regs_lessdef rs rs') : exists cunit : program,\n  Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cunit) f) /\\\n  linkorder cunit prog.","proofString":"apply function_ptr_translated; auto."},{"statement":"(a : aval) (op : operation) (bc : block_classification) (v : val) (sp : block) (m : mem) (H : const_for_result a = Some op) (H0 : vmatch bc v a) (H1 : bc sp = BCstack) (H2 : genv_match bc ge) : exists v' : val,\n  eval_operation tge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\\n  Val.lessdef v v'.","proofString":"exploit ConstpropOpproof.const_for_result_correct; eauto.\nintros (v' & A & B).\nexists v'; split.\nrewrite <- A; apply eval_operation_preserved.\nexact symbols_preserved.\nauto."},{"statement":"(a : aval) (op : operation) (bc : block_classification) (v : val) (sp : block) (m : mem) (H : const_for_result a = Some op) (H0 : vmatch bc v a) (H1 : bc sp = BCstack) (H2 : genv_match bc ge) (v' : val) (A : eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v') (B : Val.lessdef v v') : forall s : ident, Genv.find_symbol tge s = Genv.find_symbol ge s.","proofString":"exact symbols_preserved."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (pc : node) : match_pc f rs m 0 pc pc.","proofString":"apply match_pc_base."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) : match_pc f rs m (S n) pc\n  match (fn_code f) ! pc with\n  | Some (Inop s) => successor_rec n f ae s\n  | Some (Icond cond args s1 s2) =>\n      match resolve_branch (eval_static_condition cond (aregs ae args)) with\n      | Some b => successor_rec n f ae (if b then s1 else s2)\n      | None => pc\n      end\n  | _ => pc\n  end.","proofString":"destruct (fn_code f)!pc as [[]|] eqn:INSTR; try apply match_pc_base.\neapply match_pc_nop; eauto.\ndestruct (resolve_branch (eval_static_condition c (aregs ae l))) as [b|] eqn:STATIC;  try apply match_pc_base.\neapply match_pc_cond; eauto.\nintros b' DYNAMIC.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto.\nsubst b'.\napply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc n0 : node) (INSTR : (fn_code f) ! pc = Some (Inop n0)) : match_pc f rs m (S n) pc (successor_rec n f ae n0).","proofString":"eapply match_pc_nop; eauto."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) : match_pc f rs m (S n) pc\n  match resolve_branch (eval_static_condition c (aregs ae l)) with\n  | Some b => successor_rec n f ae (if b then n0 else n1)\n  | None => pc\n  end.","proofString":"destruct (resolve_branch (eval_static_condition c (aregs ae l))) as [b|] eqn:STATIC;  try apply match_pc_base.\neapply match_pc_cond; eauto.\nintros b' DYNAMIC.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto.\nsubst b'.\napply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) : match_pc f rs m (S n) pc (successor_rec n f ae (if b then n0 else n1)).","proofString":"eapply match_pc_cond; eauto.\nintros b' DYNAMIC.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto.\nsubst b'.\napply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) : forall b0 : bool,\neval_condition c rs ## l m = Some b0 ->\nmatch_pc f rs m n (if b0 then n0 else n1)\n  (successor_rec n f ae (if b then n0 else n1)).","proofString":"intros b' DYNAMIC.\nassert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto.\nsubst b'.\napply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (b' : bool) (DYNAMIC : eval_condition c rs ## l m = Some b') : match_pc f rs m n (if b' then n0 else n1)\n  (successor_rec n f ae (if b then n0 else n1)).","proofString":"assert (b = b').\neapply resolve_branch_sound; eauto.\nrewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto.\nsubst b'.\napply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (b' : bool) (DYNAMIC : eval_condition c rs ## l m = Some b') : b = b'.","proofString":"eapply resolve_branch_sound; eauto.\nrewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (b' : bool) (DYNAMIC : eval_condition c rs ## l m = Some b') : cmatch (Some b') (eval_static_condition c (aregs ae l)).","proofString":"rewrite <- DYNAMIC.\napply eval_static_condition_sound with bc.\napply aregs_sound; auto."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (b' : bool) (DYNAMIC : eval_condition c rs ## l m = Some b') : cmatch (eval_condition c rs ## l m) (eval_static_condition c (aregs ae l)).","proofString":"apply eval_static_condition_sound with bc.\napply aregs_sound; auto."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (b' : bool) (DYNAMIC : eval_condition c rs ## l m = Some b') : list_forall2 (vmatch bc) rs ## l (aregs ae l).","proofString":"apply aregs_sound; auto."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (b' : bool) (DYNAMIC : eval_condition c rs ## l m = Some b') (H0 : b = b') : match_pc f rs m n (if b' then n0 else n1)\n  (successor_rec n f ae (if b then n0 else n1)).","proofString":"subst b'.\napply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (H : ematch bc rs ae) (n : nat) (IHn : forall pc0 : node, match_pc f rs m n pc0 (successor_rec n f ae pc0)) (pc : node) (c : condition) (l : list reg) (n0 n1 : node) (INSTR : (fn_code f) ! pc = Some (Icond c l n0 n1)) (b : bool) (STATIC : resolve_branch (eval_static_condition c (aregs ae l)) = Some b) (DYNAMIC : eval_condition c rs ## l m = Some b) : match_pc f rs m n (if b then n0 else n1)\n  (successor_rec n f ae (if b then n0 else n1)).","proofString":"apply IHn."},{"statement":"(f : function) (rs : regset) (m : mem) (bc : block_classification) (ae : aenv) (pc : node) (H : ematch bc rs ae) : match_pc f rs m num_iter pc (successor f ae pc).","proofString":"eapply match_successor_rec; eauto."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (x : positive) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  match areg ae x with\n  | I n => BA_int n\n  | L n => BA_long n\n  | F n => if Compopts.generate_float_constants tt then BA_float n else BA x\n  | FS n =>\n      if Compopts.generate_float_constants tt then BA_single n else BA x\n  | _ => BA x\n  end rs # x.","proofString":"specialize (H x).\nunfold areg.\ndestruct (AE.get x ae); try constructor.\ninv H.\nconstructor.\ninv H.\nconstructor.\ndestruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor.\ndestruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (H : vmatch bc rs # x (AE.get x ae)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  match areg ae x with\n  | I n => BA_int n\n  | L n => BA_long n\n  | F n => if Compopts.generate_float_constants tt then BA_float n else BA x\n  | FS n =>\n      if Compopts.generate_float_constants tt then BA_single n else BA x\n  | _ => BA x\n  end rs # x.","proofString":"unfold areg.\ndestruct (AE.get x ae); try constructor.\ninv H.\nconstructor.\ninv H.\nconstructor.\ndestruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor.\ndestruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (H : vmatch bc rs # x (AE.get x ae)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  match AE.get x ae with\n  | I n => BA_int n\n  | L n => BA_long n\n  | F n => if Compopts.generate_float_constants tt then BA_float n else BA x\n  | FS n =>\n      if Compopts.generate_float_constants tt then BA_single n else BA x\n  | _ => BA x\n  end rs # x.","proofString":"destruct (AE.get x ae); try constructor.\ninv H.\nconstructor.\ninv H.\nconstructor.\ndestruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor.\ndestruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (n : int) (H : vmatch bc rs # x (I n)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_int n) rs # x.","proofString":"inv H.\nconstructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (n : int) (H1 : Vint n = rs # x) : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_int n) (Vint n).","proofString":"constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (n : int64) (H : vmatch bc rs # x (L n)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_long n) rs # x.","proofString":"inv H.\nconstructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (n : int64) (H1 : Vlong n = rs # x) : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_long n) (Vlong n).","proofString":"constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (f : float) (H : vmatch bc rs # x (F f)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (if Compopts.generate_float_constants tt then BA_float f else BA x) \n  rs # x.","proofString":"destruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (x : positive) (f : float32) (H : vmatch bc rs # x (FS f)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (if Compopts.generate_float_constants tt then BA_single f else BA x) \n  rs # x.","proofString":"destruct (Compopts.generate_float_constants tt); [inv H|idtac]; constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (hi lo : builtin_arg positive) (vhi vlo : val) (H0_ : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0_0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (builtin_arg_reduction ae hi) vhi) (IHeval_builtin_arg2 : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (builtin_arg_reduction ae lo) vlo) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  match builtin_arg_reduction ae hi with\n  | BA x => BA_splitlong (BA x) (builtin_arg_reduction ae lo)\n  | BA_int nhi =>\n      match builtin_arg_reduction ae lo with\n      | BA x => BA_splitlong (BA_int nhi) (BA x)\n      | BA_int nlo => BA_long (Int64.ofwords nhi nlo)\n      | BA_long n => BA_splitlong (BA_int nhi) (BA_long n)\n      | BA_float f => BA_splitlong (BA_int nhi) (BA_float f)\n      | BA_single f => BA_splitlong (BA_int nhi) (BA_single f)\n      | BA_loadstack chunk ofs =>\n          BA_splitlong (BA_int nhi) (BA_loadstack chunk ofs)\n      | BA_addrstack ofs => BA_splitlong (BA_int nhi) (BA_addrstack ofs)\n      | BA_loadglobal chunk id ofs =>\n          BA_splitlong (BA_int nhi) (BA_loadglobal chunk id ofs)\n      | BA_addrglobal id ofs =>\n          BA_splitlong (BA_int nhi) (BA_addrglobal id ofs)\n      | BA_splitlong hi0 lo0 =>\n          BA_splitlong (BA_int nhi) (BA_splitlong hi0 lo0)\n      | BA_addptr a1 a2 => BA_splitlong (BA_int nhi) (BA_addptr a1 a2)\n      end\n  | BA_long n => BA_splitlong (BA_long n) (builtin_arg_reduction ae lo)\n  | BA_float f => BA_splitlong (BA_float f) (builtin_arg_reduction ae lo)\n  | BA_single f => BA_splitlong (BA_single f) (builtin_arg_reduction ae lo)\n  | BA_loadstack chunk ofs =>\n      BA_splitlong (BA_loadstack chunk ofs) (builtin_arg_reduction ae lo)\n  | BA_addrstack ofs =>\n      BA_splitlong (BA_addrstack ofs) (builtin_arg_reduction ae lo)\n  | BA_loadglobal chunk id ofs =>\n      BA_splitlong (BA_loadglobal chunk id ofs) (builtin_arg_reduction ae lo)\n  | BA_addrglobal id ofs =>\n      BA_splitlong (BA_addrglobal id ofs) (builtin_arg_reduction ae lo)\n  | BA_splitlong hi0 lo0 =>\n      BA_splitlong (BA_splitlong hi0 lo0) (builtin_arg_reduction ae lo)\n  | BA_addptr a1 a2 =>\n      BA_splitlong (BA_addptr a1 a2) (builtin_arg_reduction ae lo)\n  end (Val.longofwords vhi vlo).","proofString":"destruct (builtin_arg_reduction ae hi); auto with barg.\ndestruct (builtin_arg_reduction ae lo); auto with barg.\ninv IHeval_builtin_arg1; inv IHeval_builtin_arg2.\nconstructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (hi lo : builtin_arg positive) (vhi vlo : val) (H0_ : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0_0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (n : int) (IHeval_builtin_arg1 : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_int n) vhi) (IHeval_builtin_arg2 : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (builtin_arg_reduction ae lo) vlo) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  match builtin_arg_reduction ae lo with\n  | BA x => BA_splitlong (BA_int n) (BA x)\n  | BA_int nlo => BA_long (Int64.ofwords n nlo)\n  | BA_long n0 => BA_splitlong (BA_int n) (BA_long n0)\n  | BA_float f => BA_splitlong (BA_int n) (BA_float f)\n  | BA_single f => BA_splitlong (BA_int n) (BA_single f)\n  | BA_loadstack chunk ofs =>\n      BA_splitlong (BA_int n) (BA_loadstack chunk ofs)\n  | BA_addrstack ofs => BA_splitlong (BA_int n) (BA_addrstack ofs)\n  | BA_loadglobal chunk id ofs =>\n      BA_splitlong (BA_int n) (BA_loadglobal chunk id ofs)\n  | BA_addrglobal id ofs => BA_splitlong (BA_int n) (BA_addrglobal id ofs)\n  | BA_splitlong hi0 lo0 => BA_splitlong (BA_int n) (BA_splitlong hi0 lo0)\n  | BA_addptr a1 a2 => BA_splitlong (BA_int n) (BA_addptr a1 a2)\n  end (Val.longofwords vhi vlo).","proofString":"destruct (builtin_arg_reduction ae lo); auto with barg.\ninv IHeval_builtin_arg1; inv IHeval_builtin_arg2.\nconstructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (hi lo : builtin_arg positive) (vhi vlo : val) (H0_ : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0_0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (n : int) (IHeval_builtin_arg1 : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_int n) vhi) (n0 : int) (IHeval_builtin_arg2 : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA_int n0) vlo) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (BA_long (Int64.ofwords n n0)) (Val.longofwords vhi vlo).","proofString":"inv IHeval_builtin_arg1; inv IHeval_builtin_arg2.\nconstructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (hi lo : builtin_arg positive) (n : int) (H0_ : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi (Vint n)) (n0 : int) (H0_0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo (Vint n0)) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (BA_long (Int64.ofwords n n0)) (Val.longofwords (Vint n) (Vint n0)).","proofString":"constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (a : builtin_arg positive) (v : val) (c : builtin_arg_constraint) (H : ematch bc rs ae) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a v) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (builtin_arg_strength_reduction ae a c) v.","proofString":"unfold builtin_arg_strength_reduction.\ndestruct (builtin_arg_ok (builtin_arg_reduction ae a) c).\neapply builtin_arg_reduction_correct; eauto.\nauto."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (a : builtin_arg positive) (v : val) (c : builtin_arg_constraint) (H : ematch bc rs ae) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a v) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (if builtin_arg_ok (builtin_arg_reduction ae a) c\n   then builtin_arg_reduction ae a\n   else a) v.","proofString":"destruct (builtin_arg_ok (builtin_arg_reduction ae a) c).\neapply builtin_arg_reduction_correct; eauto.\nauto."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (a : builtin_arg positive) (v : val) (c : builtin_arg_constraint) (H : ematch bc rs ae) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a v) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (builtin_arg_reduction ae a) v.","proofString":"eapply builtin_arg_reduction_correct; eauto."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (a : builtin_arg positive) (v : val) (c : builtin_arg_constraint) (H : ematch bc rs ae) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a v) : eval_builtin_arg ge (fun r : positive => rs # r) sp m a v.","proofString":"auto."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H1 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall cl0 : list builtin_arg_constraint,\neval_builtin_args ge (fun r : positive => rs # r) sp m\n  (builtin_args_strength_reduction ae al cl0) bl) (cl : list builtin_arg_constraint) : eval_builtin_arg ge (fun r : positive => rs # r) sp m\n  (builtin_arg_strength_reduction ae a1 (hd OK_default cl)) b1.","proofString":"eapply builtin_arg_strength_reduction_correct; eauto."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H1 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall cl0 : list builtin_arg_constraint,\neval_builtin_args ge (fun r : positive => rs # r) sp m\n  (builtin_args_strength_reduction ae al cl0) bl) (cl : list builtin_arg_constraint) : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m)\n  (builtin_args_strength_reduction ae al (tl cl)) bl.","proofString":"apply IHlist_forall2."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m nil vl'.","proofString":"exists (@nil val); constructor."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H1 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (debug_strength_reduction ae al) vl') : exists vl' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    match a1 with\n    | BA _ =>\n        match builtin_arg_reduction ae a1 with\n        | BA_int _ | BA_long _ | BA_float _ | BA_single _ =>\n            builtin_arg_reduction ae a1\n            :: a1 :: debug_strength_reduction ae al\n        | _ => a1 :: debug_strength_reduction ae al\n        end\n    | _ => a1 :: debug_strength_reduction ae al\n    end vl'.","proofString":"destruct IHlist_forall2 as (vl' & A).\nassert (eval_builtin_args ge (fun r => rs#r) sp m             (a1 :: debug_strength_reduction ae al) (b1 :: vl'))  by (constructor; eauto).\ndestruct a1; try (econstructor; eassumption).\ndestruct (builtin_arg_reduction ae (BA x)); repeat (eauto; econstructor)."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H1 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (vl' : list val) (A : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (debug_strength_reduction ae al) vl') : exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    match a1 with\n    | BA _ =>\n        match builtin_arg_reduction ae a1 with\n        | BA_int _ | BA_long _ | BA_float _ | BA_single _ =>\n            builtin_arg_reduction ae a1\n            :: a1 :: debug_strength_reduction ae al\n        | _ => a1 :: debug_strength_reduction ae al\n        end\n    | _ => a1 :: debug_strength_reduction ae al\n    end vl'0.","proofString":"assert (eval_builtin_args ge (fun r => rs#r) sp m             (a1 :: debug_strength_reduction ae al) (b1 :: vl'))  by (constructor; eauto).\ndestruct a1; try (econstructor; eassumption).\ndestruct (builtin_arg_reduction ae (BA x)); repeat (eauto; econstructor)."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H1 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (vl' : list val) (A : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (debug_strength_reduction ae al) vl') (H2 : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (a1 :: debug_strength_reduction ae al) (b1 :: vl')) : exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    match a1 with\n    | BA _ =>\n        match builtin_arg_reduction ae a1 with\n        | BA_int _ | BA_long _ | BA_float _ | BA_single _ =>\n            builtin_arg_reduction ae a1\n            :: a1 :: debug_strength_reduction ae al\n        | _ => a1 :: debug_strength_reduction ae al\n        end\n    | _ => a1 :: debug_strength_reduction ae al\n    end vl'0.","proofString":"destruct a1; try (econstructor; eassumption).\ndestruct (builtin_arg_reduction ae (BA x)); repeat (eauto; econstructor)."},{"statement":"(bc : block_classification) (sp : val) (m : mem) (rs : regset) (ae : aenv) (H : ematch bc rs ae) (x : positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m (BA x) b1) (H1 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (vl' : list val) (A : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (debug_strength_reduction ae al) vl') (H2 : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (BA x :: debug_strength_reduction ae al) (b1 :: vl')) : exists vl'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    match builtin_arg_reduction ae (BA x) with\n    | BA_int _ | BA_long _ | BA_float _ | BA_single _ =>\n        builtin_arg_reduction ae (BA x)\n        :: BA x :: debug_strength_reduction ae al\n    | _ => BA x :: debug_strength_reduction ae al\n    end vl'0.","proofString":"destruct (builtin_arg_reduction ae (BA x)); repeat (eauto; econstructor)."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (ef : external_function) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') : exists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_strength_reduction ae ef args) vargs' /\\\n  external_call ef ge vargs' m t vres m'.","proofString":"assert (DEFAULT: forall cl,    exists vargs',       eval_builtin_args ge (fun r => rs#r) sp m (builtin_args_strength_reduction ae args cl) vargs'    /\\ external_call ef ge vargs' m t vres m').\nexists vargs; split; auto.\neapply builtin_args_strength_reduction_correct; eauto.\nunfold builtin_strength_reduction.\ndestruct ef; auto.\nexploit debug_strength_reduction_correct; eauto.\nintros (vargs' & P).\nexists vargs'; split; auto.\ninv H1; constructor."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (ef : external_function) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') : forall cl : list builtin_arg_constraint,\nexists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs' /\\\n  external_call ef ge vargs' m t vres m'.","proofString":"exists vargs; split; auto.\neapply builtin_args_strength_reduction_correct; eauto."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (ef : external_function) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (cl : list builtin_arg_constraint) : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (builtin_args_strength_reduction ae args cl) vargs.","proofString":"eapply builtin_args_strength_reduction_correct; eauto."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (ef : external_function) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (DEFAULT : forall cl : list builtin_arg_constraint,\nexists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs' /\\\n  external_call ef ge vargs' m t vres m') : exists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_strength_reduction ae ef args) vargs' /\\\n  external_call ef ge vargs' m t vres m'.","proofString":"unfold builtin_strength_reduction.\ndestruct ef; auto.\nexploit debug_strength_reduction_correct; eauto.\nintros (vargs' & P).\nexists vargs'; split; auto.\ninv H1; constructor."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (ef : external_function) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (DEFAULT : forall cl : list builtin_arg_constraint,\nexists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs' /\\\n  external_call ef ge vargs' m t vres m') : exists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    match ef with\n    | EF_debug _ _ _ => debug_strength_reduction ae args\n    | _ =>\n        builtin_args_strength_reduction ae args\n          (Machregs.builtin_constraints ef)\n    end vargs' /\\ external_call ef ge vargs' m t vres m'.","proofString":"destruct ef; auto.\nexploit debug_strength_reduction_correct; eauto.\nintros (vargs' & P).\nexists vargs'; split; auto.\ninv H1; constructor."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_debug kind text targs) ge vargs m t vres m') (DEFAULT : forall cl : list builtin_arg_constraint,\nexists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m t vres m') : exists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (debug_strength_reduction ae args) vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m t vres m'.","proofString":"exploit debug_strength_reduction_correct; eauto.\nintros (vargs' & P).\nexists vargs'; split; auto.\ninv H1; constructor."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_debug kind text targs) ge vargs m t vres m') (DEFAULT : forall cl : list builtin_arg_constraint,\nexists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m t vres m') : (exists vl' : list val,\n   eval_builtin_args ge (fun r : positive => rs # r) sp m\n     (debug_strength_reduction ae args) vl') ->\nexists vargs' : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (debug_strength_reduction ae args) vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m t vres m'.","proofString":"intros (vargs' & P).\nexists vargs'; split; auto.\ninv H1; constructor."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_debug kind text targs) ge vargs m t vres m') (DEFAULT : forall cl : list builtin_arg_constraint,\nexists vargs'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m t vres m') (vargs' : list val) (P : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (debug_strength_reduction ae args) vargs') : exists vargs'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (debug_strength_reduction ae args) vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m t vres m'.","proofString":"exists vargs'; split; auto.\ninv H1; constructor."},{"statement":"(sp : val) (bc : block_classification) (ae : aenv) (rs : regset) (kind : positive) (text : ident) (targs : list typ) (args : list (builtin_arg positive)) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : ematch bc rs ae) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call (EF_debug kind text targs) ge vargs m t vres m') (DEFAULT : forall cl : list builtin_arg_constraint,\nexists vargs'0 : list val,\n  eval_builtin_args ge (fun r : positive => rs # r) sp m\n    (builtin_args_strength_reduction ae args cl) vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m t vres m') (vargs' : list val) (P : eval_builtin_args ge (fun r : positive => rs # r) sp m\n  (debug_strength_reduction ae args) vargs') : external_call (EF_debug kind text targs) ge vargs' m t vres m'.","proofString":"inv H1; constructor."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (rs : Regmap.t val) (m : mem) (s' : list stackframe) (rs' : Regmap.t val) (m' : mem) (cu : program) (H : linkorder cu prog) (H0 : list_forall2 match_stackframes s s') (H1 : regs_lessdef rs rs') (H2 : Mem.extends m m') : match_states 0 (State s f sp pc rs m)\n  (State s' (transf_function (romem_for cu) f) sp pc rs' m').","proofString":"apply match_states_intro; auto.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : node) (rs : Regmap.t val) (m : mem) (s' : list stackframe) (rs' : Regmap.t val) (m' : mem) (cu : program) (H : linkorder cu prog) (H0 : list_forall2 match_stackframes s s') (H1 : regs_lessdef rs rs') (H2 : Mem.extends m m') : match_pc f rs m 0 pc pc.","proofString":"constructor."},{"statement":"(rm : romem) (f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) : (fn_code (transf_function rm f)) ! pc =\nSome (transf_instr f (analyze rm f) rm pc i).","proofString":"simpl.\nrewrite PTree.gmap.\nrewrite H.\nauto."},{"statement":"(rm : romem) (f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) : (PTree.map (transf_instr f (analyze rm f) rm) (fn_code f)) ! pc =\nSome (transf_instr f (analyze rm f) rm pc i).","proofString":"rewrite PTree.gmap.\nrewrite H.\nauto."},{"statement":"(rm : romem) (f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) : option_map (transf_instr f (analyze rm f) rm pc) (fn_code f) ! pc =\nSome (transf_instr f (analyze rm f) rm pc i).","proofString":"rewrite H.\nauto."},{"statement":"(rm : romem) (f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) : option_map (transf_instr f (analyze rm f) rm pc) (Some i) =\nSome (transf_instr f (analyze rm f) rm pc i).","proofString":"auto."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists (n : nat) (st2 : state),\n  initial_state tprog st2 /\\ match_states n st1 st2.","proofString":"inversion H.\nexploit function_ptr_translated; eauto.\nintros (cu & FIND & LINK).\nexists O; exists (Callstate nil (transf_fundef (romem_for cu) f) nil m0); split.\neconstructor; eauto.\napply (Genv.init_mem_match TRANSL); auto.\nreplace (prog_main tprog) with (prog_main prog).\nrewrite symbols_preserved.\neauto.\nsymmetry; eapply match_program_main; eauto.\nrewrite <- H3.\napply sig_function_translated.\nconstructor.\nauto.\nconstructor.\nconstructor.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : Genv.init_mem tprog = Some m0.","proofString":"apply (Genv.init_mem_match TRANSL); auto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : prog_main prog = prog_main tprog.","proofString":"symmetry; eapply match_program_main; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : funsig (transf_fundef (romem_for cu) f) = signature_main.","proofString":"rewrite <- H3.\napply sig_function_translated."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : funsig (transf_fundef (romem_for cu) f) = funsig f.","proofString":"apply sig_function_translated."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : match_states 0 (Callstate nil f nil m0)\n  (Callstate nil (transf_fundef (romem_for cu) f) nil m0).","proofString":"constructor.\nauto.\nconstructor.\nconstructor.\napply Mem.extends_refl."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : linkorder cu prog.","proofString":"auto."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : list_forall2 match_stackframes nil nil.","proofString":"constructor."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : Val.lessdef_list nil nil.","proofString":"constructor."},{"statement":"(st1 : state) (H : initial_state prog st1) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : Callstate nil f nil m0 = st1) (cu : program) (FIND : Genv.find_funct_ptr tge b = Some (transf_fundef (romem_for cu) f)) (LINK : linkorder cu prog) : Mem.extends m0 m0.","proofString":"apply Mem.extends_refl."},{"statement":"(n : nat) (st1 st2 : state) (r : int) (H : match_states n st1 st2) (H0 : final_state st1 r) : final_state st2 r.","proofString":"inv H0.\ninv H.\ninv STACKS.\ninv RES.\nconstructor."},{"statement":"(n : nat) (st2 : state) (r : int) (m : mem) (H : match_states n (Returnstate nil (Vint r) m) st2) : final_state st2 r.","proofString":"inv H.\ninv STACKS.\ninv RES.\nconstructor."},{"statement":"(r : int) (m : mem) (s' : list stackframe) (v' : val) (m' : mem) (STACKS : list_forall2 match_stackframes nil s') (RES : Val.lessdef (Vint r) v') (MEM : Mem.extends m m') (H5 : list_forall2 match_stackframes nil s') : final_state (Returnstate s' v' m') r.","proofString":"inv STACKS.\ninv RES.\nconstructor."},{"statement":"(r : int) (m : mem) (v' : val) (m' : mem) (RES : Val.lessdef (Vint r) v') (MEM : Mem.extends m m') (H5 : list_forall2 match_stackframes nil nil) : final_state (Returnstate nil v' m') r.","proofString":"inv RES.\nconstructor."},{"statement":"(r : int) (m m' : mem) (MEM : Mem.extends m m') (H5 : list_forall2 match_stackframes nil nil) : final_state (Returnstate nil (Vint r) m') r.","proofString":"constructor."},{"statement":"well_founded lt.","proofString":"apply lt_wf."},{"statement":"forall s1 : Smallstep.state (semantics prog),\nSmallstep.initial_state (semantics prog) s1 ->\nexists (i : nat) (s2 : Smallstep.state (semantics tprog)),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  sound_state prog s1 /\\ match_states i s1 s2.","proofString":"simpl; intros.\nexploit transf_initial_states; eauto.\nintros (n & st2 & A & B).\nexists n, st2; intuition.\neapply sound_initial; eauto."},{"statement":"(s1 : state) (H : initial_state prog s1) : exists (i : nat) (s2 : state),\n  initial_state tprog s2 /\\ sound_state prog s1 /\\ match_states i s1 s2.","proofString":"exploit transf_initial_states; eauto.\nintros (n & st2 & A & B).\nexists n, st2; intuition.\neapply sound_initial; eauto."},{"statement":"(s1 : state) (H : initial_state prog s1) : (exists (n : nat) (st2 : state),\n   initial_state tprog st2 /\\ match_states n s1 st2) ->\nexists (i : nat) (s2 : state),\n  initial_state tprog s2 /\\ sound_state prog s1 /\\ match_states i s1 s2.","proofString":"intros (n & st2 & A & B).\nexists n, st2; intuition.\neapply sound_initial; eauto."},{"statement":"(s1 : state) (H : initial_state prog s1) (n : nat) (st2 : state) (A : initial_state tprog st2) (B : match_states n s1 st2) : exists (i : nat) (s2 : state),\n  initial_state tprog s2 /\\ sound_state prog s1 /\\ match_states i s1 s2.","proofString":"exists n, st2; intuition.\neapply sound_initial; eauto."},{"statement":"(s1 : state) (H : initial_state prog s1) (n : nat) (st2 : state) (A : initial_state tprog st2) (B : match_states n s1 st2) : sound_state prog s1.","proofString":"eapply sound_initial; eauto."},{"statement":"forall (i : nat) (s1 : Smallstep.state (semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : int),\nsound_state prog s1 /\\ match_states i s1 s2 ->\nSmallstep.final_state (semantics prog) s1 r ->\nSmallstep.final_state (semantics tprog) s2 r.","proofString":"simpl; intros.\ndestruct H.\neapply transf_final_states; eauto."},{"statement":"(i : nat) (s1 s2 : state) (r : int) (H : sound_state prog s1 /\\ match_states i s1 s2) (H0 : final_state s1 r) : final_state s2 r.","proofString":"destruct H.\neapply transf_final_states; eauto."},{"statement":"(i : nat) (s1 s2 : state) (r : int) (H : sound_state prog s1) (H1 : match_states i s1 s2) (H0 : final_state s1 r) : final_state s2 r.","proofString":"eapply transf_final_states; eauto."},{"statement":"forall (s1 : Smallstep.state (semantics prog)) (t : trace)\n  (s1' : Smallstep.state (semantics prog)),\nStep (semantics prog) s1 t s1' ->\nforall (i : nat) (s2 : Smallstep.state (semantics tprog)),\nsound_state prog s1 /\\ match_states i s1 s2 ->\nexists (i' : nat) (s2' : Smallstep.state (semantics tprog)),\n  (Plus (semantics tprog) s2 t s2' \\/\n   Star (semantics tprog) s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"simpl; intros.\ndestruct H0.\nassert (sound_state prog s1') by (eapply sound_step; eauto).\nfold ge; fold tge.\nexploit transf_step_correct; eauto.\nintros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].\nexists n2; exists s2'; split; auto.\nleft; apply plus_one; auto.\nexists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1 /\\ match_states i s1 s2) : exists (i' : nat) (s2' : state),\n  (plus step (Genv.globalenv tprog) s2 t s2' \\/\n   star step (Genv.globalenv tprog) s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"destruct H0.\nassert (sound_state prog s1') by (eapply sound_step; eauto).\nfold ge; fold tge.\nexploit transf_step_correct; eauto.\nintros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].\nexists n2; exists s2'; split; auto.\nleft; apply plus_one; auto.\nexists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) : exists (i' : nat) (s2' : state),\n  (plus step (Genv.globalenv tprog) s2 t s2' \\/\n   star step (Genv.globalenv tprog) s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"assert (sound_state prog s1') by (eapply sound_step; eauto).\nfold ge; fold tge.\nexploit transf_step_correct; eauto.\nintros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].\nexists n2; exists s2'; split; auto.\nleft; apply plus_one; auto.\nexists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') : exists (i' : nat) (s2' : state),\n  (plus step (Genv.globalenv tprog) s2 t s2' \\/\n   star step (Genv.globalenv tprog) s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"fold ge; fold tge.\nexploit transf_step_correct; eauto.\nintros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].\nexists n2; exists s2'; split; auto.\nleft; apply plus_one; auto.\nexists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') : exists (i' : nat) (s2' : state),\n  (plus step tge s2 t s2' \\/ star step tge s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"exploit transf_step_correct; eauto.\nintros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].\nexists n2; exists s2'; split; auto.\nleft; apply plus_one; auto.\nexists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') : (exists (n2 : nat) (s2' : state),\n   step tge s2 t s2' /\\ match_states n2 s1' s2') \\/\n(exists n2 : nat, (n2 < i)%nat /\\ t = E0 /\\ match_states n2 s1' s2) ->\nexists (i' : nat) (s2' : state),\n  (plus step tge s2 t s2' \\/ star step tge s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"intros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].\nexists n2; exists s2'; split; auto.\nleft; apply plus_one; auto.\nexists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') (n2 : nat) (s2' : state) (A : step tge s2 t s2') (B : match_states n2 s1' s2') : exists (i' : nat) (s2'0 : state),\n  (plus step tge s2 t s2'0 \\/ star step tge s2 t s2'0 /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'0.","proofString":"exists n2; exists s2'; split; auto.\nleft; apply plus_one; auto."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') (n2 : nat) (s2' : state) (A : step tge s2 t s2') (B : match_states n2 s1' s2') : plus step tge s2 t s2' \\/ star step tge s2 t s2' /\\ (n2 < i)%nat.","proofString":"left; apply plus_one; auto."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') (n2 : nat) (A : (n2 < i)%nat) (B : t = E0) (C : match_states n2 s1' s2) : exists (i' : nat) (s2' : state),\n  (plus step tge s2 t s2' \\/ star step tge s2 t s2' /\\ (i' < i)%nat) /\\\n  sound_state prog s1' /\\ match_states i' s1' s2'.","proofString":"exists n2; exists s2; split; auto.\nright; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') (n2 : nat) (A : (n2 < i)%nat) (B : t = E0) (C : match_states n2 s1' s2) : plus step tge s2 t s2 \\/ star step tge s2 t s2 /\\ (n2 < i)%nat.","proofString":"right; split; auto.\nsubst t; apply star_refl."},{"statement":"(s1 : state) (t : trace) (s1' : state) (H : step (Genv.globalenv prog) s1 t s1') (i : nat) (s2 : state) (H0 : sound_state prog s1) (H1 : match_states i s1 s2) (H2 : sound_state prog s1') (n2 : nat) (A : (n2 < i)%nat) (B : t = E0) (C : match_states n2 s1' s2) : star step tge s2 t s2.","proofString":"subst t; apply star_refl."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","proofString":"apply senv_preserved."}]}