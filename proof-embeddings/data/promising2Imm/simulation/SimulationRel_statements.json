{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/simulation/SimulationRel.v","fileSamples":[{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (SIMMSG : sim_msg G sc1 f_from b (View.unwrap rel)) (SC_EQ : sc1 ≡ sc2) : sim_mem_helper G sc2 f_from b from v (View.unwrap rel).","proofString":"red.\nsplits; eauto.\nred in SIMMSG.\nred.\nins.\nspecialize (SIMMSG l).\neapply max_value_more; eauto.\neapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (SIMMSG : sim_msg G sc1 f_from b (View.unwrap rel)) (SC_EQ : sc1 ≡ sc2) : sim_msg G sc2 f_from b (View.unwrap rel).","proofString":"red in SIMMSG.\nred.\nins.\nspecialize (SIMMSG l).\neapply max_value_more; eauto.\neapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (SIMMSG : forall l : location,\nmax_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : sim_msg G sc2 f_from b (View.unwrap rel).","proofString":"red.\nins.\nspecialize (SIMMSG l).\neapply max_value_more; eauto.\neapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (SIMMSG : forall l : location,\nmax_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : forall l : location,\nmax_value f_from\n  (fun a : actid => msg_rel G sc2 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel))).","proofString":"ins.\nspecialize (SIMMSG l).\neapply max_value_more; eauto.\neapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (SIMMSG : forall l0 : location,\nmax_value f_from\n  (fun a : actid => msg_rel G sc1 l0 a b \\/ loc (lab G) b = Some l0 /\\ a = b)\n  (LocFun.find l0 (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) (l : location) : max_value f_from\n  (fun a : actid => msg_rel G sc2 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel))).","proofString":"specialize (SIMMSG l).\neapply max_value_more; eauto.\neapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (l : location) (SIMMSG : max_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : max_value f_from\n  (fun a : actid => msg_rel G sc2 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel))).","proofString":"eapply max_value_more; eauto.\neapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (l : location) (SIMMSG : max_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : (fun a : actid => msg_rel G sc2 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n≡₁ (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b).","proofString":"eapply set_equiv_union; [| basic_solver].\nenough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (l : location) (SIMMSG : max_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : (fun a : actid => msg_rel G sc2 l a b)\n≡₁ (fun a : actid => msg_rel G sc1 l a b).","proofString":"enough (msg_rel G sc2 l ≡ msg_rel G sc1 l) by (generalize H; basic_solver).\napply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (l : location) (SIMMSG : max_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : msg_rel G sc2 l ≡ msg_rel G sc1 l.","proofString":"apply msg_rel_more; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (f_from : actid -> Time.t) (b : actid) (from : Time.t) (v : value) (rel : option View.t) (VAL : Some v = val (lab G) b) (FROM : Time.lt from (f_from b) \\/\nis_init b /\\ from = Time.bot /\\ f_from b = Time.bot) (l : location) (SIMMSG : max_value f_from\n  (fun a : actid => msg_rel G sc1 l a b \\/ loc (lab G) b = Some l /\\ a = b)\n  (LocFun.find l (View.rlx (View.unwrap rel)))) (SC_EQ : sc1 ≡ sc2) : sc2 ≡ sc1.","proofString":"by symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (COV_IN : covered T2 ⊆₁ covered T1) (ISS_IN : issued T1 ⊆₁ issued T2) (SC_EQ : sc1 ≡ sc2) : sim_prom G sc1 T1 f_from f_to t ⊆₁ sim_prom G sc2 T2 f_from f_to t.","proofString":"unfold sim_prom.\nred.\nins.\nspecialize (H l to from v rel PROM).\ndesc.\neexists.\nsplits; eauto.\neapply sim_mem_helper_same_sc; eauto."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (COV_IN : covered T2 ⊆₁ covered T1) (ISS_IN : issued T1 ⊆₁ issued T2) (SC_EQ : sc1 ≡ sc2) (x : Memory.t) (l : Loc.t) (to from : Time.t) (v : Const.t) (rel : option View.t) (b : actid) (ACTS : acts_set G b) (TID : tid b = t) (ISS : issued T1 b) (NCOV : ~ covered T1 b) (LOC : loc (lab G) b = Some l) (FROM : f_to b = from) (TO : f_from b = to) (HELPER : sim_mem_helper G sc1 f_from b from v (View.unwrap rel)) (PROM : Memory.get l to x = Some (from, Message.full v rel)) : sim_mem_helper G sc2 f_from b from v (View.unwrap rel).","proofString":"eapply sim_mem_helper_same_sc; eauto."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (H : covered T1 ⊆₁ covered T2) (H0 : covered T2 ⊆₁ covered T1) (H1 : issued T1 ⊆₁ issued T2) (H2 : issued T2 ⊆₁ issued T1) (SC_EQ : sc1 ≡ sc2) : sim_prom G sc1 T1 f_from f_to t ≡₁ sim_prom G sc2 T2 f_from f_to t.","proofString":"split; apply sim_prom_covered_issued_subsets; auto.\nby symmetry."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (H : covered T1 ⊆₁ covered T2) (H0 : covered T2 ⊆₁ covered T1) (H1 : issued T1 ⊆₁ issued T2) (H2 : issued T2 ⊆₁ issued T1) (SC_EQ : sc1 ≡ sc2) : sc2 ≡ sc1.","proofString":"by symmetry."},{"statement":"(G : execution) (T1 T2 : trav_label -> Prop) (f_to f_from : actid -> Time.t) (thread : thread_id) (ISS : issued T2 ⊆₁ issued T1) (RES : reserved T1 ⊆₁ reserved T2) : sim_res_prom G T1 f_to f_from thread ⊆₁ sim_res_prom G T2 f_to f_from thread.","proofString":"unfold sim_res_prom.\nred.\nins.\nspecialize (H l to from RES0).\ndesc.\neexists.\nsplits; eauto."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (l : Local.t) (COV_EQ : covered T1 ≡₁ covered T2) (ISS_EQ : issued T1 ≡₁ issued T2) (SC_EQ : sc1 ≡ sc2) (H : issued T2 ≡₁ issued T1) : sim_mem G sc1 T1 f_from f_to t l ≡₁ sim_mem G sc2 T2 f_from f_to t l.","proofString":"pose proof (same_rel_Symmetric SC_EQ).\ndestruct COV_EQ.\nsplit; red; ins; eapply sim_mem_covered_mori; eauto."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (l : Local.t) (COV_EQ : covered T1 ≡₁ covered T2) (ISS_EQ : issued T1 ≡₁ issued T2) (SC_EQ : sc1 ≡ sc2) (H : issued T2 ≡₁ issued T1) (H0 : sc2 ≡ sc1) : sim_mem G sc1 T1 f_from f_to t l ≡₁ sim_mem G sc2 T2 f_from f_to t l.","proofString":"destruct COV_EQ.\nsplit; red; ins; eapply sim_mem_covered_mori; eauto."},{"statement":"(G : execution) (sc1 sc2 : relation actid) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (l : Local.t) (H1 : covered T1 ⊆₁ covered T2) (H2 : covered T2 ⊆₁ covered T1) (ISS_EQ : issued T1 ≡₁ issued T2) (SC_EQ : sc1 ≡ sc2) (H : issued T2 ≡₁ issued T1) (H0 : sc2 ≡ sc1) : sim_mem G sc1 T1 f_from f_to t l ≡₁ sim_mem G sc2 T2 f_from f_to t l.","proofString":"split; red; ins; eapply sim_mem_covered_mori; eauto."},{"statement":"(G : execution) (T1 T2 : trav_label -> Prop) (f_from f_to : actid -> Time.t) (t : thread_id) (l : Local.t) (RES_IN : reserved T2 ⊆₁ reserved T1) (ISS_IN : issued T1 ⊆₁ issued T2) : sim_res_mem G T1 f_from f_to t l ⊆₁ sim_res_mem G T2 f_from f_to t l.","proofString":"unfold sim_res_mem.\nred.\nins.\nspecialize (H l0 b).\nspecialize_full H; eauto."}]}