{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/reordering/ReorderingExecB.v","fileSamples":[{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : E_t' ≡₁ E_t ∪₁ eq b_t.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : tid b_t <> tid_init.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ~ is_init b_t.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ~ E_t b_t.","proofString":"apply ADD'."},{"statement":"(E_t ∪₁ eq b_t) b_t.","proofString":"now right."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : lab_t' = upd lab_t b_t l_b.","proofString":"apply ADD'."},{"statement":"(FALSO : E_t a_t) : False.","proofString":"apply rsr_b_notin.\nnow apply (rsr_at_bt_ord INV)."},{"statement":"(FALSO : E_t a_t) : E_t b_t.","proofString":"now apply (rsr_at_bt_ord INV)."},{"statement":"~ E_t' a_t.","proofString":"intro FALSO.\napply rsr_step_acts in FALSO.\ndestruct FALSO as [AIN | EQ].\nnow apply rsr_b_a_nin.\nnow apply (rsr_at_neq_bt INV)."},{"statement":"(FALSO : E_t' a_t) : False.","proofString":"apply rsr_step_acts in FALSO.\ndestruct FALSO as [AIN | EQ].\nnow apply rsr_b_a_nin.\nnow apply (rsr_at_neq_bt INV)."},{"statement":"(FALSO : (E_t ∪₁ eq b_t) a_t) : False.","proofString":"destruct FALSO as [AIN | EQ].\nnow apply rsr_b_a_nin.\nnow apply (rsr_at_neq_bt INV)."},{"statement":"(AIN : E_t a_t) : False.","proofString":"now apply rsr_b_a_nin."},{"statement":"(EQ : b_t = a_t) : False.","proofString":"now apply (rsr_at_neq_bt INV)."},{"statement":"A_s ≡₁ ∅.","proofString":"rewrite extra_a_none_r; auto with xmm."},{"statement":"A_s' ≡₁ eq b_t.","proofString":"rewrite extra_a_some; auto with xmm.\napply rsr_b_a_nin'."},{"statement":"~ E_t' a_t.","proofString":"apply rsr_b_a_nin'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t E_s.","proofString":"rewrite (rsr_actsE INV SIMREL).\nrewrite extra_a_none_r, set_union_empty_r; auto with xmm.\napply (sb_deltaEE ADD')."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t ∪₁ B_s⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t (E_t ∪₁ B_s).","proofString":"rewrite extra_a_none_r, set_union_empty_r; auto with xmm.\napply (sb_deltaEE ADD')."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t E_t.","proofString":"apply (sb_deltaEE ADD')."},{"statement":"⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘ ≡ sb_s ∪ WCore.sb_delta b_t E_s.","proofString":"simpl.\nrewrite !id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘).\nenough (~ext_sb b_t b_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite rsr_new_a_sb_delta.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘)    ; [| basic_solver 11].\nrewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘ ≡ sb_s ∪ WCore.sb_delta b_t E_s.","proofString":"rewrite !id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘).\nenough (~ext_sb b_t b_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite rsr_new_a_sb_delta.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘)    ; [| basic_solver 11].\nrewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘\n∪ (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘)\n≡ sb_s ∪ WCore.sb_delta b_t E_s.","proofString":"change (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘).\nenough (~ext_sb b_t b_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite rsr_new_a_sb_delta.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘)    ; [| basic_solver 11].\nrewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘\n∪ (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘)\n≡ sb_s ∪ WCore.sb_delta b_t E_s.","proofString":"arewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘).\nenough (~ext_sb b_t b_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite rsr_new_a_sb_delta.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘)    ; [| basic_solver 11].\nrewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ⊆ ∅₂.","proofString":"enough (~ext_sb b_t b_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto."},{"statement":"~ ext_sb b_t b_t.","proofString":"intro FALSO; eapply ext_sb_irr; eauto."},{"statement":"sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ∪ (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ∅₂)\n≡ sb_s ∪ WCore.sb_delta b_t E_s.","proofString":"rewrite rsr_new_a_sb_delta.\narewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘)    ; [| basic_solver 11].\nrewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"sb_s ∪ WCore.sb_delta b_t E_s ∪ (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ∅₂)\n≡ sb_s ∪ WCore.sb_delta b_t E_s.","proofString":"arewrite_false (⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘)    ; [| basic_solver 11].\nrewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ⊆ ∅₂.","proofString":"rewrite (rsr_actsE INV SIMREL), !id_union, !seq_union_r.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_t⦘ ∪ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗B_s⦘ ⊆ ∅₂.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_t⦘ ∪ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗B_s⦘ ⊆ ∅₂.","proofString":"rewrite (sb_deltaEN ADD'), extra_a_none_r; auto with xmm.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ∅₂ ∪ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗∅⦘ ⊆ ∅₂.","proofString":"basic_solver 11."},{"statement":"(NEQ : a_t <> b_t) : mapper ↑ WCore.sb_delta b_t E_t ≡ WCore.sb_delta a_t E_s.","proofString":"assert (TEQ : tid a_t = tid b_t) by apply INV.\nassert (ANINI : ~is_init a_t) by apply INV.\nassert (BNINI : ~is_init b_t) by apply INV.\nunfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mapper_bt; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) : mapper ↑ WCore.sb_delta b_t E_t ≡ WCore.sb_delta a_t E_s.","proofString":"assert (ANINI : ~is_init a_t) by apply INV.\nassert (BNINI : ~is_init b_t) by apply INV.\nunfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mapper_bt; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) : mapper ↑ WCore.sb_delta b_t E_t ≡ WCore.sb_delta a_t E_s.","proofString":"assert (BNINI : ~is_init b_t) by apply INV.\nunfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mapper_bt; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑ WCore.sb_delta b_t E_t ≡ WCore.sb_delta a_t E_s.","proofString":"unfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mapper_bt; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑ (is_init ∪₁ E_t ∩₁ same_tid b_t) × eq b_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite collect_rel_cross, set_collect_eq, rsr_mapper_bt; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (mapper ↑₁ (is_init ∪₁ E_t ∩₁ same_tid b_t)) × eq a_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (mapper ↑₁ is_init ∪₁ mapper ↑₁ (E_t ∩₁ same_tid b_t)) × eq a_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (is_init ∪₁ mapper ↑₁ (E_t ∩₁ same_tid b_t)) × eq a_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t.","proofString":"arewrite (same_tid b_t ≡₁ same_tid a_t).\nunfold same_tid.\nunfolder; split; ins; desf; congruence.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : same_tid b_t ≡₁ same_tid a_t.","proofString":"unfold same_tid.\nunfolder; split; ins; desf; congruence."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (fun y : actid => tid b_t = tid y) ≡₁ (fun y : actid => tid a_t = tid y).","proofString":"unfolder; split; ins; desf; congruence."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (is_init ∪₁ mapper ↑₁ (E_t ∩₁ same_tid a_t)) × eq a_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t.","proofString":"arewrite (mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t)    ; [| reflexivity].\nrewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑₁ (E_t ∩₁ same_tid a_t) ≡₁ E_s ∩₁ same_tid a_t.","proofString":"rewrite rsr_mapper_sametid; auto.\nnow rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(NEQ : a_t <> b_t) (TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑₁ E_t ∩₁ same_tid a_t ≡₁ E_s ∩₁ same_tid a_t.","proofString":"now rewrite (rsr_acts SIMREL), rsr_b_old_exa, set_union_empty_r."},{"statement":"(is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t\n⊆ (is_init ∪₁ E_t ∩₁ same_tid b_t) × eq b_t ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"arewrite (same_tid a_t ≡₁ same_tid b_t).\nunfold same_tid.\nnow rewrite (rsr_at_bt_tid INV).\nintros x y (DEL & EQ).\nsubst y.\nexists b_t.\nsplit; [split; auto |].\nenough (ext_sb b_t a_t) by basic_solver 11.\napply (rsr_at_bt_sb INV)."},{"statement":"same_tid a_t ≡₁ same_tid b_t.","proofString":"unfold same_tid.\nnow rewrite (rsr_at_bt_tid INV)."},{"statement":"(fun y : actid => tid a_t = tid y) ≡₁ (fun y : actid => tid b_t = tid y).","proofString":"now rewrite (rsr_at_bt_tid INV)."},{"statement":"(is_init ∪₁ E_t ∩₁ same_tid b_t) × eq a_t\n⊆ (is_init ∪₁ E_t ∩₁ same_tid b_t) × eq b_t ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"intros x y (DEL & EQ).\nsubst y.\nexists b_t.\nsplit; [split; auto |].\nenough (ext_sb b_t a_t) by basic_solver 11.\napply (rsr_at_bt_sb INV)."},{"statement":"(x y : actid) (DEL : (is_init ∪₁ E_t ∩₁ same_tid b_t) x) (EQ : a_t = y) : ((is_init ∪₁ E_t ∩₁ same_tid b_t) × eq b_t ⨾ ext_sb ⨾ ⦗eq a_t⦘) x y.","proofString":"subst y.\nexists b_t.\nsplit; [split; auto |].\nenough (ext_sb b_t a_t) by basic_solver 11.\napply (rsr_at_bt_sb INV)."},{"statement":"(x : actid) (DEL : (is_init ∪₁ E_t ∩₁ same_tid b_t) x) : ((is_init ∪₁ E_t ∩₁ same_tid b_t) × eq b_t ⨾ ext_sb ⨾ ⦗eq a_t⦘) x a_t.","proofString":"exists b_t.\nsplit; [split; auto |].\nenough (ext_sb b_t a_t) by basic_solver 11.\napply (rsr_at_bt_sb INV)."},{"statement":"(x : actid) (DEL : (is_init ∪₁ E_t ∩₁ same_tid b_t) x) : ((is_init ∪₁ E_t ∩₁ same_tid b_t) × eq b_t) x b_t /\\\n(ext_sb ⨾ ⦗eq a_t⦘) b_t a_t.","proofString":"split; [split; auto |].\nenough (ext_sb b_t a_t) by basic_solver 11.\napply (rsr_at_bt_sb INV)."},{"statement":"(x : actid) (DEL : (is_init ∪₁ E_t ∩₁ same_tid b_t) x) : (ext_sb ⨾ ⦗eq a_t⦘) b_t a_t.","proofString":"enough (ext_sb b_t a_t) by basic_solver 11.\napply (rsr_at_bt_sb INV)."},{"statement":"(x : actid) (DEL : (is_init ∪₁ E_t ∩₁ same_tid b_t) x) : ext_sb b_t a_t.","proofString":"apply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ WCore.sb_delta a_t E_t.","proofString":"unfold WCore.sb_delta.\nsplit.\nrewrite ext_sb_tid_init'.\nrewrite seq_union_l, seq_union_r, !seqA.\nrewrite cross_union_l, unionC.\napply union_mori; basic_solver.\ntransitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ⨾      ext_sb ⨾ ⦗eq a_t⦘  ).\nseq_rewrite (sb_deltaEE ADD').\napply rsr_sb_delta_comp.\ntransitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ext_sb ⨾ ⦗eq a_t⦘  ); [basic_solver |].\nsin_rewrite rewrite_trans; [reflexivity |].\napply ext_sb_trans."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t.","proofString":"split.\nrewrite ext_sb_tid_init'.\nrewrite seq_union_l, seq_union_r, !seqA.\nrewrite cross_union_l, unionC.\napply union_mori; basic_solver.\ntransitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ⨾      ext_sb ⨾ ⦗eq a_t⦘  ).\nseq_rewrite (sb_deltaEE ADD').\napply rsr_sb_delta_comp.\ntransitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ext_sb ⨾ ⦗eq a_t⦘  ); [basic_solver |].\nsin_rewrite rewrite_trans; [reflexivity |].\napply ext_sb_trans."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ⊆ (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite ext_sb_tid_init'.\nrewrite seq_union_l, seq_union_r, !seqA.\nrewrite cross_union_l, unionC.\napply union_mori; basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ (ext_sb ∩ same_tid ∪ ⦗is_init⦘ ⨾ ext_sb) ⨾ ⦗eq a_t⦘\n⊆ (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite seq_union_l, seq_union_r, !seqA.\nrewrite cross_union_l, unionC.\napply union_mori; basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ∩ same_tid ⨾ ⦗eq a_t⦘ ∪ ⦗E_t⦘ ⨾ ⦗is_init⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n⊆ (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite cross_union_l, unionC.\napply union_mori; basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ⦗is_init⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ∪ ⦗E_t⦘ ⨾ ext_sb ∩ same_tid ⨾ ⦗eq a_t⦘\n⊆ is_init × eq a_t ∪ (E_t ∩₁ same_tid a_t) × eq a_t.","proofString":"apply union_mori; basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t ⊆ ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"transitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ⨾      ext_sb ⨾ ⦗eq a_t⦘  ).\nseq_rewrite (sb_deltaEE ADD').\napply rsr_sb_delta_comp.\ntransitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ext_sb ⨾ ⦗eq a_t⦘  ); [basic_solver |].\nsin_rewrite rewrite_trans; [reflexivity |].\napply ext_sb_trans."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t\n⊆ ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"seq_rewrite (sb_deltaEE ADD').\napply rsr_sb_delta_comp."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t\n⊆ WCore.sb_delta b_t E_t ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"apply rsr_sb_delta_comp."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ⊆ ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"transitivity (    ⦗E_t⦘ ⨾ ext_sb ⨾ ext_sb ⨾ ⦗eq a_t⦘  ); [basic_solver |].\nsin_rewrite rewrite_trans; [reflexivity |].\napply ext_sb_trans."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ext_sb ⨾ ⦗eq a_t⦘ ⊆ ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"sin_rewrite rewrite_trans; [reflexivity |].\napply ext_sb_trans."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : transitive ext_sb.","proofString":"apply ext_sb_trans."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ WCore.sb_delta a_t E_s''.","proofString":"simpl.\nrewrite (rsr_actsE INV SIMREL).\nrewrite extra_a_none_r, set_union_empty_r; auto with xmm.\narewrite (WCore.sb_delta a_t (E_t ∪₁ eq b_t) ≡    WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t  ).\nunfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA.\nrewrite id_union, !seq_union_l.\napply union_more.\napply rsr_new_a_sb_delta_helper'.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ WCore.sb_delta a_t (E_s ∪₁ eq b_t).","proofString":"rewrite (rsr_actsE INV SIMREL).\nrewrite extra_a_none_r, set_union_empty_r; auto with xmm.\narewrite (WCore.sb_delta a_t (E_t ∪₁ eq b_t) ≡    WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t  ).\nunfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA.\nrewrite id_union, !seq_union_l.\napply union_more.\napply rsr_new_a_sb_delta_helper'.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t ∪₁ B_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n≡ WCore.sb_delta a_t (E_t ∪₁ B_s ∪₁ eq b_t).","proofString":"rewrite extra_a_none_r, set_union_empty_r; auto with xmm.\narewrite (WCore.sb_delta a_t (E_t ∪₁ eq b_t) ≡    WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t  ).\nunfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA.\nrewrite id_union, !seq_union_l.\napply union_more.\napply rsr_new_a_sb_delta_helper'.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ WCore.sb_delta a_t (E_t ∪₁ eq b_t).","proofString":"arewrite (WCore.sb_delta a_t (E_t ∪₁ eq b_t) ≡    WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t  ).\nunfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA.\nrewrite id_union, !seq_union_l.\napply union_more.\napply rsr_new_a_sb_delta_helper'.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : WCore.sb_delta a_t (E_t ∪₁ eq b_t)\n≡ WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t.","proofString":"unfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : (is_init ∪₁ (E_t ∪₁ eq b_t) ∩₁ same_tid a_t) × eq a_t\n≡ (is_init ∪₁ E_t ∩₁ same_tid a_t) × eq a_t\n  ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : is_init × eq a_t\n∪ ((E_t ∩₁ same_tid a_t) × eq a_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t)\n≡ is_init × eq a_t ∪ (E_t ∩₁ same_tid a_t) × eq a_t\n  ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t.","proofString":"now rewrite <- unionA."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n≡ WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t.","proofString":"rewrite id_union, !seq_union_l.\napply union_more.\napply rsr_new_a_sb_delta_helper'.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ∪ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n≡ WCore.sb_delta a_t E_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t.","proofString":"apply union_more.\napply rsr_new_a_sb_delta_helper'.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ WCore.sb_delta a_t E_t.","proofString":"apply rsr_new_a_sb_delta_helper'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ (eq b_t ∩₁ same_tid a_t) × eq a_t.","proofString":"arewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t).\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nsplit; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : eq b_t ∩₁ same_tid a_t ≡₁ eq b_t.","proofString":"split; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : eq b_t ⊆₁ eq b_t ∩₁ same_tid a_t.","proofString":"unfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : eq b_t ⊆₁ eq b_t ∩₁ (fun y : actid => tid a_t = tid y).","proofString":"rewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : eq b_t ⊆₁ eq b_t ∩₁ (fun y : actid => tid b_t = tid y).","proofString":"basic_solver."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ≡ eq b_t × eq a_t.","proofString":"split; [basic_solver |].\nunfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : eq b_t × eq a_t ⊆ ⦗eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘.","proofString":"unfolder.\nintros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : forall x y : actid, b_t = x /\\ a_t = y -> b_t = x /\\ ext_sb x y /\\ a_t = y.","proofString":"intros x y (XEQ & YEQ).\nsubst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (x y : actid) (XEQ : b_t = x) (YEQ : a_t = y) : b_t = x /\\ ext_sb x y /\\ a_t = y.","proofString":"subst x y.\nsplits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : b_t = b_t /\\ ext_sb b_t a_t /\\ a_t = a_t.","proofString":"splits; auto.\napply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ext_sb b_t a_t.","proofString":"apply (rsr_at_bt_sb INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sb_s' ≡ sb_s'' ∪ WCore.sb_delta a_t E_s''.","proofString":"unfold sb at 1.\nsimpl.\nrewrite id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘)    with sb_s''.\nchange (E_s ∪₁ eq b_t) with E_s''.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘).\nenough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_s'⦘ ⨾ ext_sb ⨾ ⦗E_s'⦘ ≡ sb_s'' ∪ WCore.sb_delta a_t E_s''.","proofString":"simpl.\nrewrite id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘)    with sb_s''.\nchange (E_s ∪₁ eq b_t) with E_s''.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘).\nenough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_s ∪₁ eq b_t ∪₁ eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t ∪₁ eq a_t⦘\n≡ sb rsr_b_immg ∪ WCore.sb_delta a_t (E_s ∪₁ eq b_t).","proofString":"rewrite id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘)    with sb_s''.\nchange (E_s ∪₁ eq b_t) with E_s''.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘).\nenough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘\n∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n∪ (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘ ∪ ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘)\n≡ sb rsr_b_immg ∪ WCore.sb_delta a_t (E_s ∪₁ eq b_t).","proofString":"change (⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘)    with sb_s''.\nchange (E_s ∪₁ eq b_t) with E_s''.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘).\nenough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sb_s'' ∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n∪ (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq b_t⦘ ∪ ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘)\n≡ sb rsr_b_immg ∪ WCore.sb_delta a_t (E_s ∪₁ eq b_t).","proofString":"change (E_s ∪₁ eq b_t) with E_s''.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘).\nenough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sb_s'' ∪ ⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘\n∪ (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘ ∪ ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘)\n≡ sb rsr_b_immg ∪ WCore.sb_delta a_t E_s''.","proofString":"arewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘).\nenough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\narewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ⊆ ∅₂.","proofString":"enough (~ext_sb a_t a_t) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ~ ext_sb a_t a_t.","proofString":"intro FALSO; eapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sb_s'' ∪ ⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ∪ (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘ ∪ ∅₂)\n≡ sb rsr_b_immg ∪ WCore.sb_delta a_t E_s''.","proofString":"arewrite_false (⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘).\napply rsr_new_a_sb_delta_helper''.\nnow rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗E_s''⦘ ⊆ ∅₂.","proofString":"apply rsr_new_a_sb_delta_helper''."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sb_s'' ∪ ⦗E_s''⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ∪ (∅₂ ∪ ∅₂)\n≡ sb rsr_b_immg ∪ WCore.sb_delta a_t E_s''.","proofString":"now rewrite rsr_new_a_sb_delta', !union_false_r."},{"statement":"(BIN : E_s b_t) : False.","proofString":"apply (rsr_actsE INV SIMREL) in BIN.\ndestruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(BIN : (E_t ∪₁ B_s) b_t) : False.","proofString":"destruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(EXB : B_s b_t) : False.","proofString":"apply extra_a_none_r in EXB; auto with xmm."},{"statement":"(BIN : E_s a_t) : False.","proofString":"apply (rsr_actsE INV SIMREL) in BIN.\ndestruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(BIN : (E_t ∪₁ B_s) a_t) : False.","proofString":"destruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(EXB : B_s a_t) : False.","proofString":"apply extra_a_none_r in EXB; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) : ~ E_s'' a_t.","proofString":"simpl.\nintros [BIN | EQ]; [| congruence].\napply (rsr_actsE INV SIMREL) in BIN.\ndestruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) : ~ (E_s ∪₁ eq b_t) a_t.","proofString":"intros [BIN | EQ]; [| congruence].\napply (rsr_actsE INV SIMREL) in BIN.\ndestruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) (BIN : E_s a_t) : False.","proofString":"apply (rsr_actsE INV SIMREL) in BIN.\ndestruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) (BIN : (E_t ∪₁ B_s) a_t) : False.","proofString":"destruct BIN as [BIN | EXB]; auto with xmm.\napply extra_a_none_r in EXB; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) (EXB : B_s a_t) : False.","proofString":"apply extra_a_none_r in EXB; auto with xmm."},{"statement":"is_init ⊆₁ E_s.","proofString":"apply (rsr_init_acts_s INV SIMREL)."},{"statement":"eq_dom E_s'' lab_s'' lab_s'.","proofString":"exact rsr_b_labi."},{"statement":"eq_dom E_s lab_s (upd (upd lab_s b_t l_a) a_t l_b).","proofString":"apply eq_dom_upd_r; [| apply rsr_b_labs].\nauto with xmm."},{"statement":"~ E_s a_t.","proofString":"auto with xmm."},{"statement":"eq_dom E_s lab_s lab_s''.","proofString":"exact rsr_b_labs."},{"statement":"eq_dom E_t' lab_t' (lab_s' ∘ mapper).","proofString":"exact rsr_b_lab."},{"statement":"(NEQ : a_t <> b_t) : inj_dom E_t' mapper.","proofString":"eapply inj_dom_mori; auto with xmm.\nred; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) : flip set_subset ⊤₁ E_t'.","proofString":"red; auto with hahn."},{"statement":"eq a_t ∩₁ E_t' ⊆₁ ∅.","proofString":"unfolder.\nintros x (XEQ & XIN).\nsubst x.\nauto with xmm."},{"statement":"forall x : actid, a_t = x /\\ E_t' x -> False.","proofString":"intros x (XEQ & XIN).\nsubst x.\nauto with xmm."},{"statement":"(x : actid) (XEQ : a_t = x) (XIN : E_t' x) : False.","proofString":"subst x.\nauto with xmm."},{"statement":"(XIN : E_t' a_t) : False.","proofString":"auto with xmm."},{"statement":"mapper ↑₁ ∅ ⊆₁ eq b_t.","proofString":"rewrite set_collect_empty.\nauto with hahn."},{"statement":"∅ ⊆₁ eq b_t.","proofString":"auto with hahn."},{"statement":"set_finite ((E_s ∪₁ eq b_t) \\₁ is_init).","proofString":"rewrite set_minus_union_l, set_unionC.\napply set_finite_union.\nsplit.\neapply set_finite_mori; auto with hahn.\nred.\nbasic_solver.\napply (rsr_fin_s INV SIMREL)."},{"statement":"set_finite (eq b_t \\₁ is_init ∪₁ E_s \\₁ is_init).","proofString":"apply set_finite_union.\nsplit.\neapply set_finite_mori; auto with hahn.\nred.\nbasic_solver.\napply (rsr_fin_s INV SIMREL)."},{"statement":"set_finite (eq b_t \\₁ is_init) /\\ set_finite (E_s \\₁ is_init).","proofString":"split.\neapply set_finite_mori; auto with hahn.\nred.\nbasic_solver.\napply (rsr_fin_s INV SIMREL)."},{"statement":"set_finite (eq b_t \\₁ is_init).","proofString":"eapply set_finite_mori; auto with hahn.\nred.\nbasic_solver."},{"statement":"set_finite (E_s \\₁ is_init).","proofString":"apply (rsr_fin_s INV SIMREL)."},{"statement":"E_s'' ⊆₁ E_s'.","proofString":"simpl.\nbasic_solver."},{"statement":"E_s ∪₁ eq b_t ⊆₁ E_s ∪₁ eq b_t ∪₁ eq a_t.","proofString":"basic_solver."},{"statement":"(NINS : ~ E_s b_t) : sb_s'' ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t E_s.","proofString":"rewrite rsr_new_a_sb, seq_union_l.\narewrite_false (sb_s ⨾ ⦗eq b_t⦘).\nunfold sb.\nbasic_solver.\nrewrite union_false_l.\nunfold WCore.sb_delta.\nnow rewrite <- cross_inter_r, set_interK."},{"statement":"(NINS : ~ E_s b_t) : sb_s ⨾ ⦗eq b_t⦘ ∪ WCore.sb_delta b_t E_s ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t E_s.","proofString":"arewrite_false (sb_s ⨾ ⦗eq b_t⦘).\nunfold sb.\nbasic_solver.\nrewrite union_false_l.\nunfold WCore.sb_delta.\nnow rewrite <- cross_inter_r, set_interK."},{"statement":"(NINS : ~ E_s b_t) : sb_s ⨾ ⦗eq b_t⦘ ⊆ ∅₂.","proofString":"unfold sb.\nbasic_solver."},{"statement":"(NINS : ~ E_s b_t) : (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) ⨾ ⦗eq b_t⦘ ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(NINS : ~ E_s b_t) : ∅₂ ∪ WCore.sb_delta b_t E_s ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t E_s.","proofString":"rewrite union_false_l.\nunfold WCore.sb_delta.\nnow rewrite <- cross_inter_r, set_interK."},{"statement":"(NINS : ~ E_s b_t) : WCore.sb_delta b_t E_s ⨾ ⦗eq b_t⦘ ≡ WCore.sb_delta b_t E_s.","proofString":"unfold WCore.sb_delta.\nnow rewrite <- cross_inter_r, set_interK."},{"statement":"(NINS : ~ E_s b_t) : (is_init ∪₁ E_s ∩₁ same_tid b_t) × eq b_t ⨾ ⦗eq b_t⦘\n≡ (is_init ∪₁ E_s ∩₁ same_tid b_t) × eq b_t.","proofString":"now rewrite <- cross_inter_r, set_interK."},{"statement":"Wf G_s.","proofString":"apply (G_s_wf INV SIMREL)."},{"statement":"(WF_s : Wf G_s) : transitive co_s''.","proofString":"simpl.\napply expand_transitive.\napply WF_s.\narewrite (      W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a) =        E_s ∩₁ W_s ∩₁ Loc_s_ (WCore.lab_loc l_a)    ) by (apply set_extensionality; basic_solver).\nnow apply co_upward_closed.\nrewrite (wf_coE WF_s), dom_seq, dom_eqv.\nenough (~ E_s b_t) by basic_solver 11.\nauto with xmm."},{"statement":"(WF_s : Wf G_s) : transitive\n  (co_s\n   ∪ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a))\n     × (eq b_t ∩₁ WCore.lab_is_w l_a)).","proofString":"apply expand_transitive.\napply WF_s.\narewrite (      W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a) =        E_s ∩₁ W_s ∩₁ Loc_s_ (WCore.lab_loc l_a)    ) by (apply set_extensionality; basic_solver).\nnow apply co_upward_closed.\nrewrite (wf_coE WF_s), dom_seq, dom_eqv.\nenough (~ E_s b_t) by basic_solver 11.\nauto with xmm."},{"statement":"(WF_s : Wf G_s) : transitive co_s.","proofString":"apply WF_s."},{"statement":"(WF_s : Wf G_s) : upward_closed co_s (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a)).","proofString":"arewrite (      W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a) =        E_s ∩₁ W_s ∩₁ Loc_s_ (WCore.lab_loc l_a)    ) by (apply set_extensionality; basic_solver).\nnow apply co_upward_closed."},{"statement":"(WF_s : Wf G_s) : upward_closed co_s (E_s ∩₁ W_s ∩₁ Loc_s_ (WCore.lab_loc l_a)).","proofString":"now apply co_upward_closed."},{"statement":"(WF_s : Wf G_s) : eq b_t ∩₁ WCore.lab_is_w l_a ⊆₁ set_compl (dom_rel co_s).","proofString":"rewrite (wf_coE WF_s), dom_seq, dom_eqv.\nenough (~ E_s b_t) by basic_solver 11.\nauto with xmm."},{"statement":"(WF_s : Wf G_s) : eq b_t ∩₁ WCore.lab_is_w l_a ⊆₁ set_compl E_s.","proofString":"enough (~ E_s b_t) by basic_solver 11.\nauto with xmm."},{"statement":"(WF_s : Wf G_s) : ~ E_s b_t.","proofString":"auto with xmm."},{"statement":"Wf G_s.","proofString":"apply (G_s_wf INV SIMREL)."},{"statement":"(WF_s : Wf G_s) : functional rf_s''⁻¹.","proofString":"simpl.\napply functional_union.\napply WF_s.\narewrite (drf_s''⁻¹ ⊆ (fake_srf G_s b_t l_a)⁻¹).\napply transp_mori.\nbasic_solver.\nnow eapply fake_srff.\nintros x HIN1' HIN2'.\nassert (HIN1 : codom_rel rf_s x) by now apply dom_transp.\nassert (HIN2 : codom_rel drf_s'' x) by now apply dom_transp.\nenough (E_s b_t) by auto with xmm.\nassert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) : functional (rf_s ∪ drf_s'')⁻¹.","proofString":"apply functional_union.\napply WF_s.\narewrite (drf_s''⁻¹ ⊆ (fake_srf G_s b_t l_a)⁻¹).\napply transp_mori.\nbasic_solver.\nnow eapply fake_srff.\nintros x HIN1' HIN2'.\nassert (HIN1 : codom_rel rf_s x) by now apply dom_transp.\nassert (HIN2 : codom_rel drf_s'' x) by now apply dom_transp.\nenough (E_s b_t) by auto with xmm.\nassert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) : functional (fun x y : actid => rf_s y x).","proofString":"apply WF_s."},{"statement":"(WF_s : Wf G_s) : functional (fun x y : actid => drf_s'' y x).","proofString":"arewrite (drf_s''⁻¹ ⊆ (fake_srf G_s b_t l_a)⁻¹).\napply transp_mori.\nbasic_solver.\nnow eapply fake_srff."},{"statement":"(WF_s : Wf G_s) : drf_s''⁻¹ ⊆ (fake_srf G_s b_t l_a)⁻¹.","proofString":"apply transp_mori.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) : drf_s'' ⊆ fake_srf G_s b_t l_a.","proofString":"basic_solver."},{"statement":"(WF_s : Wf G_s) : functional (fake_srf G_s b_t l_a)⁻¹.","proofString":"now eapply fake_srff."},{"statement":"(WF_s : Wf G_s) : forall x : actid,\ndom_rel (fun x0 y : actid => rf_s y x0) x ->\ndom_rel (fun x0 y : actid => drf_s'' y x0) x -> False.","proofString":"intros x HIN1' HIN2'.\nassert (HIN1 : codom_rel rf_s x) by now apply dom_transp.\nassert (HIN2 : codom_rel drf_s'' x) by now apply dom_transp.\nenough (E_s b_t) by auto with xmm.\nassert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) : False.","proofString":"assert (HIN1 : codom_rel rf_s x) by now apply dom_transp.\nassert (HIN2 : codom_rel drf_s'' x) by now apply dom_transp.\nenough (E_s b_t) by auto with xmm.\nassert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) : False.","proofString":"assert (HIN2 : codom_rel drf_s'' x) by now apply dom_transp.\nenough (E_s b_t) by auto with xmm.\nassert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) (HIN2 : codom_rel drf_s'' x) : False.","proofString":"enough (E_s b_t) by auto with xmm.\nassert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) (HIN2 : codom_rel drf_s'' x) : E_s b_t.","proofString":"assert (XIN : E_s x).\nred in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s.\nenough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) (HIN2 : codom_rel drf_s'' x) : E_s x.","proofString":"red in HIN1.\ndestruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : exists x0 : actid, rf_s x0 x) (HIN2 : codom_rel drf_s'' x) : E_s x.","proofString":"destruct HIN1 as (y & RF).\neapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y0 : actid => rf_s y0 x0) x) (HIN2' : dom_rel (fun x0 y0 : actid => drf_s'' y0 x0) x) (y : actid) (RF : rf_s y x) (HIN2 : codom_rel drf_s'' x) : E_s x.","proofString":"eapply dom_helper_3 with (r := rf_s) (d := E_s); eauto.\napply WF_s."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y0 : actid => rf_s y0 x0) x) (HIN2' : dom_rel (fun x0 y0 : actid => drf_s'' y0 x0) x) (y : actid) (RF : rf_s y x) (HIN2 : codom_rel drf_s'' x) : rf_s ≡ ⦗E_s⦘ ⨾ rf_s ⨾ ⦗E_s⦘.","proofString":"apply WF_s."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) (HIN2 : codom_rel drf_s'' x) (XIN : E_s x) : E_s b_t.","proofString":"enough (x = b_t) by desf.\nforward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) (HIN2 : codom_rel drf_s'' x) (XIN : E_s x) : x = b_t.","proofString":"forward apply HIN2.\nbasic_solver."},{"statement":"(WF_s : Wf G_s) (x : actid) (HIN1' : dom_rel (fun x0 y : actid => rf_s y x0) x) (HIN2' : dom_rel (fun x0 y : actid => drf_s'' y x0) x) (HIN1 : codom_rel rf_s x) (HIN2 : codom_rel drf_s'' x) (XIN : E_s x) : codom_rel drf_s'' x -> x = b_t.","proofString":"basic_solver."},{"statement":"(is_init ∪₁ E_s'' ∩₁ same_tid a_t) × eq a_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t ∪ eq b_t × eq a_t.","proofString":"simpl.\nrewrite set_inter_union_l, !cross_union_l.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t)    ; [| basic_solver 11].\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"(is_init ∪₁ (E_s ∪₁ eq b_t) ∩₁ same_tid a_t) × eq a_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t ∪ eq b_t × eq a_t.","proofString":"rewrite set_inter_union_l, !cross_union_l.\narewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t)    ; [| basic_solver 11].\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"is_init × eq a_t\n∪ ((E_s ∩₁ same_tid a_t) × eq a_t ∪ (eq b_t ∩₁ same_tid a_t) × eq a_t)\n≡ is_init × eq a_t ∪ (E_s ∩₁ same_tid a_t) × eq a_t ∪ eq b_t × eq a_t.","proofString":"arewrite (eq b_t ∩₁ same_tid a_t ≡₁ eq b_t)    ; [| basic_solver 11].\nsplit; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"eq b_t ∩₁ same_tid a_t ≡₁ eq b_t.","proofString":"split; [basic_solver |].\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"eq b_t ⊆₁ eq b_t ∩₁ same_tid a_t.","proofString":"unfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"eq b_t ⊆₁ eq b_t ∩₁ (fun y : actid => tid a_t = tid y).","proofString":"rewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"eq b_t ⊆₁ eq b_t ∩₁ (fun y : actid => tid b_t = tid y).","proofString":"basic_solver."},{"statement":"dom_rel ((is_init ∪₁ E_s ∩₁ same_tid a_t) × eq a_t) × eq b_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid b_t) × eq b_t.","proofString":"arewrite (same_tid a_t ≡₁ same_tid b_t).\nunfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver.\nrewrite dom_cross; [reflexivity |].\nintro FALSO.\nunfolder in FALSO.\ndesf.\neauto."},{"statement":"same_tid a_t ≡₁ same_tid b_t.","proofString":"unfold same_tid.\nrewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"(fun y : actid => tid a_t = tid y) ≡₁ (fun y : actid => tid b_t = tid y).","proofString":"rewrite (rsr_at_bt_tid INV).\nbasic_solver."},{"statement":"(fun y : actid => tid b_t = tid y) ≡₁ (fun y : actid => tid b_t = tid y).","proofString":"basic_solver."},{"statement":"dom_rel ((is_init ∪₁ E_s ∩₁ same_tid b_t) × eq a_t) × eq b_t\n≡ (is_init ∪₁ E_s ∩₁ same_tid b_t) × eq b_t.","proofString":"rewrite dom_cross; [reflexivity |].\nintro FALSO.\nunfolder in FALSO.\ndesf.\neauto."},{"statement":"~ eq a_t ≡₁ ∅.","proofString":"intro FALSO.\nunfolder in FALSO.\ndesf.\neauto."},{"statement":"(FALSO : eq a_t ≡₁ ∅) : False.","proofString":"unfolder in FALSO.\ndesf.\neauto."},{"statement":"(FALSO : (forall x : actid, a_t = x -> False) /\\ (forall x : actid, False -> a_t = x)) : False.","proofString":"desf.\neauto."},{"statement":"(FALSO : forall x : actid, a_t = x -> False) (FALSO0 : forall x : actid, False -> a_t = x) : False.","proofString":"eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sb_s'\n≡ mapper ↑ swap_rel sb_t' (eq b_t ∩₁ E_t') (eq a_t ∩₁ E_t')\n  ∪ (mapper ↑₁ dom_rel (sb_t' ⨾ ⦗eq b_t⦘)) × A_s' ∪ \n  A_s' × eq (mapper b_t).","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\nrewrite rsr_mapper_bt, rsr_b_new_exa; auto.\narewrite (eq a_t ∩₁ E_t' ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t' a_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_r.\nrewrite (sb_deltaE ADD'), (WCore.add_event_sb ADD').\nrewrite rsr_new_a_sb', rsr_new_a_sb, (rsr_sb SIMREL).\nrewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : sb_s'\n≡ mapper ↑ swap_rel sb_t' (eq b_t ∩₁ E_t') (eq a_t ∩₁ E_t')\n  ∪ (mapper ↑₁ dom_rel (sb_t' ⨾ ⦗eq b_t⦘)) × A_s' ∪ \n  A_s' × eq (mapper b_t).","proofString":"rewrite rsr_mapper_bt, rsr_b_new_exa; auto.\narewrite (eq a_t ∩₁ E_t' ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t' a_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_r.\nrewrite (sb_deltaE ADD'), (WCore.add_event_sb ADD').\nrewrite rsr_new_a_sb', rsr_new_a_sb, (rsr_sb SIMREL).\nrewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : sb_s'\n≡ mapper ↑ swap_rel sb_t' (eq b_t ∩₁ E_t') (eq a_t ∩₁ E_t')\n  ∪ (mapper ↑₁ dom_rel (sb_t' ⨾ ⦗eq b_t⦘)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"arewrite (eq a_t ∩₁ E_t' ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t' a_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_r.\nrewrite (sb_deltaE ADD'), (WCore.add_event_sb ADD').\nrewrite rsr_new_a_sb', rsr_new_a_sb, (rsr_sb SIMREL).\nrewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : eq a_t ∩₁ E_t' ≡₁ ∅.","proofString":"split; auto with hahn.\nenough (~E_t' a_t) by basic_solver.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : eq a_t ∩₁ E_t' ⊆₁ ∅.","proofString":"enough (~E_t' a_t) by basic_solver.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : ~ E_t' a_t.","proofString":"auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : sb_s'\n≡ mapper ↑ swap_rel sb_t' (eq b_t ∩₁ E_t') ∅\n  ∪ (mapper ↑₁ dom_rel (sb_t' ⨾ ⦗eq b_t⦘)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"rewrite swap_rel_empty_r.\nrewrite (sb_deltaE ADD'), (WCore.add_event_sb ADD').\nrewrite rsr_new_a_sb', rsr_new_a_sb, (rsr_sb SIMREL).\nrewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : sb_s'\n≡ mapper ↑ sb_t' ∪ (mapper ↑₁ dom_rel (sb_t' ⨾ ⦗eq b_t⦘)) × eq b_t\n  ∪ eq b_t × eq a_t.","proofString":"rewrite (sb_deltaE ADD'), (WCore.add_event_sb ADD').\nrewrite rsr_new_a_sb', rsr_new_a_sb, (rsr_sb SIMREL).\nrewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : sb_s'\n≡ mapper ↑ (sb_t ∪ WCore.sb_delta b_t E_t)\n  ∪ (mapper ↑₁ dom_rel (WCore.sb_delta b_t E_t)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"rewrite rsr_new_a_sb', rsr_new_a_sb, (rsr_sb SIMREL).\nrewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : mapper ↑ swap_rel sb_t (eq b_t ∩₁ E_t) (eq a_t ∩₁ E_t)\n∪ (mapper ↑₁ dom_rel (sb_t ⨾ ⦗eq b_t⦘)) × A_s ∪ A_s × eq (mapper b_t)\n∪ WCore.sb_delta b_t E_s ∪ WCore.sb_delta a_t E_s''\n≡ mapper ↑ (sb_t ∪ WCore.sb_delta b_t E_t)\n  ∪ (mapper ↑₁ dom_rel (WCore.sb_delta b_t E_t)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"rewrite rsr_b_old_exa, cross_false_l, cross_false_r,          !union_false_r.\narewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : mapper ↑ swap_rel sb_t (eq b_t ∩₁ E_t) (eq a_t ∩₁ E_t)\n∪ WCore.sb_delta b_t E_s ∪ WCore.sb_delta a_t E_s''\n≡ mapper ↑ (sb_t ∪ WCore.sb_delta b_t E_t)\n  ∪ (mapper ↑₁ dom_rel (WCore.sb_delta b_t E_t)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"arewrite (eq b_t ∩₁ E_t ≡₁ ∅).\nsplit; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm.\nrewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : eq b_t ∩₁ E_t ≡₁ ∅.","proofString":"split; auto with hahn.\nenough (~E_t b_t) by basic_solver.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : eq b_t ∩₁ E_t ⊆₁ ∅.","proofString":"enough (~E_t b_t) by basic_solver.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : ~ E_t b_t.","proofString":"auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : mapper ↑ swap_rel sb_t ∅ (eq a_t ∩₁ E_t) ∪ WCore.sb_delta b_t E_s\n∪ WCore.sb_delta a_t E_s''\n≡ mapper ↑ (sb_t ∪ WCore.sb_delta b_t E_t)\n  ∪ (mapper ↑₁ dom_rel (WCore.sb_delta b_t E_t)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"rewrite swap_rel_empty_l, collect_rel_union.\nrewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : mapper ↑ sb_t ∪ WCore.sb_delta b_t E_s ∪ WCore.sb_delta a_t E_s''\n≡ mapper ↑ sb_t ∪ mapper ↑ WCore.sb_delta b_t E_t\n  ∪ (mapper ↑₁ dom_rel (WCore.sb_delta b_t E_t)) × eq b_t ∪ \n  eq b_t × eq a_t.","proofString":"rewrite set_collect_dom, rsr_b_map_sbdelta.\nrewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : mapper ↑ sb_t ∪ WCore.sb_delta b_t E_s ∪ WCore.sb_delta a_t E_s''\n≡ mapper ↑ sb_t ∪ WCore.sb_delta a_t E_s\n  ∪ dom_rel (WCore.sb_delta a_t E_s) × eq b_t ∪ eq b_t × eq a_t.","proofString":"rewrite rsr_sb_sim_sb_helper', rsr_sb_sim_sb_helper''.\nbasic_solver 11."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (NEQ : a_t <> b_t) : mapper ↑ sb_t ∪ WCore.sb_delta b_t E_s\n∪ (WCore.sb_delta a_t E_s ∪ eq b_t × eq a_t)\n≡ mapper ↑ sb_t ∪ WCore.sb_delta a_t E_s ∪ WCore.sb_delta b_t E_s\n  ∪ eq b_t × eq a_t.","proofString":"basic_solver 11."},{"statement":"(w : option actid) (EQ : drf_s'' ≡ eq_opt w × eq b_t) : eq_opt w ≡₁ dom_rel drf_s''.","proofString":"rewrite EQ.\nbasic_solver."},{"statement":"(w : option actid) (EQ : drf_s'' ≡ eq_opt w × eq b_t) : eq_opt w ≡₁ dom_rel (eq_opt w × eq b_t).","proofString":"basic_solver."},{"statement":"(w : option actid) (EQ : drf_s'' ≡ eq_opt w × eq b_t) : dom_rel drf_s''\n⊆₁ W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a) ∩₁ Val_s_ (WCore.lab_val l_a).","proofString":"apply set_subset_inter_r.\nsplit; [|apply LVAL].\nrewrite fake_srfE_left, fake_srfD_left,          fake_srfl.\nbasic_solver."},{"statement":"(w : option actid) (EQ : drf_s'' ≡ eq_opt w × eq b_t) : dom_rel drf_s'' ⊆₁ W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a) /\\\ndom_rel drf_s'' ⊆₁ Val_s_ (WCore.lab_val l_a).","proofString":"split; [|apply LVAL].\nrewrite fake_srfE_left, fake_srfD_left,          fake_srfl.\nbasic_solver."},{"statement":"(w : option actid) (EQ : drf_s'' ≡ eq_opt w × eq b_t) : dom_rel drf_s'' ⊆₁ W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a).","proofString":"rewrite fake_srfE_left, fake_srfD_left,          fake_srfl.\nbasic_solver."},{"statement":"(w : option actid) (EQ : drf_s'' ≡ eq_opt w × eq b_t) : dom_rel\n  ((⦗E_s⦘ ⨾ ⦗W_s⦘ ⨾ ⦗Loc_s_ (WCore.lab_loc l_a)⦘ ⨾ fake_srf G_s b_t l_a)\n   ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘)\n⊆₁ W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a).","proofString":"basic_solver."},{"statement":"WCore.add_event X_s X_s'' b_t l_a.","proofString":"apply rsr_b_step1."},{"statement":"(STEP : WCore.add_event X_s X_s'' b_t l_a) : Wf G_s''.","proofString":"red in STEP.\ndesf.\napply (add_event_wf STEP rsr_b_Gs_wf)."},{"statement":"(STEP : exists\n  (r : option actid) (R1 : actid -> Prop) (w : option actid) \n(W1 W2 : actid -> Prop), WCore.add_event_gen X_s X_s'' b_t l_a r R1 w W1 W2) : Wf G_s''.","proofString":"desf.\napply (add_event_wf STEP rsr_b_Gs_wf)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (STEP : WCore.add_event_gen X_s X_s'' b_t l_a r R1 w W1 W2) : Wf G_s''.","proofString":"apply (add_event_wf STEP rsr_b_Gs_wf)."},{"statement":"eq a_t ∩₁ W_s' ∩₁ Loc_s_' (loc_s' b_t) ≡₁ ∅.","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\nenough (loc_s' a_t <> loc_s' b_t) by basic_solver.\nsimpl.\nunfold loc.\nrewrite upds, updo, upds by congruence.\napply NLOC."},{"statement":"(NEQ : a_t <> b_t) : eq a_t ∩₁ W_s' ∩₁ Loc_s_' (loc_s' b_t) ≡₁ ∅.","proofString":"enough (loc_s' a_t <> loc_s' b_t) by basic_solver.\nsimpl.\nunfold loc.\nrewrite upds, updo, upds by congruence.\napply NLOC."},{"statement":"(NEQ : a_t <> b_t) : loc_s' a_t <> loc_s' b_t.","proofString":"simpl.\nunfold loc.\nrewrite upds, updo, upds by congruence.\napply NLOC."},{"statement":"(NEQ : a_t <> b_t) : loc (upd (upd lab_s b_t l_a) a_t l_b) a_t <>\nloc (upd (upd lab_s b_t l_a) a_t l_b) b_t.","proofString":"unfold loc.\nrewrite upds, updo, upds by congruence.\napply NLOC."},{"statement":"(NEQ : a_t <> b_t) : match upd (upd lab_s b_t l_a) a_t l_b a_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend <>\nmatch upd (upd lab_s b_t l_a) a_t l_b b_t with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"rewrite upds, updo, upds by congruence.\napply NLOC."},{"statement":"(NEQ : a_t <> b_t) : match l_b with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend <>\nmatch l_a with\n| Aload _ _ l _ | Astore _ _ l _ => Some l\n| Afence _ => None\nend.","proofString":"apply NLOC."},{"statement":"(BNIN : ~ E_s b_t) : WCore.is_cons G_s''.","proofString":"assert (ANIN : ~E_s a_t) by auto with xmm.\nassert (NEQ : a_t <> b_t) by apply INV.\nassert (WF_s : Wf G_s) by apply (G_s_wf INV SIMREL).\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nset (G_s''' := restrict G_s' E_s'').\nassert (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂).\nsubst G_s'''.\napply restrict_sub.\nbasic_solver.\nsimpl.\nbasic_solver.\nassert (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅).\nbasic_solver 11.\napply XmmCons.consistency_swap_lab with (G_t := G_s''').\nsimpl.\nrewrite !set_inter_union_r.\nbasic_solver 11.\nsimpl.\nrewrite <- rsr_b_fakesrf.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11.\nsimpl.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11.\nrewrite (wf_rmwE rsr_imm_Gs_wf).\nsimpl.\nrewrite (WCore.add_event_rmw ADD').\nrewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r.\nreflexivity.\nsimpl.\narewrite (      (E_s ∪₁ eq b_t) ∩₁        (E_s ∪₁ eq b_t ∪₁ eq a_t) ≡₁          E_s ∪₁ eq b_t    ) by basic_solver 11.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence.\nsimpl.\nrewrite (rsr_data SIMREL), (rsr_ndata INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_addr SIMREL), (rsr_naddr INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_ctrl SIMREL), (rsr_nctrl INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_rmw_dep SIMREL), (rsr_nrmw_dep INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply sub_WF with (G := G_s') (sc := ∅₂) (sc' := ∅₂).\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply rsr_new_Gs_wf.\nexact SUB.\napply XmmCons.consistency_subexec   with (G_t := G_s') (sc_s := ∅₂) (sc_t := ∅₂).\napply rsr_new_Gs_cons.\nexact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) : WCore.is_cons G_s''.","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\nassert (WF_s : Wf G_s) by apply (G_s_wf INV SIMREL).\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nset (G_s''' := restrict G_s' E_s'').\nassert (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂).\nsubst G_s'''.\napply restrict_sub.\nbasic_solver.\nsimpl.\nbasic_solver.\nassert (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅).\nbasic_solver 11.\napply XmmCons.consistency_swap_lab with (G_t := G_s''').\nsimpl.\nrewrite !set_inter_union_r.\nbasic_solver 11.\nsimpl.\nrewrite <- rsr_b_fakesrf.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11.\nsimpl.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11.\nrewrite (wf_rmwE rsr_imm_Gs_wf).\nsimpl.\nrewrite (WCore.add_event_rmw ADD').\nrewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r.\nreflexivity.\nsimpl.\narewrite (      (E_s ∪₁ eq b_t) ∩₁        (E_s ∪₁ eq b_t ∪₁ eq a_t) ≡₁          E_s ∪₁ eq b_t    ) by basic_solver 11.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence.\nsimpl.\nrewrite (rsr_data SIMREL), (rsr_ndata INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_addr SIMREL), (rsr_naddr INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_ctrl SIMREL), (rsr_nctrl INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_rmw_dep SIMREL), (rsr_nrmw_dep INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply sub_WF with (G := G_s') (sc := ∅₂) (sc' := ∅₂).\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply rsr_new_Gs_wf.\nexact SUB.\napply XmmCons.consistency_subexec   with (G_t := G_s') (sc_s := ∅₂) (sc_t := ∅₂).\napply rsr_new_Gs_cons.\nexact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) : WCore.is_cons G_s''.","proofString":"assert (WF_s : Wf G_s) by apply (G_s_wf INV SIMREL).\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nset (G_s''' := restrict G_s' E_s'').\nassert (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂).\nsubst G_s'''.\napply restrict_sub.\nbasic_solver.\nsimpl.\nbasic_solver.\nassert (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅).\nbasic_solver 11.\napply XmmCons.consistency_swap_lab with (G_t := G_s''').\nsimpl.\nrewrite !set_inter_union_r.\nbasic_solver 11.\nsimpl.\nrewrite <- rsr_b_fakesrf.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11.\nsimpl.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11.\nrewrite (wf_rmwE rsr_imm_Gs_wf).\nsimpl.\nrewrite (WCore.add_event_rmw ADD').\nrewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r.\nreflexivity.\nsimpl.\narewrite (      (E_s ∪₁ eq b_t) ∩₁        (E_s ∪₁ eq b_t ∪₁ eq a_t) ≡₁          E_s ∪₁ eq b_t    ) by basic_solver 11.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence.\nsimpl.\nrewrite (rsr_data SIMREL), (rsr_ndata INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_addr SIMREL), (rsr_naddr INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_ctrl SIMREL), (rsr_nctrl INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_rmw_dep SIMREL), (rsr_nrmw_dep INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply sub_WF with (G := G_s') (sc := ∅₂) (sc' := ∅₂).\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply rsr_new_Gs_wf.\nexact SUB.\napply XmmCons.consistency_subexec   with (G_t := G_s') (sc_s := ∅₂) (sc_t := ∅₂).\napply rsr_new_Gs_cons.\nexact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) : WCore.is_cons G_s''.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nset (G_s''' := restrict G_s' E_s'').\nassert (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂).\nsubst G_s'''.\napply restrict_sub.\nbasic_solver.\nsimpl.\nbasic_solver.\nassert (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅).\nbasic_solver 11.\napply XmmCons.consistency_swap_lab with (G_t := G_s''').\nsimpl.\nrewrite !set_inter_union_r.\nbasic_solver 11.\nsimpl.\nrewrite <- rsr_b_fakesrf.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11.\nsimpl.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11.\nrewrite (wf_rmwE rsr_imm_Gs_wf).\nsimpl.\nrewrite (WCore.add_event_rmw ADD').\nrewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r.\nreflexivity.\nsimpl.\narewrite (      (E_s ∪₁ eq b_t) ∩₁        (E_s ∪₁ eq b_t ∪₁ eq a_t) ≡₁          E_s ∪₁ eq b_t    ) by basic_solver 11.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence.\nsimpl.\nrewrite (rsr_data SIMREL), (rsr_ndata INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_addr SIMREL), (rsr_naddr INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_ctrl SIMREL), (rsr_nctrl INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_rmw_dep SIMREL), (rsr_nrmw_dep INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply sub_WF with (G := G_s') (sc := ∅₂) (sc' := ∅₂).\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply rsr_new_Gs_wf.\nexact SUB.\napply XmmCons.consistency_subexec   with (G_t := G_s') (sc_s := ∅₂) (sc_t := ∅₂).\napply rsr_new_Gs_cons.\nexact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : WCore.is_cons G_s''.","proofString":"set (G_s''' := restrict G_s' E_s'').\nassert (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂).\nsubst G_s'''.\napply restrict_sub.\nbasic_solver.\nsimpl.\nbasic_solver.\nassert (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅).\nbasic_solver 11.\napply XmmCons.consistency_swap_lab with (G_t := G_s''').\nsimpl.\nrewrite !set_inter_union_r.\nbasic_solver 11.\nsimpl.\nrewrite <- rsr_b_fakesrf.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11.\nsimpl.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11.\nrewrite (wf_rmwE rsr_imm_Gs_wf).\nsimpl.\nrewrite (WCore.add_event_rmw ADD').\nrewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r.\nreflexivity.\nsimpl.\narewrite (      (E_s ∪₁ eq b_t) ∩₁        (E_s ∪₁ eq b_t ∪₁ eq a_t) ≡₁          E_s ∪₁ eq b_t    ) by basic_solver 11.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence.\nsimpl.\nrewrite (rsr_data SIMREL), (rsr_ndata INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_addr SIMREL), (rsr_naddr INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_ctrl SIMREL), (rsr_nctrl INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_rmw_dep SIMREL), (rsr_nrmw_dep INV).\nbasic_solver.\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply sub_WF with (G := G_s') (sc := ∅₂) (sc' := ∅₂).\nsimpl.\nrewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver.\napply rsr_new_Gs_wf.\nexact SUB.\napply XmmCons.consistency_subexec   with (G_t := G_s') (sc_s := ∅₂) (sc_t := ∅₂).\napply rsr_new_Gs_cons.\nexact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : sub_execution G_s' (restrict G_s' E_s'') ∅₂ ∅₂.","proofString":"apply restrict_sub.\nbasic_solver.\nsimpl.\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : ∅₂ ≡ ⦗E_s''⦘ ⨾ ∅₂ ⨾ ⦗E_s''⦘.","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : E_s'' ⊆₁ E_s'.","proofString":"simpl.\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) : E_s ∪₁ eq b_t ⊆₁ E_s ∪₁ eq b_t ∪₁ eq a_t.","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅.","proofString":"basic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : E_s ∪₁ eq b_t ≡₁ (E_s ∪₁ eq b_t) ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t).","proofString":"rewrite !set_inter_union_r.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : E_s ∪₁ eq b_t\n≡₁ (E_s ∪₁ eq b_t) ∩₁ E_s ∪₁ (E_s ∪₁ eq b_t) ∩₁ eq b_t\n   ∪₁ (E_s ∪₁ eq b_t) ∩₁ eq a_t.","proofString":"basic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rf_s ∪ drf_s''\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ (rf_s ∪ mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ∪ drf_s'') ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite <- rsr_b_fakesrf.\nrewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rf_s ∪ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ (rf_s ∪ mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘)\n     ∪ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘) ⨾ ⦗\n    E_s ∪₁ eq b_t⦘.","proofString":"rewrite !seq_union_l, !seq_union_r.\narewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rf_s ∪ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ rf_s ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ (srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"arewrite_false (mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘).\nrewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r.\nrewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : mapper ↑ (rf_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite collect_rel_seqi, collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : (mapper ↑ rf_t' ⨾ ⦗eq (mapper b_t)⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite rsr_mapper_bt, seqA, <- id_inter; auto.\nnow rewrite EMP, eqv_empty, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : mapper ↑ rf_t' ⨾ ⦗eq a_t ∩₁ (E_s ∪₁ eq b_t)⦘ ⊆ ∅₂.","proofString":"now rewrite EMP, eqv_empty, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rf_s ∪ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ rf_s ⨾ ⦗E_s ∪₁ eq b_t⦘ ∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ ∅₂\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite seq_false_r, union_false_r.\napply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rf_s ∪ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ rf_s ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"apply union_more.\nrewrite (wf_rfE WF_s).\nbasic_solver 11.\nchange (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rf_s ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ rf_s ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (wf_rfE WF_s).\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s⦘ ⨾ rf_s ⨾ ⦗E_s⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ (⦗E_s⦘ ⨾ rf_s ⨾ ⦗E_s⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"change (srf rsr_b_immg) with srf_s''.\nrewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ srf_s'' ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite wf_srfE.\nsimpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : (⦗E_s''⦘ ⨾ srf_s'' ⨾ ⦗E_s''⦘) ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ (⦗E_s''⦘ ⨾ srf_s'' ⨾ ⦗E_s''⦘)\n    ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"simpl.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : (⦗E_s ∪₁ eq b_t⦘ ⨾ srf rsr_b_immg ⨾ ⦗E_s ∪₁ eq b_t⦘)\n⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ (⦗E_s ∪₁ eq b_t⦘ ⨾ srf rsr_b_immg ⨾ ⦗E_s ∪₁ eq b_t⦘)\n    ⨾ ⦗eq b_t ∩₁ WCore.lab_is_r l_a⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : co_s\n∪ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a)) × (eq b_t ∩₁ WCore.lab_is_w l_a)\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ (co_s ∪ mapper ↑ (⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘)\n     ∪ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a))\n       × (eq b_t ∩₁ WCore.lab_is_w l_a)) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite !seq_union_l, !seq_union_r.\narewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : co_s\n∪ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a)) × (eq b_t ∩₁ WCore.lab_is_w l_a)\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ co_s ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ mapper ↑ (⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a))\n      × (eq b_t ∩₁ WCore.lab_is_w l_a) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"arewrite_false (        ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ (          ⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘        ) ⨾ ⦗E_s ∪₁ eq b_t⦘    ).\nrewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r.\nrewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘\n⨾ mapper ↑ (⦗eq b_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq b_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite collect_rel_union, !collect_rel_seqi.\nrewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘\n⨾ (mapper ↑ ⦗eq b_t⦘ ⨾ mapper ↑ co_t' ∪ mapper ↑ co_t' ⨾ mapper ↑ ⦗eq b_t⦘)\n  ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite collect_rel_eqv, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘\n⨾ (⦗eq (mapper b_t)⦘ ⨾ mapper ↑ co_t' ∪ mapper ↑ co_t' ⨾ ⦗eq (mapper b_t)⦘)\n  ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite rsr_mapper_bt; auto.\nrewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘\n⨾ (⦗eq a_t⦘ ⨾ mapper ↑ co_t' ∪ mapper ↑ co_t' ⨾ ⦗eq a_t⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘\n⊆ ∅₂.","proofString":"rewrite !seq_union_l, !seq_union_r, !seqA.\nseq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ ⦗eq a_t⦘ ⨾ mapper ↑ co_t' ⨾ ⦗E_s ∪₁ eq b_t⦘\n∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ co_t' ⨾ ⦗eq a_t⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"seq_rewrite (seq_eqvC (E_s ∪₁ eq b_t) (eq a_t)).\nrewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : (⦗eq a_t⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘) ⨾ mapper ↑ co_t' ⨾ ⦗E_s ∪₁ eq b_t⦘\n∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ co_t' ⨾ ⦗eq a_t⦘ ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite <- !id_inter, EMP.\nrewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗∅⦘ ⨾ mapper ↑ co_t' ⨾ ⦗E_s ∪₁ eq b_t⦘\n∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ co_t' ⨾ ⦗∅⦘ ⊆ ∅₂.","proofString":"rewrite eqv_empty, seq_false_l, !seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : co_s\n∪ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a)) × (eq b_t ∩₁ WCore.lab_is_w l_a)\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ co_s ⨾ ⦗E_s ∪₁ eq b_t⦘ ∪ ∅₂\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a))\n      × (eq b_t ∩₁ WCore.lab_is_w l_a) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite union_false_r.\napply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : co_s\n∪ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a)) × (eq b_t ∩₁ WCore.lab_is_w l_a)\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ co_s ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘\n    ⨾ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a))\n      × (eq b_t ∩₁ WCore.lab_is_w l_a) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"apply union_more.\nrewrite (wf_coE WF_s).\nbasic_solver 11.\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : co_s ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ co_s ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (wf_coE WF_s).\nbasic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s⦘ ⨾ co_s ⨾ ⦗E_s⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ (⦗E_s⦘ ⨾ co_s ⨾ ⦗E_s⦘) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a)) × (eq b_t ∩₁ WCore.lab_is_w l_a)\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ (W_s ∩₁ E_s ∩₁ Loc_s_ (WCore.lab_loc l_a))\n    × (eq b_t ∩₁ WCore.lab_is_w l_a) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver 11."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t ⨾ ⦗E_s ∪₁ eq b_t⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t' ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (WCore.add_event_rmw ADD').\nrewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t ⨾ ⦗E_s ∪₁ eq b_t⦘\n≡ ⦗E_s ∪₁ eq b_t⦘\n  ⨾ mapper ↑ (rmw_t ∪ WCore.rmw_delta b_t r) ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite collect_rel_union, seq_union_l, seq_union_r.\narewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t ⨾ ⦗E_s ∪₁ eq b_t⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t ⨾ ⦗E_s ∪₁ eq b_t⦘\n  ∪ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ WCore.rmw_delta b_t r ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"arewrite_false (      ⦗E_s ∪₁ eq b_t⦘ ⨾        mapper ↑ WCore.rmw_delta b_t r ⨾          ⦗E_s ∪₁ eq b_t⦘    ).\nunfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r.\nnow rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ WCore.rmw_delta b_t r ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"unfold WCore.rmw_delta.\nrewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ eq_opt r × eq b_t ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite collect_rel_cross, set_collect_eq.\nrewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ (mapper ↑₁ eq_opt r) × eq (mapper b_t) ⨾ ⦗E_s ∪₁ eq b_t⦘\n⊆ ∅₂.","proofString":"rewrite rsr_mapper_bt; auto.\nrewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ (mapper ↑₁ eq_opt r) × eq a_t ⨾ ⦗E_s ∪₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite <- cross_inter_r, EMP.\nnow rewrite cross_false_r, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ (mapper ↑₁ eq_opt r) × ∅ ⊆ ∅₂.","proofString":"now rewrite cross_false_r, seq_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t ⨾ ⦗E_s ∪₁ eq b_t⦘\n≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ mapper ↑ rmw_t ⨾ ⦗E_s ∪₁ eq b_t⦘ ∪ ∅₂.","proofString":"now rewrite union_false_r."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : eq_dom ((E_s ∪₁ eq b_t) ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t)) \n  (upd lab_s b_t l_a) (upd (upd lab_s b_t l_a) a_t l_b).","proofString":"arewrite (      (E_s ∪₁ eq b_t) ∩₁        (E_s ∪₁ eq b_t ∪₁ eq a_t) ≡₁          E_s ∪₁ eq b_t    ) by basic_solver 11.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : eq_dom (E_s ∪₁ eq b_t) (upd lab_s b_t l_a) (upd (upd lab_s b_t l_a) a_t l_b).","proofString":"apply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintros [XIN | EQ]; congruence."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ~ (E_s ∪₁ eq b_t) a_t.","proofString":"unfolder.\nintros [XIN | EQ]; congruence."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ~ (E_s a_t \\/ b_t = a_t).","proofString":"intros [XIN | EQ]; congruence."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : data_s ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ data_s ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (rsr_data SIMREL), (rsr_ndata INV).\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ∅₂ ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ ∅₂ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : addr_s ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ addr_s ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (rsr_addr SIMREL), (rsr_naddr INV).\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ∅₂ ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ ∅₂ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ctrl_s ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ ctrl_s ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (rsr_ctrl SIMREL), (rsr_nctrl INV).\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ∅₂ ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ ∅₂ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : rmw_dep_s ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ rmw_dep_s ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"rewrite (rsr_rmw_dep SIMREL), (rsr_nrmw_dep INV).\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : ∅₂ ≡ ⦗E_s ∪₁ eq b_t⦘ ⨾ ∅₂ ⨾ ⦗E_s ∪₁ eq b_t⦘.","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : is_init ⊆₁ (E_s ∪₁ eq b_t) ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t).","proofString":"rewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : E_s ⊆₁ (E_s ∪₁ eq b_t) ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t).","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : is_init ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t)\n⊆₁ (E_s ∪₁ eq b_t) ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t).","proofString":"rewrite (rsr_init_acts_s INV SIMREL).\nbasic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : E_s ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t)\n⊆₁ (E_s ∪₁ eq b_t) ∩₁ (E_s ∪₁ eq b_t ∪₁ eq a_t).","proofString":"basic_solver."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : Wf G_s'.","proofString":"apply rsr_new_Gs_wf."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : sub_execution G_s' G_s''' ∅₂ ∅₂.","proofString":"exact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : WCore.is_cons G_s'''.","proofString":"apply XmmCons.consistency_subexec   with (G_t := G_s') (sc_s := ∅₂) (sc_t := ∅₂).\napply rsr_new_Gs_cons.\nexact SUB."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : WCore.is_cons G_s'.","proofString":"apply rsr_new_Gs_cons."},{"statement":"(BNIN : ~ E_s b_t) (ANIN : ~ E_s a_t) (NEQ : a_t <> b_t) (WF_s : Wf G_s) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' b_t l_b r R1 w W1 W2) (G_s''' : execution) (SUB : sub_execution G_s' G_s''' ∅₂ ∅₂) (EMP : eq a_t ∩₁ (E_s ∪₁ eq b_t) ⊆₁ ∅) : sub_execution G_s' G_s''' ∅₂ ∅₂.","proofString":"exact SUB."},{"statement":"WCore.add_event X_s X_s'' b_t l_a.","proofString":"apply rsr_b_step1."},{"statement":"rf_complete G_s''.","proofString":"apply rsr_b_imm_rfc."},{"statement":"WCore.is_cons G_s''.","proofString":"apply rsr_imm_Gs_cons."},{"statement":"WCore.add_event X_s'' X_s' a_t l_b.","proofString":"apply rsr_b_step2."},{"statement":"rf_complete G_s'.","proofString":"apply (G_s_rfc INV' rsr_b_sim)."},{"statement":"WCore.is_cons G_s'.","proofString":"apply rsr_new_Gs_cons."}]}