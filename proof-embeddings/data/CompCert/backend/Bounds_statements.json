{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Bounds.v","fileSamples":[{"statement":"(A : Type) (valu : A -> Z) : forall l : list A, max_over_list valu l >= 0.","proofString":"unfold max_over_list.\nassert (forall l z, fold_left (fun x y => Z.max x (valu y)) l z >= z).\ninduction l; simpl; intros.\nlia.\napply Zge_trans with (Z.max z (valu a)).\nauto.\napply Z.le_ge.\napply Z.le_max_l.\nauto."},{"statement":"(A : Type) (valu : A -> Z) : forall l : list A,\nfold_left (fun (m : Z) (l0 : A) => Z.max m (valu l0)) l 0 >= 0.","proofString":"assert (forall l z, fold_left (fun x y => Z.max x (valu y)) l z >= z).\ninduction l; simpl; intros.\nlia.\napply Zge_trans with (Z.max z (valu a)).\nauto.\napply Z.le_ge.\napply Z.le_max_l.\nauto."},{"statement":"(A : Type) (valu : A -> Z) : forall (l : list A) (z : Z),\nfold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l z >= z.","proofString":"induction l; simpl; intros.\nlia.\napply Zge_trans with (Z.max z (valu a)).\nauto.\napply Z.le_ge.\napply Z.le_max_l."},{"statement":"(A : Type) (valu : A -> Z) (z : Z) : z >= z.","proofString":"lia."},{"statement":"(A : Type) (valu : A -> Z) (a : A) (l : list A) (IHl : forall z0 : Z, fold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l z0 >= z0) (z : Z) : fold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l (Z.max z (valu a)) >= z.","proofString":"apply Zge_trans with (Z.max z (valu a)).\nauto.\napply Z.le_ge.\napply Z.le_max_l."},{"statement":"(A : Type) (valu : A -> Z) (a : A) (l : list A) (IHl : forall z0 : Z, fold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l z0 >= z0) (z : Z) : fold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l (Z.max z (valu a)) >=\nZ.max z (valu a).","proofString":"auto."},{"statement":"(A : Type) (valu : A -> Z) (a : A) (l : list A) (IHl : forall z0 : Z, fold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l z0 >= z0) (z : Z) : Z.max z (valu a) >= z.","proofString":"apply Z.le_ge.\napply Z.le_max_l."},{"statement":"(A : Type) (valu : A -> Z) (a : A) (l : list A) (IHl : forall z0 : Z, fold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l z0 >= z0) (z : Z) : z <= Z.max z (valu a).","proofString":"apply Z.le_max_l."},{"statement":"(A : Type) (valu : A -> Z) (H : forall (l : list A) (z : Z),\nfold_left (fun (x : Z) (y : A) => Z.max x (valu y)) l z >= z) : forall l : list A,\nfold_left (fun (m : Z) (l0 : A) => Z.max m (valu l0)) l 0 >= 0.","proofString":"auto."},{"statement":"(valu : slot * Z * typ -> Z) : max_over_slots_of_funct valu >= 0.","proofString":"unfold max_over_slots_of_funct.\nunfold max_over_instrs.\napply max_over_list_pos."},{"statement":"(valu : slot * Z * typ -> Z) : max_over_instrs (max_over_slots_of_instr valu) >= 0.","proofString":"unfold max_over_instrs.\napply max_over_list_pos."},{"statement":"(valu : slot * Z * typ -> Z) : max_over_list (max_over_slots_of_instr valu) (fn_code f) >= 0.","proofString":"apply max_over_list_pos."},{"statement":"(A : Type) (B : Type) (f0 : A -> B -> A) (P : A -> Prop) (b0 : B) (H : forall (a0 : A) (b : B), P a0 -> P (f0 a0 b)) (H0 : forall a0 : A, P (f0 a0 b0)) (a : A) (H1 : False) : P a.","proofString":"contradiction."},{"statement":"(A : Type) (B : Type) (f0 : A -> B -> A) (P : A -> Prop) (b0 : B) (H : forall (a1 : A) (b : B), P a1 -> P (f0 a1 b)) (H0 : forall a1 : A, P (f0 a1 b0)) (a : B) (l : list B) (IHl : forall a1 : A, In b0 l -> P (fold_left f0 l a1)) (a0 : A) (H1 : a = b0 \\/ In b0 l) : P (fold_left f0 l (f0 a0 a)).","proofString":"destruct H1.\nsubst a.\napply fold_left_preserves; auto.\napply IHl; auto."},{"statement":"(A : Type) (B : Type) (f0 : A -> B -> A) (P : A -> Prop) (b0 : B) (H : forall (a1 : A) (b : B), P a1 -> P (f0 a1 b)) (H0 : forall a1 : A, P (f0 a1 b0)) (a : B) (l : list B) (IHl : forall a1 : A, In b0 l -> P (fold_left f0 l a1)) (a0 : A) (H1 : a = b0) : P (fold_left f0 l (f0 a0 a)).","proofString":"subst a.\napply fold_left_preserves; auto."},{"statement":"(A : Type) (B : Type) (f0 : A -> B -> A) (P : A -> Prop) (b0 : B) (H : forall (a : A) (b : B), P a -> P (f0 a b)) (H0 : forall a : A, P (f0 a b0)) (l : list B) (IHl : forall a : A, In b0 l -> P (fold_left f0 l a)) (a0 : A) : P (fold_left f0 l (f0 a0 b0)).","proofString":"apply fold_left_preserves; auto."},{"statement":"(A : Type) (B : Type) (f0 : A -> B -> A) (P : A -> Prop) (b0 : B) (H : forall (a1 : A) (b : B), P a1 -> P (f0 a1 b)) (H0 : forall a1 : A, P (f0 a1 b0)) (a : B) (l : list B) (IHl : forall a1 : A, In b0 l -> P (fold_left f0 l a1)) (a0 : A) (H1 : In b0 l) : P (fold_left f0 l (f0 a0 a)).","proofString":"apply IHl; auto."},{"statement":"(u : RegSet.t) (r : mreg) (H : forall r1 : RegSet.elt, RegSet.In r1 u -> is_callee_save r1 = true) (r0 : RegSet.elt) (H0 : RegSet.In r0 (if is_callee_save r then RegSet.add r u else u)) : is_callee_save r0 = true.","proofString":"destruct (is_callee_save r) eqn:CS; auto.\ndestruct (mreg_eq r r0).\ncongruence.\napply H; eapply RegSet.add_3; eauto."},{"statement":"(u : RegSet.t) (r : mreg) (H : forall r1 : RegSet.elt, RegSet.In r1 u -> is_callee_save r1 = true) (r0 : RegSet.elt) (CS : is_callee_save r = true) (H0 : RegSet.In r0 (RegSet.add r u)) : is_callee_save r0 = true.","proofString":"destruct (mreg_eq r r0).\ncongruence.\napply H; eapply RegSet.add_3; eauto."},{"statement":"(u : RegSet.t) (r : mreg) (H : forall r1 : RegSet.elt, RegSet.In r1 u -> is_callee_save r1 = true) (r0 : RegSet.elt) (CS : is_callee_save r = true) (H0 : RegSet.In r0 (RegSet.add r u)) (e : r = r0) : is_callee_save r0 = true.","proofString":"congruence."},{"statement":"(u : RegSet.t) (r : mreg) (H : forall r1 : RegSet.elt, RegSet.In r1 u -> is_callee_save r1 = true) (r0 : RegSet.elt) (CS : is_callee_save r = true) (H0 : RegSet.In r0 (RegSet.add r u)) (n : r <> r0) : is_callee_save r0 = true.","proofString":"apply H; eapply RegSet.add_3; eauto."},{"statement":"(rl : list mreg) (u : RegSet.t) (H : only_callee_saves u) : only_callee_saves (record_regs u rl).","proofString":"unfold record_regs.\napply fold_left_preserves; auto using record_reg_only."},{"statement":"(rl : list mreg) (u : RegSet.t) (H : only_callee_saves u) : only_callee_saves (fold_left record_reg rl u).","proofString":"apply fold_left_preserves; auto using record_reg_only."},{"statement":"(u : RegSet.t) (i : instruction) (H : only_callee_saves u) : only_callee_saves (record_regs_of_instr u i).","proofString":"destruct i; simpl; auto using record_reg_only, record_regs_only."},{"statement":"only_callee_saves record_regs_of_function.","proofString":"unfold record_regs_of_function.\napply fold_left_preserves.\napply record_regs_of_instr_only.\nred; intros.\neelim RegSet.empty_1; eauto."},{"statement":"only_callee_saves (fold_left record_regs_of_instr (fn_code f) RegSet.empty).","proofString":"apply fold_left_preserves.\napply record_regs_of_instr_only.\nred; intros.\neelim RegSet.empty_1; eauto."},{"statement":"forall (a : RegSet.t) (b : instruction),\nonly_callee_saves a -> only_callee_saves (record_regs_of_instr a b).","proofString":"apply record_regs_of_instr_only."},{"statement":"only_callee_saves RegSet.empty.","proofString":"red; intros.\neelim RegSet.empty_1; eauto."},{"statement":"(r : RegSet.elt) (H : RegSet.In r RegSet.empty) : is_callee_save r = true.","proofString":"eelim RegSet.empty_1; eauto."},{"statement":"(u : RegSet.t) (r : mreg) (r' : RegSet.elt) (H : RegSet.In r' u) : RegSet.In r' (if is_callee_save r then RegSet.add r u else u).","proofString":"destruct (is_callee_save r); auto.\napply RegSet.add_2; auto."},{"statement":"(u : RegSet.t) (r : mreg) (r' : RegSet.elt) (H : RegSet.In r' u) : RegSet.In r' (RegSet.add r u).","proofString":"apply RegSet.add_2; auto."},{"statement":"(u : RegSet.t) (r : mreg) (H : is_callee_save r = true) : RegSet.In r (if is_callee_save r then RegSet.add r u else u).","proofString":"rewrite H.\napply RegSet.add_1; auto."},{"statement":"(u : RegSet.t) (r : mreg) (H : is_callee_save r = true) : RegSet.In r (RegSet.add r u).","proofString":"apply RegSet.add_1; auto."},{"statement":"(r' : RegSet.elt) (rl : list mreg) (u : RegSet.t) (H : RegSet.In r' u) : RegSet.In r' (record_regs u rl).","proofString":"unfold record_regs.\napply fold_left_preserves; auto using record_reg_incr."},{"statement":"(r' : RegSet.elt) (rl : list mreg) (u : RegSet.t) (H : RegSet.In r' u) : RegSet.In r' (fold_left record_reg rl u).","proofString":"apply fold_left_preserves; auto using record_reg_incr."},{"statement":"(r : mreg) (rl : list mreg) (u : RegSet.t) (H : In r rl) (H0 : is_callee_save r = true) : RegSet.In r (record_regs u rl).","proofString":"unfold record_regs.\neapply fold_left_ensures; eauto using record_reg_incr, record_reg_ok."},{"statement":"(r : mreg) (rl : list mreg) (u : RegSet.t) (H : In r rl) (H0 : is_callee_save r = true) : RegSet.In r (fold_left record_reg rl u).","proofString":"eapply fold_left_ensures; eauto using record_reg_incr, record_reg_ok."},{"statement":"(r' : RegSet.elt) (u : RegSet.t) (i : instruction) (H : RegSet.In r' u) : RegSet.In r' (record_regs_of_instr u i).","proofString":"destruct i; simpl; auto using record_reg_incr, record_regs_incr."},{"statement":"(r' : mreg) (u : RegSet.t) (i : instruction) (H : defined_by_instr r' i) (H0 : is_callee_save r' = true) : RegSet.In r' (record_regs_of_instr u i).","proofString":"destruct i; simpl in *; try contradiction; subst; auto using record_reg_ok.\ndestruct H; auto using record_regs_incr, record_regs_ok."},{"statement":"(r' : mreg) (u : RegSet.t) (e : external_function) (l : list (builtin_arg loc)) (b : builtin_res mreg) (H : In r' (params_of_builtin_res b) \\/ In r' (destroyed_by_builtin e)) (H0 : is_callee_save r' = true) : RegSet.In r'\n  (record_regs (record_regs u (params_of_builtin_res b))\n     (destroyed_by_builtin e)).","proofString":"destruct H; auto using record_regs_incr, record_regs_ok."},{"statement":"(r : mreg) (i : instruction) (H : In i (fn_code f)) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) : RegSet.In r record_regs_of_function.","proofString":"unfold record_regs_of_function.\neapply fold_left_ensures; eauto using record_regs_of_instr_incr, record_regs_of_instr_ok."},{"statement":"(r : mreg) (i : instruction) (H : In i (fn_code f)) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) : RegSet.In r (fold_left record_regs_of_instr (fn_code f) RegSet.empty).","proofString":"eapply fold_left_ensures; eauto using record_regs_of_instr_incr, record_regs_of_instr_ok."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) : In x l -> valu x <= max_over_list valu l.","proofString":"unfold max_over_list.\nassert (forall c z,            let f := fold_left (fun x y => Z.max x (valu y)) c z in            z <= f /\\ (In x c -> valu x <= f)).\ninduction c; simpl; intros.\nsplit.\nlia.\ntauto.\nelim (IHc (Z.max z (valu a))); intros.\nsplit.\napply Z.le_trans with (Z.max z (valu a)).\napply Z.le_max_l.\nauto.\nintro H1; elim H1; intro.\nsubst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto.\nauto.\nintro.\nelim (H l 0); intros.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) : In x l -> valu x <= fold_left (fun (m : Z) (l0 : A) => Z.max m (valu l0)) l 0.","proofString":"assert (forall c z,            let f := fold_left (fun x y => Z.max x (valu y)) c z in            z <= f /\\ (In x c -> valu x <= f)).\ninduction c; simpl; intros.\nsplit.\nlia.\ntauto.\nelim (IHc (Z.max z (valu a))); intros.\nsplit.\napply Z.le_trans with (Z.max z (valu a)).\napply Z.le_max_l.\nauto.\nintro H1; elim H1; intro.\nsubst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto.\nauto.\nintro.\nelim (H l 0); intros.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) : forall (c : list A) (z : Z),\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z in\nz <= f0 /\\ (In x c -> valu x <= f0).","proofString":"induction c; simpl; intros.\nsplit.\nlia.\ntauto.\nelim (IHc (Z.max z (valu a))); intros.\nsplit.\napply Z.le_trans with (Z.max z (valu a)).\napply Z.le_max_l.\nauto.\nintro H1; elim H1; intro.\nsubst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (z : Z) : z <= z /\\ (False -> valu x <= z).","proofString":"split.\nlia.\ntauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (z : Z) : z <= z.","proofString":"lia."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (z : Z) : False -> valu x <= z.","proofString":"tauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) : z <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)) /\\\n(a = x \\/ In x c ->\n valu x <=\n fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))).","proofString":"elim (IHc (Z.max z (valu a))); intros.\nsplit.\napply Z.le_trans with (Z.max z (valu a)).\napply Z.le_max_l.\nauto.\nintro H1; elim H1; intro.\nsubst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) : z <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)) /\\\n(a = x \\/ In x c ->\n valu x <=\n fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))).","proofString":"split.\napply Z.le_trans with (Z.max z (valu a)).\napply Z.le_max_l.\nauto.\nintro H1; elim H1; intro.\nsubst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) : z <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)).","proofString":"apply Z.le_trans with (Z.max z (valu a)).\napply Z.le_max_l.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) : z <= Z.max z (valu a).","proofString":"apply Z.le_max_l."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)).","proofString":"auto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) : a = x \\/ In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)).","proofString":"intro H1; elim H1; intro.\nsubst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H1 : a = x \\/ In x c) (H2 : a = x) : valu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)).","proofString":"subst a.\napply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H1 : x = x \\/ In x c) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x))) (H : Z.max z (valu x) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x))) : valu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x)).","proofString":"apply Z.le_trans with (Z.max z (valu x)).\napply Z.le_max_r.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H1 : x = x \\/ In x c) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x))) (H : Z.max z (valu x) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x))) : valu x <= Z.max z (valu x).","proofString":"apply Z.le_max_r."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H1 : x = x \\/ In x c) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x))) (H : Z.max z (valu x) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x))) : Z.max z (valu x) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu x)).","proofString":"auto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x a : A) (c : list A) (IHc : forall z0 : Z,\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z0 in\nz0 <= f0 /\\ (In x c -> valu x <= f0)) (z : Z) (H : Z.max z (valu a) <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H0 : In x c ->\nvalu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a))) (H1 : a = x \\/ In x c) (H2 : In x c) : valu x <=\nfold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c (Z.max z (valu a)).","proofString":"auto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (H : forall (c : list A) (z : Z),\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z in\nz <= f0 /\\ (In x c -> valu x <= f0)) : In x l -> valu x <= fold_left (fun (m : Z) (l0 : A) => Z.max m (valu l0)) l 0.","proofString":"intro.\nelim (H l 0); intros.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (H : forall (c : list A) (z : Z),\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z in\nz <= f0 /\\ (In x c -> valu x <= f0)) (H0 : In x l) : valu x <= fold_left (fun (m : Z) (l0 : A) => Z.max m (valu l0)) l 0.","proofString":"elim (H l 0); intros.\nauto."},{"statement":"(A : Type) (valu : A -> Z) (l : list A) (x : A) (H : forall (c : list A) (z : Z),\nlet f0 := fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) c z in\nz <= f0 /\\ (In x c -> valu x <= f0)) (H0 : In x l) (H1 : 0 <= fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) l 0) (H2 : In x l -> valu x <= fold_left (fun (x0 : Z) (y : A) => Z.max x0 (valu y)) l 0) : valu x <= fold_left (fun (m : Z) (l0 : A) => Z.max m (valu l0)) l 0.","proofString":"auto."},{"statement":"(valu : instruction -> Z) (i : instruction) (H : In i (fn_code f)) : valu i <= max_over_instrs valu.","proofString":"unfold max_over_instrs.\napply max_over_list_bound; auto."},{"statement":"(valu : instruction -> Z) (i : instruction) (H : In i (fn_code f)) : valu i <= max_over_list valu (fn_code f).","proofString":"apply max_over_list_bound; auto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : valu s <= max_over_slots_of_funct valu.","proofString":"unfold max_over_slots_of_funct.\napply Z.le_trans with (max_over_slots_of_instr valu i).\nunfold max_over_slots_of_instr.\napply max_over_list_bound.\nauto.\napply max_over_instrs_bound.\nauto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : valu s <= max_over_instrs (max_over_slots_of_instr valu).","proofString":"apply Z.le_trans with (max_over_slots_of_instr valu i).\nunfold max_over_slots_of_instr.\napply max_over_list_bound.\nauto.\napply max_over_instrs_bound.\nauto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : valu s <= max_over_slots_of_instr valu i.","proofString":"unfold max_over_slots_of_instr.\napply max_over_list_bound.\nauto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : valu s <= max_over_list valu (slots_of_instr i).","proofString":"apply max_over_list_bound.\nauto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : In s (slots_of_instr i).","proofString":"auto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : max_over_slots_of_instr valu i <=\nmax_over_instrs (max_over_slots_of_instr valu).","proofString":"apply max_over_instrs_bound.\nauto."},{"statement":"(valu : slot * Z * typ -> Z) (i : instruction) (s : slot * Z * typ) (H : In i (fn_code f)) (H0 : In s (slots_of_instr i)) : In i (fn_code f).","proofString":"auto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Local, ofs, ty) (slots_of_instr i)) : ofs + typesize ty <= bound_local function_bounds.","proofString":"unfold function_bounds, bound_local.\nchange (ofs + typesize ty) with (local_slot (Local, ofs, ty)).\neapply max_over_slots_of_funct_bound; eauto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Local, ofs, ty) (slots_of_instr i)) : ofs + typesize ty <= max_over_slots_of_funct local_slot.","proofString":"change (ofs + typesize ty) with (local_slot (Local, ofs, ty)).\neapply max_over_slots_of_funct_bound; eauto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Local, ofs, ty) (slots_of_instr i)) : local_slot (Local, ofs, ty) <= max_over_slots_of_funct local_slot.","proofString":"eapply max_over_slots_of_funct_bound; eauto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Outgoing, ofs, ty) (slots_of_instr i)) : ofs + typesize ty <= bound_outgoing function_bounds.","proofString":"change (ofs + typesize ty) with (outgoing_slot (Outgoing, ofs, ty)).\nunfold function_bounds, bound_outgoing.\napply Zmax_bound_r.\neapply max_over_slots_of_funct_bound; eauto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Outgoing, ofs, ty) (slots_of_instr i)) : outgoing_slot (Outgoing, ofs, ty) <= bound_outgoing function_bounds.","proofString":"unfold function_bounds, bound_outgoing.\napply Zmax_bound_r.\neapply max_over_slots_of_funct_bound; eauto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Outgoing, ofs, ty) (slots_of_instr i)) : outgoing_slot (Outgoing, ofs, ty) <=\nZ.max (max_over_instrs outgoing_space)\n  (max_over_slots_of_funct outgoing_slot).","proofString":"apply Zmax_bound_r.\neapply max_over_slots_of_funct_bound; eauto."},{"statement":"(i : instruction) (ofs : Z) (ty : typ) (H : In i (fn_code f)) (H0 : In (Outgoing, ofs, ty) (slots_of_instr i)) : outgoing_slot (Outgoing, ofs, ty) <= max_over_slots_of_funct outgoing_slot.","proofString":"eapply max_over_slots_of_funct_bound; eauto."},{"statement":"(sig : signature) (ros : mreg + ident) (H : In (Lcall sig ros) (fn_code f)) : size_arguments sig <= bound_outgoing function_bounds.","proofString":"change (size_arguments sig) with (outgoing_space (Lcall sig ros)).\nunfold function_bounds, bound_outgoing.\napply Zmax_bound_l.\napply max_over_instrs_bound; auto."},{"statement":"(sig : signature) (ros : mreg + ident) (H : In (Lcall sig ros) (fn_code f)) : outgoing_space (Lcall sig ros) <= bound_outgoing function_bounds.","proofString":"unfold function_bounds, bound_outgoing.\napply Zmax_bound_l.\napply max_over_instrs_bound; auto."},{"statement":"(sig : signature) (ros : mreg + ident) (H : In (Lcall sig ros) (fn_code f)) : outgoing_space (Lcall sig ros) <=\nZ.max (max_over_instrs outgoing_space)\n  (max_over_slots_of_funct outgoing_slot).","proofString":"apply Zmax_bound_l.\napply max_over_instrs_bound; auto."},{"statement":"(sig : signature) (ros : mreg + ident) (H : In (Lcall sig ros) (fn_code f)) : outgoing_space (Lcall sig ros) <= max_over_instrs outgoing_space.","proofString":"apply max_over_instrs_bound; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) : mreg_within_bounds function_bounds r.","proofString":"unfold mreg_within_bounds.\nintros.\nexploit record_regs_of_function_ok; eauto.\nintros.\napply RegSet.elements_1 in H2.\nrewrite InA_alt in H2.\ndestruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) : is_callee_save r = true -> In r (used_callee_save function_bounds).","proofString":"intros.\nexploit record_regs_of_function_ok; eauto.\nintros.\napply RegSet.elements_1 in H2.\nrewrite InA_alt in H2.\ndestruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) : In r (used_callee_save function_bounds).","proofString":"exploit record_regs_of_function_ok; eauto.\nintros.\napply RegSet.elements_1 in H2.\nrewrite InA_alt in H2.\ndestruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) : RegSet.In r record_regs_of_function ->\nIn r (used_callee_save function_bounds).","proofString":"intros.\napply RegSet.elements_1 in H2.\nrewrite InA_alt in H2.\ndestruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) (H2 : RegSet.In r record_regs_of_function) : In r (used_callee_save function_bounds).","proofString":"apply RegSet.elements_1 in H2.\nrewrite InA_alt in H2.\ndestruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) (H2 : InA (fun x y : RegOrd.t => x = y) r (RegSet.elements record_regs_of_function)) : In r (used_callee_save function_bounds).","proofString":"rewrite InA_alt in H2.\ndestruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) (H2 : exists y : IndexedMreg.t,\n  r = y /\\ In y (RegSet.elements record_regs_of_function)) : In r (used_callee_save function_bounds).","proofString":"destruct H2 as (r' & A & B).\nsubst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (r : mreg) (H0 : defined_by_instr r i) (H1 : is_callee_save r = true) (r' : IndexedMreg.t) (A : r = r') (B : In r' (RegSet.elements record_regs_of_function)) : In r (used_callee_save function_bounds).","proofString":"subst r'; auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (sl : slot) (ty : typ) (ofs : Z) (H0 : In (sl, ofs, ty) (slots_of_instr i)) : slot_within_bounds function_bounds sl ofs ty.","proofString":"unfold slot_within_bounds.\ndestruct sl.\neapply local_slot_bound; eauto.\nauto.\neapply outgoing_slot_bound; eauto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (sl : slot) (ty : typ) (ofs : Z) (H0 : In (sl, ofs, ty) (slots_of_instr i)) : match sl with\n| Local => ofs + typesize ty <= bound_local function_bounds\n| Incoming => True\n| Outgoing => ofs + typesize ty <= bound_outgoing function_bounds\nend.","proofString":"destruct sl.\neapply local_slot_bound; eauto.\nauto.\neapply outgoing_slot_bound; eauto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (ty : typ) (ofs : Z) (H0 : In (Local, ofs, ty) (slots_of_instr i)) : ofs + typesize ty <= bound_local function_bounds.","proofString":"eapply local_slot_bound; eauto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (ty : typ) (ofs : Z) (H0 : In (Incoming, ofs, ty) (slots_of_instr i)) : True.","proofString":"auto."},{"statement":"(i : instruction) (H : In i (fn_code f)) (ty : typ) (ofs : Z) (H0 : In (Outgoing, ofs, ty) (slots_of_instr i)) : ofs + typesize ty <= bound_outgoing function_bounds.","proofString":"eapply outgoing_slot_bound; eauto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) : False <-> False.","proofString":"tauto."},{"statement":"(sl : slot) (ofs : Z) (ty : typ) (a : loc) (l : list loc) (IHl : In (sl, ofs, ty) (slots_of_locs l) <-> In (S sl ofs ty) l) : In (sl, ofs, ty)\n  match a with\n  | R _ => slots_of_locs l\n  | S sl0 ofs0 ty0 => (sl0, ofs0, ty0) :: slots_of_locs l\n  end <-> a = S sl ofs ty \\/ In (S sl ofs ty) l.","proofString":"destruct a; simpl; intuition congruence."},{"statement":"(s : signature) (s0 : mreg + ident) (H : In (Lcall s s0) (fn_code f)) (H0 : forall (sl : slot) (ty : typ) (ofs : Z),\nFalse -> slot_within_bounds function_bounds sl ofs ty) (H1 : forall r : mreg, False -> mreg_within_bounds function_bounds r) : size_arguments s <=\nZ.max (max_over_instrs outgoing_space)\n  (max_over_slots_of_funct outgoing_slot).","proofString":"eapply size_arguments_bound; eauto."},{"statement":"(e : external_function) (l : list (builtin_arg loc)) (b : builtin_res mreg) (H : In (Lbuiltin e l b) (fn_code f)) (H0 : forall (sl : slot) (ty : typ) (ofs : Z),\nIn (sl, ofs, ty) (slots_of_locs (params_of_builtin_args l)) ->\nslot_within_bounds function_bounds sl ofs ty) (H1 : forall r : mreg,\nIn r (params_of_builtin_res b) \\/ In r (destroyed_by_builtin e) ->\nmreg_within_bounds function_bounds r) : (forall r : mreg,\n In r (params_of_builtin_res b) \\/ In r (destroyed_by_builtin e) ->\n mreg_within_bounds function_bounds r) /\\\n(forall (sl : slot) (ofs : Z) (ty : typ),\n In (S sl ofs ty) (params_of_builtin_args l) ->\n slot_within_bounds function_bounds sl ofs ty).","proofString":"split; intros.\napply H1; auto.\napply H0.\nrewrite slots_of_locs_charact; auto."},{"statement":"(e : external_function) (l : list (builtin_arg loc)) (b : builtin_res mreg) (H : In (Lbuiltin e l b) (fn_code f)) (H0 : forall (sl : slot) (ty : typ) (ofs : Z),\nIn (sl, ofs, ty) (slots_of_locs (params_of_builtin_args l)) ->\nslot_within_bounds function_bounds sl ofs ty) (H1 : forall r0 : mreg,\nIn r0 (params_of_builtin_res b) \\/ In r0 (destroyed_by_builtin e) ->\nmreg_within_bounds function_bounds r0) (r : mreg) (H2 : In r (params_of_builtin_res b) \\/ In r (destroyed_by_builtin e)) : mreg_within_bounds function_bounds r.","proofString":"apply H1; auto."},{"statement":"(e : external_function) (l : list (builtin_arg loc)) (b : builtin_res mreg) (H : In (Lbuiltin e l b) (fn_code f)) (H0 : forall (sl0 : slot) (ty0 : typ) (ofs0 : Z),\nIn (sl0, ofs0, ty0) (slots_of_locs (params_of_builtin_args l)) ->\nslot_within_bounds function_bounds sl0 ofs0 ty0) (H1 : forall r : mreg,\nIn r (params_of_builtin_res b) \\/ In r (destroyed_by_builtin e) ->\nmreg_within_bounds function_bounds r) (sl : slot) (ofs : Z) (ty : typ) (H2 : In (S sl ofs ty) (params_of_builtin_args l)) : slot_within_bounds function_bounds sl ofs ty.","proofString":"apply H0.\nrewrite slots_of_locs_charact; auto."},{"statement":"(e : external_function) (l : list (builtin_arg loc)) (b : builtin_res mreg) (H : In (Lbuiltin e l b) (fn_code f)) (H0 : forall (sl0 : slot) (ty0 : typ) (ofs0 : Z),\nIn (sl0, ofs0, ty0) (slots_of_locs (params_of_builtin_args l)) ->\nslot_within_bounds function_bounds sl0 ofs0 ty0) (H1 : forall r : mreg,\nIn r (params_of_builtin_res b) \\/ In r (destroyed_by_builtin e) ->\nmreg_within_bounds function_bounds r) (sl : slot) (ofs : Z) (ty : typ) (H2 : In (S sl ofs ty) (params_of_builtin_args l)) : In (sl, ofs, ty) (slots_of_locs (params_of_builtin_args l)).","proofString":"rewrite slots_of_locs_charact; auto."},{"statement":"(instr : instruction) (H : In instr (fn_code f)) : instr_within_bounds function_bounds instr.","proofString":"apply instr_is_within_bounds; auto."},{"statement":"(b : bounds) (ofs : Z) : ofs <= size_callee_save_area b ofs.","proofString":"apply size_callee_save_area_rec_incr."}]}