{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/riscV/Asmgenproof.v","fileSamples":[{"statement":"(p : Mach.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"exploit functions_translated; eauto.\nintros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : (exists tf0 : fundef,\n   Genv.find_funct_ptr tge fb = Some tf0 /\\\n   transf_fundef (Internal f) = OK tf0) ->\nGenv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"intros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (tf' : fundef) (A : Genv.find_funct_ptr tge fb = Some tf') (B : transf_fundef (Internal f) = OK tf') : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"monadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (x : function) (A : Genv.find_funct_ptr tge fb = Some (Internal x)) (EQ : transf_function f = OK x) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"rewrite H0 in EQ; inv EQ; auto."},{"statement":"(f : Mach.function) (tf : function) (H : transf_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"monadInv H.\ndestruct (zlt Ptrofs.max_unsigned (list_length_z x.(fn_code))); inv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf x : function) (EQ : transl_function f = OK x) (EQ0 : (if zlt Ptrofs.max_unsigned (list_length_z (fn_code x))\n then Error (msg \"code size exceeded\")\n else OK x) = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"destruct (zlt Ptrofs.max_unsigned (list_length_z x.(fn_code))); inv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf : function) (g : Ptrofs.max_unsigned >= list_length_z (fn_code tf)) (EQ : transl_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : exec_straight tge tf tc rs m c' rs' m') : plus step tge (State rs m) E0 (State rs' m').","proofString":"inv H.\neapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : plus step tge (State rs m) E0 (State rs' m').","proofString":"eapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"inv H.\nexploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"exploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : (exists ofs' : ptrofs,\n   rs' PC = Vptr fb ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') ->\ntransl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"intros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"rewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (Vptr fb ofs') fb f c' ep' tf tc'.","proofString":"constructor; auto."},{"statement":"(f : Mach.function) (i : ptrofs) (t : typ) (m : mreg) (ep : bool) (k c : code) (H : loadind XSP i t m k = OK c) : tail_nolabel k c.","proofString":"eapply loadind_label; eauto."},{"statement":"(f : Mach.function) (m : mreg) (i : ptrofs) (t : typ) (ep : bool) (k c : code) (H : storeind m XSP i t k = OK c) : tail_nolabel k c.","proofString":"eapply storeind_label; eauto."},{"statement":"(f : Mach.function) (i : ptrofs) (t : typ) (m : mreg) (k : code) (x : list instruction) (EQ : loadind X15 i t m k = OK x) : tail_nolabel k x.","proofString":"eapply loadind_label; eauto."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : find_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","proofString":"exploit transl_instr_label; eauto.\ndestruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : match i with\n| Mlabel lbl0 => c = Plabel lbl0 :: k\n| _ => tail_nolabel k c\nend ->\nfind_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","proofString":"destruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) : c = Plabel l :: k ->\nfind_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"intros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) (H0 : c = Plabel l :: k) : find_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"subst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : find_label lbl (Plabel l :: k) =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"simpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : (if if peq lbl l then true else false then Some k else find_label lbl k) =\n(if if peq lbl l then true else false then Some k else find_label lbl k).","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) (tc : list instruction) (H : OK nil = OK tc) : find_label lbl tc = None.","proofString":"inv H.\nauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) : find_label lbl nil = None.","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc : list instruction) (H : bind (transl_code f c (it1_is_parent ep a))\n  (fun k : list instruction => transl_instr f a ep k) = \nOK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","proofString":"monadInv H.\nrewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","proofString":"rewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","proofString":"generalize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : (if Mach.is_label lbl a then a = Mlabel lbl else a <> Mlabel lbl) ->\nmatch (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","proofString":"destruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a = Mlabel lbl) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"subst a.\nsimpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c (it1_is_parent ep (Mlabel lbl)) = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"simpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c false = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"exists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a <> Mlabel lbl) : match Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl x = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl x = None\nend.","proofString":"eapply IHc; eauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exploit (transl_find_label lbl f tf); eauto.\nrewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"rewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : (exists tc : code,\n   find_label lbl (fn_code tf) = Some tc /\\ transl_code f c' false = OK tc) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"intros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : (exists pos' : Z,\n   label_pos lbl 0 (fn_code tf) = Some pos' /\\\n   code_tail (pos' - 0) (fn_code tf) tc /\\\n   0 < pos' <= 0 + list_length_z (fn_code tf)) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"intros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m /\\\ntransl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","proofString":"split.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"unfold goto_label.\nrewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match label_pos lbl 0 (fn_code tf) with\n| Some pos =>\n    match rs PC with\n    | Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos)) m\n    | _ => Stuck\n    end\n| None => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"rewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match rs PC with\n| Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos')) m\n| _ => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"rewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m =\nNext rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","proofString":"split.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc.","proofString":"rewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (Vptr b (Ptrofs.repr pos')) b f c' false tf tc.","proofString":"constructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail (Ptrofs.unsigned (Ptrofs.repr pos')) (fn_code tf) tc.","proofString":"rewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","proofString":"replace (pos' - 0) with pos' in Q.\nauto.\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail pos' (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : pos' = pos' - 0.","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : 0 <= pos' <= Ptrofs.max_unsigned.","proofString":"generalize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned ->\n0 <= pos' <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","proofString":"intros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) (r : preg) (H3 : r <> PC) : rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","proofString":"apply Pregmap.gso; auto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X30 = parent_sp s)) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"inversion H2.\nsubst.\nmonadInv H7.\nexploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c1 : code,\ntransl_instr f i ep k = OK c1 ->\nexists rs2 : regset,\n  exec_straight tge tf c1 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X30 = parent_sp s)) (b : block) (ofs : ptrofs) (f0 : Mach.function) (c0 : list Mach.instruction) (ep0 : bool) (tf0 : function) (tc0 : list instruction) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H7 : transl_code f (i :: c) ep = OK tc) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr b ofs = rs1 PC) (H9 : b = fb) (H10 : f0 = f) (H11 : c0 = i :: c) (H12 : ep0 = ep) (H13 : tf0 = tf) (H14 : tc0 = tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"subst.\nmonadInv H7.\nexploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X30 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H7 : transl_code f (i :: c) ep = OK tc) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"monadInv H7.\nexploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X30 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"exploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X30 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : (exists rs2 : regset,\n   exec_straight tge tf tc rs1 m1' x rs2 m2' /\\\n   agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X30 = parent_sp s)) ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"intros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs0 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs0 m2' /\\\n  agree ms2 sp rs0 /\\ (it1_is_parent ep i = true -> rs0 X30 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' x rs2 m2') (B : agree ms2 sp rs2) (C : it1_is_parent ep i = true -> rs2 X30 = parent_sp s) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"exists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs0 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs0 m2' /\\\n  agree ms2 sp rs0 /\\ (it1_is_parent ep i = true -> rs0 X30 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' x rs2 m2') (B : agree ms2 sp rs2) (C : it1_is_parent ep i = true -> rs2 X30 = parent_sp s) : plus step tge (State rs1 m1') E0 (State rs2 m2').","proofString":"eapply exec_straight_exec; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs0 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs0 m2' /\\\n  agree ms2 sp rs0 /\\ (it1_is_parent ep i = true -> rs0 X30 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' x rs2 m2') (B : agree ms2 sp rs2) (C : it1_is_parent ep i = true -> rs2 X30 = parent_sp s) : match_states (Mach.State s fb sp c ms2 m2) (State rs2 m2').","proofString":"econstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"inversion H3.\nsubst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c1 : code,\ntransl_instr f i ep k = OK c1 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c1 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (b : block) (ofs : ptrofs) (f0 : Mach.function) (c0 : list Mach.instruction) (ep0 : bool) (tf0 : function) (tc0 : list instruction) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr b ofs = rs1 PC) (H11 : b = fb) (H12 : f0 = f) (H13 : c0 = i :: c) (H14 : ep0 = ep) (H15 : tf0 = tf) (H16 : tc0 = tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"subst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"monadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : (exists (jmp : instruction) (k' : list instruction) \n (rs2 : regset),\n   exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2' /\\\n   agree ms2 sp rs2 /\\\n   exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : (exists ofs' : ptrofs,\n   rs2 PC = Vptr fb ofs' /\\\n   code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : agree ms2 sp rs3.","proofString":"apply agree_exten with rs2; auto with asmgen."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : false = true -> rs3 X30 = parent_sp s.","proofString":"congruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"inversion H3.\nsubst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c1 : code,\ntransl_instr f i ep k = OK c1 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c1 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (b : block) (ofs : ptrofs) (f0 : Mach.function) (c0 : list Mach.instruction) (ep0 : bool) (tf0 : function) (tc0 : list instruction) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr b ofs = rs1 PC) (H11 : b = fb) (H12 : f0 = f) (H13 : c0 = i :: c) (H14 : ep0 = ep) (H15 : tf0 = tf) (H16 : tc0 = tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"subst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"monadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : (exists (jmp : instruction) (k' : list instruction) \n (rs2 : regset),\n   exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2' /\\\n   agree ms2 sp rs2 /\\\n   exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"inv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (jmp : instruction) (k' : list instruction) (rs2 : regset) (H3 : transl_code_at_pc ge (rs2 PC) fb f (i :: c) ep tf (jmp :: k')) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs2 m2' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) (jmp :: k')) (H6 : Vptr fb ofs = rs2 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK (jmp :: k')) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : exists st' : state,\n  plus step tge (State rs2 m2') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (jmp : instruction) (k' : list instruction) (rs2 : regset) (H3 : transl_code_at_pc ge (rs2 PC) fb f (i :: c) ep tf (jmp :: k')) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs2 m2' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) (jmp :: k')) (H6 : Vptr fb ofs = rs2 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK (jmp :: k')) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : agree ms2 sp rs3.","proofString":"apply agree_exten with rs2; auto with asmgen."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (jmp : instruction) (k' : list instruction) (rs2 : regset) (H3 : transl_code_at_pc ge (rs2 PC) fb f (i :: c) ep tf (jmp :: k')) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs2 m2' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) (jmp :: k')) (H6 : Vptr fb ofs = rs2 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK (jmp :: k')) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : false = true -> rs3 X30 = parent_sp s.","proofString":"congruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') : (exists ofs' : ptrofs,\n   rs2 PC = Vptr fb ofs' /\\\n   code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : agree ms2 sp rs3.","proofString":"apply agree_exten with rs2; auto with asmgen."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : false = true -> rs3 X30 = parent_sp s.","proofString":"congruence."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","proofString":"inversion H.\nunfold ge0 in *.\neconstructor; split.\neconstructor.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nreplace (Genv.symbol_address (Genv.globalenv tprog) (prog_main tprog) Ptrofs.zero)     with (Vptr fb Ptrofs.zero).\neconstructor; eauto.\nconstructor.\napply Mem.extends_refl.\nsplit.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto.\nunfold Genv.symbol_address.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : exists st2 : state,\n  initial_state tprog st2 /\\\n  match_states (Callstate nil fb (Regmap.init Vundef) m0) st2.","proofString":"econstructor; split.\neconstructor.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nreplace (Genv.symbol_address (Genv.globalenv tprog) (prog_main tprog) Ptrofs.zero)     with (Vptr fb Ptrofs.zero).\neconstructor; eauto.\nconstructor.\napply Mem.extends_refl.\nsplit.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto.\nunfold Genv.symbol_address.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : match_states (Callstate nil fb (Regmap.init Vundef) m0)\n  (State\n     (((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n     # SP <- Vnullptr m0).","proofString":"econstructor; eauto.\nconstructor.\napply Mem.extends_refl.\nsplit.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : match_stack ge nil.","proofString":"constructor."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Mem.extends m0 m0.","proofString":"apply Mem.extends_refl."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : agree (Regmap.init Vundef) (parent_sp nil)\n  (((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n  # SP <- Vnullptr.","proofString":"split.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : (((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n# SP <- Vnullptr SP = parent_sp nil.","proofString":"auto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : parent_sp nil <> Vundef.","proofString":"simpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vnullptr <> Vundef.","proofString":"unfold Vnullptr; destruct Archi.ptr64; congruence."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : forall r : mreg,\nVal.lessdef (Regmap.init Vundef r)\n  ((((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n   # SP <- Vnullptr (preg_of r)).","proofString":"intros.\nrewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) (r : mreg) : Val.lessdef (Regmap.init Vundef r)\n  ((((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n   # SP <- Vnullptr (preg_of r)).","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) (r : mreg) : Val.lessdef Vundef\n  ((((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n   # SP <- Vnullptr (preg_of r)).","proofString":"auto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nGenv.symbol_address (Genv.globalenv tprog) (prog_main tprog) Ptrofs.zero.","proofString":"unfold Genv.symbol_address.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nmatch Genv.find_symbol (Genv.globalenv tprog) (prog_main tprog) with\n| Some b => Vptr b Ptrofs.zero\n| None => Vundef\nend.","proofString":"rewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nmatch Genv.find_symbol (Genv.globalenv tprog) (prog_main prog) with\n| Some b => Vptr b Ptrofs.zero\n| None => Vundef\nend.","proofString":"rewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nmatch Genv.find_symbol ge (prog_main prog) with\n| Some b => Vptr b Ptrofs.zero\n| None => Vundef\nend.","proofString":"unfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero = Vptr fb Ptrofs.zero.","proofString":"auto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (r0 : mreg) (H1 : loc_result signature_main = One r0) (H2 : rs r0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : rs0 PC = Vnullptr.","proofString":"assumption."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Mach.semantics return_address_offset prog)) id.","proofString":"apply senv_preserved."}]}