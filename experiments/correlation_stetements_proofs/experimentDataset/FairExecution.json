[{"statement":"Lemma co_imm:\n    co G ≡ (immediate (co G))⁺.","proof":"apply fsupp_imm_t; apply WF || apply FAIR.\n"},{"statement":"Lemma nS_imm_co_in_sb\n        (S : actid -> Prop) w wnext\n        (WW : is_w (lab G) w)\n        (NSW : ~ S w)\n        (NCOIMM : immediate ((co G) ⨾ ⦗S⦘) w wnext)\n        (FOR_SPLIT : ⦗set_compl S⦘ ⨾ immediate (co G) ⊆ sb G) :\n    sb G w wnext.","proof":"assert (transitive (co G)) as COTRANS.\n{\napply (co_trans WF).\n}\nassert (S wnext /\\ co G w wnext) as [ISSNEXT CONEXT].\n{\ngeneralize NCOIMM.\nbasic_solver.\n}\napply clos_trans_of_transitiveD; [apply sb_trans|].\napply (inclusion_t_t FOR_SPLIT).\neapply fsupp_imm_t in CONEXT; cycle 1.\n{\napply FAIR.\n}\n{\napply (co_irr WF).\n}\n{\napply (co_trans WF).\n}\napply t_rt_step in CONEXT.\ndestruct CONEXT as [z [IMMS IMM]].\napply t_rt_step.\nexists z; split; [|apply seq_eqv_l; split; [|done]].\n{\napply rtE in IMMS.\ndestruct IMMS as [IMMS|IMMS].\n{\nred in IMMS; desf.\napply rt_refl.\n}\nassert (immediate ((co G) ⨾ ⦗S⦘) z wnext) as IMM'.\n{\nred; split; [apply seq_eqv_r; split; auto|].\n{\napply clos_trans_immediate1; auto; try by apply ct_step.\n}\nins.\neapply NCOIMM; [|by apply R2].\napply seq_eqv_r in R1; destruct R1 as [R1 R3].\napply seq_eqv_r; split; auto.\neapply (co_trans WF); [|by apply R1].\napply clos_trans_immediate1; auto.\n}\nclear IMM.\ninduction IMMS.\n{\napply rt_step.\napply seq_eqv_l; split; auto.\n}\nassert (co G y wnext) as YNEXT.\n{\napply clos_trans_immediate1; auto.\neapply transitive_ct; [by apply IMMS2|].\neapply same_relation_exp.\n{\nsymmetry.\napply fsupp_imm_t; apply FAIR || apply WF.\n}\nunfolder in IMM'.\nbasic_solver.\n}\nassert (immediate ((co G) ⨾ ⦗S⦘) y wnext) as YNEXTIMM.\n{\nred; split; [by apply seq_eqv_r; split|].\nins.\neapply NCOIMM; [|by apply R2].\napply seq_eqv_r in R1; destruct R1 as [R1 R3].\napply seq_eqv_r; split; auto.\neapply (co_trans WF); [|by apply R1].\napply clos_trans_immediate1; auto.\n}\neapply rt_trans.\n{\nby apply IHIMMS1.\n}\napply IHIMMS2; auto.\n{\napply (wf_coD WF) in YNEXT.\napply seq_eqv_l in YNEXT; desf.\n}\nintros NISS.\neapply NCOIMM; apply seq_eqv_r; split; auto.\n2: by apply NISS.\n2: done.\napply clos_trans_immediate1; auto.\n}\nintros HH.\napply rtE in IMMS; destruct IMMS as [IMSS|IMMS].\n{\nred in IMSS; desf.\n}\neapply NCOIMM; apply seq_eqv_r; split; auto.\n2: by apply HH.\nall: apply clos_trans_immediate1; auto.\nall: by apply ct_step.\n"},{"statement":"Lemma fsupp_rf: fsupp (rf G).","proof":"apply functional_inv_fsupp.\nby inversion WF.\n"},{"statement":"Lemma fsupp_sb:\n    fsupp (⦗set_compl is_init⦘ ⨾ sb G).","proof":"unfold sb, ext_sb; unfolder; ins.\ndestruct y; [exists nil; ins; desf|].\nexists (map (fun i => ThreadEvent thread i) (List.seq 0 index)).\nintros e ((NIe & E0) & (SB & E)).\ndestruct e; [done| ].\ndestruct SB as [-> LT].\napply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff.\n"},{"statement":"Lemma fsupp_sb_loc:\n    fsupp (sb G ∩ same_loc (lab G)).","proof":"rewrite <- seq_id_l.\nrewrite set_full_split with (S := is_init), id_union, seq_union_l.\napply fsupp_union.\n2: {\neapply fsupp_mori; [| by apply fsupp_sb; eauto].\nred.\nbasic_solver.\n}\nred.\nins.\nremember (loc (lab G) y) as ly.\ndestruct ly.\n{\nexists [InitEvent l].\nintros x REL%seq_eqv_l.\ndesc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence.\n}\nexists [].\nred.\nintros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence.\n"},{"statement":"Lemma fin_exec_fair G (WF: Wf G) (FIN: fin_exec G):\n  mem_fair G.","proof":"red.\napply fsupp_union_iff.\narewrite (co G ∪ fr G ≡ ⦗acts_set G⦘ ⨾ (co G ∪ fr G) ⨾ ⦗is_w (lab G)⦘).\n{\nrewrite wf_coE, wf_frE, wf_coD, wf_frD; eauto.\nbasic_solver 10.\n}\nred.\nintros w.\ndestruct (classic (is_w (lab G) w)) as [W | NW].\n2: {\nexists [].\nintros.\napply seq_eqv_lr in REL.\nby desc.\n}\nforward eapply is_w_loc as [l Lw]; eauto.\ndestruct FIN as [findom FIN].\nexists (InitEvent l :: findom).\nintros r REL%seq_eqv_lr.\ndesc.\ndestruct r eqn:RR.\n{\nsimpl.\nleft.\nf_equal.\neapply hahn_inclusion_exp in REL0.\n2: {\nrewrite wf_col, wf_frl, unionK; eauto.\nreflexivity.\n}\nred in REL0.\nunfold loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence.\n}\nright.\napply FIN.\nsplit; auto.\n"},{"statement":"Lemma fin_exec_full_fair G (WF: Wf G) (FIN: fin_exec_full G):\n  mem_fair G.","proof":"apply fin_exec_fair; auto.\napply fin_exec_full_equiv in FIN.\nby desc.\n"}]