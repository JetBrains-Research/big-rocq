{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Prop/Round_odd.v","fileSamples":[{"statement":"(x : R) (Hx : x <> IZR (Zfloor x)) : Z.even\n  (if Req_dec_T x (IZR (Zfloor x))\n   then Zfloor x\n   else if Z.even (Zfloor x) then Zceil x else Zfloor x) = false.","proofString":"destruct (Req_EM_T  x (IZR (Zfloor x))) as [H|H].\nnow contradict H.\ncase_eq (Z.even (Zfloor x)).\nintros H'.\nrewrite Zceil_floor_neq.\nrewrite Z.even_add, H'.\nreflexivity.\nnow apply sym_not_eq.\ntrivial."},{"statement":"(x : R) (Hx : x <> IZR (Zfloor x)) (H : x = IZR (Zfloor x)) : Z.even (Zfloor x) = false.","proofString":"now contradict H."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) : Z.even (if Z.even (Zfloor x) then Zceil x else Zfloor x) = false.","proofString":"case_eq (Z.even (Zfloor x)).\nintros H'.\nrewrite Zceil_floor_neq.\nrewrite Z.even_add, H'.\nreflexivity.\nnow apply sym_not_eq.\ntrivial."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) : Z.even (Zfloor x) = true -> Z.even (Zceil x) = false.","proofString":"intros H'.\nrewrite Zceil_floor_neq.\nrewrite Z.even_add, H'.\nreflexivity.\nnow apply sym_not_eq."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) (H' : Z.even (Zfloor x) = true) : Z.even (Zceil x) = false.","proofString":"rewrite Zceil_floor_neq.\nrewrite Z.even_add, H'.\nreflexivity.\nnow apply sym_not_eq."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) (H' : Z.even (Zfloor x) = true) : Z.even (Zfloor x + 1) = false.","proofString":"rewrite Z.even_add, H'.\nreflexivity."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) (H' : Z.even (Zfloor x) = true) : Bool.eqb true (Z.even 1) = false.","proofString":"reflexivity."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) (H' : Z.even (Zfloor x) = true) : IZR (Zfloor x) <> x.","proofString":"now apply sym_not_eq."},{"statement":"(x : R) (Hx H : x <> IZR (Zfloor x)) : Z.even (Zfloor x) = false -> Z.even (Zfloor x) = false.","proofString":"trivial."},{"statement":"(n : Z) (y : R) : (up (IZR n + y) - 1)%Z = (n + (up y - 1))%Z.","proofString":"unfold Zminus; rewrite Zplus_assoc; f_equal.\napply sym_eq, tech_up.\nrewrite plus_IZR.\napply Rplus_lt_compat_l.\napply archimed.\nrewrite plus_IZR, Rplus_assoc.\napply Rplus_le_compat_l.\napply Rplus_le_reg_r with (-y)%R.\nring_simplify (y+1+-y)%R.\napply archimed."},{"statement":"(n : Z) (y : R) : up (IZR n + y) = (n + up y)%Z.","proofString":"apply sym_eq, tech_up.\nrewrite plus_IZR.\napply Rplus_lt_compat_l.\napply archimed.\nrewrite plus_IZR, Rplus_assoc.\napply Rplus_le_compat_l.\napply Rplus_le_reg_r with (-y)%R.\nring_simplify (y+1+-y)%R.\napply archimed."},{"statement":"(n : Z) (y : R) : (IZR n + y < IZR (n + up y))%R.","proofString":"rewrite plus_IZR.\napply Rplus_lt_compat_l.\napply archimed."},{"statement":"(n : Z) (y : R) : (IZR n + y < IZR n + IZR (up y))%R.","proofString":"apply Rplus_lt_compat_l.\napply archimed."},{"statement":"(n : Z) (y : R) : (y < IZR (up y))%R.","proofString":"apply archimed."},{"statement":"(n : Z) (y : R) : (IZR (n + up y) <= IZR n + y + 1)%R.","proofString":"rewrite plus_IZR, Rplus_assoc.\napply Rplus_le_compat_l.\napply Rplus_le_reg_r with (-y)%R.\nring_simplify (y+1+-y)%R.\napply archimed."},{"statement":"(n : Z) (y : R) : (IZR n + IZR (up y) <= IZR n + (y + 1))%R.","proofString":"apply Rplus_le_compat_l.\napply Rplus_le_reg_r with (-y)%R.\nring_simplify (y+1+-y)%R.\napply archimed."},{"statement":"(n : Z) (y : R) : (IZR (up y) <= y + 1)%R.","proofString":"apply Rplus_le_reg_r with (-y)%R.\nring_simplify (y+1+-y)%R.\napply archimed."},{"statement":"(n : Z) (y : R) : (IZR (up y) + - y <= y + 1 + - y)%R.","proofString":"ring_simplify (y+1+-y)%R.\napply archimed."},{"statement":"(n : Z) (y : R) : (IZR (up y) + - y <= 1)%R.","proofString":"apply archimed."},{"statement":"(n : Z) (y : R) : (- Zfloor (- (IZR n + y)))%Z = (n + - Zfloor (- y))%Z.","proofString":"rewrite Ropp_plus_distr, <- Ropp_Ropp_IZR.\nrewrite Zfloor_plus.\nring."},{"statement":"(n : Z) (y : R) : (- Zfloor (IZR (- n) + - y))%Z = (n + - Zfloor (- y))%Z.","proofString":"rewrite Zfloor_plus.\nring."},{"statement":"(n : Z) (y : R) : (- (- n + Zfloor (- y)))%Z = (n + - Zfloor (- y))%Z.","proofString":"ring."},{"statement":"(z : Z) (H1 : (z <= 0)%Z) : Z.even (Z.abs z) = Z.even z.","proofString":"rewrite Z.abs_neq; try assumption.\napply Z.even_opp."},{"statement":"(z : Z) (H1 : (z <= 0)%Z) : Z.even (- z) = Z.even z.","proofString":"apply Z.even_opp."},{"statement":"(z : Z) (H1 : (0 < z)%Z) : Z.even (Z.abs z) = Z.even z.","proofString":"rewrite Z.abs_eq; auto with zarith."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) : IZR (Zrnd_odd (x + y)) = (x + IZR (Zrnd_odd y))%R.","proofString":"unfold Zrnd_odd; rewrite Hx, Zfloor_plus.\ncase (Req_EM_T y (IZR (Zfloor y))); intros Hy.\nrewrite Hy; repeat rewrite <- plus_IZR.\nrepeat rewrite Zfloor_IZR.\ncase (Req_EM_T _ _); intros K; easy.\ncase (Req_EM_T _ _); intros K.\ncontradict Hy.\napply Rplus_eq_reg_l with (IZR (Zfloor x)).\nnow rewrite K, plus_IZR.\nrewrite Z.even_add, H; simpl.\ncase (Z.even (Zfloor y)).\nnow rewrite Zceil_plus, plus_IZR.\nnow rewrite plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) : IZR\n  (if Req_dec_T (IZR (Zfloor x) + y) (IZR (Zfloor x + Zfloor y))\n   then (Zfloor x + Zfloor y)%Z\n   else\n    if Z.even (Zfloor x + Zfloor y)\n    then Zceil (IZR (Zfloor x) + y)\n    else (Zfloor x + Zfloor y)%Z) =\n(IZR (Zfloor x) +\n IZR\n   (if Req_dec_T y (IZR (Zfloor y))\n    then Zfloor y\n    else if Z.even (Zfloor y) then Zceil y else Zfloor y))%R.","proofString":"case (Req_EM_T y (IZR (Zfloor y))); intros Hy.\nrewrite Hy; repeat rewrite <- plus_IZR.\nrepeat rewrite Zfloor_IZR.\ncase (Req_EM_T _ _); intros K; easy.\ncase (Req_EM_T _ _); intros K.\ncontradict Hy.\napply Rplus_eq_reg_l with (IZR (Zfloor x)).\nnow rewrite K, plus_IZR.\nrewrite Z.even_add, H; simpl.\ncase (Z.even (Zfloor y)).\nnow rewrite Zceil_plus, plus_IZR.\nnow rewrite plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y = IZR (Zfloor y)) : IZR\n  (if Req_dec_T (IZR (Zfloor x) + y) (IZR (Zfloor x + Zfloor y))\n   then (Zfloor x + Zfloor y)%Z\n   else\n    if Z.even (Zfloor x + Zfloor y)\n    then Zceil (IZR (Zfloor x) + y)\n    else (Zfloor x + Zfloor y)%Z) = (IZR (Zfloor x) + IZR (Zfloor y))%R.","proofString":"rewrite Hy; repeat rewrite <- plus_IZR.\nrepeat rewrite Zfloor_IZR.\ncase (Req_EM_T _ _); intros K; easy."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y = IZR (Zfloor y)) : IZR\n  (if\n    Req_dec_T (IZR (Zfloor x + Zfloor y))\n      (IZR (Zfloor x + Zfloor (IZR (Zfloor y))))\n   then (Zfloor x + Zfloor (IZR (Zfloor y)))%Z\n   else\n    if Z.even (Zfloor x + Zfloor (IZR (Zfloor y)))\n    then Zceil (IZR (Zfloor x + Zfloor y))\n    else (Zfloor x + Zfloor (IZR (Zfloor y)))%Z) =\nIZR (Zfloor x + Zfloor (IZR (Zfloor y))).","proofString":"repeat rewrite Zfloor_IZR.\ncase (Req_EM_T _ _); intros K; easy."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y = IZR (Zfloor y)) : IZR\n  (if Req_dec_T (IZR (Zfloor x + Zfloor y)) (IZR (Zfloor x + Zfloor y))\n   then (Zfloor x + Zfloor y)%Z\n   else\n    if Z.even (Zfloor x + Zfloor y)\n    then Zceil (IZR (Zfloor x + Zfloor y))\n    else (Zfloor x + Zfloor y)%Z) = IZR (Zfloor x + Zfloor y).","proofString":"case (Req_EM_T _ _); intros K; easy."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y <> IZR (Zfloor y)) : IZR\n  (if Req_dec_T (IZR (Zfloor x) + y) (IZR (Zfloor x + Zfloor y))\n   then (Zfloor x + Zfloor y)%Z\n   else\n    if Z.even (Zfloor x + Zfloor y)\n    then Zceil (IZR (Zfloor x) + y)\n    else (Zfloor x + Zfloor y)%Z) =\n(IZR (Zfloor x) + IZR (if Z.even (Zfloor y) then Zceil y else Zfloor y))%R.","proofString":"case (Req_EM_T _ _); intros K.\ncontradict Hy.\napply Rplus_eq_reg_l with (IZR (Zfloor x)).\nnow rewrite K, plus_IZR.\nrewrite Z.even_add, H; simpl.\ncase (Z.even (Zfloor y)).\nnow rewrite Zceil_plus, plus_IZR.\nnow rewrite plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y <> IZR (Zfloor y)) (K : (IZR (Zfloor x) + y)%R = IZR (Zfloor x + Zfloor y)) : IZR (Zfloor x + Zfloor y) =\n(IZR (Zfloor x) + IZR (if Z.even (Zfloor y) then Zceil y else Zfloor y))%R.","proofString":"contradict Hy.\napply Rplus_eq_reg_l with (IZR (Zfloor x)).\nnow rewrite K, plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (K : (IZR (Zfloor x) + y)%R = IZR (Zfloor x + Zfloor y)) : y = IZR (Zfloor y).","proofString":"apply Rplus_eq_reg_l with (IZR (Zfloor x)).\nnow rewrite K, plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (K : (IZR (Zfloor x) + y)%R = IZR (Zfloor x + Zfloor y)) : (IZR (Zfloor x) + y)%R = (IZR (Zfloor x) + IZR (Zfloor y))%R.","proofString":"now rewrite K, plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y <> IZR (Zfloor y)) (K : (IZR (Zfloor x) + y)%R <> IZR (Zfloor x + Zfloor y)) : IZR\n  (if Z.even (Zfloor x + Zfloor y)\n   then Zceil (IZR (Zfloor x) + y)\n   else (Zfloor x + Zfloor y)%Z) =\n(IZR (Zfloor x) + IZR (if Z.even (Zfloor y) then Zceil y else Zfloor y))%R.","proofString":"rewrite Z.even_add, H; simpl.\ncase (Z.even (Zfloor y)).\nnow rewrite Zceil_plus, plus_IZR.\nnow rewrite plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y <> IZR (Zfloor y)) (K : (IZR (Zfloor x) + y)%R <> IZR (Zfloor x + Zfloor y)) : IZR\n  (if if Z.even (Zfloor y) then true else false\n   then Zceil (IZR (Zfloor x) + y)\n   else (Zfloor x + Zfloor y)%Z) =\n(IZR (Zfloor x) + IZR (if Z.even (Zfloor y) then Zceil y else Zfloor y))%R.","proofString":"case (Z.even (Zfloor y)).\nnow rewrite Zceil_plus, plus_IZR.\nnow rewrite plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y <> IZR (Zfloor y)) (K : (IZR (Zfloor x) + y)%R <> IZR (Zfloor x + Zfloor y)) : IZR (Zceil (IZR (Zfloor x) + y)) = (IZR (Zfloor x) + IZR (Zceil y))%R.","proofString":"now rewrite Zceil_plus, plus_IZR."},{"statement":"(x y : R) (Hx : x = IZR (Zfloor x)) (H : Z.even (Zfloor x) = true) (Hy : y <> IZR (Zfloor y)) (K : (IZR (Zfloor x) + y)%R <> IZR (Zfloor x + Zfloor y)) : IZR (Zfloor x + Zfloor y) = (IZR (Zfloor x) + IZR (Zfloor y))%R.","proofString":"now rewrite plus_IZR."},{"statement":"(x f : R) (H1 : format (- f)) (H2 : (- f)%R = (- x)%R \\/\n(Rnd_DN_pt format (- x) (- f) \\/ Rnd_UP_pt format (- x) (- f)) /\\\n(exists g : float beta,\n   (- f)%R = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) : format f.","proofString":"replace f with (-(-f))%R by ring.\nnow apply generic_format_opp."},{"statement":"(x f : R) (H1 : format (- f)) (H2 : (- f)%R = (- x)%R \\/\n(Rnd_DN_pt format (- x) (- f) \\/ Rnd_UP_pt format (- x) (- f)) /\\\n(exists g : float beta,\n   (- f)%R = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) : format (- - f).","proofString":"now apply generic_format_opp."},{"statement":"(x f : R) (H1 : format (- f)) (H : (- f)%R = (- x)%R) : f = x \\/\n(Rnd_DN_pt format x f \\/ Rnd_UP_pt format x f) /\\\n(exists g : float beta, f = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false).","proofString":"left.\nreplace f with (-(-f))%R by ring.\nrewrite H; ring."},{"statement":"(x f : R) (H1 : format (- f)) (H : (- f)%R = (- x)%R) : f = x.","proofString":"replace f with (-(-f))%R by ring.\nrewrite H; ring."},{"statement":"(x f : R) (H1 : format (- f)) (H : (- f)%R = (- x)%R) : (- - f)%R = x.","proofString":"rewrite H; ring."},{"statement":"(x f : R) (H1 : format (- f)) (H : Rnd_DN_pt format (- x) (- f)) (g : float beta) (Hg1 : (- f)%R = F2R g) (Hg2 : canonical g) (Hg3 : Z.even (Fnum g) = false) : forall x0 : R, format x0 -> format (- x0).","proofString":"apply generic_format_opp."},{"statement":"(x f : R) (H1 : format (- f)) (H : Rnd_UP_pt format (- x) (- f)) (g : float beta) (Hg1 : (- f)%R = F2R g) (Hg2 : canonical g) (Hg3 : Z.even (Fnum g) = false) : forall x0 : R, format x0 -> format (- x0).","proofString":"apply generic_format_opp."},{"statement":"(x f : R) (H1 : format (- f)) (H2 : Rnd_DN_pt format (- x) (- f) \\/ Rnd_UP_pt format (- x) (- f)) (g : float beta) (Hg1 : (- f)%R = F2R g) (Hg2 : canonical g) (Hg3 : Z.even (Fnum g) = false) : exists g0 : float beta,\n  f = F2R g0 /\\ canonical g0 /\\ Z.even (Fnum g0) = false.","proofString":"exists (Float beta (-Fnum g) (Fexp g)).\nsplit.\nrewrite F2R_Zopp.\nreplace f with (-(-f))%R by ring.\nrewrite Hg1; reflexivity.\nsplit.\nnow apply canonical_opp.\nsimpl.\nnow rewrite Z.even_opp."},{"statement":"(x f : R) (H1 : format (- f)) (H2 : Rnd_DN_pt format (- x) (- f) \\/ Rnd_UP_pt format (- x) (- f)) (g : float beta) (Hg1 : (- f)%R = F2R g) (Hg2 : canonical g) (Hg3 : Z.even (Fnum g) = false) : canonical {| Fnum := - Fnum g; Fexp := Fexp g |}.","proofString":"now apply canonical_opp."},{"statement":"(x f : R) (H1 : format (- f)) (H2 : Rnd_DN_pt format (- x) (- f) \\/ Rnd_UP_pt format (- x) (- f)) (g : float beta) (Hg1 : (- f)%R = F2R g) (Hg2 : canonical g) (Hg3 : Z.even (Fnum g) = false) : Z.even (- Fnum g) = false.","proofString":"now rewrite Z.even_opp."},{"statement":"(x : R) : (IZR (Zrnd_odd (scaled_mantissa beta fexp (- x))) * bpow (cexp (- x)))%R =\n(IZR (- Zrnd_odd (scaled_mantissa beta fexp x)) * bpow (cexp x))%R.","proofString":"apply f_equal2; apply f_equal.\nrewrite scaled_mantissa_opp.\ngeneralize (scaled_mantissa beta fexp x); intros r.\nunfold Zrnd_odd.\ncase (Req_EM_T (- r) (IZR (Zfloor (- r)))).\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2.\nintros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring.\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1.\nintros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity.\napply cexp_opp."},{"statement":"(x : R) : Zrnd_odd (scaled_mantissa beta fexp (- x)) =\n(- Zrnd_odd (scaled_mantissa beta fexp x))%Z.","proofString":"rewrite scaled_mantissa_opp.\ngeneralize (scaled_mantissa beta fexp x); intros r.\nunfold Zrnd_odd.\ncase (Req_EM_T (- r) (IZR (Zfloor (- r)))).\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2.\nintros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring.\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1.\nintros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x : R) : Zrnd_odd (- scaled_mantissa beta fexp x) =\n(- Zrnd_odd (scaled_mantissa beta fexp x))%Z.","proofString":"generalize (scaled_mantissa beta fexp x); intros r.\nunfold Zrnd_odd.\ncase (Req_EM_T (- r) (IZR (Zfloor (- r)))).\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2.\nintros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring.\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1.\nintros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) : Zrnd_odd (- r) = (- Zrnd_odd r)%Z.","proofString":"unfold Zrnd_odd.\ncase (Req_EM_T (- r) (IZR (Zfloor (- r)))).\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2.\nintros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring.\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1.\nintros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) : (if Req_dec_T (- r) (IZR (Zfloor (- r)))\n then Zfloor (- r)\n else if Z.even (Zfloor (- r)) then Zceil (- r) else Zfloor (- r)) =\n(-\n (if Req_dec_T r (IZR (Zfloor r))\n  then Zfloor r\n  else if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"case (Req_EM_T (- r) (IZR (Zfloor (- r)))).\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2.\nintros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring.\ncase (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1.\nintros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) : (- r)%R = IZR (Zfloor (- r)) ->\nZfloor (- r) =\n(-\n (if Req_dec_T r (IZR (Zfloor r))\n  then Zfloor r\n  else if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"case (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2.\nintros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) : r = IZR (Zfloor r) ->\n(- r)%R = IZR (Zfloor (- r)) -> Zfloor (- r) = (- Zfloor r)%Z.","proofString":"intros Y1 Y2.\napply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2."},{"statement":"(x r : R) (Y1 : r = IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : Zfloor (- r) = (- Zfloor r)%Z.","proofString":"apply eq_IZR.\nnow rewrite opp_IZR, <- Y1, <-Y2."},{"statement":"(x r : R) (Y1 : r = IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : IZR (Zfloor (- r)) = IZR (- Zfloor r).","proofString":"now rewrite opp_IZR, <- Y1, <-Y2."},{"statement":"(x r : R) : r <> IZR (Zfloor r) ->\n(- r)%R = IZR (Zfloor (- r)) ->\nZfloor (- r) = (- (if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"intros Y1 Y2.\nabsurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : Zfloor (- r) = (- (if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"absurd (r=IZR (Zfloor r)); trivial.\npattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : r = IZR (Zfloor r).","proofString":"pattern r at 2; replace r with (-(-r))%R by ring.\nrewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : r = IZR (Zfloor (- - r)).","proofString":"rewrite Y2, <- opp_IZR.\nrewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : r = IZR (Zfloor (IZR (- Zfloor (- r)))).","proofString":"rewrite Zfloor_IZR.\nrewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : r = IZR (- Zfloor (- r)).","proofString":"rewrite opp_IZR, <- Y2.\nring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R = IZR (Zfloor (- r))) : r = (- - r)%R.","proofString":"ring."},{"statement":"(x r : R) : (- r)%R <> IZR (Zfloor (- r)) ->\n(if Z.even (Zfloor (- r)) then Zceil (- r) else Zfloor (- r)) =\n(-\n (if Req_dec_T r (IZR (Zfloor r))\n  then Zfloor r\n  else if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"case (Req_EM_T r (IZR (Zfloor r))).\nintros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1.\nintros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) : r = IZR (Zfloor r) ->\n(- r)%R <> IZR (Zfloor (- r)) ->\n(if Z.even (Zfloor (- r)) then Zceil (- r) else Zfloor (- r)) =\n(- Zfloor r)%Z.","proofString":"intros Y1 Y2.\nabsurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1."},{"statement":"(x r : R) (Y1 : r = IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (if Z.even (Zfloor (- r)) then Zceil (- r) else Zfloor (- r)) =\n(- Zfloor r)%Z.","proofString":"absurd (-r=IZR (Zfloor (-r)))%R; trivial.\npattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1."},{"statement":"(x r : R) (Y1 : r = IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (- r)%R = IZR (Zfloor (- r)).","proofString":"pattern r at 2; rewrite Y1.\nrewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1."},{"statement":"(x r : R) (Y1 : r = IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (- r)%R = IZR (Zfloor (- IZR (Zfloor r))).","proofString":"rewrite <- opp_IZR, Zfloor_IZR.\nnow rewrite opp_IZR, <- Y1."},{"statement":"(x r : R) (Y1 : r = IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (- r)%R = IZR (- Zfloor r).","proofString":"now rewrite opp_IZR, <- Y1."},{"statement":"(x r : R) : r <> IZR (Zfloor r) ->\n(- r)%R <> IZR (Zfloor (- r)) ->\n(if Z.even (Zfloor (- r)) then Zceil (- r) else Zfloor (- r)) =\n(- (if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"intros Y1 Y2.\nunfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (if Z.even (Zfloor (- r)) then Zceil (- r) else Zfloor (- r)) =\n(- (if Z.even (Zfloor r) then Zceil r else Zfloor r))%Z.","proofString":"unfold Zceil; rewrite Ropp_involutive.\nreplace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (if Z.even (Zfloor (- r)) then (- Zfloor r)%Z else Zfloor (- r)) =\n(- (if Z.even (Zfloor r) then - Zfloor (- r) else Zfloor r))%Z.","proofString":"replace  (Z.even (Zfloor (- r))) with (negb (Z.even (Zfloor r))).\ncase (Z.even (Zfloor r));  simpl; ring.\napply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : (if negb (Z.even (Zfloor r)) then (- Zfloor r)%Z else Zfloor (- r)) =\n(- (if Z.even (Zfloor r) then - Zfloor (- r) else Zfloor r))%Z.","proofString":"case (Z.even (Zfloor r));  simpl; ring."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : negb (Z.even (Zfloor r)) = Z.even (Zfloor (- r)).","proofString":"apply trans_eq with (Z.even (Zceil r)).\nrewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq.\nrewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : negb (Z.even (Zfloor r)) = Z.even (Zceil r).","proofString":"rewrite Zceil_floor_neq.\nrewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity.\nnow apply sym_not_eq."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : negb (Z.even (Zfloor r)) = Z.even (Zfloor r + 1).","proofString":"rewrite Z.even_add.\ndestruct (Z.even (Zfloor r)); reflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : negb (Z.even (Zfloor r)) = Bool.eqb (Z.even (Zfloor r)) (Z.even 1).","proofString":"destruct (Z.even (Zfloor r)); reflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : IZR (Zfloor r) <> r.","proofString":"now apply sym_not_eq."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : Z.even (Zceil r) = Z.even (Zfloor (- r)).","proofString":"rewrite <- (Z.even_opp (Zfloor (- r))).\nreflexivity."},{"statement":"(x r : R) (Y1 : r <> IZR (Zfloor r)) (Y2 : (- r)%R <> IZR (Zfloor (- r))) : Z.even (Zceil r) = Z.even (- Zfloor (- r)).","proofString":"reflexivity."},{"statement":"(x : R) : cexp (- x) = cexp x.","proofString":"apply cexp_opp."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) : f1 = f2.","proofString":"case (generic_format_EM beta fexp x); intros L.\napply trans_eq with x.\ncase H1; try easy.\nintros (J,_); case J; intros J'.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption.\ncase H2; try easy.\nintros (J,_); case J; intros J'; apply sym_eq.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption.\ndestruct H1 as [H1|(H1,H1')].\ncontradict L; now rewrite <- H1.\ndestruct H2 as [H2|(H2,H2')].\ncontradict L; now rewrite <- H2.\ndestruct H1 as [H1|H1]; destruct H2 as [H2|H2].\napply Rnd_DN_pt_unique with format x; assumption.\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\napply Rnd_UP_pt_unique with format x; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) : f1 = f2.","proofString":"apply trans_eq with x.\ncase H1; try easy.\nintros (J,_); case J; intros J'.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption.\ncase H2; try easy.\nintros (J,_); case J; intros J'; apply sym_eq.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) : f1 = x.","proofString":"case H1; try easy.\nintros (J,_); case J; intros J'.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) : (Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) ->\nf1 = x.","proofString":"intros (J,_); case J; intros J'.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) (J : Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) (J' : Rnd_DN_pt format x f1) : f1 = x.","proofString":"apply Rnd_DN_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) (J : Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) (J' : Rnd_UP_pt format x f1) : f1 = x.","proofString":"apply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) : x = f2.","proofString":"case H2; try easy.\nintros (J,_); case J; intros J'; apply sym_eq.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) : (Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) ->\nx = f2.","proofString":"intros (J,_); case J; intros J'; apply sym_eq.\napply Rnd_DN_pt_idempotent with format; assumption.\napply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) (J : Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) (J' : Rnd_DN_pt format x f2) : f2 = x.","proofString":"apply Rnd_DN_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : format x) (J : Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) (J' : Rnd_UP_pt format x f2) : f2 = x.","proofString":"apply Rnd_UP_pt_idempotent with format; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x \\/\n(Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) /\\\n(exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : ~ format x) : f1 = f2.","proofString":"destruct H1 as [H1|(H1,H1')].\ncontradict L; now rewrite <- H1.\ndestruct H2 as [H2|(H2,H2')].\ncontradict L; now rewrite <- H2.\ndestruct H1 as [H1|H1]; destruct H2 as [H2|H2].\napply Rnd_DN_pt_unique with format x; assumption.\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\napply Rnd_UP_pt_unique with format x; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : f1 = x) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : ~ format x) : f1 = f2.","proofString":"contradict L; now rewrite <- H1."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : f2 = x \\/\n(Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) /\\\n(exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false)) (L : ~ format x) : f1 = f2.","proofString":"destruct H2 as [H2|(H2,H2')].\ncontradict L; now rewrite <- H2.\ndestruct H1 as [H1|H1]; destruct H2 as [H2|H2].\napply Rnd_DN_pt_unique with format x; assumption.\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\napply Rnd_UP_pt_unique with format x; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : f2 = x) (L : ~ format x) : f1 = f2.","proofString":"contradict L; now rewrite <- H2."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1 \\/ Rnd_UP_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2 \\/ Rnd_UP_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"destruct H1 as [H1|H1]; destruct H2 as [H2|H2].\napply Rnd_DN_pt_unique with format x; assumption.\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\ndestruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt...\napply Rnd_UP_pt_unique with format x; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"apply Rnd_DN_pt_unique with format x; assumption."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"destruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"destruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : f1 = f2.","proofString":"absurd (true = false); try discriminate.\nrewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : true = false.","proofString":"rewrite <- L3.\napply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : true = Z.even (Fnum gg).","proofString":"apply trans_eq with (negb (Z.even (Fnum ff))).\nrewrite K3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : true = negb (Z.even (Fnum ff)).","proofString":"rewrite K3; easy."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : negb (Z.even (Fnum ff)) = Z.even (Fnum gg).","proofString":"apply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : Z.even (Fnum gg) = negb (Z.even (Fnum ff)).","proofString":"generalize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : DN_UP_parity_prop beta fexp -> Z.even (Fnum gg) = negb (Z.even (Fnum ff)).","proofString":"unfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : F2R ff = round beta fexp Zfloor x.","proofString":"rewrite <- K1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : Rnd_DN_pt format x (round beta fexp Zfloor x).","proofString":"now apply round_DN_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : F2R gg = round beta fexp Zceil x.","proofString":"rewrite <- L1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_DN_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : Rnd_UP_pt format x (round beta fexp Zceil x).","proofString":"now apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"destruct H1' as (ff,(K1,(K2,K3))).\ndestruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"destruct H2' as (gg,(L1,(L2,L3))).\nabsurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : f1 = f2.","proofString":"absurd (true = false); try discriminate.\nrewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : true = false.","proofString":"rewrite <- K3.\napply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : true = Z.even (Fnum ff).","proofString":"apply trans_eq with (negb (Z.even (Fnum gg))).\nrewrite L3; easy.\napply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : true = negb (Z.even (Fnum gg)).","proofString":"rewrite L3; easy."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : negb (Z.even (Fnum gg)) = Z.even (Fnum ff).","proofString":"apply sym_eq.\ngeneralize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : Z.even (Fnum ff) = negb (Z.even (Fnum gg)).","proofString":"generalize (DN_UP_parity_generic beta fexp).\nunfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : DN_UP_parity_prop beta fexp -> Z.even (Fnum ff) = negb (Z.even (Fnum gg)).","proofString":"unfold DN_UP_parity_prop; intros T; apply (T x); clear T; try assumption...\nrewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt...\nrewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : F2R gg = round beta fexp Zfloor x.","proofString":"rewrite <- L1; apply Rnd_DN_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_DN_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : Rnd_DN_pt format x (round beta fexp Zfloor x).","proofString":"now apply round_DN_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : F2R ff = round beta fexp Zceil x.","proofString":"rewrite <- K1; apply Rnd_UP_pt_unique with (generic_format beta fexp) x; try easy...\nnow apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (ff : float beta) (K1 : f1 = F2R ff) (K2 : canonical ff) (K3 : Z.even (Fnum ff) = false) (Ff2 : format f2) (H2 : Rnd_DN_pt format x f2) (gg : float beta) (L1 : f2 = F2R gg) (L2 : canonical gg) (L3 : Z.even (Fnum gg) = false) (L : ~ format x) : Rnd_UP_pt format x (round beta fexp Zceil x).","proofString":"now apply round_UP_pt..."},{"statement":"(x f1 f2 : R) (Ff1 : format f1) (H1 : Rnd_UP_pt format x f1) (H1' : exists g : float beta, f1 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (Ff2 : format f2) (H2 : Rnd_UP_pt format x f2) (H2' : exists g : float beta, f2 = F2R g /\\ canonical g /\\ Z.even (Fnum g) = false) (L : ~ format x) : f1 = f2.","proofString":"apply Rnd_UP_pt_unique with format x; assumption."},{"statement":"(x y f g : R) (H1 : Rnd_odd_pt x f) (H2 : Rnd_odd_pt y g) (Hxy : (x <= y)%R) : (f <= round beta fexp Zrnd_odd x)%R.","proofString":"right; apply Rnd_odd_pt_unique with x; try assumption.\napply round_odd_pt."},{"statement":"(x y f g : R) (H1 : Rnd_odd_pt x f) (H2 : Rnd_odd_pt y g) (Hxy : (x <= y)%R) : Rnd_odd_pt x (round beta fexp Zrnd_odd x).","proofString":"apply round_odd_pt."},{"statement":"(x y f g : R) (H1 : Rnd_odd_pt x f) (H2 : Rnd_odd_pt y g) (Hxy : (x <= y)%R) : (round beta fexp Zrnd_odd y <= g)%R.","proofString":"right; apply Rnd_odd_pt_unique with y; try assumption.\napply round_odd_pt."},{"statement":"(x y f g : R) (H1 : Rnd_odd_pt x f) (H2 : Rnd_odd_pt y g) (Hxy : (x <= y)%R) : Rnd_odd_pt y (round beta fexp Zrnd_odd y).","proofString":"apply round_odd_pt."},{"statement":"(x : R) (Hx : generic_format beta fexp x) : generic_format beta fexpe x.","proofString":"apply generic_inclusion_mag with fexp; trivial; intros Hx2.\ngeneralize (fexpe_fexp (mag beta x)).\nlia."},{"statement":"(x : R) (Hx : generic_format beta fexp x) (Hx2 : x <> 0%R) : (fexpe (mag beta x) <= fexp (mag beta x))%Z.","proofString":"generalize (fexpe_fexp (mag beta x)).\nlia."},{"statement":"(x : R) (Hx : generic_format beta fexp x) (Hx2 : x <> 0%R) : (fexpe (mag beta x) <= fexp (mag beta x) - 2)%Z ->\n(fexpe (mag beta x) <= fexp (mag beta x))%Z.","proofString":"lia."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : exists f : float beta,\n  F2R f = x /\\ canonical beta c f /\\ Z.even (Fnum f) = true.","proofString":"exists (Float beta     (Fnum g*Z.pow (radix_val beta) (Fexp g - c (mag beta x)))     (c (mag beta x))).\nassert (F2R (Float beta     (Fnum g*Z.pow (radix_val beta) (Fexp g - c (mag beta x)))     (c (mag beta x))) = x).\nunfold F2R; simpl.\nrewrite mult_IZR, IZR_Zpower.\nrewrite Rmult_assoc, <- bpow_plus.\nrewrite <- Hg1; unfold F2R.\napply f_equal, f_equal.\nring.\nlia.\nsplit; trivial.\nsplit.\nunfold canonical, cexp.\nnow rewrite H.\nsimpl.\nrewrite Z.even_mul.\nrewrite Z.even_pow.\nrewrite Even_beta.\napply Bool.orb_true_intro.\nnow right.\nlia."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : (IZR (Fnum g * beta ^ (Fexp g - c (mag beta x))) * bpow (c (mag beta x)))%R =\nx.","proofString":"rewrite mult_IZR, IZR_Zpower.\nrewrite Rmult_assoc, <- bpow_plus.\nrewrite <- Hg1; unfold F2R.\napply f_equal, f_equal.\nring.\nlia."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : (IZR (Fnum g) * bpow (Fexp g - c (mag beta x)) * bpow (c (mag beta x)))%R = x.","proofString":"rewrite Rmult_assoc, <- bpow_plus.\nrewrite <- Hg1; unfold F2R.\napply f_equal, f_equal.\nring."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : (IZR (Fnum g) * bpow (Fexp g - c (mag beta x) + c (mag beta x)))%R = x.","proofString":"rewrite <- Hg1; unfold F2R.\napply f_equal, f_equal.\nring."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : (IZR (Fnum g) *\n bpow\n   (Fexp g - c (mag beta (IZR (Fnum g) * bpow (Fexp g))) +\n    c (mag beta (IZR (Fnum g) * bpow (Fexp g)))))%R =\n(IZR (Fnum g) * bpow (Fexp g))%R.","proofString":"apply f_equal, f_equal.\nring."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : (Fexp g - c (mag beta (IZR (Fnum g) * bpow (Fexp g))) +\n c (mag beta (IZR (Fnum g) * bpow (Fexp g))))%Z = \nFexp g.","proofString":"ring."},{"statement":"(c : Z -> Z) (x : R) (g : float beta) (Hg1 : F2R g = x) (Hg2 : (c (mag beta x) < Fexp g)%Z) : (0 <= Fexp g - c (mag beta x))%Z.","proofString":"lia."},{"statement":"generic_format beta fexp 0.","proofString":"apply generic_format_0."},{"statement":"(0 <= x)%R.","proofString":"now left."},{"statement":"(Y : (0 < F2R d)%R) : (0 < round beta fexp Zfloor x)%R.","proofString":"now rewrite <- d_eq."},{"statement":"(Y : (0 < F2R d)%R) : Fexp d = fexp (mag beta x).","proofString":"now rewrite Cd, <- mag_d."},{"statement":"(Y : (0 < F2R d)%R) : F2R d <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(Y : (0 < F2R d)%R) : generic_format beta fexp (F2R d).","proofString":"apply Hd."},{"statement":"(Y : (0 < F2R d)%R) : (mag beta (F2R d) <= mag beta x)%Z.","proofString":"apply mag_le; trivial.\napply Hd."},{"statement":"(Y : (0 < F2R d)%R) : (F2R d <= x)%R.","proofString":"apply Hd."},{"statement":"(Y : (0 < F2R d)%R) : F2R d <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(Y : (0 < F2R d)%R) : generic_format beta fexp (F2R d).","proofString":"now apply generic_format_canonical."},{"statement":"(F2R d <= F2R u)%R.","proofString":"apply Rle_trans with x.\napply Hd.\napply Hu."},{"statement":"(F2R d <= x)%R.","proofString":"apply Hd."},{"statement":"(x <= F2R u)%R.","proofString":"apply Hu."},{"statement":"(H : (F2R d <= F2R u)%R) : (F2R d <= m)%R.","proofString":"unfold m.\nlra."},{"statement":"(H : (F2R d <= F2R u)%R) : (F2R d <= (F2R d + F2R u) / 2)%R.","proofString":"lra."},{"statement":"(F2R d <= F2R u)%R.","proofString":"apply Rle_trans with x.\napply Hd.\napply Hu."},{"statement":"(F2R d <= x)%R.","proofString":"apply Hd."},{"statement":"(x <= F2R u)%R.","proofString":"apply Hu."},{"statement":"(H : (F2R d <= F2R u)%R) : (m <= F2R u)%R.","proofString":"unfold m.\nlra."},{"statement":"(H : (F2R d <= F2R u)%R) : ((F2R d + F2R u) / 2 <= F2R u)%R.","proofString":"lra."},{"statement":"(Y : (0 < F2R d)%R) : exists f : float beta, F2R f = F2R u /\\ Fexp f = Fexp d.","proofString":"rewrite u_eq; unfold round.\neexists; repeat split.\nsimpl; now rewrite Fexp_d."},{"statement":"(Y : 0%R = F2R d) : exists f : float beta, F2R f = m /\\ Fexp f = (fexp (mag beta (F2R u)) - 1)%Z.","proofString":"specialize (Zeven_ex (radix_val beta)); rewrite Even_beta.\nintros (b, Hb); rewrite Zplus_0_r in Hb.\nexists (Fmult (Float beta b (-1)) u)%R.\nsplit.\nrewrite F2R_mult; unfold m; rewrite <- Y, Rplus_0_l.\nrewrite Rmult_comm.\nunfold Rdiv; apply f_equal.\nunfold F2R; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r, Hb, mult_IZR.\nsimpl; field.\napply Rgt_not_eq, Rmult_lt_reg_l with (1 := Rlt_0_2).\nrewrite Rmult_0_r, <- (mult_IZR 2), <-Hb.\napply radix_pos.\napply trans_eq with (-1+Fexp u)%Z.\nunfold Fmult.\ndestruct u; reflexivity.\nrewrite Zplus_comm, Cu; unfold Zminus; now apply f_equal2."},{"statement":"(Y : (0 < F2R d)%R) : generic_format beta fexpe m.","proofString":"destruct m_eq as (g,(Hg1,Hg2)); trivial.\napply generic_format_F2R' with g.\nnow apply sym_eq.\nintros H; unfold cexp; rewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : generic_format beta fexpe m.","proofString":"apply generic_format_F2R' with g.\nnow apply sym_eq.\nintros H; unfold cexp; rewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : F2R g = m.","proofString":"now apply sym_eq."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : m <> 0%R -> (cexp beta fexpe m <= Fexp g)%Z.","proofString":"intros H; unfold cexp; rewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta m) <= fexp (mag beta x) - 1)%Z.","proofString":"rewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta (F2R d)) <= fexp (mag beta x) - 1)%Z.","proofString":"rewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta (F2R d)) <= Fexp d - 1)%Z.","proofString":"rewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta (F2R d)) <= cexp beta fexp (F2R d) - 1)%Z.","proofString":"unfold cexp.\ngeneralize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta (F2R d)) <= fexp (mag beta (F2R d)) - 1)%Z.","proofString":"generalize (fexpe_fexp (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta (F2R d)) <= fexp (mag beta (F2R d)) - 2)%Z ->\n(fexpe (mag beta (F2R d)) <= fexp (mag beta (F2R d)) - 1)%Z.","proofString":"lia."},{"statement":"(Y : 0%R = F2R d) : generic_format beta fexpe m.","proofString":"destruct m_eq_0 as (g,(Hg1,Hg2)); trivial.\napply generic_format_F2R' with g.\nassumption.\nintros H; unfold cexp; rewrite Hg2.\nrewrite mag_m_0; try assumption.\napply Z.le_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : generic_format beta fexpe m.","proofString":"apply generic_format_F2R' with g.\nassumption.\nintros H; unfold cexp; rewrite Hg2.\nrewrite mag_m_0; try assumption.\napply Z.le_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : F2R g = m.","proofString":"assumption."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : m <> 0%R -> (cexp beta fexpe m <= Fexp g)%Z.","proofString":"intros H; unfold cexp; rewrite Hg2.\nrewrite mag_m_0; try assumption.\napply Z.le_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta m) <= fexp (mag beta (F2R u)) - 1)%Z.","proofString":"rewrite mag_m_0; try assumption.\napply Z.le_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) (H : m <> 0%R) : (fexpe (mag beta (F2R u) - 1) <= fexp (mag beta (F2R u)) - 1)%Z.","proofString":"apply Z.le_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) (H : m <> 0%R) : (fexp (mag beta (F2R u) - 1) - 2 <= fexp (mag beta (F2R u)) - 1)%Z.","proofString":"generalize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) (H : m <> 0%R) : (fexp (mag beta (F2R u) - 1) < fexp (mag beta (F2R u)) + 1)%Z ->\n(fexp (mag beta (F2R u) - 1) - 2 <= fexp (mag beta (F2R u)) - 1)%Z.","proofString":"lia."},{"statement":"(Y : (0 < F2R d)%R) : exists g : float beta,\n  F2R g = m /\\ canonical beta fexpe g /\\ Z.even (Fnum g) = true.","proofString":"destruct m_eq as (g,(Hg1,Hg2)); trivial.\napply exists_even_fexp_lt.\nexists g; split; trivial.\nrewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : exists g0 : float beta,\n  F2R g0 = m /\\ canonical beta fexpe g0 /\\ Z.even (Fnum g0) = true.","proofString":"apply exists_even_fexp_lt.\nexists g; split; trivial.\nrewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : exists f : float beta, F2R f = m /\\ (fexpe (mag beta m) < Fexp f)%Z.","proofString":"exists g; split; trivial.\nrewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta m) < Fexp g)%Z.","proofString":"rewrite Hg2.\nrewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta m) < fexp (mag beta x) - 1)%Z.","proofString":"rewrite mag_m; trivial.\nrewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta (F2R d)) < fexp (mag beta x) - 1)%Z.","proofString":"rewrite <- Fexp_d; trivial.\nrewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta (F2R d)) < Fexp d - 1)%Z.","proofString":"rewrite Cd.\nunfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta (F2R d)) < cexp beta fexp (F2R d) - 1)%Z.","proofString":"unfold cexp.\ngeneralize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta (F2R d)) < fexp (mag beta (F2R d)) - 1)%Z.","proofString":"generalize (fexpe_fexp  (mag beta (F2R d))).\nlia."},{"statement":"(Y : (0 < F2R d)%R) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta x) - 1)%Z) : (fexpe (mag beta (F2R d)) <= fexp (mag beta (F2R d)) - 2)%Z ->\n(fexpe (mag beta (F2R d)) < fexp (mag beta (F2R d)) - 1)%Z.","proofString":"lia."},{"statement":"(Y : 0%R = F2R d) : exists g : float beta,\n  F2R g = m /\\ canonical beta fexpe g /\\ Z.even (Fnum g) = true.","proofString":"destruct m_eq_0 as (g,(Hg1,Hg2)); trivial.\napply exists_even_fexp_lt.\nexists g; split; trivial.\nrewrite Hg2.\nrewrite mag_m_0; trivial.\napply Z.le_lt_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : exists g0 : float beta,\n  F2R g0 = m /\\ canonical beta fexpe g0 /\\ Z.even (Fnum g0) = true.","proofString":"apply exists_even_fexp_lt.\nexists g; split; trivial.\nrewrite Hg2.\nrewrite mag_m_0; trivial.\napply Z.le_lt_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : exists f : float beta, F2R f = m /\\ (fexpe (mag beta m) < Fexp f)%Z.","proofString":"exists g; split; trivial.\nrewrite Hg2.\nrewrite mag_m_0; trivial.\napply Z.le_lt_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : (fexpe (mag beta m) < Fexp g)%Z.","proofString":"rewrite Hg2.\nrewrite mag_m_0; trivial.\napply Z.le_lt_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : (fexpe (mag beta m) < fexp (mag beta (F2R u)) - 1)%Z.","proofString":"rewrite mag_m_0; trivial.\napply Z.le_lt_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : (fexpe (mag beta (F2R u) - 1) < fexp (mag beta (F2R u)) - 1)%Z.","proofString":"apply Z.le_lt_trans with (1:=fexpe_fexp _).\ngeneralize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : (fexp (mag beta (F2R u) - 1) - 2 < fexp (mag beta (F2R u)) - 1)%Z.","proofString":"generalize (fexp_m_eq_0 Y).\nlia."},{"statement":"(Y : 0%R = F2R d) (g : float beta) (Hg1 : F2R g = m) (Hg2 : Fexp g = (fexp (mag beta (F2R u)) - 1)%Z) : (fexp (mag beta (F2R u) - 1) < fexp (mag beta (F2R u)) + 1)%Z ->\n(fexp (mag beta (F2R u) - 1) - 2 < fexp (mag beta (F2R u)) - 1)%Z.","proofString":"lia."},{"statement":"(z : R) (Hz1 : (F2R d <= z < F2R u)%R) (Y : (round beta fexp Zfloor z <= F2R d)%R) : generic_format beta fexp (F2R d).","proofString":"apply Hd."},{"statement":"(z : R) (Hz1 : (F2R d <= z < F2R u)%R) (Y : (round beta fexp Zfloor z <= F2R d)%R) : (F2R d <= z)%R.","proofString":"apply Hz1."},{"statement":"(z : R) (Hz1 : (F2R d < z <= F2R u)%R) (Y : (F2R u <= round beta fexp Zceil z)%R) : generic_format beta fexp (F2R u).","proofString":"apply Hu."},{"statement":"(z : R) (Hz1 : (F2R d < z <= F2R u)%R) (Y : (F2R u <= round beta fexp Zceil z)%R) : (z <= F2R u)%R.","proofString":"apply Hz1."},{"statement":"(x : R) (H : (x < 0)%R) (d : float beta) (Hd1 : round beta fexp Zfloor (- x) = F2R d) (Hd2 : canonical beta fexp d) (u : float beta) (Hu1 : round beta fexp Zceil (- x) = F2R u) (Hu2 : canonical beta fexp u) : (0 < - x)%R.","proofString":"auto with real."}]}