{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Liveness.v","fileSamples":[{"statement":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i)) : Regset.Subset (transfer f s live # s) live # n.","conclusion":"Regset.Subset (transfer f s live # s) live # n","hypotheses":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i))","proofString":"eapply DS.fixpoint_solution; eauto.\nintros.\nunfold transfer; rewrite H2.\napply DS.L.eq_refl."},{"statement":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i)) : forall (n0 : positive) (a : DS.L.t),\n(fn_code f) ! n0 = None -> DS.L.eq (transfer f n0 a) DS.L.bot.","conclusion":"forall (n0 : positive) (a : DS.L.t),\n(fn_code f) ! n0 = None -> DS.L.eq (transfer f n0 a) DS.L.bot","hypotheses":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i))","proofString":"intros.\nunfold transfer; rewrite H2.\napply DS.L.eq_refl."},{"statement":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i)) (n0 : positive) (a : DS.L.t) (H2 : (fn_code f) ! n0 = None) : DS.L.eq (transfer f n0 a) DS.L.bot.","conclusion":"DS.L.eq (transfer f n0 a) DS.L.bot","hypotheses":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i)) (n0 : positive) (a : DS.L.t) (H2 : (fn_code f) ! n0 = None)","proofString":"unfold transfer; rewrite H2.\napply DS.L.eq_refl."},{"statement":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i)) (n0 : positive) (a : DS.L.t) (H2 : (fn_code f) ! n0 = None) : DS.L.eq Regset.empty DS.L.bot.","conclusion":"DS.L.eq Regset.empty DS.L.bot","hypotheses":"(f : function) (live : PMap.t Regset.t) (n : positive) (i : instruction) (s : node) (H : DS.fixpoint (fn_code f) successors_instr (transfer f) = Some live) (H0 : (fn_code f) ! n = Some i) (H1 : In s (successors_instr i)) (n0 : positive) (a : DS.L.t) (H2 : (fn_code f) ! n0 = None)","proofString":"apply DS.L.eq_refl."}]}