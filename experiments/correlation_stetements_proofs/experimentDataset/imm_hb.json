[{"statement":"Lemma hb_trans : transitive hb.","proof":"vauto.\n"},{"statement":"Lemma sb_in_hb : sb ⊆ hb.","proof":"vauto.\n"},{"statement":"Lemma sw_in_hb : sw ⊆ hb.","proof":"vauto.\n"},{"statement":"Lemma cr_hb_hb : hb^? ⨾ hb ≡ hb.","proof":"generalize hb_trans; basic_solver.\n"},{"statement":"Lemma cr_hb_cr_hb : hb^? ⨾ hb^? ≡ hb^?.","proof":"generalize hb_trans; basic_solver 20.\n"},{"statement":"Lemma hb_sb_sw : hb ≡ hb^? ⨾ (sb ∪ sw).","proof":"unfold hb; rewrite ct_end at 1; rels.\n"},{"statement":"Lemma sprop_trans WF : transitive sprop.","proof":"apply transitiveI.\nunfold sprop at 1 2.\nrewrite !seqA.\narewrite (⦗Rel⦘ ⨾ ⦗W⦘ ⨾ rfe^? ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq ∪₁ W⦘ ⊆ hb^?).\n{\nrewrite crE at 1.\nrewrite !seq_union_l, !seq_union_r, !seq_id_l.\nunionL.\n{\nrewrite sb_in_hb.\nbasic_solver.\n}\nrewrite <- sw_in_hb.\nunfold sw.\narewrite (⦗Rel⦘ ⨾ ⦗W⦘ ⊆ release).\n{\nunfold release, rs.\nrewrite rtE.\nbasic_solver 40.\n}\nrewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite !seqA.\narewrite (⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq ∪₁ W⦘ ⊆ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘).\n{\nunfolder.\nins.\ndesf; eauto 10.\nall: type_solver.\n}\nbasic_solver 40.\n}\narewrite (hb ⨾ hb^? ⨾ hb ⊆ hb).\n2: done.\nrewrite cr_hb_hb.\napply transitiveI.\napply hb_trans.\n"},{"statement":"Lemma loceq_rs WF : funeq loc rs.","proof":"destruct WF; unfold rs; desf; eauto 10 with hahn.\n"},{"statement":"Lemma wf_rsE WF : rs ≡ ⦗W⦘ ∪ ⦗E⦘ ⨾ rs ⨾ ⦗E⦘.","proof":"unfold rs.\nsplit; [|basic_solver].\nrewrite rtE; relsf; unionL.\nrewrite wf_sbE; basic_solver 21.\nbasic_solver 21.\nunionR right -> right -> right.\nrewrite (dom_r (wf_rmwE WF)) at 1.\nrewrite <- !seqA.\nsin_rewrite inclusion_ct_seq_eqv_r.\nrewrite !seqA.\narewrite (⦗E⦘ ⨾ ⦗W⦘ ≡ ⦗W⦘ ⨾ ⦗E⦘) by basic_solver.\nhahn_frame.\nrewrite ct_begin.\nrewrite (dom_l (@wf_sbE G)) at 1.\nrewrite (dom_l (wf_rfE WF)) at 1.\nbasic_solver 21.\n"},{"statement":"Lemma wf_releaseE WF : release ≡ ⦗W ∩₁ Rel⦘ ∪ ⦗E⦘ ⨾ release ⨾ ⦗E⦘.","proof":"unfold release.\nrewrite (wf_rsE WF).\nrewrite (@wf_sbE G) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_swE_right WF : sw ≡ sw ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold sw.\nrewrite wf_sbE at 1 2.\nrewrite (wf_rfiE WF) at 1.\nrewrite (wf_rfeE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_swE WF : sw ≡ ⦗E⦘ ⨾ sw ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nrewrite (wf_swE_right WF) at 1.\nhahn_frame.\nunfold sw.\nrewrite (wf_releaseE WF).\nrewrite (dom_l (wf_rfiE WF)).\nrewrite (dom_l (@wf_sbE G)).\nrewrite (dom_l (wf_rfeE WF)).\nbasic_solver 40.\n"},{"statement":"Lemma wf_hbE WF : hb ≡ ⦗E⦘ ⨾ hb ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold hb.\nrewrite <- inclusion_ct_seq_eqv_r, <- inclusion_ct_seq_eqv_l.\napply inclusion_t_t.\nrewrite wf_sbE at 1.\nrewrite (wf_swE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_rsD WF : rs ≡ ⦗W⦘ ⨾ rs ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\nunfold rs.\nrelsf; unionL; [basic_solver 12|].\nrewrite rtE; relsf; unionL; [basic_solver|].\nrewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite <- !seqA.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver 42.\n"},{"statement":"Lemma wf_releaseD WF : release ≡ ⦗FW∩₁Rel⦘ ⨾ release ⨾ ⦗W⦘.","proof":"split; [|basic_solver].\nunfold release.\nrewrite (wf_rsD WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_swD WF : sw ≡ ⦗FW∩₁Rel⦘ ⨾ sw ⨾ ⦗FR∩₁Acq⦘.","proof":"split; [|basic_solver].\nunfold sw.\nrewrite (wf_releaseD WF) at 1.\nrewrite (wf_rfiD WF) at 1.\nrewrite (wf_rfeD WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma no_sw_to_init WF : sw ≡ sw ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nrewrite (wf_swD WF) at 1.\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42.\n"},{"statement":"Lemma no_hb_to_init WF : hb ≡ hb ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nunfold hb.\nrewrite ct_end.\nrewrite (no_sw_to_init WF) at 2.\nrewrite no_sb_to_init at 2.\nbasic_solver 42.\n"},{"statement":"Lemma sw_alt WF: \n  sw ≡ release ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾  ⦗R ∩₁ Acq⦘ \n     ∪ release ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾  sb ⨾ ⦗F ∩₁ Acq⦘.","proof":"unfold sw.\nrewrite (dom_r (wf_rfiD WF)).\nrewrite (dom_r (wf_rfeD WF)).\nbasic_solver 42.\n"},{"statement":"Lemma rel_rf_in_sw WF: release ⨾ rf ⨾ ⦗Acq⦘ ⊆ sw.","proof":"rewrite (wf_rfD WF), rfi_union_rfe.\nunfold sw; basic_solver 42.\n"},{"statement":"Lemma sw_in_rel_rf WF: \n  sw ⨾ ⦗R⦘ ⊆ release ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗Acq⦘.","proof":"unfold sw; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗R⦘ ⊆ ⦗Acq⦘) by type_solver 42.\n"},{"statement":"Lemma rs_in_co WF SC_PER_LOC : rs ⊆ ⦗W⦘ ⨾ co^?.","proof":"unfold rs.\nassert (A: ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ ⦗W⦘ ⨾ co^?).\n{\narewrite (⦗W⦘ ⊆ ⦗W⦘ ⨾ ⦗W⦘) at 1 by basic_solver.\nrewrite crE; relsf; unionL; [basic_solver|].\nsin_rewrite (w_sb_loc_w_in_coi WF SC_PER_LOC).\nsin_rewrite (dom_l (wf_coiD WF)).\nie_unfolder; basic_solver.\n}\nrelsf; unionL.\narewrite (sb ∩ same_loc ⊆ (sb ∩ same_loc)^?).\nby rewrite A.\nrewrite rtE; relsf; unionL; [basic_solver|].\nsin_rewrite !(rf_rmw_in_co WF SC_PER_LOC).\nsin_rewrite (dom_r (wf_coD WF)).\narewrite (⦗W⦘ ⨾ ((sb ∩ same_loc)^? ⨾ co ⨾ ⦗W⦘)⁺ ⊆ (⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ co)⁺).\nrewrite <- seqA.\nrewrite <- ct_seq_swap.\narewrite_id ⦗W⦘ at 2.\nby rels.\nsin_rewrite (dom_l (wf_coD WF)).\nsin_rewrite A.\nrewrite !seqA.\nrewrite inclusion_ct_seq_eqv_l.\ngeneralize (co_trans WF); ins; relsf.\n"},{"statement":"Lemma rs_in_eco WF SC_PER_LOC : rs ⊆ eco^?.","proof":"rewrite rs_in_co, co_in_eco; try done; basic_solver.\n"},{"statement":"Lemma rs_sb_loc WF SC_PER_LOC : rs ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ co^?.","proof":"rewrite rs_in_co; auto.\nrewrite !seqA.\napply co_sb_loc; auto.\n"},{"statement":"Lemma rs_rfi WF SC_PER_LOC :\n  rs ⨾ rfi ⊆ sb ∩ same_loc ⨾ ⦗R⦘ ∪ co^? ⨾ rfe ⨾ ⦗R⦘ ⨾ sb.","proof":"generalize (@sb_same_loc_trans G); ins.\nassert (SB: (sb ∩ same_loc)^? ⨾ rfi ⨾ rmw ⊆ sb ∩ same_loc).\n{\nrewrite (rfi_in_sbloc' WF).\narewrite (rmw ⊆ rmw ∩ rmw).\nrewrite (rmw_in_sb WF) at 1; rewrite (wf_rmwl WF).\nrelsf.\n}\nunfold rs.\nrewrite rtE; relsf; unionL.\n{\nrewrite (dom_r (wf_rfiD WF)), (rfi_in_sbloc' WF).\ngeneralize (@sb_same_loc_trans G).\nbasic_solver 12.\n}\n{\nrewrite (dom_r (wf_rfiD WF)); rewrite (rfi_in_sbloc' WF).\nbasic_solver 12.\n}\nrewrite rfi_union_rfe; relsf.\nrewrite path_ut_last; relsf; unionL.\n{\nrewrite (dom_r (wf_rfiD WF)) at 2; rewrite (rfi_in_sbloc' WF) at 2.\nsin_rewrite SB.\nrewrite !seqA.\nrelsf.\nbasic_solver.\n}\narewrite (⦗W⦘ ⨾ ((sb ∩ same_loc)^? ⨾ rfi ⨾ rmw ∪ (sb ∩ same_loc)^? ⨾ rfe ⨾ rmw)＊ ⊆ rs).\n{\nunfold rs.\nrewrite rfi_union_rfe.\nrelsf.\n}\nrewrite (dom_l (wf_rfeD WF)) at 1.\nrewrite !seqA.\nsin_rewrite (rs_sb_loc WF SC_PER_LOC).\nrewrite (dom_l (wf_rmwD WF)).\narewrite (rfi ⊆ sb); rewrite (rmw_in_sb WF).\narewrite ((sb ∩ same_loc)^? ⊆ sb^?).\narewrite_id ⦗R⦘ at 2.\nrewrite seq_id_l.\narewrite (sb ⨾ (sb^? ⨾ sb ⨾ sb)＊ ⨾ sb ⊆ sb).\n{\ngeneralize (@sb_trans G).\nins.\nrelsf.\n}\neauto with hahn.\n"},{"statement":"Lemma release_in_co WF SC_PER_LOC : ⦗W⦘ ⨾ release ⊆ co^?.","proof":"unfold release; rewrite rs_in_co; try done.\ntype_solver.\n"},{"statement":"Lemma sw_in_eco_helper WF SC_PER_LOC  :\n rs ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⊆ eco.","proof":"rewrite (dom_l (wf_rsD WF)).\nrewrite rs_in_co; try done.\narewrite (rfi ⊆ rf).\narewrite (rfe ⊆ rf).\nrelsf; unionL.\n- rewrite co_in_eco, rf_in_eco; try done.\ngeneralize (eco_trans WF); type_solver 42.\n- rewrite (dom_r (wf_coD WF)), (dom_l (wf_rfD WF)).\narewrite (⦗W⦘ ⨾ (co ⨾ ⦗W⦘)^? ⊆ co^? ⨾ ⦗W⦘).\nbasic_solver.\narewrite !(⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ co^?).\nrewrite crE; relsf; unionL; [basic_solver|].\nsin_rewrite (w_sb_loc_w_in_coi WF SC_PER_LOC).\nie_unfolder; basic_solver.\nrewrite co_in_eco, rf_in_eco; try done.\ngeneralize (eco_trans WF); type_solver 42.\n"},{"statement":"Lemma sw_in_eco WF SC_PER_LOC : ⦗W⦘ ⨾ sw ⨾ ⦗R⦘ ⊆ eco.","proof":"unfold sw; rewrite !seqA.\nunfold release; rewrite !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\nby type_solver.\nrels.\nsin_rewrite (sw_in_eco_helper WF SC_PER_LOC).\ngeneralize (eco_trans WF); type_solver 42.\n"},{"statement":"Lemma sw_in_eco_sb WF SC_PER_LOC : ⦗W⦘ ⨾ sw ⨾ ⦗F⦘ ⊆ eco ⨾ sb ⨾ ⦗F⦘.","proof":"unfold sw; rewrite !seqA.\nunfold release; rewrite !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\nby type_solver.\nrels.\nsin_rewrite (sw_in_eco_helper WF SC_PER_LOC).\nrewrite (wf_ecoD WF) at 1.\ngeneralize (eco_trans WF); type_solver 42.\n"},{"statement":"Lemma sw_in_sb_eco_sb WF SC_PER_LOC :\n    sw ⊆ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ (sb ⨾ ⦗F ∩₁ Acq⦘)^?.","proof":"unfold sw.\nunfold release; rewrite !seqA.\nsin_rewrite sw_in_eco_helper; try done.\nbasic_solver 42.\n"},{"statement":"Lemma eco_sw_helper WF SC_PER_LOC \n  x y z (ECO: eco x y) (SW: sw y z) (NECO: ~ eco y z) :\n  exists k, eco x k /\\ sb k z /\\ ~ rmw k z.","proof":"assert (Wy: W y).\n{\napply (wf_ecoD WF) in ECO; try edone.\napply (wf_swD WF) in SW; try edone.\nby unfolder in *; type_solver.\n}\nassert (SW1 := SW).\napply (wf_swD WF) in SW1; try edone.\nunfolder in SW1; desc.\ndestruct SW2.\n2: {\nexfalso; apply NECO.\napply sw_in_eco; try done.\nunfolder; ins; desf.\n}\nedestruct sw_in_eco_sb as [x' [AA BB]]; eauto.\n{\nunfolder; splits; eauto.\ndesf.\n}\napply seq_eqv_r in BB.\ndestruct BB as [SB FF].\nexists x'; splits; eauto using (eco_trans WF); subst.\nintro A; eapply (wf_rmwD WF) in A; unfolder in *; type_solver.\n"},{"statement":"Lemma eco_sw WF SC_PER_LOC :\neco ⨾ (sw \\ eco) ⊆ eco ⨾ (sb \\ rmw).","proof":"unfold seq, minus_rel, inclusion; ins; desc.\neapply eco_sw_helper; eauto.\n"},{"statement":"Lemma eco_sw_1 WF SC_PER_LOC :\neco ⨾ sw ⊆ eco ∪ eco ⨾ (sb \\ rmw).","proof":"unfolder; ins; desf.\ndestruct (classic (eco z y)).\nby generalize (eco_trans WF); basic_solver.\nright; eapply eco_sw_helper; eauto.\n"},{"statement":"Lemma eco_seq_hb WF SC_PER_LOC COMP : \n  eco ⨾ hb ⊆ eco ∪ eco ⨾ (sb \\ rmw) ⨾ hb^?.","proof":"unfold hb; rewrite seq_ct_absorb_lt, cr_of_ct; eauto using eco_trans.\nrewrite minus_union_l.\nrelsf; unionL; eauto with hahn.\nrewrite rmw_in_fr, fr_in_eco; auto with hahn.\nsin_rewrite eco_sw; auto.\nrewrite !seqA; auto with hahn.\n"},{"statement":"Lemma release_in_hb_co WF SC_PER_LOC: release ⊆ (hb^? ⨾ co^?).","proof":"unfold release; rewrite rs_in_co; try done.\nrewrite sb_in_hb; basic_solver 10.\n"},{"statement":"Lemma hb_alt WF: \n  hb ⊆ ⦗W⦘ ⨾ sw ∪ (⦗W⦘ ⨾ sw)^? ⨾ ((sb \\ rmw) ∪ rmw ∪ ⦗F⦘ ⨾ sw ∪ (sb \\ rmw) ⨾ sw ∪ rmw ⨾ sw)⁺.","proof":"unfold hb.\nrewrite (dom_l (wf_swD WF)) at 1.\narewrite (⦗FW ∩₁ Rel⦘ ⊆ ⦗F⦘ ∪ ⦗W⦘) by type_solver 12.\nrelsf; rewrite <- !unionA.\narewrite (sb ⊆ (sb \\ rmw) ∪ rmw) at 1 by unfolder; ins; tauto.\nrewrite path_union1.\nassert (TRANS: transitive (⦗W⦘ ⨾ sw)).\nby apply transitiveI; rewrite (dom_r (wf_swD WF)) at 1; type_solver.\nrelsf.\nunionL; [by vauto|].\nrewrite !seqA.\narewrite_false (sw ⨾ ⦗W⦘).\nby rewrite (dom_r (wf_swD WF)) at 1; type_solver.\nunionR right.\nhahn_frame.\napply inclusion_t_t.\nbasic_solver 42.\n"},{"statement":"Lemma rs_rf_rmw WF: \n  rs ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ rmw ⊆ rs.","proof":"unfold rs; rewrite !seqA.\narewrite ((rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ rmw ⊆ (sb ∩ same_loc)^? ⨾ rf ⨾ rmw).\nrewrite rfi_union_rfe; basic_solver 12.\nrelsf; unionL.\nrewrite !seqA.\narewrite ( sb ∩ same_loc ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⊆ sb ∩ same_loc).\nby arewrite_id ⦗W⦘; generalize (@sb_same_loc_trans G); ins; relsf.\nrewrite (dom_l (wf_rfD WF)).\nrewrite rtE.\nrewrite <- ct_step.\nbasic_solver 21.\nunionR right.\nhahn_frame.\nrewrite <- ct_end.\nbasic_solver.\n"},{"statement":"Lemma sw_rmw_sw WF: sw ⨾ rmw ⨾ sw ⊆ sw ⨾ sb^?.","proof":"unfold sw at 2.\nunfold release; rewrite !seqA.\narewrite (rmw ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ rmw).\nby rewrite (dom_r (wf_rmwD WF)); type_solver.\nunfold rs.\nrelsf.\nrewrite !unionA.\napply inclusion_union_l.\n- arewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF).\ngeneralize (@sb_trans G); basic_solver 21.\n- unfold sw, release.\nrewrite !seqA.\narewrite !((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ rmw ⊆ rmw).\nby rewrite (dom_l (wf_rmwD WF)); type_solver.\nsin_rewrite !(rs_rf_rmw WF).\narewrite !((⦗W⦘ ⨾ (sb ∩ same_loc ⨾ ⦗W⦘ ∪ ((sb ∩ same_loc)^? ⨾ rf ⨾ rmw)＊))    ⨾ ⦗W⦘ ⨾ ((sb ∩ same_loc)^? ⨾ rf ⨾ rmw)＊ ⊆⦗W⦘ ⨾ (sb ∩ same_loc ⨾ ⦗W⦘ ∪ ((sb ∩ same_loc)^? ⨾ rf ⨾ rmw)＊)).\nrelsf; unionL; [|by arewrite_id ⦗W⦘ at 2; relsf].\nrewrite rtE at 1; relsf; unionL; [basic_solver 12|unionR right].\nrewrite ct_begin, !seqA; rels.\narewrite (sb ∩ same_loc ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⊆ (sb ∩ same_loc)^?).\ngeneralize (@sb_same_loc_trans G); basic_solver 21.\nhahn_frame_l; rewrite <- !seqA; rewrite <- ct_begin; rels.\nunionL.\n* generalize (@sb_same_loc_trans G).\nbasic_solver 42.\n* unfold rs.\nhahn_frame.\nbasic_solver 21.\n* unfold rs.\nhahn_frame.\nbasic_solver 21.\n"},{"statement":"Lemma coherence_sc_per_loc COH : sc_per_loc G.","proof":"red; rewrite sb_in_hb.\nred in COH; unfolder in *; basic_solver 12.\n"},{"statement":"Lemma hb_eco_r_alt : \n  hb ⨾ eco ≡ \n    hb ⨾ rf ∪ hb ⨾ co ∪ hb ⨾ co ⨾ rf ∪ hb ⨾ fr ∪ hb ⨾ fr ⨾ rf.","proof":"unfold Execution_eco.eco, Execution.fr; basic_solver 42.\n"},{"statement":"Proposition coherence_expanded_eq :\n  coherence <-> coherent_expanded.","proof":"unfold coherence; rewrite hb_eco_r_alt; unfold Execution.fr.\nunfold coherent_expanded; unnw.\nsplit; ins.\n- rewrite !seqA in *.\nrepeat (apply irreflexive_union in H; desf); splits.\nall: try by rotate 1.\nall: try by rotate 2.\n- desf.\nrelsf; repeat (splits; try apply irreflexive_union).\nall: try by rotate 1.\nall: try by rotate 2.\n"},{"statement":"Proposition coherence_alt :\n  irreflexive (hb ∪ hb ⨾ rfe ∪ hb ⨾ co ⨾ rfe^? ∪ hb ⨾ fr ⨾ rfe^?) -> coherence.","proof":"unfold coherence; unfold Execution_eco.eco; relsf.\nrewrite rfi_union_rfe; relsf.\narewrite (rfi ⊆ sb); rewrite sb_in_hb; rewrite !crE; relsf.\nins; unionL.\nall: try rotate 1.\nall: generalize hb_trans; ins; relsf.\nall: try (unfolder in *; basic_solver 12).\n"},{"statement":"Lemma hb_eco_irr COH : irreflexive (hb ⨾ eco).","proof":"apply COH.\n"},{"statement":"Lemma hb_irr WF COH : irreflexive hb.","proof":"unfold hb.\nrewrite path_ut_first.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rewrite (ct_of_trans (@sb_trans G)); apply sb_irr.\nrewrite (sw_in_sb_eco_sb WF (coherence_sc_per_loc COH)) at 1.\nrotate 2.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⊆ (sb ∪ sw)＊).\narewrite (sb＊ ⊆ (sb ∪ sw)＊).\narewrite ((⦗F ∩₁ Rel⦘ ⨾ sb)^? ⊆ (sb ∪ sw)＊).\nrelsf.\ngeneralize (eco_irr WF).\nred in COH; revert COH.\nbasic_solver.\n"},{"statement":"Lemma hb_acyc WF COH : acyclic hb.","proof":"eapply trans_irr_acyclic.\n2: by apply hb_trans.\napply hb_irr; auto.\n"},{"statement":"Lemma w_hb_loc_w_in_co WF COH :\n  ⦗W⦘ ⨾ hb ∩ same_loc ⨾ ⦗W⦘ ⊆ co.","proof":"apply (w_r_loc_w_in_co WF (wf_hbE WF) (hb_irr WF COH) (hb_eco_irr COH)).\n"},{"statement":"Lemma w_hb_loc_r_in_co_rf WF COH COMP:\n  ⦗W⦘ ⨾ hb ∩ same_loc ⨾ ⦗R⦘ ⊆ co^? ⨾ rf.","proof":"apply (w_r_loc_r_in_co_rf WF (wf_hbE WF) (hb_eco_irr COH) COMP).\n"},{"statement":"Lemma r_hb_loc_w_in_fr WF COH COMP:\n  ⦗R⦘ ⨾ hb ∩ same_loc ⨾ ⦗W⦘ ⊆ fr.","proof":"apply (r_r_loc_w_in_fr WF (wf_hbE WF) (hb_eco_irr COH) COMP).\n"},{"statement":"Lemma r_hb_loc_r_in_fr_rf WF COH COMP:\n  ⦗R⦘ ⨾ hb ∩ same_loc ⨾ ⦗R⦘ ⊆ fr ⨾ rf ∪ rf^{-1} ⨾ rf.","proof":"apply (r_r_loc_r_in_fr_rf WF (wf_hbE WF) (hb_eco_irr COH) COMP).\n"},{"statement":"Lemma hb_loc_in_eco WF COH COMP:\n  ⦗RW⦘ ⨾ hb ∩ same_loc ⨾ ⦗RW⦘ ⊆ eco ∪ (sb \\ rmw) ∪ (sb \\ rmw) ⨾ hb ⨾ (sb \\ rmw).","proof":"unfold restr_eq_rel, Events.same_loc.\nunfolder; ins; desc.\nrename H0 into HB, H2 into SAME_LOC, H into RWx, H1 into RWy.\nhahn_rewrite (wf_hbE WF) in HB; unfolder in *; desc.\nforward (apply eco_almost_total with (x:=x) (y:=y)); eauto.\nby intro; subst; eapply hb_irr; edone.\ndesf.\n- ins; desf; [basic_solver | |].\nby exfalso; eapply COH; basic_solver.\napply ct_begin in HB0.\nunfold seq in HB0; desc.\ndestruct HB0 as [HB0|X]; cycle 1.\nby hahn_rewrite (wf_swD WF) in X; hahn_rewrite (wf_rfD WF) in H; exfalso; type_unfolder; unfolder in *; desf.\napply rtE in HB2.\nunfold eqv_rel, union in HB2; desf.\n-- destruct (classic (rmw x y)).\nby left; left; apply fr_in_eco, rmw_in_fr; auto using coherence_sc_per_loc.\nby left; right; splits; eauto.\n-- apply ct_end in HB2.\nunfold seq in HB2; desc.\ndestruct HB3 as [HB3|X]; cycle 1.\n* exfalso.\napply sw_in_sb_eco_sb in X; auto using coherence_sc_per_loc.\nunfold seq, eqv_rel, clos_refl in X; desf.\n+ apply COH with (x:=x).\nexists z2; splits.\napply ct_begin; basic_solver.\napply eco_transp_rf_rf_in_eco; auto; basic_solver 8.\n+ apply COH with (x:=x).\nexists z2; splits.\napply ct_begin; eexists; splits; try apply rt_end; basic_solver 6.\nby apply eco_transp_rf_rf_in_eco; auto; basic_solver 8.\n+ type_solver.\n+ type_solver.\n* assert (~rmw x z0).\n{\nintro RMW_x_z0.\napply COH with (x:=z0).\nexists y; splits.\napply ct_end; basic_solver 6.\napply rmw_in_fr, fr_in_eco in RMW_x_z0; auto using coherence_sc_per_loc.\napply transp_rf_rf_eco_in_eco; auto; basic_solver 8.\n}\nassert (~rmw z1 y).\n{\nintro RMW_z1_y.\napply COH with (x:=x).\nexists z1; splits.\napply ct_begin; basic_solver 6.\napply rmw_in_fr, fr_in_eco in RMW_z1_y; auto using coherence_sc_per_loc.\napply eco_transp_rf_rf_in_eco; auto; basic_solver 8.\n}\napply rtE in HB2; unfold union, eqv_rel in HB2; desf.\n+ left; right; splits.\neby eapply sb_trans.\nintro RMW_x_y.\nby hahn_rewrite (wf_rmwD WF) in RMW_x_y; hahn_rewrite (wf_rfD WF) in H0; unfolder in *; type_solver.\n+ basic_solver 8.\n- ins; desf; [basic_solver | |].\nby exfalso; eapply COH; basic_solver.\nhahn_rewrite (wf_rfD WF) in H; exfalso; type_unfolder; unfolder in *; desf.\n- ins; desf; [basic_solver | |].\nby exfalso; eapply COH; basic_solver.\nhahn_rewrite (wf_rfD WF) in H0; exfalso; type_unfolder; unfolder in *; desf.\n- ins; desf; [basic_solver | |].\nby exfalso; eapply COH; basic_solver.\nhahn_rewrite (wf_rfD WF) in H; exfalso; type_unfolder; unfolder in *; desf.\n"},{"statement":"Lemma hb_in_sb_swe : hb ⊆ (sb ∪ (sw \\ sb))⁺.","proof":"unfold hb.\nrewrite (ri_union_re G sw) at 1.\napply inclusion_t_t.\nbasic_solver.\n"},{"statement":"Lemma sprop_irr WF COH : irreflexive sprop.","proof":"unfold sprop.\nrewrite sb_in_hb.\narewrite ((hb ⨾ ⦗F⦘)^? ⨾ ⦗Acq ∪₁ W⦘ ⨾ hb ⨾ ⦗Rel⦘ ⊆ hb^? ⨾ hb).\n{\nbasic_solver.\n}\nrewrite cr_hb_hb.\narewrite_id ⦗W⦘.\nrewrite seq_id_l.\napply irreflexive_seqC.\nrewrite crE, seq_union_r, seq_id_r.\napply irreflexive_union.\nsplit.\n{\nby apply hb_irr.\n}\narewrite (rfe ⊆ rf).\nrewrite rf_in_eco.\napply COH.\n"}]