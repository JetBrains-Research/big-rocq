{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/RTL.v","fileSamples":[{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (rs' : val * PTree.tree val) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (H1 : rs' = rs # res <- v) : step (State s f sp pc rs m) E0 (State s f sp pc' rs' m).","conclusion":"step (State s f sp pc rs m) E0 (State s f sp pc' rs' m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (rs' : val * PTree.tree val) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (H1 : rs' = rs # res <- v)","proofString":"subst rs'.\neapply exec_Iop; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) : step (State s f sp pc rs m) E0 (State s f sp pc' rs # res <- v m).","conclusion":"step (State s f sp pc rs m) E0 (State s f sp pc' rs # res <- v m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v)","proofString":"eapply exec_Iop; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (rs' : val * PTree.tree val) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (H2 : rs' = rs # dst <- v) : step (State s f sp pc rs m) E0 (State s f sp pc' rs' m).","conclusion":"step (State s f sp pc rs m) E0 (State s f sp pc' rs' m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (rs' : val * PTree.tree val) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (H2 : rs' = rs # dst <- v)","proofString":"subst rs'.\neapply exec_Iload; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) : step (State s f sp pc rs m) E0 (State s f sp pc' rs # dst <- v m).","conclusion":"step (State s f sp pc rs m) E0 (State s f sp pc' rs # dst <- v m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v)","proofString":"eapply exec_Iload; eauto."},{"statement":"(p : program) : receptive (semantics p).","conclusion":"receptive (semantics p)","hypotheses":"(p : program)","proofString":"constructor; simpl; intros.\nassert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State s0 f sp pc' (regmap_setres res vres2 rs) m2).\neapply exec_Ibuiltin; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate s0 vres2 m2).\neconstructor; eauto.\nred; intros; inv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2)","proofString":"assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State s0 f sp pc' (regmap_setres res vres2 rs) m2).\neapply exec_Ibuiltin; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate s0 vres2 m2).\neconstructor; eauto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) : t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2)","proofString":"intros.\nsubst.\ninv H0.\nexists s1; auto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0)","proofString":"subst.\ninv H0.\nexists s1; auto."},{"statement":"(p : program) (s s1 : state) (t2 : trace) (H0 : match_traces (Genv.globalenv p) E0 t2) (H : step (Genv.globalenv p) s E0 s1) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s s1 : state) (t2 : trace) (H0 : match_traces (Genv.globalenv p) E0 t2) (H : step (Genv.globalenv p) s E0 s1)","proofString":"inv H0.\nexists s1; auto."},{"statement":"(p : program) (s s1 : state) (H : step (Genv.globalenv p) s E0 s1) : exists s2 : state, step (Genv.globalenv p) s nil s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s nil s2","hypotheses":"(p : program) (s s1 : state) (H : step (Genv.globalenv p) s E0 s1)","proofString":"exists s1; auto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2)","proofString":"inversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State s0 f sp pc' (regmap_setres res vres2 rs) m2).\neapply exec_Ibuiltin; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate s0 vres2 m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m') : exists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m')","proofString":"exploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State s0 f sp pc' (regmap_setres res vres2 rs) m2).\neapply exec_Ibuiltin; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m') : (exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2.","conclusion":"(exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m')","proofString":"intros [vres2 [m2 EC2]].\nexists (State s0 f sp pc' (regmap_setres res vres2 rs) m2).\neapply exec_Ibuiltin; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) : exists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2)","proofString":"exists (State s0 f sp pc' (regmap_setres res vres2 rs) m2).\neapply exec_Ibuiltin; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) : step (Genv.globalenv p) (State s0 f sp pc rs m) t2\n  (State s0 f sp pc' (regmap_setres res vres2 rs) m2).","conclusion":"step (Genv.globalenv p) (State s0 f sp pc rs m) t2\n  (State s0 f sp pc' (regmap_setres res vres2 rs) m2)","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : builtin_res reg) (pc' : node) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State s0 f sp pc rs m) t1\n  (State s0 f sp pc' (regmap_setres res vres rs) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state, step (Genv.globalenv p) (State s0 f sp pc rs m) t2 s2) (ef : external_function) (args : list (builtin_arg reg)) (vargs : list val) (H2 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H3 : eval_builtin_args (Genv.globalenv p) (fun r : positive => rs # r) sp m args\n  vargs) (H4 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2)","proofString":"eapply exec_Ibuiltin; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m') : exists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2.","conclusion":"exists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m')","proofString":"exploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate s0 vres2 m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m') : (exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) args m t2 vres2 m2) ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2.","conclusion":"(exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) args m t2 vres2 m2) ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m')","proofString":"intros [vres2 [m2 EC2]].\nexists (Returnstate s0 vres2 m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) args m t2 vres2 m2) : exists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2.","conclusion":"exists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) args m t2 vres2 m2)","proofString":"exists (Returnstate s0 vres2 m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) args m t2 vres2 m2) : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2\n  (Returnstate s0 vres2 m2).","conclusion":"step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2\n  (Returnstate s0 vres2 m2)","hypotheses":"(p : program) (t1 t2 : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (m : mem) (res : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate s0 (External ef) args m) t1\n  (Returnstate s0 res m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate s0 (External ef) args m) t2 s2) (H2 : external_call ef (Genv.globalenv p) args m t1 res m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) args m t2 vres2 m2)","proofString":"econstructor; eauto."},{"statement":"(p : program) : single_events (semantics p).","conclusion":"single_events (semantics p)","hypotheses":"(p : program)","proofString":"red; intros; inv H; simpl; try lia.\neapply external_call_trace_length; eauto.\neapply external_call_trace_length; eauto."},{"statement":"(p : program) (t : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H0 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H1 : eval_builtin_args (globalenv (semantics p)) (fun r : positive => rs # r) sp m\n  args vargs) (H2 : external_call ef (globalenv (semantics p)) vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (s0 : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (vres : val) (m' : mem) (H0 : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H1 : eval_builtin_args (globalenv (semantics p)) (fun r : positive => rs # r) sp m\n  args vargs) (H2 : external_call ef (globalenv (semantics p)) vargs m t vres m')","proofString":"eapply external_call_trace_length; eauto."},{"statement":"(p : program) (t : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (res : val) (m m' : mem) (H0 : external_call ef (globalenv (semantics p)) args m t res m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (t : trace) (s0 : list stackframe) (ef : external_function) (args : list val) (res : val) (m m' : mem) (H0 : external_call ef (globalenv (semantics p)) args m t res m')","proofString":"eapply external_call_trace_length; eauto."},{"statement":"(f : function) (pc : positive) (i : instruction) : (fn_code f) ! pc = Some i -> Ple pc (max_pc_function f).","conclusion":"(fn_code f) ! pc = Some i -> Ple pc (max_pc_function f)","hypotheses":"(f : function) (pc : positive) (i : instruction)","proofString":"unfold max_pc_function.\napply PTree_Properties.fold_rec with (P := fun c m => c!pc = Some i -> Ple pc m).\nintros.\napply H0.\nrewrite H; auto.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\nextlia.\napply Ple_trans with a.\nauto.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) : (fn_code f) ! pc = Some i ->\nPle pc\n  (PTree.fold (fun (m pc0 : positive) (_ : instruction) => Pos.max m pc0)\n     (fn_code f) 1%positive).","conclusion":"(fn_code f) ! pc = Some i ->\nPle pc\n  (PTree.fold (fun (m pc0 : positive) (_ : instruction) => Pos.max m pc0)\n     (fn_code f) 1%positive)","hypotheses":"(f : function) (pc : positive) (i : instruction)","proofString":"apply PTree_Properties.fold_rec with (P := fun c m => c!pc = Some i -> Ple pc m).\nintros.\napply H0.\nrewrite H; auto.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\nextlia.\napply Ple_trans with a.\nauto.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) : forall (m m' : PTree.t instruction) (a : positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! pc = Some i -> Ple pc a) -> m' ! pc = Some i -> Ple pc a.","conclusion":"forall (m m' : PTree.t instruction) (a : positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! pc = Some i -> Ple pc a) -> m' ! pc = Some i -> Ple pc a","hypotheses":"(f : function) (pc : positive) (i : instruction)","proofString":"intros.\napply H0.\nrewrite H; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! pc = Some i -> Ple pc a) (H1 : m' ! pc = Some i) : Ple pc a.","conclusion":"Ple pc a","hypotheses":"(f : function) (pc : positive) (i : instruction) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! pc = Some i -> Ple pc a) (H1 : m' ! pc = Some i)","proofString":"apply H0.\nrewrite H; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! pc = Some i -> Ple pc a) (H1 : m' ! pc = Some i) : m ! pc = Some i.","conclusion":"m ! pc = Some i","hypotheses":"(f : function) (pc : positive) (i : instruction) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! pc = Some i -> Ple pc a) (H1 : m' ! pc = Some i)","proofString":"rewrite H; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) : (PTree.empty instruction) ! pc = Some i -> Ple pc 1.","conclusion":"(PTree.empty instruction) ! pc = Some i -> Ple pc 1","hypotheses":"(f : function) (pc : positive) (i : instruction)","proofString":"rewrite PTree.gempty.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) : None = Some i -> Ple pc 1.","conclusion":"None = Some i -> Ple pc 1","hypotheses":"(f : function) (pc : positive) (i : instruction)","proofString":"congruence."},{"statement":"(f : function) (pc : positive) (i : instruction) : forall (m : PTree.t instruction) (a : positive) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\n(m ! pc = Some i -> Ple pc a) ->\n(PTree.set k v m) ! pc = Some i -> Ple pc (Pos.max a k).","conclusion":"forall (m : PTree.t instruction) (a : positive) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\n(m ! pc = Some i -> Ple pc a) ->\n(PTree.set k v m) ! pc = Some i -> Ple pc (Pos.max a k)","hypotheses":"(f : function) (pc : positive) (i : instruction)","proofString":"intros.\nrewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\nextlia.\napply Ple_trans with a.\nauto.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (H2 : (PTree.set k v m) ! pc = Some i) : Ple pc (Pos.max a k).","conclusion":"Ple pc (Pos.max a k)","hypotheses":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (H2 : (PTree.set k v m) ! pc = Some i)","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq pc k).\ninv H2.\nextlia.\napply Ple_trans with a.\nauto.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (H2 : (if peq pc k then Some v else m ! pc) = Some i) : Ple pc (Pos.max a k).","conclusion":"Ple pc (Pos.max a k)","hypotheses":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (H2 : (if peq pc k then Some v else m ! pc) = Some i)","proofString":"destruct (peq pc k).\ninv H2.\nextlia.\napply Ple_trans with a.\nauto.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (e : pc = k) (H2 : Some v = Some i) : Ple pc (Pos.max a k).","conclusion":"Ple pc (Pos.max a k)","hypotheses":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (e : pc = k) (H2 : Some v = Some i)","proofString":"inv H2.\nextlia."},{"statement":"(f : function) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (H : m ! k = None) (H0 : (fn_code f) ! k = Some i) (H1 : m ! k = Some i -> Ple k a) : Ple k (Pos.max a k).","conclusion":"Ple k (Pos.max a k)","hypotheses":"(f : function) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (H : m ! k = None) (H0 : (fn_code f) ! k = Some i) (H1 : m ! k = Some i -> Ple k a)","proofString":"extlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (n : pc <> k) (H2 : m ! pc = Some i) : Ple pc (Pos.max a k).","conclusion":"Ple pc (Pos.max a k)","hypotheses":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (n : pc <> k) (H2 : m ! pc = Some i)","proofString":"apply Ple_trans with a.\nauto.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (n : pc <> k) (H2 : m ! pc = Some i) : Ple pc a.","conclusion":"Ple pc a","hypotheses":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (n : pc <> k) (H2 : m ! pc = Some i)","proofString":"auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (n : pc <> k) (H2 : m ! pc = Some i) : Ple a (Pos.max a k).","conclusion":"Ple a (Pos.max a k)","hypotheses":"(f : function) (pc : positive) (i : instruction) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : m ! pc = Some i -> Ple pc a) (n : pc <> k) (H2 : m ! pc = Some i)","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) : Ple m (max_reg_instr m pc i).","conclusion":"Ple m (max_reg_instr m pc i)","hypotheses":"(m : positive) (pc : node) (i : instruction)","proofString":"assert (X: forall l n, Ple m n -> Ple m (fold_left Pos.max l n)).\ninduction l; simpl; intros.\nauto.\napply IHl.\nextlia.\ndestruct i; simpl; try (destruct s0); repeat (apply X); try extlia.\ndestruct o; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) : forall (l : list positive) (n : positive),\nPle m n -> Ple m (fold_left Pos.max l n).","conclusion":"forall (l : list positive) (n : positive),\nPle m n -> Ple m (fold_left Pos.max l n)","hypotheses":"(m : positive) (pc : node) (i : instruction)","proofString":"induction l; simpl; intros.\nauto.\napply IHl.\nextlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (n : positive) (H : Ple m n) : Ple m n.","conclusion":"Ple m n","hypotheses":"(m : positive) (pc : node) (i : instruction) (n : positive) (H : Ple m n)","proofString":"auto."},{"statement":"(m : positive) (pc : node) (i : instruction) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple m n0 -> Ple m (fold_left Pos.max l n0)) (n : positive) (H : Ple m n) : Ple m (fold_left Pos.max l (Pos.max n a)).","conclusion":"Ple m (fold_left Pos.max l (Pos.max n a))","hypotheses":"(m : positive) (pc : node) (i : instruction) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple m n0 -> Ple m (fold_left Pos.max l n0)) (n : positive) (H : Ple m n)","proofString":"apply IHl.\nextlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple m n0 -> Ple m (fold_left Pos.max l n0)) (n : positive) (H : Ple m n) : Ple m (Pos.max n a).","conclusion":"Ple m (Pos.max n a)","hypotheses":"(m : positive) (pc : node) (i : instruction) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple m n0 -> Ple m (fold_left Pos.max l n0)) (n : positive) (H : Ple m n)","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (X : forall (l : list positive) (n : positive),\nPle m n -> Ple m (fold_left Pos.max l n)) : Ple m (max_reg_instr m pc i).","conclusion":"Ple m (max_reg_instr m pc i)","hypotheses":"(m : positive) (pc : node) (i : instruction) (X : forall (l : list positive) (n : positive),\nPle m n -> Ple m (fold_left Pos.max l n))","proofString":"destruct i; simpl; try (destruct s0); repeat (apply X); try extlia.\ndestruct o; extlia."},{"statement":"(m : positive) (pc : node) (o : option reg) (X : forall (l : list positive) (n : positive),\nPle m n -> Ple m (fold_left Pos.max l n)) : Ple m match o with\n      | Some arg => Pos.max arg m\n      | None => m\n      end.","conclusion":"Ple m match o with\n      | Some arg => Pos.max arg m\n      | None => m\n      end","hypotheses":"(m : positive) (pc : node) (o : option reg) (X : forall (l : list positive) (n : positive),\nPle m n -> Ple m (fold_left Pos.max l n))","proofString":"destruct o; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) : Ple r (max_reg_instr m pc i).","conclusion":"Ple r (max_reg_instr m pc i)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r)","proofString":"assert (X: forall l n, Ple r n -> Ple r (fold_left Pos.max l n)).\ninduction l; simpl; intros.\nextlia.\napply IHl.\nextlia.\ndestruct i; simpl in *; inv H.\napply X.\nextlia.\napply X.\nextlia.\ndestruct s0; apply X; extlia.\ndestruct b; inv H1.\napply X.\nsimpl.\nextlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) : forall (l : list positive) (n : positive),\nPle r n -> Ple r (fold_left Pos.max l n).","conclusion":"forall (l : list positive) (n : positive),\nPle r n -> Ple r (fold_left Pos.max l n)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r)","proofString":"induction l; simpl; intros.\nextlia.\napply IHl.\nextlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (n : positive) (H0 : Ple r n) : Ple r n.","conclusion":"Ple r n","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (n : positive) (H0 : Ple r n)","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : Ple r n) : Ple r (fold_left Pos.max l (Pos.max n a)).","conclusion":"Ple r (fold_left Pos.max l (Pos.max n a))","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : Ple r n)","proofString":"apply IHl.\nextlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : Ple r n) : Ple r (Pos.max n a).","conclusion":"Ple r (Pos.max n a)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (a : positive) (l : list positive) (IHl : forall n0 : positive, Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : Ple r n)","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (X : forall (l : list positive) (n : positive),\nPle r n -> Ple r (fold_left Pos.max l n)) : Ple r (max_reg_instr m pc i).","conclusion":"Ple r (max_reg_instr m pc i)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : instr_defs i = Some r) (X : forall (l : list positive) (n : positive),\nPle r n -> Ple r (fold_left Pos.max l n))","proofString":"destruct i; simpl in *; inv H.\napply X.\nextlia.\napply X.\nextlia.\ndestruct s0; apply X; extlia.\ndestruct b; inv H1.\napply X.\nsimpl.\nextlia."},{"statement":"(m : positive) (pc : node) (o : operation) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r (fold_left Pos.max l (Pos.max r m)).","conclusion":"Ple r (fold_left Pos.max l (Pos.max r m))","hypotheses":"(m : positive) (pc : node) (o : operation) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"apply X.\nextlia."},{"statement":"(m : positive) (pc : node) (o : operation) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r (Pos.max r m).","conclusion":"Ple r (Pos.max r m)","hypotheses":"(m : positive) (pc : node) (o : operation) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r (fold_left Pos.max l (Pos.max r m)).","conclusion":"Ple r (fold_left Pos.max l (Pos.max r m))","hypotheses":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"apply X.\nextlia."},{"statement":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r (Pos.max r m).","conclusion":"Ple r (Pos.max r m)","hypotheses":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r\n  match s0 with\n  | inl r0 => fold_left Pos.max l (Pos.max r0 (Pos.max r m))\n  | inr _ => fold_left Pos.max l (Pos.max r m)\n  end.","conclusion":"Ple r\n  match s0 with\n  | inl r0 => fold_left Pos.max l (Pos.max r0 (Pos.max r m))\n  | inr _ => fold_left Pos.max l (Pos.max r m)\n  end","hypotheses":"(m : positive) (pc : node) (s : signature) (s0 : reg + ident) (l : list reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"destruct s0; apply X; extlia."},{"statement":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) (H1 : match b with\n| BR r0 => Some r0\n| _ => None\nend = Some r) : Ple r\n  (fold_left Pos.max (params_of_builtin_args l)\n     (fold_left Pos.max (params_of_builtin_res b) m)).","conclusion":"Ple r\n  (fold_left Pos.max (params_of_builtin_args l)\n     (fold_left Pos.max (params_of_builtin_res b) m))","hypotheses":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) (H1 : match b with\n| BR r0 => Some r0\n| _ => None\nend = Some r)","proofString":"destruct b; inv H1.\napply X.\nsimpl.\nextlia."},{"statement":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r\n  (fold_left Pos.max (params_of_builtin_args l)\n     (fold_left Pos.max (params_of_builtin_res (BR r)) m)).","conclusion":"Ple r\n  (fold_left Pos.max (params_of_builtin_args l)\n     (fold_left Pos.max (params_of_builtin_res (BR r)) m))","hypotheses":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"apply X.\nsimpl.\nextlia."},{"statement":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r (fold_left Pos.max (params_of_builtin_res (BR r)) m).","conclusion":"Ple r (fold_left Pos.max (params_of_builtin_res (BR r)) m)","hypotheses":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"simpl.\nextlia."},{"statement":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0)) : Ple r (Pos.max m r).","conclusion":"Ple r (Pos.max m r)","hypotheses":"(m : positive) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (n : node) (r : reg) (X : forall (l0 : list positive) (n0 : positive),\nPle r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) : Ple r (max_reg_instr m pc i).","conclusion":"Ple r (max_reg_instr m pc i)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i))","proofString":"assert (X: forall l n, In r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\ndestruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia.\ndestruct i; simpl in *; try (destruct s0); try (apply X; auto).\ncontradiction.\ndestruct H.\nright; subst; extlia.\nauto.\ndestruct H.\nright; subst; extlia.\nauto.\ndestruct H.\nright; subst; extlia.\nauto.\nintuition.\nsubst; extlia.\ndestruct o; simpl in H; intuition.\nsubst; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n).","conclusion":"forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i))","proofString":"induction l; simpl; intros.\ntauto.\napply IHl.\ndestruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (n : positive) (H0 : False \\/ Ple r n) : Ple r n.","conclusion":"Ple r n","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (n : positive) (H0 : False \\/ Ple r n)","proofString":"tauto."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n) : Ple r (fold_left Pos.max l (Pos.max n a)).","conclusion":"Ple r (fold_left Pos.max l (Pos.max n a))","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n)","proofString":"apply IHl.\ndestruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n)","proofString":"destruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : a = r) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : a = r)","proofString":"right; subst; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : In r l) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : In r l)","proofString":"auto."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : Ple r n) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : Ple r n)","proofString":"right; extlia."},{"statement":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) : Ple r (max_reg_instr m pc i).","conclusion":"Ple r (max_reg_instr m pc i)","hypotheses":"(m : positive) (pc : node) (i : instruction) (r : reg) (H : In r (instr_uses i)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n))","proofString":"destruct i; simpl in *; try (destruct s0); try (apply X; auto).\ncontradiction.\ndestruct H.\nright; subst; extlia.\nauto.\ndestruct H.\nright; subst; extlia.\nauto.\ndestruct H.\nright; subst; extlia.\nauto.\nintuition.\nsubst; extlia.\ndestruct o; simpl in H; intuition.\nsubst; extlia."},{"statement":"(m : positive) (pc n : node) (r : reg) (H : False) (X : forall (l : list reg) (n0 : positive),\nIn r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) : Ple r m.","conclusion":"Ple r m","hypotheses":"(m : positive) (pc n : node) (r : reg) (H : False) (X : forall (l : list reg) (n0 : positive),\nIn r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0))","proofString":"contradiction."},{"statement":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : r0 = r \\/ In r l) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0)) : In r l \\/ Ple r (Pos.max r0 m).","conclusion":"In r l \\/ Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : r0 = r \\/ In r l) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"destruct H.\nright; subst; extlia.\nauto."},{"statement":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : r0 = r) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0)) : In r l \\/ Ple r (Pos.max r0 m).","conclusion":"In r l \\/ Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : r0 = r) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"right; subst; extlia."},{"statement":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : In r l) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0)) : In r l \\/ Ple r (Pos.max r0 m).","conclusion":"In r l \\/ Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (m0 : memory_chunk) (a : addressing) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : In r l) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"auto."},{"statement":"(m : positive) (pc : node) (s : signature) (r1 : reg) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : In r (r1 :: l)) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0)) : In r l \\/ Ple r (Pos.max r1 (Pos.max r0 m)).","conclusion":"In r l \\/ Ple r (Pos.max r1 (Pos.max r0 m))","hypotheses":"(m : positive) (pc : node) (s : signature) (r1 : reg) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : In r (r1 :: l)) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"destruct H.\nright; subst; extlia.\nauto."},{"statement":"(m : positive) (pc : node) (s : signature) (r1 : reg) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : r1 = r) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0)) : In r l \\/ Ple r (Pos.max r1 (Pos.max r0 m)).","conclusion":"In r l \\/ Ple r (Pos.max r1 (Pos.max r0 m))","hypotheses":"(m : positive) (pc : node) (s : signature) (r1 : reg) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : r1 = r) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"right; subst; extlia."},{"statement":"(m : positive) (pc : node) (s : signature) (r1 : reg) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : In r l) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0)) : In r l \\/ Ple r (Pos.max r1 (Pos.max r0 m)).","conclusion":"In r l \\/ Ple r (Pos.max r1 (Pos.max r0 m))","hypotheses":"(m : positive) (pc : node) (s : signature) (r1 : reg) (l : list reg) (r0 : reg) (n : node) (r : reg) (H : In r l) (X : forall (l0 : list reg) (n0 : positive),\nIn r l0 \\/ Ple r n0 -> Ple r (fold_left Pos.max l0 n0))","proofString":"auto."},{"statement":"(m : positive) (pc : node) (s : signature) (r0 : reg) (l : list reg) (r : reg) (H : In r (r0 :: l)) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n)) : In r l \\/ Ple r (Pos.max r0 m).","conclusion":"In r l \\/ Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (s : signature) (r0 : reg) (l : list reg) (r : reg) (H : In r (r0 :: l)) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n))","proofString":"destruct H.\nright; subst; extlia.\nauto."},{"statement":"(m : positive) (pc : node) (s : signature) (r0 : reg) (l : list reg) (r : reg) (H : r0 = r) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n)) : In r l \\/ Ple r (Pos.max r0 m).","conclusion":"In r l \\/ Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (s : signature) (r0 : reg) (l : list reg) (r : reg) (H : r0 = r) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n))","proofString":"right; subst; extlia."},{"statement":"(m : positive) (pc : node) (s : signature) (r0 : reg) (l : list reg) (r : reg) (H : In r l) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n)) : In r l \\/ Ple r (Pos.max r0 m).","conclusion":"In r l \\/ Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (s : signature) (r0 : reg) (l : list reg) (r : reg) (H : In r l) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n))","proofString":"auto."},{"statement":"(m : positive) (pc : node) (r0 : reg) (l : list node) (r : reg) (H : r0 = r \\/ False) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n)) : Ple r (Pos.max r0 m).","conclusion":"Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (r0 : reg) (l : list node) (r : reg) (H : r0 = r \\/ False) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n))","proofString":"intuition.\nsubst; extlia."},{"statement":"(m : positive) (pc : node) (r0 : reg) (l : list node) (r : reg) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n)) (H0 : r0 = r) : Ple r (Pos.max r0 m).","conclusion":"Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (r0 : reg) (l : list node) (r : reg) (X : forall (l0 : list reg) (n : positive),\nIn r l0 \\/ Ple r n -> Ple r (fold_left Pos.max l0 n)) (H0 : r0 = r)","proofString":"subst; extlia."},{"statement":"(m : positive) (pc : node) (o : option reg) (r : reg) (H : In r match o with\n     | Some arg => arg :: nil\n     | None => nil\n     end) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) : Ple r match o with\n      | Some arg => Pos.max arg m\n      | None => m\n      end.","conclusion":"Ple r match o with\n      | Some arg => Pos.max arg m\n      | None => m\n      end","hypotheses":"(m : positive) (pc : node) (o : option reg) (r : reg) (H : In r match o with\n     | Some arg => arg :: nil\n     | None => nil\n     end) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n))","proofString":"destruct o; simpl in H; intuition.\nsubst; extlia."},{"statement":"(m : positive) (pc : node) (r0 r : reg) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) (H0 : r0 = r) : Ple r (Pos.max r0 m).","conclusion":"Ple r (Pos.max r0 m)","hypotheses":"(m : positive) (pc : node) (r0 r : reg) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) (H0 : r0 = r)","proofString":"subst; extlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r)","proofString":"assert (Ple r (PTree.fold max_reg_instr f.(fn_code) 1%positive)).\nrevert H.\napply PTree_Properties.fold_rec with       (P := fun c m => c!pc = Some i -> Ple r m).\nintros.\nrewrite H in H1; auto.\nrewrite PTree.gempty; congruence.\nintros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_def; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge.\nunfold max_reg_function.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r) : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive).","conclusion":"Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r)","proofString":"revert H.\napply PTree_Properties.fold_rec with       (P := fun c m => c!pc = Some i -> Ple r m).\nintros.\nrewrite H in H1; auto.\nrewrite PTree.gempty; congruence.\nintros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_def; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) : (fn_code f) ! pc = Some i ->\nPle r (PTree.fold max_reg_instr (fn_code f) 1%positive).","conclusion":"(fn_code f) ! pc = Some i ->\nPle r (PTree.fold max_reg_instr (fn_code f) 1%positive)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r)","proofString":"apply PTree_Properties.fold_rec with       (P := fun c m => c!pc = Some i -> Ple r m).\nintros.\nrewrite H in H1; auto.\nrewrite PTree.gempty; congruence.\nintros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_def; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) : forall (m m' : PTree.t instruction) (a : positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! pc = Some i -> Ple r a) -> m' ! pc = Some i -> Ple r a.","conclusion":"forall (m m' : PTree.t instruction) (a : positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! pc = Some i -> Ple r a) -> m' ! pc = Some i -> Ple r a","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r)","proofString":"intros.\nrewrite H in H1; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H1 : m ! pc = Some i -> Ple r a) (H2 : m' ! pc = Some i) : Ple r a.","conclusion":"Ple r a","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H1 : m ! pc = Some i -> Ple r a) (H2 : m' ! pc = Some i)","proofString":"rewrite H in H1; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) : (PTree.empty instruction) ! pc = Some i -> Ple r 1.","conclusion":"(PTree.empty instruction) ! pc = Some i -> Ple r 1","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r)","proofString":"rewrite PTree.gempty; congruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) : forall (m : PTree.t instruction) (a : positive) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\n(m ! pc = Some i -> Ple r a) ->\n(PTree.set k v m) ! pc = Some i -> Ple r (max_reg_instr a k v).","conclusion":"forall (m : PTree.t instruction) (a : positive) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\n(m ! pc = Some i -> Ple r a) ->\n(PTree.set k v m) ! pc = Some i -> Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r)","proofString":"intros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_def; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (PTree.set k v m) ! pc = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (PTree.set k v m) ! pc = Some i)","proofString":"rewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_def; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (if peq pc k then Some v else m ! pc) = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (if peq pc k then Some v else m ! pc) = Some i)","proofString":"destruct (peq pc k).\ninv H3.\neapply max_reg_instr_def; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (e : pc = k) (H3 : Some v = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (e : pc = k) (H3 : Some v = Some i)","proofString":"inv H3.\neapply max_reg_instr_def; eauto."},{"statement":"(f : function) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (H : m ! k = None) (H1 : (fn_code f) ! k = Some i) (H2 : m ! k = Some i -> Ple r a) : Ple r (max_reg_instr a k i).","conclusion":"Ple r (max_reg_instr a k i)","hypotheses":"(f : function) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (H : m ! k = None) (H1 : (fn_code f) ! k = Some i) (H2 : m ! k = Some i -> Ple r a)","proofString":"eapply max_reg_instr_def; eauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i)","proofString":"apply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i) : Ple r a.","conclusion":"Ple r a","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i)","proofString":"auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i) : Ple a (max_reg_instr a k v).","conclusion":"Ple a (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : instr_defs i = Some r) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i)","proofString":"apply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive))","proofString":"unfold max_reg_function.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive)) : Ple r\n  (Pos.max (PTree.fold max_reg_instr (fn_code f) 1%positive)\n     (fold_left Pos.max (fn_params f) 1%positive)).","conclusion":"Ple r\n  (Pos.max (PTree.fold max_reg_instr (fn_code f) 1%positive)\n     (fold_left Pos.max (fn_params f) 1%positive))","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : instr_defs i = Some r) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive))","proofString":"extlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i))","proofString":"assert (Ple r (PTree.fold max_reg_instr f.(fn_code) 1%positive)).\nrevert H.\napply PTree_Properties.fold_rec with       (P := fun c m => c!pc = Some i -> Ple r m).\nintros.\nrewrite H in H1; auto.\nrewrite PTree.gempty; congruence.\nintros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_uses; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge.\nunfold max_reg_function.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i)) : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive).","conclusion":"Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i))","proofString":"revert H.\napply PTree_Properties.fold_rec with       (P := fun c m => c!pc = Some i -> Ple r m).\nintros.\nrewrite H in H1; auto.\nrewrite PTree.gempty; congruence.\nintros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_uses; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) : (fn_code f) ! pc = Some i ->\nPle r (PTree.fold max_reg_instr (fn_code f) 1%positive).","conclusion":"(fn_code f) ! pc = Some i ->\nPle r (PTree.fold max_reg_instr (fn_code f) 1%positive)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i))","proofString":"apply PTree_Properties.fold_rec with       (P := fun c m => c!pc = Some i -> Ple r m).\nintros.\nrewrite H in H1; auto.\nrewrite PTree.gempty; congruence.\nintros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_uses; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) : forall (m m' : PTree.t instruction) (a : positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! pc = Some i -> Ple r a) -> m' ! pc = Some i -> Ple r a.","conclusion":"forall (m m' : PTree.t instruction) (a : positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! pc = Some i -> Ple r a) -> m' ! pc = Some i -> Ple r a","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i))","proofString":"intros.\nrewrite H in H1; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H1 : m ! pc = Some i -> Ple r a) (H2 : m' ! pc = Some i) : Ple r a.","conclusion":"Ple r a","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m m' : PTree.t instruction) (a : positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H1 : m ! pc = Some i -> Ple r a) (H2 : m' ! pc = Some i)","proofString":"rewrite H in H1; auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) : (PTree.empty instruction) ! pc = Some i -> Ple r 1.","conclusion":"(PTree.empty instruction) ! pc = Some i -> Ple r 1","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i))","proofString":"rewrite PTree.gempty; congruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) : forall (m : PTree.t instruction) (a : positive) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\n(m ! pc = Some i -> Ple r a) ->\n(PTree.set k v m) ! pc = Some i -> Ple r (max_reg_instr a k v).","conclusion":"forall (m : PTree.t instruction) (a : positive) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\n(m ! pc = Some i -> Ple r a) ->\n(PTree.set k v m) ! pc = Some i -> Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i))","proofString":"intros.\nrewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_uses; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (PTree.set k v m) ! pc = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (PTree.set k v m) ! pc = Some i)","proofString":"rewrite PTree.gsspec in H3.\ndestruct (peq pc k).\ninv H3.\neapply max_reg_instr_uses; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (if peq pc k then Some v else m ! pc) = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (H3 : (if peq pc k then Some v else m ! pc) = Some i)","proofString":"destruct (peq pc k).\ninv H3.\neapply max_reg_instr_uses; eauto.\napply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (e : pc = k) (H3 : Some v = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (e : pc = k) (H3 : Some v = Some i)","proofString":"inv H3.\neapply max_reg_instr_uses; eauto."},{"statement":"(f : function) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (H : m ! k = None) (H1 : (fn_code f) ! k = Some i) (H2 : m ! k = Some i -> Ple r a) : Ple r (max_reg_instr a k i).","conclusion":"Ple r (max_reg_instr a k i)","hypotheses":"(f : function) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (H : m ! k = None) (H1 : (fn_code f) ! k = Some i) (H2 : m ! k = Some i -> Ple r a)","proofString":"eapply max_reg_instr_uses; eauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i) : Ple r (max_reg_instr a k v).","conclusion":"Ple r (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i)","proofString":"apply Ple_trans with a.\nauto.\napply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i) : Ple r a.","conclusion":"Ple r a","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i)","proofString":"auto."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i) : Ple a (max_reg_instr a k v).","conclusion":"Ple a (max_reg_instr a k v)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H0 : In r (instr_uses i)) (m : PTree.t instruction) (a : positive) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H1 : (fn_code f) ! k = Some v) (H2 : m ! pc = Some i -> Ple r a) (n : pc <> k) (H3 : m ! pc = Some i)","proofString":"apply max_reg_instr_ge."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i)) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i)) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive))","proofString":"unfold max_reg_function.\nextlia."},{"statement":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i)) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive)) : Ple r\n  (Pos.max (PTree.fold max_reg_instr (fn_code f) 1%positive)\n     (fold_left Pos.max (fn_params f) 1%positive)).","conclusion":"Ple r\n  (Pos.max (PTree.fold max_reg_instr (fn_code f) 1%positive)\n     (fold_left Pos.max (fn_params f) 1%positive))","hypotheses":"(f : function) (pc : positive) (i : instruction) (r : reg) (H : (fn_code f) ! pc = Some i) (H0 : In r (instr_uses i)) (H1 : Ple r (PTree.fold max_reg_instr (fn_code f) 1%positive))","proofString":"extlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f))","proofString":"assert (X: forall l n, In r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\ndestruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia.\nassert (Y: Ple r (fold_left Pos.max f.(fn_params) 1%positive)).\napply X; auto.\nunfold max_reg_function.\nextlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n).","conclusion":"forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f))","proofString":"induction l; simpl; intros.\ntauto.\napply IHl.\ndestruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (n : positive) (H0 : False \\/ Ple r n) : Ple r n.","conclusion":"Ple r n","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (n : positive) (H0 : False \\/ Ple r n)","proofString":"tauto."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n) : Ple r (fold_left Pos.max l (Pos.max n a)).","conclusion":"Ple r (fold_left Pos.max l (Pos.max n a))","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n)","proofString":"apply IHl.\ndestruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (H0 : (a = r \\/ In r l) \\/ Ple r n)","proofString":"destruct H0 as [[A|A]|A].\nright; subst; extlia.\nauto.\nright; extlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : a = r) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : a = r)","proofString":"right; subst; extlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : In r l) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : In r l)","proofString":"auto."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : Ple r n) : In r l \\/ Ple r (Pos.max n a).","conclusion":"In r l \\/ Ple r (Pos.max n a)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (a : reg) (l : list reg) (IHl : forall n0 : positive, In r l \\/ Ple r n0 -> Ple r (fold_left Pos.max l n0)) (n : positive) (A : Ple r n)","proofString":"right; extlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n))","proofString":"assert (Y: Ple r (fold_left Pos.max f.(fn_params) 1%positive)).\napply X; auto.\nunfold max_reg_function.\nextlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) : Ple r (fold_left Pos.max (fn_params f) 1%positive).","conclusion":"Ple r (fold_left Pos.max (fn_params f) 1%positive)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n))","proofString":"apply X; auto."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) (Y : Ple r (fold_left Pos.max (fn_params f) 1%positive)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) (Y : Ple r (fold_left Pos.max (fn_params f) 1%positive))","proofString":"unfold max_reg_function.\nextlia."},{"statement":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) (Y : Ple r (fold_left Pos.max (fn_params f) 1%positive)) : Ple r\n  (Pos.max (PTree.fold max_reg_instr (fn_code f) 1%positive)\n     (fold_left Pos.max (fn_params f) 1%positive)).","conclusion":"Ple r\n  (Pos.max (PTree.fold max_reg_instr (fn_code f) 1%positive)\n     (fold_left Pos.max (fn_params f) 1%positive))","hypotheses":"(f : function) (r : reg) (H : In r (fn_params f)) (X : forall (l : list reg) (n : positive),\nIn r l \\/ Ple r n -> Ple r (fold_left Pos.max l n)) (Y : Ple r (fold_left Pos.max (fn_params f) 1%positive))","proofString":"extlia."},{"statement":"(cu prog : AST.program fundef unit) (ros : reg + ident) (bf : builtin_function) (rs : regset) (fd : fundef) (H : match ros with\n| inl _ => None\n| inr id =>\n    match (prog_defmap cu) ! id with\n    | Some (Gfun (External (EF_runtime name sg))) =>\n        lookup_builtin_function name sg\n    | _ => None\n    end\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) ros rs = Some fd) : exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf.","conclusion":"exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (ros : reg + ident) (bf : builtin_function) (rs : regset) (fd : fundef) (H : match ros with\n| inl _ => None\n| inr id =>\n    match (prog_defmap cu) ! id with\n    | Some (Gfun (External (EF_runtime name sg))) =>\n        lookup_builtin_function name sg\n    | _ => None\n    end\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) ros rs = Some fd)","proofString":"destruct ros as [r|id]; try discriminate.\ndestruct (prog_defmap cu)!id as [gd|] eqn:D; try discriminate.\ndestruct gd as [f|v]; try discriminate.\ndestruct f as [f|ef]; try discriminate.\ndestruct ef; try discriminate.\nexploit (prog_defmap_linkorder cu prog); eauto.\nintros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (H : match (prog_defmap cu) ! id with\n| Some (Gfun (External (EF_runtime name sg))) =>\n    lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) : exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf.","conclusion":"exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (H : match (prog_defmap cu) ! id with\n| Some (Gfun (External (EF_runtime name sg))) =>\n    lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd)","proofString":"destruct (prog_defmap cu)!id as [gd|] eqn:D; try discriminate.\ndestruct gd as [f|v]; try discriminate.\ndestruct f as [f|ef]; try discriminate.\ndestruct ef; try discriminate.\nexploit (prog_defmap_linkorder cu prog); eauto.\nintros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (gd : globdef fundef unit) (D : (prog_defmap cu) ! id = Some gd) (H : match gd with\n| Gfun (External (EF_runtime name sg)) => lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) : exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf.","conclusion":"exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (gd : globdef fundef unit) (D : (prog_defmap cu) ! id = Some gd) (H : match gd with\n| Gfun (External (EF_runtime name sg)) => lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd)","proofString":"destruct gd as [f|v]; try discriminate.\ndestruct f as [f|ef]; try discriminate.\ndestruct ef; try discriminate.\nexploit (prog_defmap_linkorder cu prog); eauto.\nintros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd f : fundef) (D : (prog_defmap cu) ! id = Some (Gfun f)) (H : match f with\n| External (EF_runtime name sg) => lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) : exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf.","conclusion":"exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd f : fundef) (D : (prog_defmap cu) ! id = Some (Gfun f)) (H : match f with\n| External (EF_runtime name sg) => lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd)","proofString":"destruct f as [f|ef]; try discriminate.\ndestruct ef; try discriminate.\nexploit (prog_defmap_linkorder cu prog); eauto.\nintros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (ef : external_function) (D : (prog_defmap cu) ! id = Some (Gfun (External ef))) (H : match ef with\n| EF_runtime name sg => lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) : exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf.","conclusion":"exists (name : string) (sg : signature),\n  fd = External (EF_runtime name sg) /\\\n  lookup_builtin_function name sg = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (ef : external_function) (D : (prog_defmap cu) ! id = Some (Gfun (External ef))) (H : match ef with\n| EF_runtime name sg => lookup_builtin_function name sg\n| _ => None\nend = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd)","proofString":"destruct ef; try discriminate.\nexploit (prog_defmap_linkorder cu prog); eauto.\nintros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd)","proofString":"exploit (prog_defmap_linkorder cu prog); eauto.\nintros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) : (exists gd2 : globdef fundef unit,\n   (prog_defmap prog) ! id = Some gd2 /\\\n   linkorder (Gfun (External (EF_runtime name sg))) gd2) ->\nexists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"(exists gd2 : globdef fundef unit,\n   (prog_defmap prog) ! id = Some gd2 /\\\n   linkorder (Gfun (External (EF_runtime name sg))) gd2) ->\nexists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd)","proofString":"intros (gd & D2 & LD).\ninv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (gd : globdef fundef unit) (D2 : (prog_defmap prog) ! id = Some gd) (LD : linkorder (Gfun (External (EF_runtime name sg))) gd) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (gd : globdef fundef unit) (D2 : (prog_defmap prog) ! id = Some gd) (LD : linkorder (Gfun (External (EF_runtime name sg))) gd)","proofString":"inv LD.\ninv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (fd2 : fundef) (D2 : (prog_defmap prog) ! id = Some (Gfun fd2)) (H3 : linkorder (External (EF_runtime name sg)) fd2) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (fd2 : fundef) (D2 : (prog_defmap prog) ! id = Some (Gfun fd2)) (H3 : linkorder (External (EF_runtime name sg)) fd2)","proofString":"inv H3.\napply Genv.find_def_symbol in D2.\nfold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (D2 : exists b : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b /\\\n  Genv.find_def (Genv.globalenv prog) b =\n  Some (Gfun (External (EF_runtime name sg)))) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (D2 : exists b : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b /\\\n  Genv.find_def (Genv.globalenv prog) b =\n  Some (Gfun (External (EF_runtime name sg))))","proofString":"fold ge in D2.\ndestruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (D2 : exists b : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b /\\\n  Genv.find_def (Genv.globalenv prog) b =\n  Some (Gfun (External (EF_runtime name sg)))) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (D2 : exists b : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b /\\\n  Genv.find_def (Genv.globalenv prog) b =\n  Some (Gfun (External (EF_runtime name sg))))","proofString":"destruct D2 as (b & F1 & F2).\nsimpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (b : block) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg)))) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : find_function (Genv.globalenv prog) (inr id) rs = Some fd) (b : block) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg))))","proofString":"simpl in H1.\nrewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : match Genv.find_symbol (Genv.globalenv prog) id with\n| Some b0 => Genv.find_funct_ptr (Genv.globalenv prog) b0\n| None => None\nend = Some fd) (b : block) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg)))) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (H1 : match Genv.find_symbol (Genv.globalenv prog) id with\n| Some b0 => Genv.find_funct_ptr (Genv.globalenv prog) b0\n| None => None\nend = Some fd) (b : block) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg))))","proofString":"rewrite F1 in H1.\napply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (b : block) (H1 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some fd) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg)))) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (b : block) (H1 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some fd) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg))))","proofString":"apply Genv.find_funct_ptr_iff in H1.\nexists name, sg; intuition congruence."},{"statement":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (b : block) (H1 : Genv.find_def (Genv.globalenv prog) b = Some (Gfun fd)) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg)))) : exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf.","conclusion":"exists (name0 : string) (sg0 : signature),\n  fd = External (EF_runtime name0 sg0) /\\\n  lookup_builtin_function name0 sg0 = Some bf","hypotheses":"(cu prog : AST.program fundef unit) (id : ident) (bf : builtin_function) (rs : regset) (fd : fundef) (name : string) (sg : signature) (D : (prog_defmap cu) ! id = Some (Gfun (External (EF_runtime name sg)))) (H : lookup_builtin_function name sg = Some bf) (H0 : linkorder cu prog) (b : block) (H1 : Genv.find_def (Genv.globalenv prog) b = Some (Gfun fd)) (F1 : Genv.find_symbol (Genv.globalenv prog) id = Some b) (F2 : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg))))","proofString":"exists name, sg; intuition congruence."}]}