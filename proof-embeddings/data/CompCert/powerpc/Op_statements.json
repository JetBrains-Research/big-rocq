{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/powerpc/Op.v","fileSamples":[{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"assert (forall (x y: comparison), {x=y}+{x<>y}).\ndecide equality.\ndecide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}.","proofString":"decide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : addressing) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) ->\n(forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) ->\n(forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (ofs : ptrofs) : eval_addressing genv sp (Ainstack ofs) nil = Some (Val.offset_ptr sp ofs).","proofString":"reflexivity."},{"statement":"(sp v : val) (m : mem) (H : Omove <> Omove) : Val.has_type v Tint.","proofString":"congruence."},{"statement":"(i : int) (sp : val) (m : mem) (H : Ointconst i <> Omove) : True.","proofString":"exact I."},{"statement":"(f : float) (sp : val) (m : mem) (H : Ofloatconst f <> Omove) : True.","proofString":"auto."},{"statement":"(f : float32) (sp : val) (m : mem) (H : Osingleconst f <> Omove) : True.","proofString":"auto."},{"statement":"(A : Type) (op : operation) (args : list A) (a : A) : is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil.","proofString":"unfold is_move_operation; destruct op;  try (intros; discriminate).\ndestruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (args : list A) (a : A) : match args with\n| nil => None\n| arg :: nil => Some arg\n| arg :: _ :: _ => None\nend = Some a -> Omove = Omove /\\ args = a :: nil.","proofString":"destruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a : A) : None = Some a -> Omove = Omove /\\ nil = a :: nil.","proofString":"intros; discriminate."},{"statement":"(A : Type) (a0 : A) (args : list A) (a : A) : match args with\n| nil => Some a0\n| _ :: _ => None\nend = Some a -> Omove = Omove /\\ a0 :: args = a :: nil.","proofString":"destruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a0 a : A) : Some a0 = Some a -> Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intros.\nintuition congruence."},{"statement":"(A : Type) (a0 a : A) (H : Some a0 = Some a) : Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intuition congruence."},{"statement":"(A : Type) (a0 a1 : A) (args : list A) (a : A) : None = Some a -> Omove = Omove /\\ a0 :: a1 :: args = a :: nil.","proofString":"intros; discriminate."},{"statement":"(cond : condition) (vl : list val) (m : mem) : eval_condition (negate_condition cond) vl m =\noption_map negb (eval_condition cond vl m).","proofString":"destruct cond; simpl.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0); auto.\ndestruct b; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.maskzero_bool v i) as [[]|]; auto.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmp_bool c v v0).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (i : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool (negate_comparison c) v1 (Vint i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool c v1 (Vint i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (i : int) (v : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (Vint i) =\noption_map negb (Val.cmp_bool c v (Vint i)).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (i : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vint i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (i : int) (v : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vint i) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (Vint i)).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpf_bool c v v0 =\noption_map negb (option_map negb (Val.cmpf_bool c v v0)).","proofString":"destruct (Val.cmpf_bool c v v0); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) (b : bool) : Some b = option_map negb (option_map negb (Some b)).","proofString":"destruct b; auto."},{"statement":"(i : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => option_map negb (Val.maskzero_bool v1 i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.maskzero_bool v1 i\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(i : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.maskzero_bool v1 i\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => option_map negb (Val.maskzero_bool v1 i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.maskzero_bool v i) as [[]|]; auto."},{"statement":"(i : int) (v : val) (m : mem) : Val.maskzero_bool v i =\noption_map negb (option_map negb (Val.maskzero_bool v i)).","proofString":"destruct (Val.maskzero_bool v i) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpl_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpl_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmpl_bool c v v0).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (i : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool (negate_comparison c) v1 (Vlong i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool c v1 (Vlong i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (i : int64) (v : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v (Vlong i) =\noption_map negb (Val.cmpl_bool c v (Vlong i)).","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (i : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vlong i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (i : int64) (v : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vlong i) =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v (Vlong i)).","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(delta : Z) (addr : addressing) : type_of_addressing (shift_stack_addressing delta addr) =\ntype_of_addressing addr.","proofString":"destruct addr; auto."},{"statement":"(delta : Z) (op : operation) : type_of_operation (shift_stack_operation delta op) = type_of_operation op.","proofString":"destruct op; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing ge (Vptr sp Ptrofs.zero) (shift_stack_addressing delta addr)\n  vl = eval_addressing ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"destruct addr; simpl; auto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (vl : list val) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add (Ptrofs.repr delta) i)))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))\n| _ :: _ => None\nend.","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (op : operation) (vl : list val) (m : mem) (delta : Z) : eval_operation ge (Vptr sp Ptrofs.zero) (shift_stack_operation delta op) vl m =\neval_operation ge (Vptr sp (Ptrofs.repr delta)) op vl m.","proofString":"destruct op; simpl; auto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (vl : list val) (m : mem) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add (Ptrofs.repr delta) i)))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))\n| _ :: _ => None\nend.","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : int) (v0 : val) (delta : Z) : Some (Val.add v0 (Vint (Int.add i (Int.repr delta)))) =\nSome (Val.add (Val.add v0 (Vint i)) (Vint (Int.repr delta))).","proofString":"rewrite Val.add_assoc; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (v0 : val) (delta : Z) (b : block) : Some (Val.add v0 (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta)))) =\nSome\n  (Val.add v0\n     (if Archi.ptr64\n      then Vundef\n      else Vptr b (Ptrofs.add i0 (Ptrofs.of_int (Int.repr delta))))).","proofString":"auto."},{"statement":"(s : ident) (ofs : ptrofs) : match Genv.find_symbol ge2 s with\n| Some b => Vptr b ofs\n| None => Vundef\nend =\nmatch Genv.find_symbol ge1 s with\n| Some b => Vptr b ofs\n| None => Vundef\nend.","proofString":"rewrite agree_on_symbols; auto."},{"statement":"(sp : val) (op : operation) (vl : list val) (m : mem) : eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.","proofString":"destruct op; simpl; auto; rewrite symbol_address_preserved; auto."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.","proofString":"destruct addr; simpl; auto; rewrite symbol_address_preserved; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (i : int) (v : val) (b : bool) (H0 : Val.cmp_bool c v (Vint i) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool c v' (Vint i) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (i : int) (v : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (Vint i) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpu_bool (Mem.valid_pointer m2) c v' (Vint i) = Some b.","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpf_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpf_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpf_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(i : int) (v : val) (b : bool) (H0 : Val.maskzero_bool v i = Some b) (v' : val) (H3 : Val.inject f v v') : Val.maskzero_bool v' i = Some b.","proofString":"inv H3; try discriminate; auto."},{"statement":"(i : int) (v : val) (b : bool) (H0 : option_map negb (Val.maskzero_bool v i) = Some b) (v' : val) (H3 : Val.inject f v v') : option_map negb (Val.maskzero_bool v' i) = Some b.","proofString":"inv H3; try discriminate; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpl_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpl_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddrsymbol i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0).","proofString":"apply GL; simpl; auto."},{"statement":"(i : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddrstack i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 i) (Val.offset_ptr sp2 i).","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast8signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 8 v) (Val.sign_ext 8 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast16signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 16 v) (Val.sign_ext 16 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oadd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.add v v0) (Val.add v' v'0).","proofString":"apply Val.add_inject; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.add v (Vint i)) (Val.add v' (Vint i)).","proofString":"apply Val.add_inject; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddsymbol i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.add (Genv.symbol_address ge1 i i0) v)\n  (Val.add (Genv.symbol_address ge2 i i0) v').","proofString":"apply Val.add_inject; auto.\napply GL; simpl; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddsymbol i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0).","proofString":"apply GL; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v v0) (Val.sub v' v'0).","proofString":"apply Val.sub_inject; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osubimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f match v with\n             | Vint n2 => Vint (Int.sub i n2)\n             | _ => Vundef\n             end\n  match v' with\n  | Vint n2 => Vint (Int.sub i n2)\n  | _ => Vundef\n  end.","proofString":"inv H4; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omul) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mul v v0) (Val.mul v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Omulimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.mul v (Vint i)) (Val.mul v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhs v v0) (Val.mulhs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhu v v0) (Val.mulhu v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divs v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divs v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero         || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val, Val.divs (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero         || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero         || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divs i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divs i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val, Val.divu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v v0) (Val.and v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.and v (Vint i)) (Val.and v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v v0) (Val.or v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.or v (Vint i)) (Val.or v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v v0) (Val.xor v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xor v (Vint i)) (Val.xor v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onot) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notint v) (Val.notint v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.notint (Val.and v v0)) (Val.notint (Val.and v' v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.notint (Val.or v v0)) (Val.notint (Val.or v' v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.notint (Val.xor v v0)) (Val.notint (Val.xor v' v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oandc) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (Val.notint v0)) (Val.and v' (Val.notint v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oorc) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v (Val.notint v0)) (Val.or v' (Val.notint v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shl v v0) (Val.shl v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shr v v0) (Val.shr v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shr v (Vint i)) (Val.shr v' (Vint i)).","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu i Int.iwordsize); auto."},{"statement":"(i : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i0 : int) : Val.inject f\n  (if Int.ltu i Int.iwordsize then Vint (Int.shr i0 i) else Vundef)\n  (if Int.ltu i Int.iwordsize then Vint (Int.shr i0 i) else Vundef).","proofString":"destruct (Int.ltu i Int.iwordsize); auto."},{"statement":"(i : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrx v (Vint i) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrx v' (Vint i) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in *; inv H1.\ndestruct (Int.ltu i (Int.repr 31)); inv H2.\neconstructor; eauto."},{"statement":"(i : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nFalse ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i0 : int) (H2 : (if Int.ltu i (Int.repr 31) then Some (Vint (Int.shrx i0 i)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu i (Int.repr 31) then Some (Vint (Int.shrx i0 i)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.ltu i (Int.repr 31)); inv H2.\neconstructor; eauto."},{"statement":"(i : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nFalse ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i0 : int) : exists v2 : val,\n  Some (Vint (Int.shrx i0 i)) = Some v2 /\\\n  Val.inject f (Vint (Int.shrx i0 i)) v2.","proofString":"econstructor; eauto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shru v v0) (Val.shru v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(i i0 : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Orolm i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.rolm v i i0) (Val.rolm v' i i0).","proofString":"inv H4; simpl; auto."},{"statement":"(i i0 : int) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oroli i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or (Val.and v (Vint (Int.not i0))) (Val.rolm v0 i i0))\n  (Val.or (Val.and v' (Vint (Int.not i0))) (Val.rolm v'0 i i0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.longofint v) (Val.longofint v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32unsigned) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.longofintu v) (Val.longofintu v').","proofString":"inv H4; simpl; auto."},{"statement":"(addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing ge1 sp1 addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct addr; simpl in H2; simpl; FuncInv; InvInject; TrivialExists;    auto using Val.add_inject, Val.offset_ptr_inject.\napply H; simpl; auto.\napply Val.add_inject; auto.\napply H; simpl; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aglobal i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0).","proofString":"apply H; simpl; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 v sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Abased i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') : Val.inject f (Val.add (Genv.symbol_address ge1 i i0) v)\n  (Val.add (Genv.symbol_address ge2 i i0) v').","proofString":"apply Val.add_inject; auto.\napply H; simpl; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 v sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Abased i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') : Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0).","proofString":"apply H; simpl; auto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 : mem) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"inv H.\nrewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned.","proofString":"rewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned.","proofString":"apply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"inv H2; inv H3.\nauto."},{"statement":"(m1 : mem) (ofs1 ofs2 : ptrofs) (b1' b2' : block) (H0 : Mem.valid_pointer m1 b1' (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2' (Ptrofs.unsigned ofs2) = true) (H : b1' <> b2') : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr 0)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr 0)).","proofString":"auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends; auto.\napply valid_different_pointers_extends; auto.\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends; auto.\napply valid_different_pointers_extends; auto.\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends; auto.\napply valid_different_pointers_extends; auto.\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (H2 : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_operation genv sp op vl2 m2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.lessdef_list vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (H1 : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_addressing genv sp addr vl2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"exploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : f b = Some (b, 0) -> Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"intros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := f) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl2 = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_addressing.\neapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 (Ptrofs.repr delta)) addr vl2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) (id : ident) (ofs : ptrofs) (H1 : In id (globals_addressing addr)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op)\n    vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_operation.\nsimpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"simpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) (id : ident) (ofs : ptrofs) (H2 : In id (globals_operation op)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."}]}