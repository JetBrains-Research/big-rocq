{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/basic/FairExecution.v","fileSamples":[{"statement":"functional (rf G)⁻¹.","conclusion":"functional (rf G)⁻¹","hypotheses":"","proofString":"by inversion WF."},{"statement":"(y : actid) : exists findom : list actid,\n  forall x : actid,\n  (~ is_init x /\\ acts_set G x) /\\\n  match x with\n  | InitEvent _ =>\n      match y with\n      | InitEvent _ => False\n      | ThreadEvent _ _ => True\n      end\n  | ThreadEvent t i =>\n      match y with\n      | InitEvent _ => False\n      | ThreadEvent t' i' => t = t' /\\ i < i'\n      end\n  end /\\ acts_set G y -> In x findom.","conclusion":"exists findom : list actid,\n  forall x : actid,\n  (~ is_init x /\\ acts_set G x) /\\\n  match x with\n  | InitEvent _ =>\n      match y with\n      | InitEvent _ => False\n      | ThreadEvent _ _ => True\n      end\n  | ThreadEvent t i =>\n      match y with\n      | InitEvent _ => False\n      | ThreadEvent t' i' => t = t' /\\ i < i'\n      end\n  end /\\ acts_set G y -> In x findom","hypotheses":"(y : actid)","proofString":"destruct y; [exists nil; ins; desf|].\nexists (map (fun i => ThreadEvent thread i) (List.seq 0 index)).\nintros e ((NIe & E0) & (SB & E)).\ndestruct e; [done| ].\ndestruct SB as [-> LT].\napply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index : nat) : exists findom : list actid,\n  forall x : actid,\n  (~ is_init x /\\ acts_set G x) /\\\n  match x with\n  | InitEvent _ => True\n  | ThreadEvent t i => t = thread /\\ i < index\n  end /\\ acts_set G (ThreadEvent thread index) -> \n  In x findom.","conclusion":"exists findom : list actid,\n  forall x : actid,\n  (~ is_init x /\\ acts_set G x) /\\\n  match x with\n  | InitEvent _ => True\n  | ThreadEvent t i => t = thread /\\ i < index\n  end /\\ acts_set G (ThreadEvent thread index) -> \n  In x findom","hypotheses":"(thread : thread_id) (index : nat)","proofString":"exists (map (fun i => ThreadEvent thread i) (List.seq 0 index)).\nintros e ((NIe & E0) & (SB & E)).\ndestruct e; [done| ].\ndestruct SB as [-> LT].\napply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index : nat) : forall x : actid,\n(~ is_init x /\\ acts_set G x) /\\\nmatch x with\n| InitEvent _ => True\n| ThreadEvent t i => t = thread /\\ i < index\nend /\\ acts_set G (ThreadEvent thread index) ->\nIn x (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index)).","conclusion":"forall x : actid,\n(~ is_init x /\\ acts_set G x) /\\\nmatch x with\n| InitEvent _ => True\n| ThreadEvent t i => t = thread /\\ i < index\nend /\\ acts_set G (ThreadEvent thread index) ->\nIn x (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index))","hypotheses":"(thread : thread_id) (index : nat)","proofString":"intros e ((NIe & E0) & (SB & E)).\ndestruct e; [done| ].\ndestruct SB as [-> LT].\napply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index : nat) (e : actid) (NIe : ~ is_init e) (E0 : acts_set G e) (SB : match e with\n| InitEvent _ => True\n| ThreadEvent t i => t = thread /\\ i < index\nend) (E : acts_set G (ThreadEvent thread index)) : In e (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index)).","conclusion":"In e (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index))","hypotheses":"(thread : thread_id) (index : nat) (e : actid) (NIe : ~ is_init e) (E0 : acts_set G e) (SB : match e with\n| InitEvent _ => True\n| ThreadEvent t i => t = thread /\\ i < index\nend) (E : acts_set G (ThreadEvent thread index))","proofString":"destruct e; [done| ].\ndestruct SB as [-> LT].\napply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index : nat) (thread0 : thread_id) (index0 : nat) (NIe : ~ is_init (ThreadEvent thread0 index0)) (E0 : acts_set G (ThreadEvent thread0 index0)) (SB : thread0 = thread /\\ index0 < index) (E : acts_set G (ThreadEvent thread index)) : In (ThreadEvent thread0 index0)\n  (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index)).","conclusion":"In (ThreadEvent thread0 index0)\n  (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index))","hypotheses":"(thread : thread_id) (index : nat) (thread0 : thread_id) (index0 : nat) (NIe : ~ is_init (ThreadEvent thread0 index0)) (E0 : acts_set G (ThreadEvent thread0 index0)) (SB : thread0 = thread /\\ index0 < index) (E : acts_set G (ThreadEvent thread index))","proofString":"destruct SB as [-> LT].\napply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index index0 : nat) (E0 : acts_set G (ThreadEvent thread index0)) (NIe : ~ is_init (ThreadEvent thread index0)) (LT : index0 < index) (E : acts_set G (ThreadEvent thread index)) : In (ThreadEvent thread index0)\n  (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index)).","conclusion":"In (ThreadEvent thread index0)\n  (map (fun i : nat => ThreadEvent thread i) (List.seq 0 index))","hypotheses":"(thread : thread_id) (index index0 : nat) (E0 : acts_set G (ThreadEvent thread index0)) (NIe : ~ is_init (ThreadEvent thread index0)) (LT : index0 < index) (E : acts_set G (ThreadEvent thread index))","proofString":"apply in_map_iff.\neexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index index0 : nat) (E0 : acts_set G (ThreadEvent thread index0)) (NIe : ~ is_init (ThreadEvent thread index0)) (LT : index0 < index) (E : acts_set G (ThreadEvent thread index)) : exists x : nat,\n  ThreadEvent thread x = ThreadEvent thread index0 /\\ In x (List.seq 0 index).","conclusion":"exists x : nat,\n  ThreadEvent thread x = ThreadEvent thread index0 /\\ In x (List.seq 0 index)","hypotheses":"(thread : thread_id) (index index0 : nat) (E0 : acts_set G (ThreadEvent thread index0)) (NIe : ~ is_init (ThreadEvent thread index0)) (LT : index0 < index) (E : acts_set G (ThreadEvent thread index))","proofString":"eexists.\nsplit; eauto.\nby apply in_seq0_iff."},{"statement":"(thread : thread_id) (index index0 : nat) (E0 : acts_set G (ThreadEvent thread index0)) (NIe : ~ is_init (ThreadEvent thread index0)) (LT : index0 < index) (E : acts_set G (ThreadEvent thread index)) : In index0 (List.seq 0 index).","conclusion":"In index0 (List.seq 0 index)","hypotheses":"(thread : thread_id) (index index0 : nat) (E0 : acts_set G (ThreadEvent thread index0)) (NIe : ~ is_init (ThreadEvent thread index0)) (LT : index0 < index) (E : acts_set G (ThreadEvent thread index))","proofString":"by apply in_seq0_iff."},{"statement":"Basics.flip inclusion (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G)\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G ∩ same_loc (lab G)).","conclusion":"Basics.flip inclusion (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G)\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G ∩ same_loc (lab G))","hypotheses":"","proofString":"red.\nbasic_solver."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G ∩ same_loc (lab G)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G.","conclusion":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G ∩ same_loc (lab G)\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G","hypotheses":"","proofString":"basic_solver."},{"statement":"forall y : actid,\nexists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom.","conclusion":"forall y : actid,\nexists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom","hypotheses":"","proofString":"ins.\nremember (loc (lab G) y) as ly.\ndestruct ly.\nexists [InitEvent l].\nintros x REL%seq_eqv_l.\ndesc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence.\nexists [].\nred.\nintros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) : exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom.","conclusion":"exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom","hypotheses":"(y : actid)","proofString":"remember (loc (lab G) y) as ly.\ndestruct ly.\nexists [InitEvent l].\nintros x REL%seq_eqv_l.\ndesc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence.\nexists [].\nred.\nintros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (ly : option location) (Heqly : ly = loc (lab G) y) : exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom.","conclusion":"exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom","hypotheses":"(y : actid) (ly : option location) (Heqly : ly = loc (lab G) y)","proofString":"destruct ly.\nexists [InitEvent l].\nintros x REL%seq_eqv_l.\ndesc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence.\nexists [].\nred.\nintros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) : exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom.","conclusion":"exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y)","proofString":"exists [InitEvent l].\nintros x REL%seq_eqv_l.\ndesc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) : forall x : actid,\n(⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y ->\nIn x [InitEvent l].","conclusion":"forall x : actid,\n(⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y ->\nIn x [InitEvent l]","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y)","proofString":"intros x REL%seq_eqv_l.\ndesc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (x : actid) (REL : is_init x /\\ (sb G ∩ same_loc (lab G)) x y) : In x [InitEvent l].","conclusion":"In x [InitEvent l]","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (x : actid) (REL : is_init x /\\ (sb G ∩ same_loc (lab G)) x y)","proofString":"desc.\ndestruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : (sb G ∩ same_loc (lab G)) x y) : In x [InitEvent l].","conclusion":"In x [InitEvent l]","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : (sb G ∩ same_loc (lab G)) x y)","proofString":"destruct x; [| done].\nsimpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y) : In (InitEvent l0) [InitEvent l].","conclusion":"In (InitEvent l0) [InitEvent l]","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y)","proofString":"simpl.\nleft.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y) : InitEvent l = InitEvent l0 \\/ False.","conclusion":"InitEvent l = InitEvent l0 \\/ False","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y)","proofString":"left.\nf_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y) : InitEvent l = InitEvent l0.","conclusion":"InitEvent l = InitEvent l0","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y)","proofString":"f_equal.\napply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y) : l = l0.","conclusion":"l = l0","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : (sb G ∩ same_loc (lab G)) (InitEvent l0) y)","proofString":"apply proj2 in REL0.\nred in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : same_loc (lab G) (InitEvent l0) y) : l = l0.","conclusion":"l = l0","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : same_loc (lab G) (InitEvent l0) y)","proofString":"red in REL0.\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : loc (lab G) (InitEvent l0) = loc (lab G) y) : l = l0.","conclusion":"l = l0","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : loc (lab G) (InitEvent l0) = loc (lab G) y)","proofString":"unfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : match lab G (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = loc (lab G) y) : l = l0.","conclusion":"l = l0","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : match lab G (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = loc (lab G) y)","proofString":"rewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : Some l0 = loc (lab G) y) : l = l0.","conclusion":"l = l0","hypotheses":"(y : actid) (l : location) (Heqly : Some l = loc (lab G) y) (l0 : location) (REL : is_init (InitEvent l0)) (REL0 : Some l0 = loc (lab G) y)","proofString":"congruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) : exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom.","conclusion":"exists findom : list actid,\n  forall x : actid,\n  (⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x findom","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y)","proofString":"exists [].\nred.\nintros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) : forall x : actid,\n(⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x [].","conclusion":"forall x : actid,\n(⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> In x []","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y)","proofString":"red.\nintros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) : forall x : actid,\n(⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> False.","conclusion":"forall x : actid,\n(⦗fun a : actid => is_init a⦘ ⨾ sb G ∩ same_loc (lab G)) x y -> False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y)","proofString":"intros x REL%seq_eqv_l.\ndesc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x /\\ (sb G ∩ same_loc (lab G)) x y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x /\\ (sb G ∩ same_loc (lab G)) x y)","proofString":"desc.\napply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : (sb G ∩ same_loc (lab G)) x y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : (sb G ∩ same_loc (lab G)) x y)","proofString":"apply proj2 in REL0.\nred in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : same_loc (lab G) x y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : same_loc (lab G) x y)","proofString":"red in REL0.\ndestruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : loc (lab G) x = loc (lab G) y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (x : actid) (REL : is_init x) (REL0 : loc (lab G) x = loc (lab G) y)","proofString":"destruct x; [| done].\nunfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (l : location) (REL : is_init (InitEvent l)) (REL0 : loc (lab G) (InitEvent l) = loc (lab G) y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (l : location) (REL : is_init (InitEvent l)) (REL0 : loc (lab G) (InitEvent l) = loc (lab G) y)","proofString":"unfold Events.loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (l : location) (REL : is_init (InitEvent l)) (REL0 : match lab G (InitEvent l) with\n| Aload _ _ l0 _ | Astore _ _ l0 _ => Some l0\n| Afence _ => None\nend = loc (lab G) y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (l : location) (REL : is_init (InitEvent l)) (REL0 : match lab G (InitEvent l) with\n| Aload _ _ l0 _ | Astore _ _ l0 _ => Some l0\n| Afence _ => None\nend = loc (lab G) y)","proofString":"rewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(y : actid) (Heqly : None = loc (lab G) y) (l : location) (REL : is_init (InitEvent l)) (REL0 : Some l = loc (lab G) y) : False.","conclusion":"False","hypotheses":"(y : actid) (Heqly : None = loc (lab G) y) (l : location) (REL : is_init (InitEvent l)) (REL0 : Some l = loc (lab G) y)","proofString":"congruence."},{"statement":"(G : execution) (WF : Wf G) (FIN : fin_exec G) : co G ∪ fr G\n≡ ⦗acts_set G⦘ ⨾ (co G ∪ fr G) ⨾ ⦗fun a : actid => is_w (lab G) a⦘.","conclusion":"co G ∪ fr G\n≡ ⦗acts_set G⦘ ⨾ (co G ∪ fr G) ⨾ ⦗fun a : actid => is_w (lab G) a⦘","hypotheses":"(G : execution) (WF : Wf G) (FIN : fin_exec G)","proofString":"rewrite wf_coE, wf_frE, wf_coD, wf_frD; eauto.\nbasic_solver 10."},{"statement":"(G : execution) (WF : Wf G) (FIN : fin_exec G) : ⦗acts_set G⦘\n⨾ (⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ co G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n  acts_set G⦘\n∪ ⦗acts_set G⦘\n  ⨾ (⦗fun a : actid => is_r (lab G) a⦘\n     ⨾ fr G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n    acts_set G⦘\n≡ ⦗acts_set G⦘\n  ⨾ (⦗acts_set G⦘\n     ⨾ (⦗fun a : actid => is_w (lab G) a⦘\n        ⨾ co G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n       acts_set G⦘\n     ∪ ⦗acts_set G⦘\n       ⨾ (⦗fun a : actid => is_r (lab G) a⦘\n          ⨾ fr G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n         acts_set G⦘) ⨾ ⦗fun a : actid => is_w (lab G) a⦘.","conclusion":"⦗acts_set G⦘\n⨾ (⦗fun a : actid => is_w (lab G) a⦘\n   ⨾ co G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n  acts_set G⦘\n∪ ⦗acts_set G⦘\n  ⨾ (⦗fun a : actid => is_r (lab G) a⦘\n     ⨾ fr G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n    acts_set G⦘\n≡ ⦗acts_set G⦘\n  ⨾ (⦗acts_set G⦘\n     ⨾ (⦗fun a : actid => is_w (lab G) a⦘\n        ⨾ co G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n       acts_set G⦘\n     ∪ ⦗acts_set G⦘\n       ⨾ (⦗fun a : actid => is_r (lab G) a⦘\n          ⨾ fr G ⨾ ⦗fun a : actid => is_w (lab G) a⦘) ⨾ ⦗\n         acts_set G⦘) ⨾ ⦗fun a : actid => is_w (lab G) a⦘","hypotheses":"(G : execution) (WF : Wf G) (FIN : fin_exec G)","proofString":"basic_solver 10."},{"statement":"(G : execution) (WF : Wf G) (FIN : fin_exec G) (w : actid) (NW : ~ is_w (lab G) w) (x : actid) (REL : (⦗acts_set G⦘ ⨾ (co G ∪ fr G) ⨾ ⦗fun a : actid => is_w (lab G) a⦘) x w) : In x [].","conclusion":"In x []","hypotheses":"(G : execution) (WF : Wf G) (FIN : fin_exec G) (w : actid) (NW : ~ is_w (lab G) w) (x : actid) (REL : (⦗acts_set G⦘ ⨾ (co G ∪ fr G) ⨾ ⦗fun a : actid => is_w (lab G) a⦘) x w)","proofString":"apply seq_eqv_lr in REL.\nby desc."},{"statement":"(G : execution) (WF : Wf G) (FIN : fin_exec G) (w : actid) (NW : ~ is_w (lab G) w) (x : actid) (REL : acts_set G x /\\ (co G ∪ fr G) x w /\\ is_w (lab G) w) : In x [].","conclusion":"In x []","hypotheses":"(G : execution) (WF : Wf G) (FIN : fin_exec G) (w : actid) (NW : ~ is_w (lab G) w) (x : actid) (REL : acts_set G x /\\ (co G ∪ fr G) x w /\\ is_w (lab G) w)","proofString":"by desc."},{"statement":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (l0 : location) (RR : r = InitEvent l0) (REL : acts_set G (InitEvent l0)) (REL1 : is_w (lab G) w) (REL0 : loc (lab G) (InitEvent l0) = loc (lab G) w) : l = l0.","conclusion":"l = l0","hypotheses":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (l0 : location) (RR : r = InitEvent l0) (REL : acts_set G (InitEvent l0)) (REL1 : is_w (lab G) w) (REL0 : loc (lab G) (InitEvent l0) = loc (lab G) w)","proofString":"unfold loc in REL0 at 1.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (l0 : location) (RR : r = InitEvent l0) (REL : acts_set G (InitEvent l0)) (REL1 : is_w (lab G) w) (REL0 : match lab G (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = loc (lab G) w) : l = l0.","conclusion":"l = l0","hypotheses":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (l0 : location) (RR : r = InitEvent l0) (REL : acts_set G (InitEvent l0)) (REL1 : is_w (lab G) w) (REL0 : match lab G (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = loc (lab G) w)","proofString":"rewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (l0 : location) (RR : r = InitEvent l0) (REL : acts_set G (InitEvent l0)) (REL1 : is_w (lab G) w) (REL0 : Some l0 = loc (lab G) w) : l = l0.","conclusion":"l = l0","hypotheses":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (l0 : location) (RR : r = InitEvent l0) (REL : acts_set G (InitEvent l0)) (REL1 : is_w (lab G) w) (REL0 : Some l0 = loc (lab G) w)","proofString":"congruence."},{"statement":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (thread : thread_id) (index : nat) (RR : r = ThreadEvent thread index) (REL : acts_set G (ThreadEvent thread index)) (REL0 : (co G ∪ fr G) (ThreadEvent thread index) w) (REL1 : is_w (lab G) w) : In (ThreadEvent thread index) (InitEvent l :: findom).","conclusion":"In (ThreadEvent thread index) (InitEvent l :: findom)","hypotheses":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (thread : thread_id) (index : nat) (RR : r = ThreadEvent thread index) (REL : acts_set G (ThreadEvent thread index)) (REL0 : (co G ∪ fr G) (ThreadEvent thread index) w) (REL1 : is_w (lab G) w)","proofString":"right.\napply FIN.\nsplit; auto."},{"statement":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (thread : thread_id) (index : nat) (RR : r = ThreadEvent thread index) (REL : acts_set G (ThreadEvent thread index)) (REL0 : (co G ∪ fr G) (ThreadEvent thread index) w) (REL1 : is_w (lab G) w) : In (ThreadEvent thread index) findom.","conclusion":"In (ThreadEvent thread index) findom","hypotheses":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (thread : thread_id) (index : nat) (RR : r = ThreadEvent thread index) (REL : acts_set G (ThreadEvent thread index)) (REL0 : (co G ∪ fr G) (ThreadEvent thread index) w) (REL1 : is_w (lab G) w)","proofString":"apply FIN.\nsplit; auto."},{"statement":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (thread : thread_id) (index : nat) (RR : r = ThreadEvent thread index) (REL : acts_set G (ThreadEvent thread index)) (REL0 : (co G ∪ fr G) (ThreadEvent thread index) w) (REL1 : is_w (lab G) w) : (acts_set G \\₁ (fun a : actid => is_init a)) (ThreadEvent thread index).","conclusion":"(acts_set G \\₁ (fun a : actid => is_init a)) (ThreadEvent thread index)","hypotheses":"(G : execution) (WF : Wf G) (findom : list actid) (FIN : forall x : actid,\n(acts_set G \\₁ (fun a : actid => is_init a)) x -> In x findom) (w : actid) (W : is_w (lab G) w) (l : location) (Lw : loc (lab G) w = Some l) (r : actid) (thread : thread_id) (index : nat) (RR : r = ThreadEvent thread index) (REL : acts_set G (ThreadEvent thread index)) (REL0 : (co G ∪ fr G) (ThreadEvent thread index) w) (REL1 : is_w (lab G) w)","proofString":"split; auto."},{"statement":"(G : execution) (WF : Wf G) (FIN : fin_exec_full G) : fin_exec G.","conclusion":"fin_exec G","hypotheses":"(G : execution) (WF : Wf G) (FIN : fin_exec_full G)","proofString":"apply fin_exec_full_equiv in FIN.\nby desc."},{"statement":"(G : execution) (WF : Wf G) (FIN : fin_exec G /\\ set_finite (acts_set G ∩₁ (fun a : actid => is_init a))) : fin_exec G.","conclusion":"fin_exec G","hypotheses":"(G : execution) (WF : Wf G) (FIN : fin_exec G /\\ set_finite (acts_set G ∩₁ (fun a : actid => is_init a)))","proofString":"by desc."}]}