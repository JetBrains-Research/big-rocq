{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/promising2ToImm/src/ext_traversal/ExtTraversalCounting.v","fileSamples":[{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : tc_enum G steps_enum 0 ≡₁ init_tls G.","conclusion":"tc_enum G steps_enum 0 ≡₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"unfold tc_enum.\nrewrite trav_prefix_init.\nrewrite sim_clos_empty.\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : sim_clos G (trav_prefix steps_enum 0) ∪₁ init_tls G ≡₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum 0) ∪₁ init_tls G ≡₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"rewrite trav_prefix_init.\nrewrite sim_clos_empty.\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : sim_clos G ∅ ∪₁ init_tls G ≡₁ init_tls G.","conclusion":"sim_clos G ∅ ∪₁ init_tls G ≡₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"rewrite sim_clos_empty.\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : ∅ ∪₁ init_tls G ≡₁ init_tls G.","conclusion":"∅ ∪₁ init_tls G ≡₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"basic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) ->\ntls_coherent G (tc_enum G steps_enum i0).","conclusion":"forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) ->\ntls_coherent G (tc_enum G steps_enum i0)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"apply tc_enum_tls_coherent; eauto."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (tc_enum G steps_enum i0)\n  (tc_enum G steps_enum (1 + i0)).","conclusion":"forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (tc_enum G steps_enum i0)\n  (tc_enum G steps_enum (1 + i0))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"apply sim_traversal_next; auto.\nrewrite iord_exec_tls.\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : iord G sc ⊆ exec_tls G × exec_tls G.","conclusion":"iord G sc ⊆ exec_tls G × exec_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"rewrite iord_exec_tls.\nbasic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : restr_rel (exec_tls G) (iord G sc) ⊆ exec_tls G × exec_tls G.","conclusion":"restr_rel (exec_tls G) (iord G sc) ⊆ exec_tls G × exec_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"basic_solver."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e).","conclusion":"forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"intros e Ee.\npose proof ENUM as ENUM'.\napply enumeratesE' in ENUM.\ndesc.\nspecialize (IND (mkTL ta_cover e)).\nspecialize_full IND.\nred.\nleft.\nvauto.\ndesc.\nexists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (e : actid) (Ee : (E \\₁ (fun a : actid => is_init a)) e) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e).","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (e : actid) (Ee : (E \\₁ (fun a : actid => is_init a)) e)","proofString":"pose proof ENUM as ENUM'.\napply enumeratesE' in ENUM.\ndesc.\nspecialize (IND (mkTL ta_cover e)).\nspecialize_full IND.\nred.\nleft.\nvauto.\ndesc.\nexists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (e : actid) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e).","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (e : actid) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G))","proofString":"apply enumeratesE' in ENUM.\ndesc.\nspecialize (IND (mkTL ta_cover e)).\nspecialize_full IND.\nred.\nleft.\nvauto.\ndesc.\nexists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (IND : forall a : trav_label,\nexec_tls G a ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\ steps_enum i0 = a) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (e : actid) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e).","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (IND : forall a : trav_label,\nexec_tls G a ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\ steps_enum i0 = a) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (e : actid) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G))","proofString":"specialize (IND (mkTL ta_cover e)).\nspecialize_full IND.\nred.\nleft.\nvauto.\ndesc.\nexists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e).","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G))","proofString":"specialize_full IND.\nred.\nleft.\nvauto.\ndesc.\nexists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) : exec_tls G (mkTL ta_cover e).","conclusion":"exec_tls G (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G))","proofString":"red.\nleft.\nvauto."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) : (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n    ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)) (mkTL ta_cover e).","conclusion":"(eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n    ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)) (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G))","proofString":"left.\nvauto."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) : (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))) (mkTL ta_cover e).","conclusion":"(eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))) (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (IND : exec_tls G (mkTL ta_cover e) ->\nexists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G))","proofString":"vauto."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (IND : exists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e).","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) -> exec_tls G (steps_enum i0)) (INJ : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i0 = steps_enum j -> i0 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (IND : exists i0 : nat,\n  NOmega.lt_nat_l i0 (set_size (exec_tls G)) /\\\n  steps_enum i0 = mkTL ta_cover e)","proofString":"desc.\nexists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e) : exists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i1 (mkTL ta_cover e).","conclusion":"exists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i1 (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e)","proofString":"exists (S i0).\nsplit; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e) : NOmega.le (NOnum (S i0)) (set_size (exec_tls G)) /\\\ntc_enum G steps_enum (S i0) (mkTL ta_cover e).","conclusion":"NOmega.le (NOnum (S i0)) (set_size (exec_tls G)) /\\\ntc_enum G steps_enum (S i0) (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e)","proofString":"split; [by vauto| ].\neapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e) : tc_enum G steps_enum (S i0) (mkTL ta_cover e).","conclusion":"tc_enum G steps_enum (S i0) (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e)","proofString":"eapply set_equiv_exp.\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e) : (sim_clos G (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e)) ∪₁ init_tls G)\n  (mkTL ta_cover e).","conclusion":"(sim_clos G (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e)) ∪₁ init_tls G)\n  (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e)","proofString":"unfold sim_clos.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e) : (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e)\n ∪₁ rmw_clos G (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e))\n ∪₁ rel_clos G (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e))\n ∪₁ init_tls G) (mkTL ta_cover e).","conclusion":"(trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e)\n ∪₁ rmw_clos G (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e))\n ∪₁ rel_clos G (trav_prefix steps_enum i0 ∪₁ eq (mkTL ta_cover e))\n ∪₁ init_tls G) (mkTL ta_cover e)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (INSET : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) -> exec_tls G (steps_enum i1)) (INJ : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\nforall j : nat,\nNOmega.lt_nat_l j (set_size (exec_tls G)) ->\nsteps_enum i1 = steps_enum j -> i1 = j) (e : actid) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (Ee : (E \\₁ (fun a : actid => is_init a)) e) (ENUM' : enumerates steps_enum (exec_tls G)) (i0 : nat) (IND : NOmega.lt_nat_l i0 (set_size (exec_tls G))) (IND0 : steps_enum i0 = mkTL ta_cover e)","proofString":"basic_solver 10."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 ≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 ≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"desc.\nexists i.\nsplit; auto.\nunfold tc_enum.\nrewrite <- set_unionK with (s := init_tls G)at 1.\nrewrite <- set_unionA.\nforward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 ≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"exists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  tc_enum G steps_enum i0 ≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"exists i.\nsplit; auto.\nunfold tc_enum.\nrewrite <- set_unionK with (s := init_tls G)at 1.\nrewrite <- set_unionA.\nforward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : NOmega.le (NOnum i) (set_size (exec_tls G)) /\\\ntc_enum G steps_enum i ≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"NOmega.le (NOnum i) (set_size (exec_tls G)) /\\\ntc_enum G steps_enum i ≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"split; auto.\nunfold tc_enum.\nrewrite <- set_unionK with (s := init_tls G)at 1.\nrewrite <- set_unionA.\nforward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : tc_enum G steps_enum i ≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"tc_enum G steps_enum i ≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"unfold tc_enum.\nrewrite <- set_unionK with (s := init_tls G)at 1.\nrewrite <- set_unionA.\nforward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"rewrite <- set_unionK with (s := init_tls G)at 1.\nrewrite <- set_unionA.\nforward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : sim_clos G (trav_prefix steps_enum i) ∪₁ (init_tls G ∪₁ init_tls G)\n≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i) ∪₁ (init_tls G ∪₁ init_tls G)\n≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"rewrite <- set_unionA.\nforward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) : sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T)","proofString":"forward eapply init_tls_sim_coh as INIT;eauto.\nred in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : sim_coherent G (init_tls G)) : sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : sim_coherent G (init_tls G))","proofString":"red in INIT.\nrewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : init_tls G ≡₁ sim_clos G (init_tls G)) : sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i) ∪₁ init_tls G ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : init_tls G ≡₁ sim_clos G (init_tls G))","proofString":"rewrite INIT at 1.\nrewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : init_tls G ≡₁ sim_clos G (init_tls G)) : sim_clos G (trav_prefix steps_enum i) ∪₁ sim_clos G (init_tls G)\n∪₁ init_tls G ≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i) ∪₁ sim_clos G (init_tls G)\n∪₁ init_tls G ≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : init_tls G ≡₁ sim_clos G (init_tls G))","proofString":"rewrite <- sim_clos_dist.\nby rewrite T_I0."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : init_tls G ≡₁ sim_clos G (init_tls G)) : sim_clos G (trav_prefix steps_enum i ∪₁ init_tls G) ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G.","conclusion":"sim_clos G (trav_prefix steps_enum i ∪₁ init_tls G) ∪₁ init_tls G\n≡₁ sim_clos G T ∪₁ init_tls G","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (T_FIN : tls_fin T) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (steps_enum : nat -> trav_label) (ENUM : enumerates steps_enum (exec_tls G)) (RESP : respects_rel steps_enum (iord G sc)⁺ (exec_tls G)) (i : nat) (T_I : NOmega.le (NOnum i) (set_size (exec_tls G))) (T_I0 : trav_prefix steps_enum i ∪₁ init_tls G ≡₁ T) (INIT : init_tls G ≡₁ sim_clos G (init_tls G))","proofString":"by rewrite T_I0."},{"statement":"(T1 T2 : trav_label -> Prop) (l : trav_label) (STEP : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2 /\\\niord_coherent G sc T1 /\\ iord_coherent G sc T2) : T1 ⊆₁ T2.","conclusion":"T1 ⊆₁ T2","hypotheses":"(T1 T2 : trav_label -> Prop) (l : trav_label) (STEP : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2 /\\\niord_coherent G sc T1 /\\ iord_coherent G sc T2)","proofString":"desc.\ngeneralize STEP.\nbasic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) (l : trav_label) (STEP : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2) (STEP0 : iord_coherent G sc T1) (STEP1 : iord_coherent G sc T2) : T1 ⊆₁ T2.","conclusion":"T1 ⊆₁ T2","hypotheses":"(T1 T2 : trav_label -> Prop) (l : trav_label) (STEP : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2) (STEP0 : iord_coherent G sc T1) (STEP1 : iord_coherent G sc T2)","proofString":"generalize STEP.\nbasic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) (l : trav_label) (STEP : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2) (STEP0 : iord_coherent G sc T1) (STEP1 : iord_coherent G sc T2) : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2 -> \nT1 ⊆₁ T2.","conclusion":"(⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2 -> \nT1 ⊆₁ T2","hypotheses":"(T1 T2 : trav_label -> Prop) (l : trav_label) (STEP : (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) T1 T2) (STEP0 : iord_coherent G sc T1) (STEP1 : iord_coherent G sc T2)","proofString":"basic_solver."},{"statement":"(x y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (IHSTEP1 : x ⊆₁ y) (IHSTEP2 : y ⊆₁ z) : x ⊆₁ z.","conclusion":"x ⊆₁ z","hypotheses":"(x y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (IHSTEP1 : x ⊆₁ y) (IHSTEP2 : y ⊆₁ z)","proofString":"etransitivity; eauto."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) : tls_fin T.","conclusion":"tls_fin T","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T)","proofString":"eapply fin_exec_tls_fin; eauto."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : tls_coherent G (sim_enum n).","conclusion":"tls_coherent G (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply COH.\nrewrite SIZE.\nsimpl.\nlia."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : NOmega.le (NOnum n) (set_size (exec_tls G)).","conclusion":"NOmega.le (NOnum n) (set_size (exec_tls G))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"rewrite SIZE.\nsimpl.\nlia."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : NOmega.le (NOnum n) (NOnum n).","conclusion":"NOmega.le (NOnum n) (NOnum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"simpl.\nlia."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : n <= n.","conclusion":"n <= n","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"lia."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G).","conclusion":"(sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply rt_of_rt.\nrewrite <- CLOS_T0, <- INIT.\neapply enum_steps_crt; eauto; [| lia].\nins.\nrewrite Nat.add_comm.\nby apply STEPS."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : ((sim_clos_step G sc)＊)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G).","conclusion":"((sim_clos_step G sc)＊)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"rewrite <- CLOS_T0, <- INIT.\neapply enum_steps_crt; eauto; [| lia].\nins.\nrewrite Nat.add_comm.\nby apply STEPS."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : ((sim_clos_step G sc)＊)＊ (sim_enum 0) (sim_enum i).","conclusion":"((sim_clos_step G sc)＊)＊ (sim_enum 0) (sim_enum i)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"eapply enum_steps_crt; eauto; [| lia].\nins.\nrewrite Nat.add_comm.\nby apply STEPS."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1)).","conclusion":"forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"ins.\nrewrite Nat.add_comm.\nby apply STEPS."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : NOmega.lt_nat_l i0 (set_size (exec_tls G))) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : NOmega.lt_nat_l i0 (set_size (exec_tls G)))","proofString":"rewrite Nat.add_comm.\nby apply STEPS."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : NOmega.lt_nat_l i0 (set_size (exec_tls G))) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : NOmega.lt_nat_l i0 (set_size (exec_tls G)))","proofString":"by apply STEPS."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) (sim_enum n).","conclusion":"(sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"rewrite <- CLOS_T0.\napply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); try by vauto.\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE.\nby rewrite SIZE in CLOS_T."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : (sim_clos_step G sc)＊ (sim_enum i) (sim_enum n).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); try by vauto.\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE.\nby rewrite SIZE in CLOS_T."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : ((sim_clos_step G sc)＊)＊ (sim_enum i) (sim_enum n).","conclusion":"((sim_clos_step G sc)＊)＊ (sim_enum i) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"eapply enum_steps_crt with (b := NOnum n); try by vauto.\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE.\nby rewrite SIZE in CLOS_T."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : forall i0 : nat,\nNOmega.lt_nat_l i0 (NOnum n) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1)).","conclusion":"forall i0 : nat,\nNOmega.lt_nat_l i0 (NOnum n) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"ins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n)","proofString":"rewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n)","proofString":"apply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n) : NOmega.lt_nat_l i0 (set_size (exec_tls G)).","conclusion":"NOmega.lt_nat_l i0 (set_size (exec_tls G))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n)","proofString":"by rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : i <= n.","conclusion":"i <= n","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"by rewrite SIZE in CLOS_T."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : E ∩₁ (fun a : actid => is_init a) ⊆₁ covered (sim_enum n).","conclusion":"E ∩₁ (fun a : actid => is_init a) ⊆₁ covered (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"transitivity (covered (sim_enum 0)).\nrewrite INIT.\nrewrite set_interC, init_covered; [reflexivity| ].\napply init_tls_tls_coherent.\napply covered_mori.\napply sim_clos_step_crt_incl.\napply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); (try by vauto); [| lia].\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : E ∩₁ (fun a : actid => is_init a) ⊆₁ covered (sim_enum 0).","conclusion":"E ∩₁ (fun a : actid => is_init a) ⊆₁ covered (sim_enum 0)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"rewrite INIT.\nrewrite set_interC, init_covered; [reflexivity| ].\napply init_tls_tls_coherent."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : E ∩₁ (fun a : actid => is_init a) ⊆₁ covered (init_tls G).","conclusion":"E ∩₁ (fun a : actid => is_init a) ⊆₁ covered (init_tls G)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"rewrite set_interC, init_covered; [reflexivity| ].\napply init_tls_tls_coherent."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : tls_coherent G (init_tls G).","conclusion":"tls_coherent G (init_tls G)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply init_tls_tls_coherent."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : covered (sim_enum 0) ⊆₁ covered (sim_enum n).","conclusion":"covered (sim_enum 0) ⊆₁ covered (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply covered_mori.\napply sim_clos_step_crt_incl.\napply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); (try by vauto); [| lia].\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : sim_enum 0 ⊆₁ sim_enum n.","conclusion":"sim_enum 0 ⊆₁ sim_enum n","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply sim_clos_step_crt_incl.\napply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); (try by vauto); [| lia].\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : (sim_clos_step G sc)＊ (sim_enum 0) (sim_enum n).","conclusion":"(sim_clos_step G sc)＊ (sim_enum 0) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"apply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); (try by vauto); [| lia].\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : ((sim_clos_step G sc)＊)＊ (sim_enum 0) (sim_enum n).","conclusion":"((sim_clos_step G sc)＊)＊ (sim_enum 0) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"eapply enum_steps_crt with (b := NOnum n); (try by vauto); [| lia].\nins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) : forall i0 : nat,\nNOmega.lt_nat_l i0 (NOnum n) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1)).","conclusion":"forall i0 : nat,\nNOmega.lt_nat_l i0 (NOnum n) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i0 : nat,\nNOmega.le (NOnum i0) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i0)) (STEPS : forall i0 : nat,\nNOmega.lt_nat_l i0 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i0 : nat,\n  NOmega.le (NOnum i0) (set_size (exec_tls G)) /\\\n  sim_enum i0 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n)","proofString":"ins.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (i0 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n)","proofString":"rewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum (1 + i0))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n)","proofString":"apply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n) : NOmega.lt_nat_l i0 (set_size (exec_tls G)).","conclusion":"NOmega.lt_nat_l i0 (set_size (exec_tls G))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nmatch set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i1 <= m\nend -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (S i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  match set_size (exec_tls G) with\n  | NOinfinity => True\n  | NOnum m => i1 <= m\n  end /\\ sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : match set_size (exec_tls G) with\n| NOinfinity => True\n| NOnum m => i <= m\nend) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (i0 : nat) (DOM : i0 < n)","proofString":"by rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) : (sim_clos_step G sc)＊ (sim_enum i0) (sim_enum n).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i0) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x))","proofString":"apply rt_of_rt.\neapply enum_steps_crt with (b := NOnum n); (try by vauto).\nintros.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE.\nby rewrite SIZE in H."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) : ((sim_clos_step G sc)＊)＊ (sim_enum i0) (sim_enum n).","conclusion":"((sim_clos_step G sc)＊)＊ (sim_enum i0) (sim_enum n)","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x))","proofString":"eapply enum_steps_crt with (b := NOnum n); (try by vauto).\nintros.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE.\nby rewrite SIZE in H."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) : forall i1 : nat,\nNOmega.lt_nat_l i1 (NOnum n) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (i1 + 1)).","conclusion":"forall i1 : nat,\nNOmega.lt_nat_l i1 (NOnum n) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (i1 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x))","proofString":"intros.\nrewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i2 : nat,\nNOmega.le (NOnum i2) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i2)) (STEPS : forall i2 : nat,\nNOmega.lt_nat_l i2 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i2) (sim_enum (1 + i2))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i2 : nat,\n  NOmega.le (NOnum i2) (set_size (exec_tls G)) /\\\n  sim_enum i2 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) (i1 : nat) (DOM : NOmega.lt_nat_l i1 (NOnum n)) : (sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (i1 + 1)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (i1 + 1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i2 : nat,\nNOmega.le (NOnum i2) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i2)) (STEPS : forall i2 : nat,\nNOmega.lt_nat_l i2 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i2) (sim_enum (1 + i2))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i2 : nat,\n  NOmega.le (NOnum i2) (set_size (exec_tls G)) /\\\n  sim_enum i2 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) (i1 : nat) (DOM : NOmega.lt_nat_l i1 (NOnum n))","proofString":"rewrite Nat.add_comm.\napply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i2 : nat,\nNOmega.le (NOnum i2) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i2)) (STEPS : forall i2 : nat,\nNOmega.lt_nat_l i2 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i2) (sim_enum (1 + i2))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i2 : nat,\n  NOmega.le (NOnum i2) (set_size (exec_tls G)) /\\\n  sim_enum i2 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) (i1 : nat) (DOM : NOmega.lt_nat_l i1 (NOnum n)) : (sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1)).","conclusion":"(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i2 : nat,\nNOmega.le (NOnum i2) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i2)) (STEPS : forall i2 : nat,\nNOmega.lt_nat_l i2 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i2) (sim_enum (1 + i2))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i2 : nat,\n  NOmega.le (NOnum i2) (set_size (exec_tls G)) /\\\n  sim_enum i2 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) (i1 : nat) (DOM : NOmega.lt_nat_l i1 (NOnum n))","proofString":"apply STEPS.\nby rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i2 : nat,\nNOmega.le (NOnum i2) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i2)) (STEPS : forall i2 : nat,\nNOmega.lt_nat_l i2 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i2) (sim_enum (1 + i2))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i2 : nat,\n  NOmega.le (NOnum i2) (set_size (exec_tls G)) /\\\n  sim_enum i2 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) (i1 : nat) (DOM : NOmega.lt_nat_l i1 (NOnum n)) : NOmega.lt_nat_l i1 (set_size (exec_tls G)).","conclusion":"NOmega.lt_nat_l i1 (set_size (exec_tls G))","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i2 : nat,\nNOmega.le (NOnum i2) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i2)) (STEPS : forall i2 : nat,\nNOmega.lt_nat_l i2 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i2) (sim_enum (1 + i2))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i2 : nat,\n  NOmega.le (NOnum i2) (set_size (exec_tls G)) /\\\n  sim_enum i2 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) (i1 : nat) (DOM : NOmega.lt_nat_l i1 (NOnum n))","proofString":"by rewrite SIZE."},{"statement":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x)) : i0 <= n.","conclusion":"i0 <= n","hypotheses":"(T : trav_label -> Prop) (FAIR : mem_fair G) (IMM_FAIR : imm_s_fair G sc) (CONS : imm_consistent G sc) (FIN_THREADS : fin_threads G) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (sim_enum : nat -> trav_label -> Prop) (INIT : sim_enum 0 ≡₁ init_tls G) (COH : forall i1 : nat,\nNOmega.le (NOnum i1) (set_size (exec_tls G)) -> tls_coherent G (sim_enum i1)) (STEPS : forall i1 : nat,\nNOmega.lt_nat_l i1 (set_size (exec_tls G)) ->\n(sim_clos_step G sc)＊ (sim_enum i1) (sim_enum (1 + i1))) (ENUM : forall e : actid,\n(E \\₁ (fun a : actid => is_init a)) e ->\nexists i1 : nat,\n  NOmega.le (NOnum i1) (set_size (exec_tls G)) /\\\n  sim_enum i1 (mkTL ta_cover e)) (i : nat) (CLOS_T : NOmega.le (NOnum i) (set_size (exec_tls G))) (CLOS_T0 : sim_enum i ≡₁ sim_clos G T ∪₁ init_tls G) (AA : set_finite (exec_tls G) -> exists n0 : nat, set_size (exec_tls G) = NOnum n0) (n : nat) (SIZE : set_size (exec_tls G) = NOnum n) (x : actid) (i0 : nat) (H : NOmega.le (NOnum i0) (set_size (exec_tls G))) (H0 : sim_enum i0 (mkTL ta_cover x))","proofString":"by rewrite SIZE in H."},{"statement":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread) : T1 (ta_cover, e).","conclusion":"T1 (ta_cover, e)","hypotheses":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread)","proofString":"apply tls_set_alt, NCOV.\nsplit; auto.\nreplace e with (event (ta_cover, e)) by done.\neapply tlsc_E; eauto.\napply T2_EQ.\nvauto."},{"statement":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread) : (NTid_ thread ∩₁ E) e.","conclusion":"(NTid_ thread ∩₁ E) e","hypotheses":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread)","proofString":"split; auto.\nreplace e with (event (ta_cover, e)) by done.\neapply tlsc_E; eauto.\napply T2_EQ.\nvauto."},{"statement":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread) : E e.","conclusion":"E e","hypotheses":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread)","proofString":"replace e with (event (ta_cover, e)) by done.\neapply tlsc_E; eauto.\napply T2_EQ.\nvauto."},{"statement":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread) : E (event (ta_cover, e)).","conclusion":"E (event (ta_cover, e))","hypotheses":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread)","proofString":"eapply tlsc_E; eauto.\napply T2_EQ.\nvauto."},{"statement":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread) : T2 (ta_cover, e).","conclusion":"T2 (ta_cover, e)","hypotheses":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread)","proofString":"apply T2_EQ.\nvauto."},{"statement":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread) : (T1 ∪₁ eq (ta_cover, e)) (ta_cover, e).","conclusion":"(T1 ∪₁ eq (ta_cover, e)) (ta_cover, e)","hypotheses":"(thread : BinNums.positive) (T1 T2 : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T1) (e : actid) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, e)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (Nte : tid e <> thread)","proofString":"vauto."},{"statement":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r) : ext_itrav_step G sc (mkTL ta_cover r) T1 T2.","conclusion":"ext_itrav_step G sc (mkTL ta_cover r) T1 T2","hypotheses":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r)","proofString":"split; eauto.\nins.\nsimpl.\nrewrite set_pair_alt.\nrewrite T2_EQ.\nbasic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r) : W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT1 (ta_reserve, event (mkTL ta_cover r)).","conclusion":"W_ex G (event (mkTL ta_cover r)) ->\naction (mkTL ta_cover r) = ta_issue ->\nT1 (ta_reserve, event (mkTL ta_cover r))","hypotheses":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r)","proofString":"ins."},{"statement":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r) : T2\n≡₁ T1 ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T1.","conclusion":"T2\n≡₁ T1 ∪₁ eq (mkTL ta_cover r)\n   ∪₁ eq ta_reserve <*> ets_upd_reserve G (mkTL ta_cover r) T1","hypotheses":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r)","proofString":"simpl.\nrewrite set_pair_alt.\nrewrite T2_EQ.\nbasic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r) : T2 ≡₁ T1 ∪₁ eq (mkTL ta_cover r) ∪₁ eq ta_reserve <*> ∅.","conclusion":"T2 ≡₁ T1 ∪₁ eq (mkTL ta_cover r) ∪₁ eq ta_reserve <*> ∅","hypotheses":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r)","proofString":"rewrite set_pair_alt.\nrewrite T2_EQ.\nbasic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r) : T2 ≡₁ T1 ∪₁ eq (mkTL ta_cover r) ∪₁ fst ↓₁ eq ta_reserve ∩₁ snd ↓₁ ∅.","conclusion":"T2 ≡₁ T1 ∪₁ eq (mkTL ta_cover r) ∪₁ fst ↓₁ eq ta_reserve ∩₁ snd ↓₁ ∅","hypotheses":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r)","proofString":"rewrite T2_EQ.\nbasic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r) : T1 ∪₁ eq (ta_cover, r)\n≡₁ T1 ∪₁ eq (mkTL ta_cover r) ∪₁ fst ↓₁ eq ta_reserve ∩₁ snd ↓₁ ∅.","conclusion":"T1 ∪₁ eq (ta_cover, r)\n≡₁ T1 ∪₁ eq (mkTL ta_cover r) ∪₁ fst ↓₁ eq ta_reserve ∩₁ snd ↓₁ ∅","hypotheses":"(T1 T2 : trav_label -> Prop) (r : actid) (NCOV : NTid_ (tid r) ∩₁ E ⊆₁ covered T1) (NT1e : set_compl T1 (ta_cover, r)) (T2_EQ : T2 ≡₁ T1 ∪₁ eq (ta_cover, r)) (ICOH1 : iord_coherent G sc T1) (ICOH2 : iord_coherent G sc T2) (H0 : sim_coherent G T1) (H1 : sim_coherent G T2) (RCOH : reserve_coherent G T1) (TCOH2 : tls_coherent G T2) (RCOH2 : reserve_coherent G T2) (R : is_r lab r) (NRMWe : ~ dom_rel rmw r)","proofString":"basic_solver."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y : trav_label -> Prop) (H : sim_clos_step G sc x y) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G y) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G y) : (ext_isim_trav_step G sc thread)＊ x y.","conclusion":"(ext_isim_trav_step G sc thread)＊ x y","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y : trav_label -> Prop) (H : sim_clos_step G sc x y) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G y) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G y)","proofString":"apply rt_step, sim_clos_step2ext_isim_trav_step; auto."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (TCOH1 TCOH2 : tls_coherent G x) (RCOH RCOH2 : reserve_coherent G x) : (ext_isim_trav_step G sc thread)＊ x x.","conclusion":"(ext_isim_trav_step G sc thread)＊ x x","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (TCOH1 TCOH2 : tls_coherent G x) (RCOH RCOH2 : reserve_coherent G x)","proofString":"apply rt_refl."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) : tls_coherent G y.","conclusion":"tls_coherent G y","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z)","proofString":"constructor.\ntransitivity x; auto.\napply TCOH1.\ntransitivity z; auto.\napply TCOH2."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) : init_tls G ⊆₁ y.","conclusion":"init_tls G ⊆₁ y","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z)","proofString":"transitivity x; auto.\napply TCOH1."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) : init_tls G ⊆₁ x.","conclusion":"init_tls G ⊆₁ x","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z)","proofString":"apply TCOH1."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) : y ⊆₁ init_tls G ∪₁ exec_tls G.","conclusion":"y ⊆₁ init_tls G ∪₁ exec_tls G","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z)","proofString":"transitivity z; auto.\napply TCOH2."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) : z ⊆₁ init_tls G ∪₁ exec_tls G.","conclusion":"z ⊆₁ init_tls G ∪₁ exec_tls G","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z)","proofString":"apply TCOH2."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) (TLSY : tls_coherent G y) (RCOHY : reserve_coherent G y) : (ext_isim_trav_step G sc thread)＊ x z.","conclusion":"(ext_isim_trav_step G sc thread)＊ x z","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) (TLSY : tls_coherent G y) (RCOHY : reserve_coherent G y)","proofString":"eapply rt_trans; [apply IHSTEP1 | apply IHSTEP2]; eauto.\netransitivity; eauto.\nnow apply covered_mori."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) (TLSY : tls_coherent G y) (RCOHY : reserve_coherent G y) : NTid_ thread ∩₁ E ⊆₁ covered y.","conclusion":"NTid_ thread ∩₁ E ⊆₁ covered y","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) (TLSY : tls_coherent G y) (RCOHY : reserve_coherent G y)","proofString":"etransitivity; eauto.\nnow apply covered_mori."},{"statement":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) (TLSY : tls_coherent G y) (RCOHY : reserve_coherent G y) : covered x ⊆₁ covered y.","conclusion":"covered x ⊆₁ covered y","hypotheses":"(thread : BinNums.positive) (x : trav_label -> Prop) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered x) (y z : trav_label -> Prop) (STEP1 : (sim_clos_step G sc)＊ x y) (STEP2 : (sim_clos_step G sc)＊ y z) (TCOH1 : tls_coherent G x) (TCOH2 : tls_coherent G z) (RCOH : reserve_coherent G x) (RCOH2 : reserve_coherent G z) (IHSTEP1 : NTid_ thread ∩₁ E ⊆₁ covered x ->\ntls_coherent G x ->\ntls_coherent G y ->\nreserve_coherent G x ->\nreserve_coherent G y -> (ext_isim_trav_step G sc thread)＊ x y) (IHSTEP2 : NTid_ thread ∩₁ E ⊆₁ covered y ->\ntls_coherent G y ->\ntls_coherent G z ->\nreserve_coherent G y ->\nreserve_coherent G z -> (ext_isim_trav_step G sc thread)＊ y z) (XY : x ⊆₁ y) (YZ : y ⊆₁ z) (TLSY : tls_coherent G y) (RCOHY : reserve_coherent G y)","proofString":"now apply covered_mori."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : T ≡₁ sim_clos G T.","conclusion":"T ≡₁ sim_clos G T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"unfold sim_clos.\nsplit; [basic_solver| ].\nunionL; [done| ..].\nunfold rmw_clos.\nrewrite set_pair_alt.\nunfolder.\nintros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt.\nunfold rel_clos.\nrewrite set_pair_alt.\nunfolder.\nins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : T ≡₁ T ∪₁ rmw_clos G T ∪₁ rel_clos G T.","conclusion":"T ≡₁ T ∪₁ rmw_clos G T ∪₁ rel_clos G T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"split; [basic_solver| ].\nunionL; [done| ..].\nunfold rmw_clos.\nrewrite set_pair_alt.\nunfolder.\nintros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt.\nunfold rel_clos.\nrewrite set_pair_alt.\nunfolder.\nins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : T ∪₁ rmw_clos G T ∪₁ rel_clos G T ⊆₁ T.","conclusion":"T ∪₁ rmw_clos G T ∪₁ rel_clos G T ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"unionL; [done| ..].\nunfold rmw_clos.\nrewrite set_pair_alt.\nunfolder.\nintros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt.\nunfold rel_clos.\nrewrite set_pair_alt.\nunfolder.\nins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : rmw_clos G T ⊆₁ T.","conclusion":"rmw_clos G T ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"unfold rmw_clos.\nrewrite set_pair_alt.\nunfolder.\nintros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered T⦘ ⨾ rmw) ⊆₁ T.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered T⦘ ⨾ rmw) ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"rewrite set_pair_alt.\nunfolder.\nintros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue) ∩₁ snd ↓₁ codom_rel (⦗covered T⦘ ⨾ rmw)\n⊆₁ T.","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue) ∩₁ snd ↓₁ codom_rel (⦗covered T⦘ ⨾ rmw)\n⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"unfolder.\nintros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : forall x : trav_label,\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid, covered T x0 /\\ rmw x0 (snd x)) -> \nT x.","conclusion":"forall x : trav_label,\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid, covered T x0 /\\ rmw x0 (snd x)) -> \nT x","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"intros [a w] [LBLw [r [COVr RMW]]].\nins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = fst (a, w) \\/ ta_issue = fst (a, w)) (r : actid) (COVr : covered T r) (RMW : rmw r (snd (a, w))) : T (a, w).","conclusion":"T (a, w)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = fst (a, w) \\/ ta_issue = fst (a, w)) (r : actid) (COVr : covered T r) (RMW : rmw r (snd (a, w)))","proofString":"ins.\nassert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w) : T (a, w).","conclusion":"T (a, w)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w)","proofString":"assert (T (mkTL ta_cover w)) as COV.\napply tls_set_alt.\neapply (RMWCOV r w); eauto.\ndes; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w) : T (mkTL ta_cover w).","conclusion":"T (mkTL ta_cover w)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w)","proofString":"apply tls_set_alt.\neapply (RMWCOV r w); eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w) : (event ↑₁ ((fun t : trav_label => T t) ∩₁ action ↓₁ eq ta_cover)) w.","conclusion":"(event ↑₁ ((fun t : trav_label => T t) ∩₁ action ↓₁ eq ta_cover)) w","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w)","proofString":"eapply (RMWCOV r w); eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w)) : T (a, w).","conclusion":"T (a, w)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (a : trav_action) (w : actid) (LBLw : ta_cover = a \\/ ta_issue = a) (r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w))","proofString":"des; apply tls_set_alt; vauto.\neapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w)) : (event ↑₁ ((fun t : trav_label => T t) ∩₁ action ↓₁ eq ta_issue)) w.","conclusion":"(event ↑₁ ((fun t : trav_label => T t) ∩₁ action ↓₁ eq ta_issue)) w","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w))","proofString":"eapply w_covered_issued; eauto.\nsplit.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w)) : (W ∩₁ covered (fun t : trav_label => T t)) w.","conclusion":"(W ∩₁ covered (fun t : trav_label => T t)) w","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w))","proofString":"split.\napply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc.\nby apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w)) : is_w lab w.","conclusion":"is_w lab w","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w))","proofString":"apply wf_rmwD, seq_eqv_lr in RMW; eauto.\nby desc."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : is_r lab r /\\ rmw r w /\\ is_w lab w) (COV : T (mkTL ta_cover w)) : is_w lab w.","conclusion":"is_w lab w","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : is_r lab r /\\ rmw r w /\\ is_w lab w) (COV : T (mkTL ta_cover w))","proofString":"by desc."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w)) : covered (fun t : trav_label => T t) w.","conclusion":"covered (fun t : trav_label => T t) w","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r0 w0 : actid, rmw r0 w0 -> covered T r0 <-> covered T w0) (w r : actid) (COVr : covered T r) (RMW : rmw r w) (COV : T (mkTL ta_cover w))","proofString":"by apply tls_set_alt."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : rel_clos G T ⊆₁ T.","conclusion":"rel_clos G T ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"unfold rel_clos.\nrewrite set_pair_alt.\nunfolder.\nins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : eq ta_cover <*> (Rel ∩₁ issued T) ⊆₁ T.","conclusion":"eq ta_cover <*> (Rel ∩₁ issued T) ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"rewrite set_pair_alt.\nunfolder.\nins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued T) ⊆₁ T.","conclusion":"fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued T) ⊆₁ T","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"unfolder.\nins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : forall x : trav_label,\nta_cover = fst x /\\ is_rel lab (snd x) /\\ issued T (snd x) -> T x.","conclusion":"forall x : trav_label,\nta_cover = fst x /\\ is_rel lab (snd x) /\\ issued T (snd x) -> T x","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w)","proofString":"ins.\ndestruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (x : trav_label) (H : ta_cover = fst x /\\ is_rel lab (snd x) /\\ issued T (snd x)) : T x.","conclusion":"T x","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (x : trav_label) (H : ta_cover = fst x /\\ is_rel lab (snd x) /\\ issued T (snd x))","proofString":"destruct x.\nins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (t : trav_action) (a : actid) (H : ta_cover = fst (t, a) /\\ is_rel lab (snd (t, a)) /\\ issued T (snd (t, a))) : T (t, a).","conclusion":"T (t, a)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (t : trav_action) (a : actid) (H : ta_cover = fst (t, a) /\\ is_rel lab (snd (t, a)) /\\ issued T (snd (t, a)))","proofString":"ins.\ndesc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (t : trav_action) (a : actid) (H : ta_cover = t /\\ is_rel lab a /\\ issued T a) : T (t, a).","conclusion":"T (t, a)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (t : trav_action) (a : actid) (H : ta_cover = t /\\ is_rel lab a /\\ issued T a)","proofString":"desc.\nsubst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (t : trav_action) (a : actid) (H : ta_cover = t) (H0 : is_rel lab a) (H1 : issued T a) : T (t, a).","conclusion":"T (t, a)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (t : trav_action) (a : actid) (H : ta_cover = t) (H0 : is_rel lab a) (H1 : issued T a)","proofString":"subst.\napply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a) : T (ta_cover, a).","conclusion":"T (ta_cover, a)","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a)","proofString":"apply tls_set_alt, RELCOV.\nunfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a) : (W ∩₁ Rel ∩₁ issued T) a.","conclusion":"(W ∩₁ Rel ∩₁ issued T) a","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a)","proofString":"unfolder.\nsplits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a) : (is_w lab a /\\ is_rel lab a) /\\ issued T a.","conclusion":"(is_w lab a /\\ is_rel lab a) /\\ issued T a","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a)","proofString":"splits; auto.\neapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a) : is_w lab a.","conclusion":"is_w lab a","hypotheses":"(T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (a : actid) (H0 : is_rel lab a) (H1 : issued T a)","proofString":"eapply issuedW in H1; eauto."},{"statement":"(T : trav_label -> Prop) (thread : BinNums.positive) (IMMCON : imm_consistent G sc) (FAIR : mem_fair G) (FIN_THREADS : fin_threads G) (IMM_FAIR : imm_s_fair G sc) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RCOH : reserve_coherent G T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (T' : trav_label -> Prop) (COH : tls_coherent G T') (STEPS1 : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)) (STEPS2 : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) T') (COV : E ⊆₁ covered T') (SCOH : T ≡₁ sim_clos G T) : T ≡₁ sim_clos G T.","conclusion":"T ≡₁ sim_clos G T","hypotheses":"(T : trav_label -> Prop) (thread : BinNums.positive) (IMMCON : imm_consistent G sc) (FAIR : mem_fair G) (FIN_THREADS : fin_threads G) (IMM_FAIR : imm_s_fair G sc) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RCOH : reserve_coherent G T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (T' : trav_label -> Prop) (COH : tls_coherent G T') (STEPS1 : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)) (STEPS2 : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) T') (COV : E ⊆₁ covered T') (SCOH : T ≡₁ sim_clos G T)","proofString":"by apply sim_coherent_alt."},{"statement":"(T : trav_label -> Prop) (thread : BinNums.positive) (IMMCON : imm_consistent G sc) (FAIR : mem_fair G) (FIN_THREADS : fin_threads G) (IMM_FAIR : imm_s_fair G sc) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RCOH : reserve_coherent G T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (T' : trav_label -> Prop) (COH : tls_coherent G T') (STEPS1 : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)) (STEPS2 : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) T') (COV : E ⊆₁ covered T') (T_ALT : T ≡₁ sim_clos G T ∪₁ init_tls G) : (sim_clos_step G sc)＊ T T'.","conclusion":"(sim_clos_step G sc)＊ T T'","hypotheses":"(T : trav_label -> Prop) (thread : BinNums.positive) (IMMCON : imm_consistent G sc) (FAIR : mem_fair G) (FIN_THREADS : fin_threads G) (IMM_FAIR : imm_s_fair G sc) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RCOH : reserve_coherent G T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (T' : trav_label -> Prop) (COH : tls_coherent G T') (STEPS1 : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)) (STEPS2 : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) T') (COV : E ⊆₁ covered T') (T_ALT : T ≡₁ sim_clos G T ∪₁ init_tls G)","proofString":"apply set_extensionality in T_ALT as T_ALT'.\nby rewrite T_ALT'."},{"statement":"(T : trav_label -> Prop) (thread : BinNums.positive) (IMMCON : imm_consistent G sc) (FAIR : mem_fair G) (FIN_THREADS : fin_threads G) (IMM_FAIR : imm_s_fair G sc) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RCOH : reserve_coherent G T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (T' : trav_label -> Prop) (COH : tls_coherent G T') (STEPS1 : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)) (STEPS2 : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) T') (COV : E ⊆₁ covered T') (T_ALT : T ≡₁ sim_clos G T ∪₁ init_tls G) (T_ALT' : T = sim_clos G T ∪₁ init_tls G) : (sim_clos_step G sc)＊ T T'.","conclusion":"(sim_clos_step G sc)＊ T T'","hypotheses":"(T : trav_label -> Prop) (thread : BinNums.positive) (IMMCON : imm_consistent G sc) (FAIR : mem_fair G) (FIN_THREADS : fin_threads G) (IMM_FAIR : imm_s_fair G sc) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (RCOH : reserve_coherent G T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) (T' : trav_label -> Prop) (COH : tls_coherent G T') (STEPS1 : (sim_clos_step G sc)＊ (init_tls G) (sim_clos G T ∪₁ init_tls G)) (STEPS2 : (sim_clos_step G sc)＊ (sim_clos G T ∪₁ init_tls G) T') (COV : E ⊆₁ covered T') (T_ALT : T ≡₁ sim_clos G T ∪₁ init_tls G) (T_ALT' : T = sim_clos G T ∪₁ init_tls G)","proofString":"by rewrite T_ALT'."}]}