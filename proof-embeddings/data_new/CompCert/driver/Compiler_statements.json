{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/driver/Compiler.v","fileSamples":[{"statement":"(A : Type) (printer : A -> unit) (prog : A) : prog = prog.","conclusion":"prog = prog","hypotheses":"(A : Type) (printer : A -> unit) (prog : A)","proofString":"destruct (printer prog); auto."},{"statement":"(A : Type) (x : res A) (f : A -> unit) : x @@ print f = x.","conclusion":"x @@ print f = x","hypotheses":"(A : Type) (x : res A) (f : A -> unit)","proofString":"destruct x; simpl.\nrewrite print_identity.\nauto.\nauto."},{"statement":"(A : Type) (a : A) (f : A -> unit) : OK (print f a) = OK a.","conclusion":"OK (print f a) = OK a","hypotheses":"(A : Type) (a : A) (f : A -> unit)","proofString":"rewrite print_identity.\nauto."},{"statement":"(A : Type) (a : A) (f : A -> unit) : OK a = OK a.","conclusion":"OK a = OK a","hypotheses":"(A : Type) (a : A) (f : A -> unit)","proofString":"auto."},{"statement":"(A : Type) (flag : unit -> bool) (f : A -> A) (rel : A -> A -> Prop) (prog : A) (H : forall p : A, rel p (f p)) : match_if flag rel prog (total_if flag f prog).","conclusion":"match_if flag rel prog (total_if flag f prog)","hypotheses":"(A : Type) (flag : unit -> bool) (f : A -> A) (rel : A -> A -> Prop) (prog : A) (H : forall p : A, rel p (f p))","proofString":"unfold match_if, total_if.\ndestruct (flag tt); auto."},{"statement":"(A : Type) (flag : unit -> bool) (f : A -> A) (rel : A -> A -> Prop) (prog : A) (H : forall p : A, rel p (f p)) : (if flag tt then rel else eq) prog (if flag tt then f prog else prog).","conclusion":"(if flag tt then rel else eq) prog (if flag tt then f prog else prog)","hypotheses":"(A : Type) (flag : unit -> bool) (f : A -> A) (rel : A -> A -> Prop) (prog : A) (H : forall p : A, rel p (f p))","proofString":"destruct (flag tt); auto."},{"statement":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : partial_if flag f prog = OK tprog) : match_if flag rel prog tprog.","conclusion":"match_if flag rel prog tprog","hypotheses":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : partial_if flag f prog = OK tprog)","proofString":"unfold match_if, partial_if in *.\ndestruct (flag tt).\nauto.\ncongruence."},{"statement":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : (if flag tt then f prog else OK prog) = OK tprog) : (if flag tt then rel else eq) prog tprog.","conclusion":"(if flag tt then rel else eq) prog tprog","hypotheses":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : (if flag tt then f prog else OK prog) = OK tprog)","proofString":"destruct (flag tt).\nauto.\ncongruence."},{"statement":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : f prog = OK tprog) : rel prog tprog.","conclusion":"rel prog tprog","hypotheses":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : f prog = OK tprog)","proofString":"auto."},{"statement":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : OK prog = OK tprog) : prog = tprog.","conclusion":"prog = tprog","hypotheses":"(A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A) (H : forall p tp : A, f p = OK tp -> rel p tp) (H0 : OK prog = OK tprog)","proofString":"congruence."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (T : transf_c_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (T : transf_c_program p = OK tp)","proofString":"unfold transf_c_program, time in T.\nsimpl in T.\ndestruct (SimplExpr.transl_program p) as [p1|e] eqn:P1; simpl in T; try discriminate.\nunfold transf_clight_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (T : OK p @@@ SimplExpr.transl_program @@@ transf_clight_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (T : OK p @@@ SimplExpr.transl_program @@@ transf_clight_program = OK tp)","proofString":"simpl in T.\ndestruct (SimplExpr.transl_program p) as [p1|e] eqn:P1; simpl in T; try discriminate.\nunfold transf_clight_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (T : SimplExpr.transl_program p @@@ transf_clight_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (T : SimplExpr.transl_program p @@@ transf_clight_program = OK tp)","proofString":"destruct (SimplExpr.transl_program p) as [p1|e] eqn:P1; simpl in T; try discriminate.\nunfold transf_clight_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : transf_clight_program p1 = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : transf_clight_program p1 = OK tp)","proofString":"unfold transf_clight_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : OK p1 @@ print print_Clight @@@ SimplLocals.transf_program @@@\nCshmgen.transl_program @@@ Cminorgen.transl_program @@@ transf_cminor_program =\nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : OK p1 @@ print print_Clight @@@ SimplLocals.transf_program @@@\nCshmgen.transl_program @@@ Cminorgen.transl_program @@@ transf_cminor_program =\nOK tp)","proofString":"rewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : OK p1 @@@ SimplLocals.transf_program @@@ Cshmgen.transl_program @@@\nCminorgen.transl_program @@@ transf_cminor_program = \nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : OK p1 @@@ SimplLocals.transf_program @@@ Cshmgen.transl_program @@@\nCminorgen.transl_program @@@ transf_cminor_program = \nOK tp)","proofString":"simpl in T.\ndestruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : SimplLocals.transf_program p1 @@@ Cshmgen.transl_program @@@\nCminorgen.transl_program @@@ transf_cminor_program = \nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (T : SimplLocals.transf_program p1 @@@ Cshmgen.transl_program @@@\nCminorgen.transl_program @@@ transf_cminor_program = \nOK tp)","proofString":"destruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.\ndestruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (T : Cshmgen.transl_program p2 @@@ Cminorgen.transl_program @@@\ntransf_cminor_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (T : Cshmgen.transl_program p2 @@@ Cminorgen.transl_program @@@\ntransf_cminor_program = OK tp)","proofString":"destruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.\ndestruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (T : Cminorgen.transl_program p3 @@@ transf_cminor_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (T : Cminorgen.transl_program p3 @@@ transf_cminor_program = OK tp)","proofString":"destruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.\nunfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : transf_cminor_program p4 = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : transf_cminor_program p4 = OK tp)","proofString":"unfold transf_cminor_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : OK p4 @@ print print_Cminor @@@ Selection.sel_program @@@\nRTLgen.transl_program @@@ transf_rtl_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : OK p4 @@ print print_Cminor @@@ Selection.sel_program @@@\nRTLgen.transl_program @@@ transf_rtl_program = OK tp)","proofString":"rewrite ! compose_print_identity in T.\nsimpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : OK p4 @@@ Selection.sel_program @@@ RTLgen.transl_program @@@\ntransf_rtl_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : OK p4 @@@ Selection.sel_program @@@ RTLgen.transl_program @@@\ntransf_rtl_program = OK tp)","proofString":"simpl in T.\ndestruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : Selection.sel_program p4 @@@ RTLgen.transl_program @@@ transf_rtl_program =\nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (T : Selection.sel_program p4 @@@ RTLgen.transl_program @@@ transf_rtl_program =\nOK tp)","proofString":"destruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.\ndestruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (T : RTLgen.transl_program p5 @@@ transf_rtl_program = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (T : RTLgen.transl_program p5 @@@ transf_rtl_program = OK tp)","proofString":"destruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.\nunfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : transf_rtl_program p6 = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : transf_rtl_program p6 = OK tp)","proofString":"unfold transf_rtl_program, time in T.\nrewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : OK p6 @@ print (print_RTL 0) @@\ntotal_if optim_tailcalls Tailcall.transf_program @@ \nprint (print_RTL 1) @@@ Inlining.transf_program @@ \nprint (print_RTL 2) @@ Renumber.transf_program @@ \nprint (print_RTL 3) @@ total_if optim_constprop Constprop.transf_program @@\nprint (print_RTL 4) @@ total_if optim_constprop Renumber.transf_program @@\nprint (print_RTL 5) @@@ partial_if optim_CSE CSE.transf_program @@\nprint (print_RTL 6) @@@ partial_if optim_redundancy Deadcode.transf_program @@\nprint (print_RTL 7) @@@ Unusedglob.transform_program @@ \nprint (print_RTL 8) @@@ Allocation.transf_program @@ \nprint print_LTL @@ Tunneling.tunnel_program @@@ Linearize.transf_program @@\nCleanupLabels.transf_program @@@ partial_if debug Debugvar.transf_program @@@\nStacking.transf_program @@ print print_Mach @@@ Asmgen.transf_program = \nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : OK p6 @@ print (print_RTL 0) @@\ntotal_if optim_tailcalls Tailcall.transf_program @@ \nprint (print_RTL 1) @@@ Inlining.transf_program @@ \nprint (print_RTL 2) @@ Renumber.transf_program @@ \nprint (print_RTL 3) @@ total_if optim_constprop Constprop.transf_program @@\nprint (print_RTL 4) @@ total_if optim_constprop Renumber.transf_program @@\nprint (print_RTL 5) @@@ partial_if optim_CSE CSE.transf_program @@\nprint (print_RTL 6) @@@ partial_if optim_redundancy Deadcode.transf_program @@\nprint (print_RTL 7) @@@ Unusedglob.transform_program @@ \nprint (print_RTL 8) @@@ Allocation.transf_program @@ \nprint print_LTL @@ Tunneling.tunnel_program @@@ Linearize.transf_program @@\nCleanupLabels.transf_program @@@ partial_if debug Debugvar.transf_program @@@\nStacking.transf_program @@ print print_Mach @@@ Asmgen.transf_program = \nOK tp)","proofString":"rewrite ! compose_print_identity in T.\nsimpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : OK p6 @@ total_if optim_tailcalls Tailcall.transf_program @@@\nInlining.transf_program @@ Renumber.transf_program @@\ntotal_if optim_constprop Constprop.transf_program @@\ntotal_if optim_constprop Renumber.transf_program @@@\npartial_if optim_CSE CSE.transf_program @@@\npartial_if optim_redundancy Deadcode.transf_program @@@\nUnusedglob.transform_program @@@ Allocation.transf_program @@\nTunneling.tunnel_program @@@ Linearize.transf_program @@\nCleanupLabels.transf_program @@@ partial_if debug Debugvar.transf_program @@@\nStacking.transf_program @@@ Asmgen.transf_program = \nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : OK p6 @@ total_if optim_tailcalls Tailcall.transf_program @@@\nInlining.transf_program @@ Renumber.transf_program @@\ntotal_if optim_constprop Constprop.transf_program @@\ntotal_if optim_constprop Renumber.transf_program @@@\npartial_if optim_CSE CSE.transf_program @@@\npartial_if optim_redundancy Deadcode.transf_program @@@\nUnusedglob.transform_program @@@ Allocation.transf_program @@\nTunneling.tunnel_program @@@ Linearize.transf_program @@\nCleanupLabels.transf_program @@@ partial_if debug Debugvar.transf_program @@@\nStacking.transf_program @@@ Asmgen.transf_program = \nOK tp)","proofString":"simpl in T.\nset (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : Inlining.transf_program (total_if optim_tailcalls Tailcall.transf_program p6) @@\nRenumber.transf_program @@ total_if optim_constprop Constprop.transf_program @@\ntotal_if optim_constprop Renumber.transf_program @@@\npartial_if optim_CSE CSE.transf_program @@@\npartial_if optim_redundancy Deadcode.transf_program @@@\nUnusedglob.transform_program @@@ Allocation.transf_program @@\nTunneling.tunnel_program @@@ Linearize.transf_program @@\nCleanupLabels.transf_program @@@ partial_if debug Debugvar.transf_program @@@\nStacking.transf_program @@@ Asmgen.transf_program = \nOK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (T : Inlining.transf_program (total_if optim_tailcalls Tailcall.transf_program p6) @@\nRenumber.transf_program @@ total_if optim_constprop Constprop.transf_program @@\ntotal_if optim_constprop Renumber.transf_program @@@\npartial_if optim_CSE CSE.transf_program @@@\npartial_if optim_redundancy Deadcode.transf_program @@@\nUnusedglob.transform_program @@@ Allocation.transf_program @@\nTunneling.tunnel_program @@@ Linearize.transf_program @@\nCleanupLabels.transf_program @@@ partial_if debug Debugvar.transf_program @@@\nStacking.transf_program @@@ Asmgen.transf_program = \nOK tp)","proofString":"set (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.\ndestruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.\nset (p9 := Renumber.transf_program p8) in *.\nset (p10 := total_if optim_constprop Constprop.transf_program p9) in *.\nset (p11 := total_if optim_constprop Renumber.transf_program p10) in *.\ndestruct (partial_if optim_CSE CSE.transf_program p11) as [p12|e] eqn:P12; simpl in T; try discriminate.\ndestruct (partial_if optim_redundancy Deadcode.transf_program p12) as [p13|e] eqn:P13; simpl in T; try discriminate.\ndestruct (Unusedglob.transform_program p13) as [p14|e] eqn:P14; simpl in T; try discriminate.\ndestruct (Allocation.transf_program p14) as [p15|e] eqn:P15; simpl in T; try discriminate.\nset (p16 := Tunneling.tunnel_program p15) in *.\ndestruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.\nset (p18 := CleanupLabels.transf_program p17) in *.\ndestruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.\ndestruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.\nunfold match_prog; simpl.\nexists p1; split.\napply SimplExprproof.transf_program_match; auto.\nexists p2; split.\napply SimplLocalsproof.match_transf_program; auto.\nexists p3; split.\napply Cshmgenproof.transf_program_match; auto.\nexists p4; split.\napply Cminorgenproof.transf_program_match; auto.\nexists p5; split.\napply Selectionproof.transf_program_match; auto.\nexists p6; split.\napply RTLgenproof.transf_program_match; auto.\nexists p7; split.\napply total_if_match.\napply Tailcallproof.transf_program_match.\nexists p8; split.\napply Inliningproof.transf_program_match; auto.\nexists p9; split.\napply Renumberproof.transf_program_match; auto.\nexists p10; split.\napply total_if_match.\napply Constpropproof.transf_program_match.\nexists p11; split.\napply total_if_match.\napply Renumberproof.transf_program_match.\nexists p12; split.\neapply partial_if_match; eauto.\napply CSEproof.transf_program_match.\nexists p13; split.\neapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match.\nexists p14; split.\napply Unusedglobproof.transf_program_match; auto.\nexists p15; split.\napply Allocproof.transf_program_match; auto.\nexists p16; split.\napply Tunnelingproof.transf_program_match.\nexists p17; split.\napply Linearizeproof.transf_program_match; auto.\nexists p18; split.\napply CleanupLabelsproof.transf_program_match; auto.\nexists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : SimplExprproof.match_prog p p1.","conclusion":"SimplExprproof.match_prog p p1","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply SimplExprproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : SimplLocalsproof.match_prog p1 p2.","conclusion":"SimplLocalsproof.match_prog p1 p2","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply SimplLocalsproof.match_transf_program; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Cshmgenproof.match_prog p2 p3.","conclusion":"Cshmgenproof.match_prog p2 p3","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Cshmgenproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Cminorgenproof.match_prog p3 p4.","conclusion":"Cminorgenproof.match_prog p3 p4","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Cminorgenproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Selectionproof.match_prog p4 p5.","conclusion":"Selectionproof.match_prog p4 p5","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Selectionproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : RTLgenproof.match_prog p5 p6.","conclusion":"RTLgenproof.match_prog p5 p6","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply RTLgenproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : forall p0 : RTL.program,\nTailcallproof.match_prog p0 (Tailcall.transf_program p0).","conclusion":"forall p0 : RTL.program,\nTailcallproof.match_prog p0 (Tailcall.transf_program p0)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Tailcallproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Inliningproof.match_prog p7 p8.","conclusion":"Inliningproof.match_prog p7 p8","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Inliningproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : forall p0 : RTL.program,\nConstpropproof.match_prog p0 (Constprop.transf_program p0).","conclusion":"forall p0 : RTL.program,\nConstpropproof.match_prog p0 (Constprop.transf_program p0)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Constpropproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : forall p0 : RTL.program,\nRenumberproof.match_prog p0 (Renumber.transf_program p0).","conclusion":"forall p0 : RTL.program,\nRenumberproof.match_prog p0 (Renumber.transf_program p0)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Renumberproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : match_if optim_CSE CSEproof.match_prog p11 p12.","conclusion":"match_if optim_CSE CSEproof.match_prog p11 p12","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"eapply partial_if_match; eauto.\napply CSEproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : forall p0 tp0 : RTL.program,\nCSE.transf_program p0 = OK tp0 -> CSEproof.match_prog p0 tp0.","conclusion":"forall p0 tp0 : RTL.program,\nCSE.transf_program p0 = OK tp0 -> CSEproof.match_prog p0 tp0","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply CSEproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : match_if optim_redundancy Deadcodeproof.match_prog p12 p13.","conclusion":"match_if optim_redundancy Deadcodeproof.match_prog p12 p13","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"eapply partial_if_match; eauto.\napply Deadcodeproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : forall p0 tp0 : RTL.program,\nDeadcode.transf_program p0 = OK tp0 -> Deadcodeproof.match_prog p0 tp0.","conclusion":"forall p0 tp0 : RTL.program,\nDeadcode.transf_program p0 = OK tp0 -> Deadcodeproof.match_prog p0 tp0","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Deadcodeproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Unusedglobproof.match_prog p13 p14.","conclusion":"Unusedglobproof.match_prog p13 p14","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Unusedglobproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Allocproof.match_prog p14 p15.","conclusion":"Allocproof.match_prog p14 p15","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Allocproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Linearizeproof.match_prog p16 p17.","conclusion":"Linearizeproof.match_prog p16 p17","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Linearizeproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : exists p0 : Linear.program,\n  match_if debug Debugvarproof.match_prog p18 p0 /\\\n  (exists p21 : Mach.program,\n     Stackingproof.match_prog p0 p21 /\\\n     (exists p22 : Asm.program, Asmgenproof.match_prog p21 p22 /\\ p22 = tp)).","conclusion":"exists p0 : Linear.program,\n  match_if debug Debugvarproof.match_prog p18 p0 /\\\n  (exists p21 : Mach.program,\n     Stackingproof.match_prog p0 p21 /\\\n     (exists p22 : Asm.program, Asmgenproof.match_prog p21 p22 /\\ p22 = tp))","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"exists p19; split.\neapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match.\nexists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : match_if debug Debugvarproof.match_prog p18 p19.","conclusion":"match_if debug Debugvarproof.match_prog p18 p19","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"eapply partial_if_match; eauto.\napply Debugvarproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : forall p0 tp0 : Linear.program,\nDebugvar.transf_program p0 = OK tp0 -> Debugvarproof.match_prog p0 tp0.","conclusion":"forall p0 tp0 : Linear.program,\nDebugvar.transf_program p0 = OK tp0 -> Debugvarproof.match_prog p0 tp0","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Debugvarproof.transf_program_match."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : exists p0 : Mach.program,\n  Stackingproof.match_prog p19 p0 /\\\n  (exists p21 : Asm.program, Asmgenproof.match_prog p0 p21 /\\ p21 = tp).","conclusion":"exists p0 : Mach.program,\n  Stackingproof.match_prog p19 p0 /\\\n  (exists p21 : Asm.program, Asmgenproof.match_prog p0 p21 /\\ p21 = tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"exists p20; split.\napply Stackingproof.transf_program_match; auto.\nexists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Stackingproof.match_prog p19 p20.","conclusion":"Stackingproof.match_prog p19 p20","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Stackingproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : exists p0 : Asm.program, Asmgenproof.match_prog p20 p0 /\\ p0 = tp.","conclusion":"exists p0 : Asm.program, Asmgenproof.match_prog p20 p0 /\\ p0 = tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"exists tp; split.\napply Asmgenproof.transf_program_match; auto.\nreflexivity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : Asmgenproof.match_prog p20 tp.","conclusion":"Asmgenproof.match_prog p20 tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"apply Asmgenproof.transf_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp) : tp = tp.","conclusion":"tp = tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p1 : Clight.program) (P1 : SimplExpr.transl_program p = OK p1) (p2 : Clight.program) (P2 : SimplLocals.transf_program p1 = OK p2) (p3 : Csharpminor.program) (P3 : Cshmgen.transl_program p2 = OK p3) (p4 : Cminor.program) (P4 : Cminorgen.transl_program p3 = OK p4) (p5 : CminorSel.program) (P5 : Selection.sel_program p4 = OK p5) (p6 : RTL.program) (P6 : RTLgen.transl_program p5 = OK p6) (p7 : RTL.program) (p8 : RTL.program) (P8 : Inlining.transf_program p7 = OK p8) (p9 : RTL.program) (p10 : RTL.program) (p11 : RTL.program) (p12 : RTL.program) (P12 : partial_if optim_CSE CSE.transf_program p11 = OK p12) (p13 : RTL.program) (P13 : partial_if optim_redundancy Deadcode.transf_program p12 = OK p13) (p14 : RTL.program) (P14 : Unusedglob.transform_program p13 = OK p14) (p15 : LTL.program) (P15 : Allocation.transf_program p14 = OK p15) (p16 : LTL.program) (p17 : Linear.program) (P17 : Linearize.transf_program p16 = OK p17) (p18 : Linear.program) (p19 : Linear.program) (P19 : partial_if debug Debugvar.transf_program p18 = OK p19) (p20 : Mach.program) (P20 : Stacking.transf_program p19 = OK p20) (T : Asmgen.transf_program p20 = OK tp)","proofString":"reflexivity."},{"statement":"(sem : semantics) : forward_simulation sem sem.","conclusion":"forward_simulation sem sem","hypotheses":"(sem : semantics)","proofString":"apply forward_simulation_step with (fun s1 s2 => s2 = s1); intros.\nauto.\nexists s1; auto.\nsubst s2; auto.\nsubst s2.\nexists s1'; auto."},{"statement":"(sem : semantics) (id : ident) : Globalenvs.Senv.public_symbol (symbolenv sem) id =\nGlobalenvs.Senv.public_symbol (symbolenv sem) id.","conclusion":"Globalenvs.Senv.public_symbol (symbolenv sem) id =\nGlobalenvs.Senv.public_symbol (symbolenv sem) id","hypotheses":"(sem : semantics) (id : ident)","proofString":"auto."},{"statement":"(sem : semantics) (s1 : state sem) (H : initial_state sem s1) : exists s2 : state sem, initial_state sem s2 /\\ s2 = s1.","conclusion":"exists s2 : state sem, initial_state sem s2 /\\ s2 = s1","hypotheses":"(sem : semantics) (s1 : state sem) (H : initial_state sem s1)","proofString":"exists s1; auto."},{"statement":"(sem : semantics) (s1 s2 : state sem) (r : Integers.Int.int) (H : s2 = s1) (H0 : final_state sem s1 r) : final_state sem s2 r.","conclusion":"final_state sem s2 r","hypotheses":"(sem : semantics) (s1 s2 : state sem) (r : Integers.Int.int) (H : s2 = s1) (H0 : final_state sem s1 r)","proofString":"subst s2; auto."},{"statement":"(sem : semantics) (s1 : state sem) (t : Events.trace) (s1' : state sem) (H : Step sem s1 t s1') (s2 : state sem) (H0 : s2 = s1) : exists s2' : state sem, Step sem s2 t s2' /\\ s2' = s1'.","conclusion":"exists s2' : state sem, Step sem s2 t s2' /\\ s2' = s1'","hypotheses":"(sem : semantics) (s1 : state sem) (t : Events.trace) (s1' : state sem) (H : Step sem s1 t s1') (s2 : state sem) (H0 : s2 = s1)","proofString":"subst s2.\nexists s1'; auto."},{"statement":"(sem : semantics) (s1 : state sem) (t : Events.trace) (s1' : state sem) (H : Step sem s1 t s1') : exists s2' : state sem, Step sem s1 t s2' /\\ s2' = s1'.","conclusion":"exists s2' : state sem, Step sem s1 t s2' /\\ s2' = s1'","hypotheses":"(sem : semantics) (s1 : state sem) (t : Events.trace) (s1' : state sem) (H : Step sem s1 t s1')","proofString":"exists s1'; auto."},{"statement":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : match_if flag transf prog tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp)) : forward_simulation (sem prog) (sem tprog).","conclusion":"forward_simulation (sem prog) (sem tprog)","hypotheses":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : match_if flag transf prog tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp))","proofString":"unfold match_if in *.\ndestruct (flag tt).\neauto.\nsubst.\napply forward_simulation_identity."},{"statement":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : (if flag tt then transf else eq) prog tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp)) : forward_simulation (sem prog) (sem tprog).","conclusion":"forward_simulation (sem prog) (sem tprog)","hypotheses":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : (if flag tt then transf else eq) prog tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp))","proofString":"destruct (flag tt).\neauto.\nsubst.\napply forward_simulation_identity."},{"statement":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : transf prog tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp)) : forward_simulation (sem prog) (sem tprog).","conclusion":"forward_simulation (sem prog) (sem tprog)","hypotheses":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : transf prog tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp))","proofString":"eauto."},{"statement":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : prog = tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp)) : forward_simulation (sem prog) (sem tprog).","conclusion":"forward_simulation (sem prog) (sem tprog)","hypotheses":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A) (H : prog = tprog) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp))","proofString":"subst.\napply forward_simulation_identity."},{"statement":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (tprog : A) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp)) : forward_simulation (sem tprog) (sem tprog).","conclusion":"forward_simulation (sem tprog) (sem tprog)","hypotheses":"(A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (tprog : A) (H0 : forall p tp : A, transf p tp -> forward_simulation (sem p) (sem tp))","proofString":"apply forward_simulation_identity."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (M : match_prog p tp) : forward_simulation (Cstrategy.semantics p) (Asm.semantics tp) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics tp) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (M : match_prog p tp)","proofString":"unfold match_prog, pass_match in M; simpl in M.\nLtac DestructM :=  match goal with    [ H: exists p, _ /\\ _ |- _ ] =>      let p := fresh \"p\" in let M := fresh \"M\" in let MM := fresh \"MM\" in      destruct H as (p & M & MM); clear H  end.\nrepeat DestructM.\nsubst tp.\nassert (F: forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)).\neapply compose_forward_simulations.\neapply SimplExprproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply SimplLocalsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cshmgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cminorgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Selectionproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply RTLgenproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Tailcallproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Inliningproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Renumberproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Constpropproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Renumberproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact CSEproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Deadcodeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Unusedglobproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Allocproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Tunnelingproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Linearizeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply CleanupLabelsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Debugvarproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).\nexact Asmgenproof.return_address_exists.\neassumption.\neapply Asmgenproof.transf_program_correct; eassumption.\nsplit.\nauto.\napply forward_to_backward_simulation.\napply factor_forward_simulation.\nauto.\neapply sd_traces.\neapply Asm.semantics_determinate.\napply atomic_receptive.\napply Cstrategy.semantics_strongly_receptive.\napply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (MM : p21 = tp) : forward_simulation (Cstrategy.semantics p) (Asm.semantics tp) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics tp) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (MM : p21 = tp)","proofString":"subst tp.\nassert (F: forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)).\neapply compose_forward_simulations.\neapply SimplExprproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply SimplLocalsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cshmgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cminorgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Selectionproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply RTLgenproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Tailcallproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Inliningproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Renumberproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Constpropproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Renumberproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact CSEproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Deadcodeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Unusedglobproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Allocproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Tunnelingproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Linearizeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply CleanupLabelsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Debugvarproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).\nexact Asmgenproof.return_address_exists.\neassumption.\neapply Asmgenproof.transf_program_correct; eassumption.\nsplit.\nauto.\napply forward_to_backward_simulation.\napply factor_forward_simulation.\nauto.\neapply sd_traces.\neapply Asm.semantics_determinate.\napply atomic_receptive.\napply Cstrategy.semantics_strongly_receptive.\napply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics p21) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21)","proofString":"assert (F: forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)).\neapply compose_forward_simulations.\neapply SimplExprproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply SimplLocalsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cshmgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cminorgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Selectionproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply RTLgenproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Tailcallproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Inliningproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Renumberproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Constpropproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Renumberproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact CSEproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Deadcodeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Unusedglobproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Allocproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Tunnelingproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Linearizeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply CleanupLabelsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Debugvarproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).\nexact Asmgenproof.return_address_exists.\neassumption.\neapply Asmgenproof.transf_program_correct; eassumption.\nsplit.\nauto.\napply forward_to_backward_simulation.\napply factor_forward_simulation.\nauto.\neapply sd_traces.\neapply Asm.semantics_determinate.\napply atomic_receptive.\napply Cstrategy.semantics_strongly_receptive.\napply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21)","proofString":"eapply compose_forward_simulations.\neapply SimplExprproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply SimplLocalsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cshmgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Cminorgenproof.transl_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Selectionproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply RTLgenproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Tailcallproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Inliningproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Renumberproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Constpropproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Renumberproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact CSEproof.transf_program_correct.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Deadcodeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Unusedglobproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Allocproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Tunnelingproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply Linearizeproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply CleanupLabelsproof.transf_program_correct; eassumption.\neapply compose_forward_simulations.\neapply match_if_simulation.\neassumption.\nexact Debugvarproof.transf_program_correct.\neapply compose_forward_simulations.\neapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).\nexact Asmgenproof.return_address_exists.\neassumption.\neapply Asmgenproof.transf_program_correct; eassumption."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) : forall (f : Mach.function) (sg : signature) (ros : Machregs.mreg + ident)\n  (c : list Mach.instruction),\nis_tail (Mach.Mcall sg ros :: c) (Mach.fn_code f) ->\nexists ofs : Integers.Ptrofs.int, Asmgenproof0.return_address_offset f c ofs.","conclusion":"forall (f : Mach.function) (sg : signature) (ros : Machregs.mreg + ident)\n  (c : list Mach.instruction),\nis_tail (Mach.Mcall sg ros :: c) (Mach.fn_code f) ->\nexists ofs : Integers.Ptrofs.int, Asmgenproof0.return_address_offset f c ofs","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21)","proofString":"exact Asmgenproof.return_address_exists."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics p21) /\\\nbackward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"split.\nauto.\napply forward_to_backward_simulation.\napply factor_forward_simulation.\nauto.\neapply sd_traces.\neapply Asm.semantics_determinate.\napply atomic_receptive.\napply Cstrategy.semantics_strongly_receptive.\napply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"auto."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21).","conclusion":"backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"apply forward_to_backward_simulation.\napply factor_forward_simulation.\nauto.\neapply sd_traces.\neapply Asm.semantics_determinate.\napply atomic_receptive.\napply Cstrategy.semantics_strongly_receptive.\napply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : forward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21).","conclusion":"forward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"apply factor_forward_simulation.\nauto.\neapply sd_traces.\neapply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21).","conclusion":"forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"auto."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : single_events (Asm.semantics p21).","conclusion":"single_events (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"eapply sd_traces.\neapply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : determinate (Asm.semantics p21).","conclusion":"determinate (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"eapply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : receptive (atomic (Cstrategy.semantics p)).","conclusion":"receptive (atomic (Cstrategy.semantics p))","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"apply atomic_receptive.\napply Cstrategy.semantics_strongly_receptive."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : strongly_receptive (Cstrategy.semantics p).","conclusion":"strongly_receptive (Cstrategy.semantics p)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"apply Cstrategy.semantics_strongly_receptive."},{"statement":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)) : determinate (Asm.semantics p21).","conclusion":"determinate (Asm.semantics p21)","hypotheses":"(p : Csyntax.program) (p0 : Clight.program) (M0 : SimplExprproof.match_prog p p0) (p1 : Clight.program) (M : SimplLocalsproof.match_prog p0 p1) (p3 : Csharpminor.program) (M1 : Cshmgenproof.match_prog p1 p3) (p4 : Cminor.program) (M2 : Cminorgenproof.match_prog p3 p4) (p5 : CminorSel.program) (M3 : Selectionproof.match_prog p4 p5) (p6 : RTL.program) (M4 : RTLgenproof.match_prog p5 p6) (p7 : RTL.program) (M5 : match_if optim_tailcalls Tailcallproof.match_prog p6 p7) (p8 : RTL.program) (M6 : Inliningproof.match_prog p7 p8) (p9 : RTL.program) (M7 : Renumberproof.match_prog p8 p9) (p10 : RTL.program) (M8 : match_if optim_constprop Constpropproof.match_prog p9 p10) (p11 : RTL.program) (M9 : match_if optim_constprop Renumberproof.match_prog p10 p11) (p12 : RTL.program) (M10 : match_if optim_CSE CSEproof.match_prog p11 p12) (p13 : RTL.program) (M11 : match_if optim_redundancy Deadcodeproof.match_prog p12 p13) (p14 : RTL.program) (M12 : Unusedglobproof.match_prog p13 p14) (p15 : LTL.program) (M13 : Allocproof.match_prog p14 p15) (p16 : LTL.program) (M14 : Tunnelingproof.match_prog p15 p16) (p17 : Linear.program) (M15 : Linearizeproof.match_prog p16 p17) (p18 : Linear.program) (M16 : CleanupLabelsproof.match_prog p17 p18) (p19 : Linear.program) (M17 : match_if debug Debugvarproof.match_prog p18 p19) (p20 : Mach.program) (M18 : Stackingproof.match_prog p19 p20) (p21 : Asm.program) (M19 : Asmgenproof.match_prog p20 p21) (F : forward_simulation (Cstrategy.semantics p) (Asm.semantics p21))","proofString":"apply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : backward_simulation (Csem.semantics p) (Asm.semantics tp).","conclusion":"backward_simulation (Csem.semantics p) (Asm.semantics tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"apply compose_backward_simulation with (atomic (Cstrategy.semantics p)).\neapply sd_traces; eapply Asm.semantics_determinate.\napply factor_backward_simulation.\napply Cstrategy.strategy_simulation.\napply Csem.semantics_single_events.\neapply ssr_well_behaved; eapply Cstrategy.semantics_strongly_receptive.\nexact (proj2 (cstrategy_semantic_preservation _ _ H))."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : single_events (Asm.semantics tp).","conclusion":"single_events (Asm.semantics tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"eapply sd_traces; eapply Asm.semantics_determinate."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : backward_simulation (Csem.semantics p) (atomic (Cstrategy.semantics p)).","conclusion":"backward_simulation (Csem.semantics p) (atomic (Cstrategy.semantics p))","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"apply factor_backward_simulation.\napply Cstrategy.strategy_simulation.\napply Csem.semantics_single_events.\neapply ssr_well_behaved; eapply Cstrategy.semantics_strongly_receptive."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : backward_simulation (Csem.semantics p) (Cstrategy.semantics p).","conclusion":"backward_simulation (Csem.semantics p) (Cstrategy.semantics p)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"apply Cstrategy.strategy_simulation."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : single_events (Csem.semantics p).","conclusion":"single_events (Csem.semantics p)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"apply Csem.semantics_single_events."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : well_behaved_traces (Cstrategy.semantics p).","conclusion":"well_behaved_traces (Cstrategy.semantics p)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"eapply ssr_well_behaved; eapply Cstrategy.semantics_strongly_receptive."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp) : backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp).","conclusion":"backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : match_prog p tp)","proofString":"exact (proj2 (cstrategy_semantic_preservation _ _ H))."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : transf_c_program p = OK tp) : backward_simulation (Csem.semantics p) (Asm.semantics tp).","conclusion":"backward_simulation (Csem.semantics p) (Asm.semantics tp)","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : transf_c_program p = OK tp)","proofString":"apply c_semantic_preservation.\napply transf_c_program_match; auto."},{"statement":"(p : Csyntax.program) (tp : Asm.program) (H : transf_c_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : Asm.program) (H : transf_c_program p = OK tp)","proofString":"apply transf_c_program_match; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) : exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).","conclusion":"exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program)","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program)","proofString":"assert (nlist_forall2 match_prog c_units asm_units).\neapply nlist_forall2_imply.\neauto.\nsimpl; intros.\napply transf_c_program_match; auto.\nassert (exists asm_program, link_list asm_units = Some asm_program /\\ match_prog c_program asm_program).\neapply link_list_compose_passes; eauto.\ndestruct H2 as (asm_program & P & Q).\nexists asm_program; split; auto.\napply c_semantic_preservation; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) : nlist_forall2 match_prog c_units asm_units.","conclusion":"nlist_forall2 match_prog c_units asm_units","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program)","proofString":"eapply nlist_forall2_imply.\neauto.\nsimpl; intros.\napply transf_c_program_match; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (v1 : Csyntax.program) (v2 : Asm.program) (H1 : nIn v1 c_units) (H2 : nIn v2 asm_units) (H3 : transf_c_program v1 = OK v2) : match_prog v1 v2.","conclusion":"match_prog v1 v2","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (v1 : Csyntax.program) (v2 : Asm.program) (H1 : nIn v1 c_units) (H2 : nIn v2 asm_units) (H3 : transf_c_program v1 = OK v2)","proofString":"apply transf_c_program_match; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) : exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).","conclusion":"exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program)","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units)","proofString":"assert (exists asm_program, link_list asm_units = Some asm_program /\\ match_prog c_program asm_program).\neapply link_list_compose_passes; eauto.\ndestruct H2 as (asm_program & P & Q).\nexists asm_program; split; auto.\napply c_semantic_preservation; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) : exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\ match_prog c_program asm_program.","conclusion":"exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\ match_prog c_program asm_program","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units)","proofString":"eapply link_list_compose_passes; eauto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) (H2 : exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\ match_prog c_program asm_program) : exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).","conclusion":"exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program)","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) (H2 : exists asm_program : Asm.program,\n  link_list asm_units = Some asm_program /\\ match_prog c_program asm_program)","proofString":"destruct H2 as (asm_program & P & Q).\nexists asm_program; split; auto.\napply c_semantic_preservation; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) (asm_program : Asm.program) (P : link_list asm_units = Some asm_program) (Q : match_prog c_program asm_program) : exists asm_program0 : Asm.program,\n  link_list asm_units = Some asm_program0 /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program0).","conclusion":"exists asm_program0 : Asm.program,\n  link_list asm_units = Some asm_program0 /\\\n  backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program0)","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) (asm_program : Asm.program) (P : link_list asm_units = Some asm_program) (Q : match_prog c_program asm_program)","proofString":"exists asm_program; split; auto.\napply c_semantic_preservation; auto."},{"statement":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) (asm_program : Asm.program) (P : link_list asm_units = Some asm_program) (Q : match_prog c_program asm_program) : backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).","conclusion":"backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program)","hypotheses":"(c_units : nlist Csyntax.program) (asm_units : nlist Asm.program) (c_program : Csyntax.program) (H : nlist_forall2\n  (fun (cu : Csyntax.program) (tcu : Asm.program) =>\n   transf_c_program cu = OK tcu) c_units asm_units) (H0 : link_list c_units = Some c_program) (H1 : nlist_forall2 match_prog c_units asm_units) (asm_program : Asm.program) (P : link_list asm_units = Some asm_program) (Q : match_prog c_program asm_program)","proofString":"apply c_semantic_preservation; auto."}]}