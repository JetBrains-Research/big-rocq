{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/riscV/Op.v","fileSamples":[{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","conclusion":"(forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}","hypotheses":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0})","proofString":"assert (forall (x y: comparison), {x=y}+{x<>y}).\ndecide equality.\ndecide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}.","conclusion":"forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}","hypotheses":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0})","proofString":"decide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","conclusion":"(forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}","hypotheses":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0})","proofString":"decide equality."},{"statement":"(x y : addressing) (H : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","conclusion":"{x = y} + {x <> y}","hypotheses":"(x y : addressing) (H : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0})","proofString":"decide equality."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H2 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H3 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H4 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H5 : forall x0 y0 : condition, {x0 = y0} + {x0 <> y0}) (x y : operation) : {x = y} + {x <> y}.","conclusion":"{x = y} + {x <> y}","hypotheses":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : int64, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H2 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H3 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H4 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H5 : forall x0 y0 : condition, {x0 = y0} + {x0 <> y0}) (x y : operation)","proofString":"decide equality."},{"statement":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (ofs : ptrofs) : eval_addressing genv sp (Ainstack ofs) nil = Some (Val.offset_ptr sp ofs).","conclusion":"eval_addressing genv sp (Ainstack ofs) nil = Some (Val.offset_ptr sp ofs)","hypotheses":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (ofs : ptrofs)","proofString":"reflexivity."},{"statement":"(v1 v2 : val) : Val.has_type (Val.add v1 v2) Tint.","conclusion":"Val.has_type (Val.add v1 v2) Tint","hypotheses":"(v1 v2 : val)","proofString":"unfold Val.has_type, Val.add.\ndestruct Archi.ptr64, v1, v2; auto."},{"statement":"(v1 v2 : val) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend.","conclusion":"match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vint _ => True\n| Vptr _ _ => Archi.ptr64 = false\n| _ => False\nend","hypotheses":"(v1 v2 : val)","proofString":"destruct Archi.ptr64, v1, v2; auto."},{"statement":"(v1 v2 : val) : Val.has_type (Val.addl v1 v2) Tlong.","conclusion":"Val.has_type (Val.addl v1 v2) Tlong","hypotheses":"(v1 v2 : val)","proofString":"unfold Val.has_type, Val.addl.\ndestruct Archi.ptr64, v1, v2; auto."},{"statement":"(v1 v2 : val) : match\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend.","conclusion":"match\n  match v1 with\n  | Vlong n1 =>\n      match v2 with\n      | Vlong n2 => Vlong (Int64.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1))\n          else Vundef\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vlong n2 =>\n          if Archi.ptr64\n          then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2))\n          else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend","hypotheses":"(v1 v2 : val)","proofString":"destruct Archi.ptr64, v1, v2; auto."},{"statement":"(A : Type) (op : operation) (args : list A) (a : A) : is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil.","conclusion":"is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil","hypotheses":"(A : Type) (op : operation) (args : list A) (a : A)","proofString":"unfold is_move_operation; destruct op;  try (intros; discriminate).\ndestruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (args : list A) (a : A) : match args with\n| nil => None\n| arg :: nil => Some arg\n| arg :: _ :: _ => None\nend = Some a -> Omove = Omove /\\ args = a :: nil.","conclusion":"match args with\n| nil => None\n| arg :: nil => Some arg\n| arg :: _ :: _ => None\nend = Some a -> Omove = Omove /\\ args = a :: nil","hypotheses":"(A : Type) (args : list A) (a : A)","proofString":"destruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a : A) : None = Some a -> Omove = Omove /\\ nil = a :: nil.","conclusion":"None = Some a -> Omove = Omove /\\ nil = a :: nil","hypotheses":"(A : Type) (a : A)","proofString":"intros; discriminate."},{"statement":"(A : Type) (a0 : A) (args : list A) (a : A) : match args with\n| nil => Some a0\n| _ :: _ => None\nend = Some a -> Omove = Omove /\\ a0 :: args = a :: nil.","conclusion":"match args with\n| nil => Some a0\n| _ :: _ => None\nend = Some a -> Omove = Omove /\\ a0 :: args = a :: nil","hypotheses":"(A : Type) (a0 : A) (args : list A) (a : A)","proofString":"destruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a0 a : A) : Some a0 = Some a -> Omove = Omove /\\ a0 :: nil = a :: nil.","conclusion":"Some a0 = Some a -> Omove = Omove /\\ a0 :: nil = a :: nil","hypotheses":"(A : Type) (a0 a : A)","proofString":"intros.\nintuition congruence."},{"statement":"(A : Type) (a0 a : A) (H : Some a0 = Some a) : Omove = Omove /\\ a0 :: nil = a :: nil.","conclusion":"Omove = Omove /\\ a0 :: nil = a :: nil","hypotheses":"(A : Type) (a0 a : A) (H : Some a0 = Some a)","proofString":"intuition congruence."},{"statement":"(A : Type) (a0 a1 : A) (args : list A) (a : A) : None = Some a -> Omove = Omove /\\ a0 :: a1 :: args = a :: nil.","conclusion":"None = Some a -> Omove = Omove /\\ a0 :: a1 :: args = a :: nil","hypotheses":"(A : Type) (a0 a1 : A) (args : list A) (a : A)","proofString":"intros; discriminate."},{"statement":"(cond : condition) (vl : list val) (m : mem) : eval_condition (negate_condition cond) vl m =\noption_map negb (eval_condition cond vl m).","conclusion":"eval_condition (negate_condition cond) vl m =\noption_map negb (eval_condition cond vl m)","hypotheses":"(cond : condition) (vl : list val) (m : mem)","proofString":"destruct cond; simpl.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpl_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmplu_bool.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0) as [[]|]; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmp_bool c v v0).","conclusion":"Val.cmp_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmp_bool c v v0)","hypotheses":"(c : comparison) (v v0 : val) (m : mem)","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v v0).","conclusion":"Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v v0)","hypotheses":"(c : comparison) (v v0 : val) (m : mem)","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (n : int) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (n : int) (v : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmp_bool c v (Vint n)).","conclusion":"Val.cmp_bool (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmp_bool c v (Vint n))","hypotheses":"(c : comparison) (n : int) (v : val) (m : mem)","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (n : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vint n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint n)\n  | v1 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (n : int) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (n : int) (v : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (Vint n)).","conclusion":"Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vint n) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (Vint n))","hypotheses":"(c : comparison) (n : int) (v : val) (m : mem)","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpl_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpl_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpl_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpl_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmpl_bool c v v0).","conclusion":"Val.cmpl_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmpl_bool c v v0)","hypotheses":"(c : comparison) (v v0 : val) (m : mem)","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v v0).","conclusion":"Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v v0)","hypotheses":"(c : comparison) (v v0 : val) (m : mem)","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => Val.cmpl_bool (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpl_bool c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (n : int64) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (n : int64) (v : val) (m : mem) : Val.cmpl_bool (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmpl_bool c v (Vlong n)).","conclusion":"Val.cmpl_bool (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmpl_bool c v (Vlong n))","hypotheses":"(c : comparison) (n : int64) (v : val) (m : mem)","proofString":"apply Val.negate_cmpl_bool."},{"statement":"(c : comparison) (n : int64) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vlong n)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmplu_bool (Mem.valid_pointer m) c v1 (Vlong n)\n  | v1 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (n : int64) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (n : int64) (v : val) (m : mem) : Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v (Vlong n)).","conclusion":"Val.cmplu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vlong n) =\noption_map negb (Val.cmplu_bool (Mem.valid_pointer m) c v (Vlong n))","hypotheses":"(c : comparison) (n : int64) (v : val) (m : mem)","proofString":"apply Val.negate_cmplu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpf_bool c v v0 =\noption_map negb (option_map negb (Val.cmpf_bool c v v0)).","conclusion":"Val.cmpf_bool c v v0 =\noption_map negb (option_map negb (Val.cmpf_bool c v v0))","hypotheses":"(c : comparison) (v v0 : val) (m : mem)","proofString":"destruct (Val.cmpf_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","conclusion":"match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end","hypotheses":"(c : comparison) (vl : list val) (m : mem)","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpfs_bool c v v0 =\noption_map negb (option_map negb (Val.cmpfs_bool c v v0)).","conclusion":"Val.cmpfs_bool c v v0 =\noption_map negb (option_map negb (Val.cmpfs_bool c v v0))","hypotheses":"(c : comparison) (v v0 : val) (m : mem)","proofString":"destruct (Val.cmpfs_bool c v v0) as [[]|]; auto."},{"statement":"(delta : Z) (addr : addressing) : type_of_addressing (shift_stack_addressing delta addr) =\ntype_of_addressing addr.","conclusion":"type_of_addressing (shift_stack_addressing delta addr) =\ntype_of_addressing addr","hypotheses":"(delta : Z) (addr : addressing)","proofString":"destruct addr; auto."},{"statement":"(delta : Z) (op : operation) : type_of_operation (shift_stack_operation delta op) = type_of_operation op.","conclusion":"type_of_operation (shift_stack_operation delta op) = type_of_operation op","hypotheses":"(delta : Z) (op : operation)","proofString":"destruct op; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing ge (Vptr sp Ptrofs.zero) (shift_stack_addressing delta addr)\n  vl = eval_addressing ge (Vptr sp (Ptrofs.repr delta)) addr vl.","conclusion":"eval_addressing ge (Vptr sp Ptrofs.zero) (shift_stack_addressing delta addr)\n  vl = eval_addressing ge (Vptr sp (Ptrofs.repr delta)) addr vl","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z)","proofString":"destruct addr; simpl; auto.\ndestruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (vl : list val) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta))))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))\n| _ :: _ => None\nend.","conclusion":"match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta))))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))\n| _ :: _ => None\nend","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (vl : list val) (delta : Z)","proofString":"destruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (delta : Z) : Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i)).","conclusion":"Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add i (Ptrofs.repr delta)))) =\nSome (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (delta : Z)","proofString":"rewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (op : operation) (vl : list val) (m : mem) (delta : Z) : eval_operation ge (Vptr sp Ptrofs.zero) (shift_stack_operation delta op) vl m =\neval_operation ge (Vptr sp (Ptrofs.repr delta)) op vl m.","conclusion":"eval_operation ge (Vptr sp Ptrofs.zero) (shift_stack_operation delta op) vl m =\neval_operation ge (Vptr sp (Ptrofs.repr delta)) op vl m","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (op : operation) (vl : list val) (m : mem) (delta : Z)","proofString":"destruct op; simpl; auto.\ndestruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (vl : list val) (m : mem) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta))))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs))\n| _ :: _ => None\nend.","conclusion":"match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta))))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs))\n| _ :: _ => None\nend","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (vl : list val) (m : mem) (delta : Z)","proofString":"destruct vl; auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (m : mem) (delta : Z) : Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta)))) =\nSome (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs)).","conclusion":"Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add ofs (Ptrofs.repr delta)))) =\nSome (Vptr sp (Ptrofs.add (Ptrofs.repr delta) ofs))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (ofs : ptrofs) (m : mem) (delta : Z)","proofString":"rewrite Ptrofs.add_zero_l, Ptrofs.add_commut; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta))).","conclusion":"eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false)","proofString":"assert (A: forall x n,             Val.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =             Val.add (Val.offset_ptr x n) (Vint (Int.repr delta))).\nintros; destruct x; simpl; auto.\nrewrite H1.\nrewrite Ptrofs.add_assoc.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs.\ndestruct addr; simpl in H; inv H; simpl in *; FuncInv; subst.\nrewrite A; auto.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge i); auto.\nsimpl.\nrewrite H1.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs.\nrewrite A; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta)).","conclusion":"forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false)","proofString":"intros; destruct x; simpl; auto.\nrewrite H1.\nrewrite Ptrofs.add_assoc.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs) : Vptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.repr delta))) =\n(if Archi.ptr64\n then Vundef\n else Vptr b (Ptrofs.add (Ptrofs.add i n) (Ptrofs.of_int (Int.repr delta)))).","conclusion":"Vptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.repr delta))) =\n(if Archi.ptr64\n then Vundef\n else Vptr b (Ptrofs.add (Ptrofs.add i n) (Ptrofs.of_int (Int.repr delta))))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs)","proofString":"rewrite H1.\nrewrite Ptrofs.add_assoc.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs) : Vptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.repr delta))) =\nVptr b (Ptrofs.add (Ptrofs.add i n) (Ptrofs.of_int (Int.repr delta))).","conclusion":"Vptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.repr delta))) =\nVptr b (Ptrofs.add (Ptrofs.add i n) (Ptrofs.of_int (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs)","proofString":"rewrite Ptrofs.add_assoc.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs) : Vptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.repr delta))) =\nVptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.of_int (Int.repr delta)))).","conclusion":"Vptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.repr delta))) =\nVptr b (Ptrofs.add i (Ptrofs.add n (Ptrofs.of_int (Int.repr delta))))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs)","proofString":"f_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs) : Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta).","conclusion":"Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta)","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (b : block) (i n : ptrofs)","proofString":"symmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) : eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta))).","conclusion":"eval_addressing ge sp addr' args = Some (Val.add v (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (addr : addressing) (args : list val) (delta : Z) (addr' : addressing) (v : val) (H : offset_addressing addr delta = Some addr') (H0 : eval_addressing ge sp addr args = Some v) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta)))","proofString":"destruct addr; simpl in H; inv H; simpl in *; FuncInv; subst.\nrewrite A; auto.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge i); auto.\nsimpl.\nrewrite H1.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs.\nrewrite A; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ptrofs) (v0 : val) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) : Some (Val.offset_ptr v0 (Ptrofs.add i (Ptrofs.repr delta))) =\nSome (Val.add (Val.offset_ptr v0 i) (Vint (Int.repr delta))).","conclusion":"Some (Val.offset_ptr v0 (Ptrofs.add i (Ptrofs.repr delta))) =\nSome (Val.add (Val.offset_ptr v0 i) (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ptrofs) (v0 : val) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta)))","proofString":"rewrite A; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) : Some (Genv.symbol_address ge i (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta))).","conclusion":"Some (Genv.symbol_address ge i (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Val.add (Genv.symbol_address ge i i0) (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta)))","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge i); auto.\nsimpl.\nrewrite H1.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) : Some\n  match Genv.find_symbol ge i with\n  | Some b => Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))\n  | None => Vundef\n  end =\nSome\n  (Val.add\n     match Genv.find_symbol ge i with\n     | Some b => Vptr b i0\n     | None => Vundef\n     end (Vint (Int.repr delta))).","conclusion":"Some\n  match Genv.find_symbol ge i with\n  | Some b => Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))\n  | None => Vundef\n  end =\nSome\n  (Val.add\n     match Genv.find_symbol ge i with\n     | Some b => Vptr b i0\n     | None => Vundef\n     end (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta)))","proofString":"destruct (Genv.find_symbol ge i); auto.\nsimpl.\nrewrite H1.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Val.add (Vptr b i0) (Vint (Int.repr delta))).","conclusion":"Some (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Val.add (Vptr b i0) (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block)","proofString":"simpl.\nrewrite H1.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome\n  (if Archi.ptr64\n   then Vundef\n   else Vptr b (Ptrofs.add i0 (Ptrofs.of_int (Int.repr delta)))).","conclusion":"Some (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome\n  (if Archi.ptr64\n   then Vundef\n   else Vptr b (Ptrofs.add i0 (Ptrofs.of_int (Int.repr delta))))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block)","proofString":"rewrite H1.\nf_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block) : Some (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Vptr b (Ptrofs.add i0 (Ptrofs.of_int (Int.repr delta)))).","conclusion":"Some (Vptr b (Ptrofs.add i0 (Ptrofs.repr delta))) =\nSome (Vptr b (Ptrofs.add i0 (Ptrofs.of_int (Int.repr delta))))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block)","proofString":"f_equal; f_equal; f_equal.\nsymmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block) : Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta).","conclusion":"Ptrofs.repr delta = Ptrofs.of_int (Int.repr delta)","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ident) (i0 : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) (b : block)","proofString":"symmetry; auto with ptrofs."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta))) : Some (Val.offset_ptr sp (Ptrofs.add i (Ptrofs.repr delta))) =\nSome (Val.add (Val.offset_ptr sp i) (Vint (Int.repr delta))).","conclusion":"Some (Val.offset_ptr sp (Ptrofs.add i (Ptrofs.repr delta))) =\nSome (Val.add (Val.offset_ptr sp i) (Vint (Int.repr delta)))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : ptrofs) (delta : Z) (H1 : Archi.ptr64 = false) (A : forall (x : val) (n : ptrofs),\nVal.offset_ptr x (Ptrofs.add n (Ptrofs.repr delta)) =\nVal.add (Val.offset_ptr x n) (Vint (Int.repr delta)))","proofString":"rewrite A; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (op : operation) (args : list val) (m1 m2 : mem) : op_depends_on_memory op = false ->\neval_operation ge sp op args m1 = eval_operation ge sp op args m2.","conclusion":"op_depends_on_memory op = false ->\neval_operation ge sp op args m1 = eval_operation ge sp op args m2","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (op : operation) (args : list val) (m1 m2 : mem)","proofString":"destruct op; simpl; try congruence.\ndestruct cond; simpl; intros SF; auto; rewrite ? negb_false_iff in SF;  unfold Val.cmpu_bool, Val.cmplu_bool; rewrite SF; reflexivity."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (args : list val) (m1 m2 : mem) : match cond with\n| Ccompu _ | Ccompuimm _ _ => negb Archi.ptr64\n| Ccomplu _ | Ccompluimm _ _ => Archi.ptr64\n| _ => false\nend = false ->\nSome (Val.of_optbool (eval_condition cond args m1)) =\nSome (Val.of_optbool (eval_condition cond args m2)).","conclusion":"match cond with\n| Ccompu _ | Ccompuimm _ _ => negb Archi.ptr64\n| Ccomplu _ | Ccompluimm _ _ => Archi.ptr64\n| _ => false\nend = false ->\nSome (Val.of_optbool (eval_condition cond args m1)) =\nSome (Val.of_optbool (eval_condition cond args m2))","hypotheses":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (cond : condition) (args : list val) (m1 m2 : mem)","proofString":"destruct cond; simpl; intros SF; auto; rewrite ? negb_false_iff in SF;  unfold Val.cmpu_bool, Val.cmplu_bool; rewrite SF; reflexivity."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.","conclusion":"eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl","hypotheses":"(sp : val) (addr : addressing) (vl : list val)","proofString":"unfold eval_addressing; destruct addr; auto.\ndestruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (i : ident) (i0 : ptrofs) (vl : list val) : match vl with\n| nil => Some (Genv.symbol_address ge2 i i0)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 i i0)\n| _ :: _ => None\nend.","conclusion":"match vl with\n| nil => Some (Genv.symbol_address ge2 i i0)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 i i0)\n| _ :: _ => None\nend","hypotheses":"(sp : val) (i : ident) (i0 : ptrofs) (vl : list val)","proofString":"destruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (i : ident) (i0 : ptrofs) : Some (Genv.symbol_address ge2 i i0) = Some (Genv.symbol_address ge1 i i0).","conclusion":"Some (Genv.symbol_address ge2 i i0) = Some (Genv.symbol_address ge1 i i0)","hypotheses":"(sp : val) (i : ident) (i0 : ptrofs)","proofString":"unfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (i : ident) (i0 : ptrofs) : Some\n  match Genv.find_symbol ge2 i with\n  | Some b => Vptr b i0\n  | None => Vundef\n  end =\nSome\n  match Genv.find_symbol ge1 i with\n  | Some b => Vptr b i0\n  | None => Vundef\n  end.","conclusion":"Some\n  match Genv.find_symbol ge2 i with\n  | Some b => Vptr b i0\n  | None => Vundef\n  end =\nSome\n  match Genv.find_symbol ge1 i with\n  | Some b => Vptr b i0\n  | None => Vundef\n  end","hypotheses":"(sp : val) (i : ident) (i0 : ptrofs)","proofString":"rewrite agree_on_symbols; auto."},{"statement":"(sp : val) (op : operation) (vl : list val) (m : mem) : eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.","conclusion":"eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m","hypotheses":"(sp : val) (op : operation) (vl : list val) (m : mem)","proofString":"unfold eval_operation; destruct op; auto.\ndestruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (vl : list val) (m : mem) : match vl with\n| nil => Some (Genv.symbol_address ge2 id ofs)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 id ofs)\n| _ :: _ => None\nend.","conclusion":"match vl with\n| nil => Some (Genv.symbol_address ge2 id ofs)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 id ofs)\n| _ :: _ => None\nend","hypotheses":"(sp : val) (id : ident) (ofs : ptrofs) (vl : list val) (m : mem)","proofString":"destruct vl; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (m : mem) : Some (Genv.symbol_address ge2 id ofs) = Some (Genv.symbol_address ge1 id ofs).","conclusion":"Some (Genv.symbol_address ge2 id ofs) = Some (Genv.symbol_address ge1 id ofs)","hypotheses":"(sp : val) (id : ident) (ofs : ptrofs) (m : mem)","proofString":"unfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (id : ident) (ofs : ptrofs) (m : mem) : Some\n  match Genv.find_symbol ge2 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end =\nSome\n  match Genv.find_symbol ge1 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Some\n  match Genv.find_symbol ge2 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end =\nSome\n  match Genv.find_symbol ge1 id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(sp : val) (id : ident) (ofs : ptrofs) (m : mem)","proofString":"rewrite agree_on_symbols; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (H : Val.inject_list f vl1 vl2) (H0 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","conclusion":"eval_condition cond vl2 m2 = Some b","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (H : Val.inject_list f vl1 vl2) (H0 : eval_condition cond vl1 m1 = Some b)","proofString":"destruct cond; simpl in H0; FuncInv; InvInject; simpl; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\ninv H3; simpl in H0; inv H0; auto.\neauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\ninv H3; inv H2; simpl in H0; inv H0; auto.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies.\ninv H3; simpl in H0; inv H0; auto.\neauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' v'0 = Some b.","conclusion":"Val.cmp_bool c v' v'0 = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","conclusion":"Val.cmpu_bool (Mem.valid_pointer m2) c v' v'0 = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmp_bool c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool c v' (Vint n) = Some b.","conclusion":"Val.cmp_bool c v' (Vint n) = Some b","hypotheses":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmp_bool c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v')","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpu_bool (Mem.valid_pointer m2) c v' (Vint n) = Some b.","conclusion":"Val.cmpu_bool (Mem.valid_pointer m2) c v' (Vint n) = Some b","hypotheses":"(c : comparison) (n : int) (v : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (Vint n) = Some b) (v' : val) (H3 : Val.inject f v v')","proofString":"eauto 3 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpl_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpl_bool c v' v'0 = Some b.","conclusion":"Val.cmpl_bool c v' v'0 = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpl_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmplu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","conclusion":"Val.cmplu_bool (Mem.valid_pointer m2) c v' v'0 = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmpl_bool c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpl_bool c v' (Vlong n) = Some b.","conclusion":"Val.cmpl_bool c v' (Vlong n) = Some b","hypotheses":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmpl_bool c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v')","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmplu_bool (Mem.valid_pointer m2) c v' (Vlong n) = Some b.","conclusion":"Val.cmplu_bool (Mem.valid_pointer m2) c v' (Vlong n) = Some b","hypotheses":"(c : comparison) (n : int64) (v : val) (b : bool) (H0 : Val.cmplu_bool (Mem.valid_pointer m1) c v (Vlong n) = Some b) (v' : val) (H3 : Val.inject f v v')","proofString":"eauto 3 using Val.cmplu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpf_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpf_bool c v' v'0 = Some b.","conclusion":"Val.cmpf_bool c v' v'0 = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpf_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpf_bool c v' v'0) = Some b.","conclusion":"option_map negb (Val.cmpf_bool c v' v'0) = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpfs_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpfs_bool c v' v'0 = Some b.","conclusion":"Val.cmpfs_bool c v' v'0 = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpfs_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpfs_bool c v' v'0) = Some b.","conclusion":"option_map negb (Val.cmpfs_bool c v' v'0) = Some b","hypotheses":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(op : operation) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_operation ge1 sp1 op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation ge2 sp2 op vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_operation ge2 sp2 op vl2 m2 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(op : operation) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_operation ge1 sp1 op vl1 m1 = Some v1)","proofString":"destruct op; simpl in H1; simpl; FuncInv; InvInject; TrivialExists.\napply GL; simpl; auto.\napply Val.offset_ptr_inject; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\napply Val.add_inject; auto.\napply Val.add_inject; auto.\ninv H4; simpl; auto.\napply Val.sub_inject; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero                     || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto.\ninv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\napply Val.addl_inject; auto.\napply Val.addl_inject; auto.\ninv H4; simpl; auto.\napply Val.subl_inject; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero                     || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto.\ninv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\ninv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists.\nsubst v1.\ndestruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(id : ident) (ofs : ptrofs) (sp1 sp2 : val) (GL : forall (id0 : ident) (ofs0 : ptrofs),\nIn id0 (globals_operation (Oaddrsymbol id ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id0 ofs0)\n  (Genv.symbol_address ge2 id0 ofs0)) (H : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs).","conclusion":"Val.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (sp1 sp2 : val) (GL : forall (id0 : ident) (ofs0 : ptrofs),\nIn id0 (globals_operation (Oaddrsymbol id ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id0 ofs0)\n  (Genv.symbol_address ge2 id0 ofs0)) (H : Val.inject f sp1 sp2)","proofString":"apply GL; simpl; auto."},{"statement":"(ofs : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs0 : ptrofs),\nIn id (globals_operation (Oaddrstack ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs0)\n  (Genv.symbol_address ge2 id ofs0)) (H : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 ofs) (Val.offset_ptr sp2 ofs).","conclusion":"Val.inject f (Val.offset_ptr sp1 ofs) (Val.offset_ptr sp2 ofs)","hypotheses":"(ofs : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs0 : ptrofs),\nIn id (globals_operation (Oaddrstack ofs)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs0)\n  (Genv.symbol_address ge2 id ofs0)) (H : Val.inject f sp1 sp2)","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast8signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 8 v) (Val.sign_ext 8 v').","conclusion":"Val.inject f (Val.sign_ext 8 v) (Val.sign_ext 8 v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast8signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast16signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 16 v) (Val.sign_ext 16 v').","conclusion":"Val.inject f (Val.sign_ext 16 v) (Val.sign_ext 16 v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast16signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oadd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.add v v0) (Val.add v' v'0).","conclusion":"Val.inject f (Val.add v v0) (Val.add v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oadd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"apply Val.add_inject; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.add v (Vint n)) (Val.add v' (Vint n)).","conclusion":"Val.inject f (Val.add v (Vint n)) (Val.add v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"apply Val.add_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oneg) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.neg v) (Val.neg v').","conclusion":"Val.inject f (Val.neg v) (Val.neg v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oneg) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v v0) (Val.sub v' v'0).","conclusion":"Val.inject f (Val.sub v v0) (Val.sub v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"apply Val.sub_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omul) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mul v v0) (Val.mul v' v'0).","conclusion":"Val.inject f (Val.mul v v0) (Val.mul v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omul) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhs v v0) (Val.mulhs v' v'0).","conclusion":"Val.inject f (Val.mulhs v v0) (Val.mulhs v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhu v v0) (Val.mulhu v' v'0).","conclusion":"Val.inject f (Val.mulhu v v0) (Val.mulhu v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divs v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divs v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.divs v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divs v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val, Val.divs (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.divs (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1)","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1)","proofString":"destruct (Int.eq i0 Int.zero              || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divs i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divs i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vint (Int.divs i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divs i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.divu v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val, Val.divu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.divu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1)","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1)","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divu i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vint (Int.divu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divu i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.mods v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.mods v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.mods v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.mods v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero                     || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v1) : exists v2 : val, Val.mods (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.mods (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v1)","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero                     || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.mods i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.mods i i0))) = Some v2 /\\ \n  Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v1)","proofString":"destruct (Int.eq i0 Int.zero                     || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.mods i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.mods i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vint (Int.mods i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.mods i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omod) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.modu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.modu v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v1) : exists v2 : val, Val.modu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.modu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v1)","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v1)","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.modu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.modu i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vint (Int.modu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.modu i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v v0) (Val.and v' v'0).","conclusion":"Val.inject f (Val.and v v0) (Val.and v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.and v (Vint n)) (Val.and v' (Vint n)).","conclusion":"Val.inject f (Val.and v (Vint n)) (Val.and v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v v0) (Val.or v' v'0).","conclusion":"Val.inject f (Val.or v v0) (Val.or v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.or v (Vint n)) (Val.or v' (Vint n)).","conclusion":"Val.inject f (Val.or v (Vint n)) (Val.or v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v v0) (Val.xor v' v'0).","conclusion":"Val.inject f (Val.xor v v0) (Val.xor v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xor v (Vint n)) (Val.xor v' (Vint n)).","conclusion":"Val.inject f (Val.xor v (Vint n)) (Val.xor v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shl v v0) (Val.shl v' v'0).","conclusion":"Val.inject f (Val.shl v v0) (Val.shl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shl v (Vint n)) (Val.shl v' (Vint n)).","conclusion":"Val.inject f (Val.shl v (Vint n)) (Val.shl v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : Val.inject f (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef).","conclusion":"Val.inject f (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shl i n) else Vundef)","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"destruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shr v v0) (Val.shr v' v'0).","conclusion":"Val.inject f (Val.shr v v0) (Val.shr v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shr v (Vint n)) (Val.shr v' (Vint n)).","conclusion":"Val.inject f (Val.shr v (Vint n)) (Val.shr v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : Val.inject f (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef).","conclusion":"Val.inject f (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef)","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"destruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shru v v0) (Val.shru v' v'0).","conclusion":"Val.inject f (Val.shru v v0) (Val.shru v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int)","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshruimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shru v (Vint n)) (Val.shru v' (Vint n)).","conclusion":"Val.inject f (Val.shru v (Vint n)) (Val.shru v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshruimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshruimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : Val.inject f\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef)\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru i n) else Vundef)","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshruimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"destruct (Int.ltu n Int.iwordsize); auto."},{"statement":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrx v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrx v' (Vint n) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.shrx v' (Vint n) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrx v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1) : exists v2 : val, Val.shrx (Vint i) (Vint n) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.shrx (Vint i) (Vint n) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1)","proofString":"simpl.\ndestruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2","hypotheses":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) (H1 : (if Int.ltu n (Int.repr 31) then Some (Vint (Int.shrx i n)) else None) =\nSome v1)","proofString":"destruct (Int.ltu n (Int.repr 31)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vint (Int.shrx i n)) = Some v2 /\\\n  Val.inject f (Vint (Int.shrx i n)) v2.","conclusion":"exists v2 : val,\n  Some (Vint (Int.shrx i n)) = Some v2 /\\\n  Val.inject f (Vint (Int.shrx i n)) v2","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omakelong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.longofwords v v0) (Val.longofwords v' v'0).","conclusion":"Val.inject f (Val.longofwords v v0) (Val.longofwords v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omakelong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olowlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.loword v) (Val.loword v').","conclusion":"Val.inject f (Val.loword v) (Val.loword v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olowlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ohighlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.hiword v) (Val.hiword v').","conclusion":"Val.inject f (Val.hiword v) (Val.hiword v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ohighlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.longofint v) (Val.longofint v').","conclusion":"Val.inject f (Val.longofint v) (Val.longofint v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32unsigned) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.longofintu v) (Val.longofintu v').","conclusion":"Val.inject f (Val.longofintu v) (Val.longofintu v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast32unsigned) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addl v v0) (Val.addl v' v'0).","conclusion":"Val.inject f (Val.addl v v0) (Val.addl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"apply Val.addl_inject; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.addl v (Vlong n)) (Val.addl v' (Vlong n)).","conclusion":"Val.inject f (Val.addl v (Vlong n)) (Val.addl v' (Vlong n))","hypotheses":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"apply Val.addl_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negl v) (Val.negl v').","conclusion":"Val.inject f (Val.negl v) (Val.negl v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subl v v0) (Val.subl v' v'0).","conclusion":"Val.inject f (Val.subl v v0) (Val.subl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"apply Val.subl_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omull) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mull v v0) (Val.mull v' v'0).","conclusion":"Val.inject f (Val.mull v v0) (Val.mull v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omull) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mullhs v v0) (Val.mullhs v' v'0).","conclusion":"Val.inject f (Val.mullhs v v0) (Val.mullhs v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mullhu v v0) (Val.mullhu v' v'0).","conclusion":"Val.inject f (Val.mullhu v v0) (Val.mullhu v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omullhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divls v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.divls v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1) : exists v2 : val,\n  Val.divls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.divls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1)","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v1)","proofString":"destruct (Int64.eq i0 Int64.zero              || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.divs i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divs i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vlong (Int64.divs i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divs i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divlu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.divlu v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1) : exists v2 : val,\n  Val.divlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.divlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1)","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1) : exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v1)","proofString":"destruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.divu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divu i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vlong (Int64.divu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.divu i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.modls v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.modls v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modls v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero                     || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v1) : exists v2 : val,\n  Val.modls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.modls (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v1)","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero                     || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.mods i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.mods i i0))) = Some v2 /\\ \n  Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v1)","proofString":"destruct (Int64.eq i0 Int64.zero                     || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.mods i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.mods i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vlong (Int64.mods i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.mods i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.modlu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.modlu v' v'0 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.modlu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0)","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v1) : exists v2 : val,\n  Val.modlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.modlu (Vlong i) (Vlong i0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v1)","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v1) : exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) (H2 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v1)","proofString":"destruct (Int64.eq i0 Int64.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64) : exists v2 : val,\n  Some (Vlong (Int64.modu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.modu i i0)) v2.","conclusion":"exists v2 : val,\n  Some (Vlong (Int64.modu i i0)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.modu i i0)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omodlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oandl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.andl v v0) (Val.andl v' v'0).","conclusion":"Val.inject f (Val.andl v v0) (Val.andl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oandl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.andl v (Vlong n)) (Val.andl v' (Vlong n)).","conclusion":"Val.inject f (Val.andl v (Vlong n)) (Val.andl v' (Vlong n))","hypotheses":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.orl v v0) (Val.orl v' v'0).","conclusion":"Val.inject f (Val.orl v v0) (Val.orl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.orl v (Vlong n)) (Val.orl v' (Vlong n)).","conclusion":"Val.inject f (Val.orl v (Vlong n)) (Val.orl v' (Vlong n))","hypotheses":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xorl v v0) (Val.xorl v' v'0).","conclusion":"Val.inject f (Val.xorl v v0) (Val.xorl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxorl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xorl v (Vlong n)) (Val.xorl v' (Vlong n)).","conclusion":"Val.inject f (Val.xorl v (Vlong n)) (Val.xorl v' (Vlong n))","hypotheses":"(n : int64) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shll v v0) (Val.shll v' v'0).","conclusion":"Val.inject f (Val.shll v v0) (Val.shll v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef)","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshll) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int)","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shll v (Vint n)) (Val.shll v' (Vint n)).","conclusion":"Val.inject f (Val.shll v (Vint n)) (Val.shll v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef)","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshllimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shrl v v0) (Val.shrl v' v'0).","conclusion":"Val.inject f (Val.shrl v v0) (Val.shrl v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int)","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shrl v (Vint n)) (Val.shrl v' (Vint n)).","conclusion":"Val.inject f (Val.shrl v (Vint n)) (Val.shrl v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shrlu v v0) (Val.shrlu v' v'0).","conclusion":"Val.inject f (Val.shrlu v v0) (Val.shrlu v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef)","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshrlu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (i0 : int)","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrluimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.shrlu v (Vint n)) (Val.shrlu v' (Vint n)).","conclusion":"Val.inject f (Val.shrlu v (Vint n)) (Val.shrlu v' (Vint n))","hypotheses":"(n : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrluimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrluimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef).","conclusion":"Val.inject f\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef)\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef)","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrluimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto."},{"statement":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrxl v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrxl v' (Vint n) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.shrxl v' (Vint n) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(n : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrxl v (Vint n) = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; try discriminate.\nsimpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1) : exists v2 : val, Val.shrxl (Vlong i) (Vint n) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.shrxl (Vlong i) (Vint n) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1)","proofString":"simpl.\ndestruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\n  Some v2 /\\ Val.inject f v1 v2","hypotheses":"(n : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) (H1 : (if Int.ltu n (Int.repr 63) then Some (Vlong (Int64.shrx' i n)) else None) =\nSome v1)","proofString":"destruct (Int.ltu n (Int.repr 63)); inv H1.\nTrivialExists."},{"statement":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vlong (Int64.shrx' i n)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.shrx' i n)) v2.","conclusion":"exists v2 : val,\n  Some (Vlong (Int64.shrx' i n)) = Some v2 /\\\n  Val.inject f (Vlong (Int64.shrx' i n)) v2","hypotheses":"(n : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrxlimm n)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negf v) (Val.negf v').","conclusion":"Val.inject f (Val.negf v) (Val.negf v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absf v) (Val.absf v').","conclusion":"Val.inject f (Val.absf v) (Val.absf v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addf v v0) (Val.addf v' v'0).","conclusion":"Val.inject f (Val.addf v v0) (Val.addf v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subf v v0) (Val.subf v' v'0).","conclusion":"Val.inject f (Val.subf v v0) (Val.subf v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulf v v0) (Val.mulf v' v'0).","conclusion":"Val.inject f (Val.mulf v v0) (Val.mulf v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divf v v0) (Val.divf v' v'0).","conclusion":"Val.inject f (Val.divf v v0) (Val.divf v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negfs v) (Val.negfs v').","conclusion":"Val.inject f (Val.negfs v) (Val.negfs v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absfs v) (Val.absfs v').","conclusion":"Val.inject f (Val.absfs v) (Val.absfs v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addfs v v0) (Val.addfs v' v'0).","conclusion":"Val.inject f (Val.addfs v v0) (Val.addfs v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subfs v v0) (Val.subfs v' v'0).","conclusion":"Val.inject f (Val.subfs v v0) (Val.subfs v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulfs v v0) (Val.mulfs v' v'0).","conclusion":"Val.inject f (Val.mulfs v v0) (Val.mulfs v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divfs v v0) (Val.divfs v' v'0).","conclusion":"Val.inject f (Val.divfs v v0) (Val.divfs v' v'0)","hypotheses":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0)","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.singleoffloat v) (Val.singleoffloat v').","conclusion":"Val.inject f (Val.singleoffloat v) (Val.singleoffloat v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.floatofsingle v) (Val.floatofsingle v').","conclusion":"Val.inject f (Val.floatofsingle v) (Val.floatofsingle v')","hypotheses":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intoffloat v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intoffloat v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val, Val.intoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1)","proofString":"simpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vint (Float.to_int f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1)","proofString":"destruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","conclusion":"exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int)","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intuoffloat v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intuoffloat v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1) : exists v2 : val, Val.intuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1)","proofString":"simpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_intu f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vint (Float.to_intu f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1)","proofString":"destruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","conclusion":"exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int)","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofint v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.floatofint v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofint v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.floatofint (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","conclusion":"exists v2 : val,\n  Val.floatofint (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_int i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","conclusion":"exists v2 : val,\n  Some (Vfloat (Float.of_int i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofintu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofintu v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.floatofintu v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofintu v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.floatofintu (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2.","conclusion":"exists v2 : val,\n  Val.floatofintu (Vint i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_intu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2.","conclusion":"exists v2 : val,\n  Some (Vfloat (Float.of_intu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intofsingle v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intofsingle v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val, Val.intofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1)","proofString":"simpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vint (Float32.to_int f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1)","proofString":"destruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","conclusion":"exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int)","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intuofsingle v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.intuofsingle v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1) : exists v2 : val,\n  Val.intuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.intuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1)","proofString":"simpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_intu f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vint (Float32.to_intu f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1)","proofString":"destruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","conclusion":"exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int)","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofint v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.singleofint v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofint v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.singleofint (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","conclusion":"exists v2 : val,\n  Val.singleofint (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_int i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","conclusion":"exists v2 : val,\n  Some (Vsingle (Float32.of_int i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofintu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofintu v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.singleofintu v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofintu v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Val.singleofintu (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2.","conclusion":"exists v2 : val,\n  Val.singleofintu (Vint i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_intu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2.","conclusion":"exists v2 : val,\n  Some (Vsingle (Float32.of_intu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longoffloat v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.longoffloat v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1) : exists v2 : val, Val.longoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.longoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1)","proofString":"simpl.\ndestruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float.to_long f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Float.to_long f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_long f0) = Some v1)","proofString":"destruct (Float.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64)","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longuoffloat v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.longuoffloat v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_longu f0) = Some v1) : exists v2 : val, Val.longuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.longuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_longu f0) = Some v1)","proofString":"simpl.\ndestruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_longu f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float.to_longu f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Float.to_longu f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vlong (Float.to_longu f0) = Some v1)","proofString":"destruct (Float.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int64)","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflong v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatoflong v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.floatoflong v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflong v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.floatoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2.","conclusion":"exists v2 : val,\n  Val.floatoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vfloat (Float.of_long i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2.","conclusion":"exists v2 : val,\n  Some (Vfloat (Float.of_long i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_long i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflongu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatoflongu v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.floatoflongu v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatoflongu v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.floatoflongu (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_longu i)) v2.","conclusion":"exists v2 : val,\n  Val.floatoflongu (Vlong i) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_longu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vfloat (Float.of_longu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_longu i)) v2.","conclusion":"exists v2 : val,\n  Some (Vfloat (Float.of_longu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_longu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longofsingle v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.longofsingle v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1) : exists v2 : val,\n  Val.longofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.longofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1)","proofString":"simpl.\ndestruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float32.to_long f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Float32.to_long f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_long f0) = Some v1)","proofString":"destruct (Float32.to_long f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olongofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64)","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.longuofsingle v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.longuofsingle v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.longuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_longu f0) = Some v1) : exists v2 : val,\n  Val.longuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  Val.longuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_longu f0) = Some v1)","proofString":"simpl.\ndestruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_longu f0) = Some v1) : exists v2 : val,\n  option_map Vlong (Float32.to_longu f0) = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Float32.to_longu f0) = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vlong (Float32.to_longu f0) = Some v1)","proofString":"destruct (Float32.to_longu f0); simpl in H2; inv H2.\nexists (Vlong i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64) : exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2.","conclusion":"exists v2 : val,\n  option_map Vlong (Some i) = Some v2 /\\ Val.inject f (Vlong i) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olonguofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int64)","proofString":"exists (Vlong i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflong v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleoflong v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.singleoflong v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflong v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.singleoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2.","conclusion":"exists v2 : val,\n  Val.singleoflong (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vsingle (Float32.of_long i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2.","conclusion":"exists v2 : val,\n  Some (Vsingle (Float32.of_long i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_long i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflongu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleoflongu v' = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, Val.singleoflongu v' = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleoflongu v = Some v1) (v' : val) (H4 : Val.inject f v v')","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Val.singleoflongu (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) v2.","conclusion":"exists v2 : val,\n  Val.singleoflongu (Vlong i) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"simpl.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64) : exists v2 : val,\n  Some (Vsingle (Float32.of_longu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) v2.","conclusion":"exists v2 : val,\n  Some (Vsingle (Float32.of_longu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) v2","hypotheses":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoflongu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int64)","proofString":"TrivialExists."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H2 : Val.of_optbool (eval_condition cond vl1 m1) = v1) : Val.inject f v1 (Val.of_optbool (eval_condition cond vl2 m2)).","conclusion":"Val.inject f v1 (Val.of_optbool (eval_condition cond vl2 m2))","hypotheses":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H2 : Val.of_optbool (eval_condition cond vl1 m1) = v1)","proofString":"subst v1.\ndestruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) : Val.inject f (Val.of_optbool (eval_condition cond vl1 m1))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","conclusion":"Val.inject f (Val.of_optbool (eval_condition cond vl1 m1))\n  (Val.of_optbool (eval_condition cond vl2 m2))","hypotheses":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2)","proofString":"destruct (eval_condition cond vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : Val.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","conclusion":"Val.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2))","hypotheses":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b)","proofString":"exploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b ->\nVal.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2)).","conclusion":"eval_condition cond vl2 m2 = Some b ->\nVal.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition cond vl2 m2))","hypotheses":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b)","proofString":"intros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) (EQ : eval_condition cond vl2 m2 = Some b) : Val.inject f (Val.of_optbool (Some b)) (Val.of_optbool (Some b)).","conclusion":"Val.inject f (Val.of_optbool (Some b)) (Val.of_optbool (Some b))","hypotheses":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition cond vl1 m1 = Some b) (EQ : eval_condition cond vl2 m2 = Some b)","proofString":"destruct b; simpl; constructor."},{"statement":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (Heqo : eval_condition cond vl1 m1 = None) : Val.inject f (Val.of_optbool None)\n  (Val.of_optbool (eval_condition cond vl2 m2)).","conclusion":"Val.inject f (Val.of_optbool None)\n  (Val.of_optbool (eval_condition cond vl2 m2))","hypotheses":"(cond : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp cond)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (Heqo : eval_condition cond vl1 m1 = None)","proofString":"simpl; constructor."},{"statement":"(addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing ge1 sp1 addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing ge1 sp1 addr vl1 = Some v1)","proofString":"destruct addr; simpl in H2; simpl; FuncInv; InvInject; TrivialExists.\napply Val.offset_ptr_inject; auto.\napply H; simpl; auto.\napply Val.offset_ptr_inject; auto."},{"statement":"(i : ptrofs) (sp1 v sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') : Val.inject f (Val.offset_ptr v i) (Val.offset_ptr v' i).","conclusion":"Val.inject f (Val.offset_ptr v i) (Val.offset_ptr v' i)","hypotheses":"(i : ptrofs) (sp1 v sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v')","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aglobal i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0).","conclusion":"Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0)","hypotheses":"(i : ident) (i0 : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aglobal i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2)","proofString":"apply H; simpl; auto."},{"statement":"(i : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Ainstack i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 i) (Val.offset_ptr sp2 i).","conclusion":"Val.inject f (Val.offset_ptr sp1 i) (Val.offset_ptr sp2 i)","hypotheses":"(i : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Ainstack i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2)","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","conclusion":"Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true","hypotheses":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true)","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue.","conclusion":"Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue","hypotheses":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true)","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","conclusion":"Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true","hypotheses":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true)","proofString":"eapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","conclusion":"Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true","hypotheses":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true)","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true.","conclusion":"Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true","hypotheses":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true)","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","conclusion":"Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true","hypotheses":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true)","proofString":"eapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 : mem) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","conclusion":"0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned","hypotheses":"(m1 : mem) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true)","proofString":"inv H.\nrewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned.","conclusion":"0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned","hypotheses":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true)","proofString":"rewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned.","conclusion":"0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned","hypotheses":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true)","proofString":"apply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","conclusion":"b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2))","hypotheses":"(m1 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2))","proofString":"inv H2; inv H3.\nauto."},{"statement":"(m1 : mem) (ofs1 ofs2 : ptrofs) (b1' b2' : block) (H0 : Mem.valid_pointer m1 b1' (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2' (Ptrofs.unsigned ofs2) = true) (H : b1' <> b2') : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr 0)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr 0)).","conclusion":"b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr 0)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr 0))","hypotheses":"(m1 : mem) (ofs1 ofs2 : ptrofs) (b1' b2' : block) (H0 : Mem.valid_pointer m1 b1' (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2' (Ptrofs.unsigned ofs2) = true) (H : b1' <> b2')","proofString":"auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","conclusion":"eval_condition cond vl2 m2 = Some b","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"eapply eval_condition_inj with (f := fun b => Some(b, 0)) (m1 := m1).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nrewrite <- val_inject_list_lessdef.\neauto.\nauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"apply valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","conclusion":"forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2))","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"assert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"eapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\napply val_inject_lessdef.\nauto.\napply val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"apply valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","conclusion":"forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2))","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","conclusion":"Val.inject (fun b : block => Some (b, 0)) sp sp","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1)","proofString":"apply val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (H2 : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (H2 : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2)","proofString":"destruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_operation genv sp op vl2 m2 = Some v0 /\\ Val.lessdef v1 v0.","conclusion":"exists v0 : val,\n  eval_operation genv sp op vl2 m2 = Some v0 /\\ Val.lessdef v1 v0","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2)","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","conclusion":"Val.lessdef v1 v2","hypotheses":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2)","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.lessdef_list vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.lessdef_list vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1)","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1)","proofString":"assert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1)","proofString":"eapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","conclusion":"Val.inject (fun b : block => Some (b, 0)) sp sp","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1)","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (H1 : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (H1 : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2)","proofString":"destruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_addressing genv sp addr vl2 = Some v0 /\\ Val.lessdef v1 v0.","conclusion":"exists v0 : val,\n  eval_addressing genv sp addr vl2 = Some v0 /\\ Val.lessdef v1 v0","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2)","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","conclusion":"Val.lessdef v1 v2","hypotheses":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2)","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","conclusion":"Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs)","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","conclusion":"Val.inject f\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"destruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : Val.inject f (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.inject f (Vptr b ofs) (Vptr b ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b)","proofString":"exploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : f b = Some (b, 0) -> Val.inject f (Vptr b ofs) (Vptr b ofs).","conclusion":"f b = Some (b, 0) -> Val.inject f (Vptr b ofs) (Vptr b ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b)","proofString":"intros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : Val.inject f (Vptr b ofs) (Vptr b ofs).","conclusion":"Val.inject f (Vptr b ofs) (Vptr b ofs)","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0))","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","conclusion":"ofs = Ptrofs.add ofs (Ptrofs.repr 0)","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0))","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","conclusion":"eval_condition cond vl2 m2 = Some b","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"eapply eval_condition_inj with (f := f) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","conclusion":"forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2))","hypotheses":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b)","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl2 = Some v2 /\\ \n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing genv (Vptr sp2 Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl2 = Some v2 /\\ \n  Val.inject f v1 v2","hypotheses":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1)","proofString":"rewrite eval_shift_stack_addressing.\neapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 (Ptrofs.repr delta)) addr vl2 = Some v2 /\\\n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_addressing genv (Vptr sp2 (Ptrofs.repr delta)) addr vl2 = Some v2 /\\\n  Val.inject f v1 v2","hypotheses":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1)","proofString":"eapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","conclusion":"forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs)","hypotheses":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1)","proofString":"intros.\napply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) (id : ident) (ofs : ptrofs) (H1 : In id (globals_addressing addr)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","conclusion":"Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs)","hypotheses":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) (id : ident) (ofs : ptrofs) (H1 : In id (globals_addressing addr))","proofString":"apply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","conclusion":"Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta))","hypotheses":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1)","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","conclusion":"Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)","hypotheses":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1)","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op)\n    vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op)\n    vl2 m2 = Some v2 /\\ Val.inject f v1 v2","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"rewrite eval_shift_stack_operation.\nsimpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"simpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","conclusion":"exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"eapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","conclusion":"forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","conclusion":"forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2))","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","conclusion":"forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs)","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"intros.\napply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) (id : ident) (ofs : ptrofs) (H2 : In id (globals_operation op)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","conclusion":"Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs)","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) (id : ident) (ofs : ptrofs) (H2 : In id (globals_operation op))","proofString":"apply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","conclusion":"Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta))","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","conclusion":"Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)","hypotheses":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1)","proofString":"rewrite Ptrofs.add_zero_l; auto."}]}