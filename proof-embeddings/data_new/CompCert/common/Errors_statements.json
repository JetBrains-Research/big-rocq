{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Errors.v","fileSamples":[{"statement":"(A : Type) (B : Type) (f : res A) (g : A -> res B) (y : B) : bind f g = OK y -> exists x : A, f = OK x /\\ g x = OK y.","conclusion":"bind f g = OK y -> exists x : A, f = OK x /\\ g x = OK y","hypotheses":"(A : Type) (B : Type) (f : res A) (g : A -> res B) (y : B)","proofString":"destruct f; simpl; intros.\nexists a; auto.\ndiscriminate."},{"statement":"(A : Type) (B : Type) (a : A) (g : A -> res B) (y : B) (H : g a = OK y) : exists x : A, OK a = OK x /\\ g x = OK y.","conclusion":"exists x : A, OK a = OK x /\\ g x = OK y","hypotheses":"(A : Type) (B : Type) (a : A) (g : A -> res B) (y : B) (H : g a = OK y)","proofString":"exists a; auto."},{"statement":"(A : Type) (B : Type) (e : errmsg) (g : A -> res B) (y : B) (H : Error e = OK y) : exists x : A, Error e = OK x /\\ g x = OK y.","conclusion":"exists x : A, Error e = OK x /\\ g x = OK y","hypotheses":"(A : Type) (B : Type) (e : errmsg) (g : A -> res B) (y : B) (H : Error e = OK y)","proofString":"discriminate."},{"statement":"(A : Type) (B : Type) (C : Type) (f : res (A * B)) (g : A -> B -> res C) (z : C) : bind2 f g = OK z -> exists (x : A) (y : B), f = OK (x, y) /\\ g x y = OK z.","conclusion":"bind2 f g = OK z -> exists (x : A) (y : B), f = OK (x, y) /\\ g x y = OK z","hypotheses":"(A : Type) (B : Type) (C : Type) (f : res (A * B)) (g : A -> B -> res C) (z : C)","proofString":"destruct f; simpl.\ndestruct p; simpl; intros.\nexists a; exists b; auto.\nintros; discriminate."},{"statement":"(A : Type) (B : Type) (C : Type) (p : A * B) (g : A -> B -> res C) (z : C) : (let (x, y) := p in g x y) = OK z ->\nexists (x : A) (y : B), OK p = OK (x, y) /\\ g x y = OK z.","conclusion":"(let (x, y) := p in g x y) = OK z ->\nexists (x : A) (y : B), OK p = OK (x, y) /\\ g x y = OK z","hypotheses":"(A : Type) (B : Type) (C : Type) (p : A * B) (g : A -> B -> res C) (z : C)","proofString":"destruct p; simpl; intros.\nexists a; exists b; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (a : A) (b : B) (g : A -> B -> res C) (z : C) (H : g a b = OK z) : exists (x : A) (y : B), OK (a, b) = OK (x, y) /\\ g x y = OK z.","conclusion":"exists (x : A) (y : B), OK (a, b) = OK (x, y) /\\ g x y = OK z","hypotheses":"(A : Type) (B : Type) (C : Type) (a : A) (b : B) (g : A -> B -> res C) (z : C) (H : g a b = OK z)","proofString":"exists a; exists b; auto."},{"statement":"(A : Type) (B : Type) (C : Type) (e : errmsg) (g : A -> B -> res C) (z : C) : Error e = OK z -> exists (x : A) (y : B), Error e = OK (x, y) /\\ g x y = OK z.","conclusion":"Error e = OK z -> exists (x : A) (y : B), Error e = OK (x, y) /\\ g x y = OK z","hypotheses":"(A : Type) (B : Type) (C : Type) (e : errmsg) (g : A -> B -> res C) (z : C)","proofString":"intros; discriminate."},{"statement":"(l' : list B) (H : OK nil = OK l') : list_forall2 (fun (x : A) (y : B) => f x = OK y) nil l'.","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) nil l'","hypotheses":"(l' : list B) (H : OK nil = OK l')","proofString":"inversion_clear H.\nconstructor."},{"statement":"(l' : list B) : list_forall2 (fun (x : A) (y : B) => f x = OK y) nil nil.","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) nil nil","hypotheses":"(l' : list B)","proofString":"constructor."},{"statement":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd' <- f a; do tl' <- mmap l; OK (hd' :: tl')) = OK l') : list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) l'.","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) l'","hypotheses":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd' <- f a; do tl' <- mmap l; OK (hd' :: tl')) = OK l')","proofString":"destruct (bind_inversion _ _ H) as [hd' [P Q]].\ndestruct (bind_inversion _ _ Q) as [tl' [R S]].\ninversion_clear S.\nconstructor.\nauto.\nauto."},{"statement":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl' <- mmap l; OK (hd'0 :: tl')) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl' <- mmap l; OK (hd' :: tl')) = OK l') : list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) l'.","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) l'","hypotheses":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl' <- mmap l; OK (hd'0 :: tl')) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl' <- mmap l; OK (hd' :: tl')) = OK l')","proofString":"destruct (bind_inversion _ _ Q) as [tl' [R S]].\ninversion_clear S.\nconstructor.\nauto.\nauto."},{"statement":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl') (S : OK (hd' :: tl') = OK l') : list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) l'.","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) l'","hypotheses":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl') (S : OK (hd' :: tl') = OK l')","proofString":"inversion_clear S.\nconstructor.\nauto.\nauto."},{"statement":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl') : list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) (hd' :: tl').","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) (a :: l) (hd' :: tl')","hypotheses":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl')","proofString":"constructor.\nauto.\nauto."},{"statement":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl') : f a = OK hd'.","conclusion":"f a = OK hd'","hypotheses":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl')","proofString":"auto."},{"statement":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl') : list_forall2 (fun (x : A) (y : B) => f x = OK y) l tl'.","conclusion":"list_forall2 (fun (x : A) (y : B) => f x = OK y) l tl'","hypotheses":"(a : A) (l : list A) (IHl : forall l'0 : list B,\nmmap l = OK l'0 -> list_forall2 (fun (x : A) (y : B) => f x = OK y) l l'0) (l' : list B) (H : (do hd'0 <- f a; do tl'0 <- mmap l; OK (hd'0 :: tl'0)) = OK l') (hd' : B) (P : f a = OK hd') (Q : (do tl'0 <- mmap l; OK (hd' :: tl'0)) = OK l') (tl' : list B) (R : mmap l = OK tl')","proofString":"auto."}]}