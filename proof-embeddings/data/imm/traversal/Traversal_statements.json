{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/traversal/Traversal.v","fileSamples":[{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C) (ISSEQ : I ≡₁ I ∪₁ eq e) (NEW : set_disjoint (C ∪₁ C') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : (C ∪₁ C') e.","proofString":"left.\napply COVEQ.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C) (ISSEQ : I ≡₁ I ∪₁ eq e) (NEW : set_disjoint (C ∪₁ C') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : C e.","proofString":"apply COVEQ.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C) (ISSEQ : I ≡₁ I ∪₁ eq e) (NEW : set_disjoint (C ∪₁ C') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : (C ∪₁ eq e) e.","proofString":"basic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C) (ISSEQ : I ≡₁ I ∪₁ eq e) (NEW : set_disjoint (C ∪₁ C') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C' ∪₁ eq e; issued := I ∪₁ I' |}.","proofString":"destruct STEP'.\ninversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver.\nrewrite set_unionA, set_unionC with (s := C'), <- set_unionA.\nauto."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C ∪₁ eq e) (ISSEQ : I ≡₁ I) (NEW : set_disjoint (C ∪₁ C') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C' ∪₁ eq e; issued := I ∪₁ I' |}.","proofString":"inversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C ∪₁ eq e) (ISSEQ : I ≡₁ I) (NEW : set_disjoint (C ∪₁ C') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) (H1 : C ∪₁ C' = C ∪₁ eq e ∪₁ C') : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C' ∪₁ eq e; issued := I ∪₁ I' |}.","proofString":"destruct (NEW e); auto.\nrewrite H1.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C ∪₁ eq e) (ISSEQ : I ≡₁ I) (NEW : set_disjoint (C ∪₁ C') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) (H1 : C ∪₁ C' = C ∪₁ eq e ∪₁ C') : (C ∪₁ C') e.","proofString":"rewrite H1.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C ∪₁ eq e) (ISSEQ : I ≡₁ I) (NEW : set_disjoint (C ∪₁ C') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) (H1 : C ∪₁ C' = C ∪₁ eq e ∪₁ C') : (C ∪₁ eq e ∪₁ C') e.","proofString":"basic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C ∪₁ eq e) (ISSEQ : I ≡₁ I) (NEW : set_disjoint (C ∪₁ C') (eq e)) (H : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C' ∪₁ eq e; issued := I ∪₁ I' |}.","proofString":"rewrite set_unionA, set_unionC with (s := C'), <- set_unionA.\nauto."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ∪₁ eq e ≡₁ C ∪₁ eq e) (ISSEQ : I ≡₁ I) (NEW : set_disjoint (C ∪₁ C') (eq e)) (H : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ eq e ∪₁ C'; issued := I ∪₁ I' |}.","proofString":"auto."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (STEP : itrav_step e {| covered := C; issued := I |}\n  {| covered := C; issued := I ∪₁ eq e |}) (NEW : set_disjoint (I ∪₁ I') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ I' ∪₁ eq e |}.","proofString":"red in STEP.\ndesf; simpl in *.\ndestruct (NEW e); auto.\nleft.\napply ISSEQ.\nbasic_solver.\ndestruct STEP'.\ninversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver.\nrewrite set_unionA, set_unionC with (s := I'), <- set_unionA.\nauto."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C ∪₁ eq e) (ISSEQ : I ∪₁ eq e ≡₁ I) (NEW : set_disjoint (I ∪₁ I') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ I' ∪₁ eq e |}.","proofString":"destruct (NEW e); auto.\nleft.\napply ISSEQ.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C ∪₁ eq e) (ISSEQ : I ∪₁ eq e ≡₁ I) (NEW : set_disjoint (I ∪₁ I') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : (I ∪₁ I') e.","proofString":"left.\napply ISSEQ.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C ∪₁ eq e) (ISSEQ : I ∪₁ eq e ≡₁ I) (NEW : set_disjoint (I ∪₁ I') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : I e.","proofString":"apply ISSEQ.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NEXT : ~ C e) (COV : coverable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C ∪₁ eq e) (ISSEQ : I ∪₁ eq e ≡₁ I) (NEW : set_disjoint (I ∪₁ I') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : (I ∪₁ eq e) e.","proofString":"basic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (STEP' : (itrav_step e)^? {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ I' ∪₁ eq e |}.","proofString":"destruct STEP'.\ninversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver.\nrewrite set_unionA, set_unionC with (s := I'), <- set_unionA.\nauto."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ I' ∪₁ eq e |}.","proofString":"inversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) (H1 : I ∪₁ I' = I ∪₁ eq e ∪₁ I') : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ I' ∪₁ eq e |}.","proofString":"destruct (NEW e); auto.\nrewrite H1.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) (H1 : I ∪₁ I' = I ∪₁ eq e ∪₁ I') : (I ∪₁ I') e.","proofString":"rewrite H1.\nbasic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (H : {| covered := C ∪₁ C'; issued := I ∪₁ I' |} =\n{| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) (H1 : I ∪₁ I' = I ∪₁ eq e ∪₁ I') : (I ∪₁ eq e ∪₁ I') e.","proofString":"basic_solver."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (H : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ I' ∪₁ eq e |}.","proofString":"rewrite set_unionA, set_unionC with (s := I'), <- set_unionA.\nauto."},{"statement":"(e : actid) (C I C' I' : actid -> Prop) (NISS : ~ I e) (ISS : issuable G sc {| covered := C; issued := I |} e) (COVEQ : C ≡₁ C) (ISSEQ : I ∪₁ eq e ≡₁ I ∪₁ eq e) (NEW : set_disjoint (I ∪₁ I') (eq e)) (H : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}) : itrav_step e {| covered := C ∪₁ C'; issued := I ∪₁ I' |}\n  {| covered := C ∪₁ C'; issued := I ∪₁ eq e ∪₁ I' |}.","proofString":"auto."},{"statement":"(C C' : trav_config) (T : trav_step C C') (H : tc_coherent G sc C) : coverable G sc C ⊆₁ coverable G sc C' /\\ issuable G sc C ⊆₁ issuable G sc C'.","proofString":"by apply traversal_mon; apply step_mon; eauto."},{"statement":"(C C' : trav_config) (T : trav_step C C') (H : tc_coherent G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C' /\\ issuable G sc C ⊆₁ issuable G sc C') : tc_coherent G sc C'.","proofString":"destruct T as [e [STEP | STEP]]; auto; unnw; desf.\nunfold tc_coherent in *; splits; desf.\nunfolder in *; basic_solver 12.\nrewrite STEP1, <- H0; basic_solver 21.\nunfolder in *; basic_solver 12.\nunfold tc_coherent in *; splits; desf.\nunfolder in *; basic_solver 12.\nrewrite STEP1, <- H0; basic_solver 21.\nrewrite STEP2, <- H1; basic_solver 21."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ covered C e) (STEP0 : coverable G sc C e) (STEP1 : covered C' ≡₁ covered C ∪₁ eq e) (STEP2 : issued C' ≡₁ issued C) (H : tc_coherent G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : tc_coherent G sc C'.","proofString":"unfold tc_coherent in *; splits; desf.\nunfolder in *; basic_solver 12.\nrewrite STEP1, <- H0; basic_solver 21.\nunfolder in *; basic_solver 12."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ covered C e) (STEP0 : coverable G sc C e) (STEP1 : covered C' ≡₁ covered C ∪₁ eq e) (STEP2 : issued C' ≡₁ issued C) (ICOV : Init ∩₁ E ⊆₁ covered C) (CC : covered C ⊆₁ coverable G sc C) (II : issued C ⊆₁ issuable G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : Init ∩₁ E ⊆₁ covered C'.","proofString":"unfolder in *; basic_solver 12."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ covered C e) (STEP0 : coverable G sc C e) (STEP1 : covered C' ≡₁ covered C ∪₁ eq e) (STEP2 : issued C' ≡₁ issued C) (ICOV : Init ∩₁ E ⊆₁ covered C) (CC : covered C ⊆₁ coverable G sc C) (II : issued C ⊆₁ issuable G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : covered C' ⊆₁ coverable G sc C'.","proofString":"rewrite STEP1, <- H0; basic_solver 21."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ covered C e) (STEP0 : coverable G sc C e) (STEP1 : covered C' ≡₁ covered C ∪₁ eq e) (STEP2 : issued C' ≡₁ issued C) (ICOV : Init ∩₁ E ⊆₁ covered C) (CC : covered C ⊆₁ coverable G sc C) (II : issued C ⊆₁ issuable G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : issued C' ⊆₁ issuable G sc C'.","proofString":"unfolder in *; basic_solver 12."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ issued C e) (STEP0 : issuable G sc C e) (STEP1 : covered C' ≡₁ covered C) (STEP2 : issued C' ≡₁ issued C ∪₁ eq e) (H : tc_coherent G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : tc_coherent G sc C'.","proofString":"unfold tc_coherent in *; splits; desf.\nunfolder in *; basic_solver 12.\nrewrite STEP1, <- H0; basic_solver 21.\nrewrite STEP2, <- H1; basic_solver 21."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ issued C e) (STEP0 : issuable G sc C e) (STEP1 : covered C' ≡₁ covered C) (STEP2 : issued C' ≡₁ issued C ∪₁ eq e) (ICOV : Init ∩₁ E ⊆₁ covered C) (CC : covered C ⊆₁ coverable G sc C) (II : issued C ⊆₁ issuable G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : Init ∩₁ E ⊆₁ covered C'.","proofString":"unfolder in *; basic_solver 12."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ issued C e) (STEP0 : issuable G sc C e) (STEP1 : covered C' ≡₁ covered C) (STEP2 : issued C' ≡₁ issued C ∪₁ eq e) (ICOV : Init ∩₁ E ⊆₁ covered C) (CC : covered C ⊆₁ coverable G sc C) (II : issued C ⊆₁ issuable G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : covered C' ⊆₁ coverable G sc C'.","proofString":"rewrite STEP1, <- H0; basic_solver 21."},{"statement":"(C C' : trav_config) (e : actid) (STEP : ~ issued C e) (STEP0 : issuable G sc C e) (STEP1 : covered C' ≡₁ covered C) (STEP2 : issued C' ≡₁ issued C ∪₁ eq e) (ICOV : Init ∩₁ E ⊆₁ covered C) (CC : covered C ⊆₁ coverable G sc C) (II : issued C ⊆₁ issuable G sc C) (H0 : coverable G sc C ⊆₁ coverable G sc C') (H1 : issuable G sc C ⊆₁ issuable G sc C') : issued C' ⊆₁ issuable G sc C'.","proofString":"rewrite STEP2, <- H1; basic_solver 21."},{"statement":"(C C' : trav_config) (T : clos_trans_n1 trav_config trav_step C C') (H : tc_coherent G sc C) : tc_coherent G sc C'.","proofString":"induction T; eapply trav_step_coherence; eauto."},{"statement":"tc_coherent G sc {| covered := Init ∩₁ E; issued := Init ∩₁ E |}.","proofString":"red; splits; ins.\nunfold coverable; ins.\nrepeat (splits; try apply set_subset_inter_r).\nbasic_solver.\nrewrite no_sb_to_init; unfold dom_cond; basic_solver.\ngeneralize (init_w WF); basic_solver 12.\nunfold issuable; ins.\nrepeat (splits; try apply set_subset_inter_r).\nbasic_solver.\ngeneralize (init_w WF); basic_solver 12.\nrewrite fwbob_in_bob, bob_in_sb, no_sb_to_init; unfold dom_cond; basic_solver.\neapply dom_cond_in with (r' := fun _ _ => False).\nrewrite id_inter.\nrewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"Init ∩₁ E ⊆₁ coverable G sc {| covered := Init ∩₁ E; issued := Init ∩₁ E |}.","proofString":"unfold coverable; ins.\nrepeat (splits; try apply set_subset_inter_r).\nbasic_solver.\nrewrite no_sb_to_init; unfold dom_cond; basic_solver.\ngeneralize (init_w WF); basic_solver 12."},{"statement":"Init ∩₁ E\n⊆₁ E ∩₁ dom_cond sb (Init ∩₁ E)\n   ∩₁ (W ∩₁ (Init ∩₁ E) ∪₁ R ∩₁ dom_cond rf (Init ∩₁ E)\n       ∪₁ F ∩₁ dom_cond sc (Init ∩₁ E)).","proofString":"repeat (splits; try apply set_subset_inter_r).\nbasic_solver.\nrewrite no_sb_to_init; unfold dom_cond; basic_solver.\ngeneralize (init_w WF); basic_solver 12."},{"statement":"Init ∩₁ E ⊆₁ E.","proofString":"basic_solver."},{"statement":"Init ∩₁ E ⊆₁ dom_cond sb (Init ∩₁ E).","proofString":"rewrite no_sb_to_init; unfold dom_cond; basic_solver."},{"statement":"Init ∩₁ E\n⊆₁ W ∩₁ (Init ∩₁ E) ∪₁ R ∩₁ dom_cond rf (Init ∩₁ E)\n   ∪₁ F ∩₁ dom_cond sc (Init ∩₁ E).","proofString":"generalize (init_w WF); basic_solver 12."},{"statement":"Init ∩₁ E ⊆₁ issuable G sc {| covered := Init ∩₁ E; issued := Init ∩₁ E |}.","proofString":"unfold issuable; ins.\nrepeat (splits; try apply set_subset_inter_r).\nbasic_solver.\ngeneralize (init_w WF); basic_solver 12.\nrewrite fwbob_in_bob, bob_in_sb, no_sb_to_init; unfold dom_cond; basic_solver.\neapply dom_cond_in with (r' := fun _ _ => False).\nrewrite id_inter.\nrewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"Init ∩₁ E\n⊆₁ E ∩₁ W ∩₁ dom_cond fwbob (Init ∩₁ E)\n   ∩₁ dom_cond (⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺) (Init ∩₁ E).","proofString":"repeat (splits; try apply set_subset_inter_r).\nbasic_solver.\ngeneralize (init_w WF); basic_solver 12.\nrewrite fwbob_in_bob, bob_in_sb, no_sb_to_init; unfold dom_cond; basic_solver.\neapply dom_cond_in with (r' := fun _ _ => False).\nrewrite id_inter.\nrewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"Init ∩₁ E ⊆₁ E.","proofString":"basic_solver."},{"statement":"Init ∩₁ E ⊆₁ W.","proofString":"generalize (init_w WF); basic_solver 12."},{"statement":"Init ∩₁ E ⊆₁ dom_cond fwbob (Init ∩₁ E).","proofString":"rewrite fwbob_in_bob, bob_in_sb, no_sb_to_init; unfold dom_cond; basic_solver."},{"statement":"Init ∩₁ E ⊆₁ dom_cond (⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺) (Init ∩₁ E).","proofString":"eapply dom_cond_in with (r' := fun _ _ => False).\nrewrite id_inter.\nrewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"(⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺) ⨾ ⦗Init ∩₁ E⦘ ⊆ ⦗Init ∩₁ E⦘ ⨾ ∅₂.","proofString":"rewrite id_inter.\nrewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"(⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺) ⨾ ⦗Init⦘ ⨾ ⦗E⦘ ⊆ (⦗Init⦘ ⨾ ⦗E⦘) ⨾ ∅₂.","proofString":"rewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"⦗W⦘\n⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)＊\n  ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⨾ ⦗E⦘ ⊆ \n⦗Init⦘ ⨾ ⦗E⦘ ⨾ ∅₂.","proofString":"arewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\nby apply no_ar_rf_ppo_loc_to_init.\nbasic_solver."},{"statement":"(ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂.","proofString":"by apply no_ar_rf_ppo_loc_to_init."},{"statement":"⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)＊ ⨾ ∅₂ ⨾ ⦗E⦘ ⊆ ⦗Init⦘ ⨾ ⦗E⦘ ⨾ ∅₂.","proofString":"basic_solver."},{"statement":"(P : actid -> Prop) : forall e : actid, E e -> ~ P e -> exists e' : actid, sb^? e' e /\\ next G P e'.","proofString":"set (Q e := E e -> ~ P e ->                exists e' : actid, sb^? e' e /\\ next G P e').\napply (@well_founded_ind _ sb (wf_sb G) Q).\nins; subst Q; simpls.\ndestruct (classic (exists e', sb e' x /\\ ~ P e')) as        [[e' [H' COV]]| H']; ins.\nassert (E e') as ACTS.\napply seq_eqv_l in H'; desf.\nspecialize (H e' H' ACTS COV).\ndestruct H as [z [X Y]].\nexists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto.\nexists x; splits; [by left|]; red; splits; auto.\nunfolder; splits; eauto.\nunfold dom_cond; unfolder.\nins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e' : actid, sb^? e' y /\\ next G P e') : E x -> ~ P x -> exists e' : actid, sb^? e' x /\\ next G P e'.","proofString":"destruct (classic (exists e', sb e' x /\\ ~ P e')) as        [[e' [H' COV]]| H']; ins.\nassert (E e') as ACTS.\napply seq_eqv_l in H'; desf.\nspecialize (H e' H' ACTS COV).\ndestruct H as [z [X Y]].\nexists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto.\nexists x; splits; [by left|]; red; splits; auto.\nunfolder; splits; eauto.\nunfold dom_cond; unfolder.\nins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e'0 : actid, sb^? e'0 y /\\ next G P e'0) (e' : actid) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) : exists e'0 : actid, sb^? e'0 x /\\ next G P e'0.","proofString":"assert (E e') as ACTS.\napply seq_eqv_l in H'; desf.\nspecialize (H e' H' ACTS COV).\ndestruct H as [z [X Y]].\nexists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e'0 : actid, sb^? e'0 y /\\ next G P e'0) (e' : actid) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) : E e'.","proofString":"apply seq_eqv_l in H'; desf."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e'0 : actid, sb^? e'0 y /\\ next G P e'0) (e' : actid) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) (ACTS : E e') : exists e'0 : actid, sb^? e'0 x /\\ next G P e'0.","proofString":"specialize (H e' H' ACTS COV).\ndestruct H as [z [X Y]].\nexists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x e' : actid) (H : exists e'0 : actid, sb^? e'0 e' /\\ next G P e'0) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) (ACTS : E e') : exists e'0 : actid, sb^? e'0 x /\\ next G P e'0.","proofString":"destruct H as [z [X Y]].\nexists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x e' z : actid) (X : sb^? z e') (Y : next G P z) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) (ACTS : E e') : exists e'0 : actid, sb^? e'0 x /\\ next G P e'0.","proofString":"exists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x e' z : actid) (X : sb^? z e') (Y : next G P z) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) (ACTS : E e') : sb^? z x.","proofString":"right.\nred in X; desf.\neapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x e' z : actid) (X : sb^? z e') (Y : next G P z) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) (ACTS : E e') : sb z x.","proofString":"red in X; desf.\neapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x e' z : actid) (X : sb z e') (Y : next G P z) (H' : sb e' x) (COV : ~ P e') (H0 : E x) (H1 : ~ P x) (ACTS : E e') : sb z x.","proofString":"eapply sb_trans; eauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e' : actid, sb^? e' y /\\ next G P e') (H' : ~ (exists e' : actid, sb e' x /\\ ~ P e')) (H0 : E x) (H1 : ~ P x) : exists e' : actid, sb^? e' x /\\ next G P e'.","proofString":"exists x; splits; [by left|]; red; splits; auto.\nunfolder; splits; eauto.\nunfold dom_cond; unfolder.\nins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e' : actid, sb^? e' y /\\ next G P e') (H' : ~ (exists e' : actid, sb e' x /\\ ~ P e')) (H0 : E x) (H1 : ~ P x) : (E ∩₁ dom_cond sb P ∩₁ set_compl P) x.","proofString":"unfolder; splits; eauto.\nunfold dom_cond; unfolder.\nins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e' : actid, sb^? e' y /\\ next G P e') (H' : ~ (exists e' : actid, sb e' x /\\ ~ P e')) (H0 : E x) (H1 : ~ P x) : forall x0 : actid, (exists y z : actid, sb x0 z /\\ z = y /\\ x = z) -> P x0.","proofString":"unfold dom_cond; unfolder.\nins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (x : actid) (H : forall y : actid,\nsb y x -> E y -> ~ P y -> exists e' : actid, sb^? e' y /\\ next G P e') (H' : ~ (exists e' : actid, sb e' x /\\ ~ P e')) (H0 : E x) (H1 : ~ P x) : forall x0 : actid, (exists y z : actid, sb x0 z /\\ z = y /\\ x = z) -> P x0.","proofString":"ins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (y : actid) (H1 : ~ P y) (H0 : E y) (H' : ~ (exists e' : actid, sb e' y /\\ ~ P e')) (H : forall y0 : actid,\nsb y0 y -> E y0 -> ~ P y0 -> exists e' : actid, sb^? e' y0 /\\ next G P e') (x0 : actid) (H2 : sb x0 y) : P x0.","proofString":"destruct (classic (P x0)); auto.\nexfalso; apply H'; vauto."},{"statement":"(P : actid -> Prop) (y : actid) (H1 : ~ P y) (H0 : E y) (H' : ~ (exists e' : actid, sb e' y /\\ ~ P e')) (H : forall y0 : actid,\nsb y0 y -> E y0 -> ~ P y0 -> exists e' : actid, sb^? e' y0 /\\ next G P e') (x0 : actid) (H2 : sb x0 y) (H3 : ~ P x0) : P x0.","proofString":"exfalso; apply H'; vauto."}]}