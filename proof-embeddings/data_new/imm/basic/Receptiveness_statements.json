{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/basic/Receptiveness.v","fileSamples":[{"statement":"(tid : thread_id) (s1 : state) (LT : eindex s1 < eindex s1) (H : acts_set (G s1) (ThreadEvent tid (eindex s1))) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 : state) (LT : eindex s1 < eindex s1) (H : acts_set (G s1) (ThreadEvent tid (eindex s1)))","proofString":"lia."},{"statement":"(tid : thread_id) (s1 : state) (LT : eindex s1 + 1 < eindex s1) (H : acts_set (G s1) (ThreadEvent tid (eindex s1 + 1))) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 : state) (LT : eindex s1 + 1 < eindex s1) (H : acts_set (G s1) (ThreadEvent tid (eindex s1 + 1)))","proofString":"lia."},{"statement":"(regf regf' : RegFun.t value) (depf : RegFun.t (actid -> Prop)) (MOD : actid -> Prop) (expr : Instr.lexpr) (REGF : forall reg : BinNums.positive,\nRegFun.find reg regf = RegFun.find reg regf' \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)) (NDEP : forall a : actid,\nMOD a ->\n~\nmatch expr with\n| Instr.lexpr_loc _ => ∅\n| Instr.lexpr_choice reg _ _ => DepsFile.val_deps depf reg\nend a) : RegFile.eval_lexpr regf expr = RegFile.eval_lexpr regf' expr.","conclusion":"RegFile.eval_lexpr regf expr = RegFile.eval_lexpr regf' expr","hypotheses":"(regf regf' : RegFun.t value) (depf : RegFun.t (actid -> Prop)) (MOD : actid -> Prop) (expr : Instr.lexpr) (REGF : forall reg : BinNums.positive,\nRegFun.find reg regf = RegFun.find reg regf' \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)) (NDEP : forall a : actid,\nMOD a ->\n~\nmatch expr with\n| Instr.lexpr_loc _ => ∅\n| Instr.lexpr_choice reg _ _ => DepsFile.val_deps depf reg\nend a)","proofString":"unfold RegFile.eval_lexpr.\ndesf; exfalso; apply n; erewrite regf_expr_helper; eauto.\nins; specialize (REGF reg); desf; eauto."},{"statement":"(regf regf' : RegFun.t value) (depf : RegFun.t (actid -> Prop)) (MOD : actid -> Prop) (expr : Instr.lexpr) (REGF : forall reg : BinNums.positive,\nRegFun.find reg regf = RegFun.find reg regf' \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)) (NDEP : forall a : actid,\nMOD a ->\n~\nmatch expr with\n| Instr.lexpr_loc _ => ∅\n| Instr.lexpr_choice reg _ _ => DepsFile.val_deps depf reg\nend a) : match expr with\n| Instr.lexpr_loc loc => loc\n| Instr.lexpr_choice op loc1 loc2 =>\n    if Const.eq_dec (RegFile.eval_expr regf op) Const.zero\n    then loc2\n    else loc1\nend =\nmatch expr with\n| Instr.lexpr_loc loc => loc\n| Instr.lexpr_choice op loc1 loc2 =>\n    if Const.eq_dec (RegFile.eval_expr regf' op) Const.zero\n    then loc2\n    else loc1\nend.","conclusion":"match expr with\n| Instr.lexpr_loc loc => loc\n| Instr.lexpr_choice op loc1 loc2 =>\n    if Const.eq_dec (RegFile.eval_expr regf op) Const.zero\n    then loc2\n    else loc1\nend =\nmatch expr with\n| Instr.lexpr_loc loc => loc\n| Instr.lexpr_choice op loc1 loc2 =>\n    if Const.eq_dec (RegFile.eval_expr regf' op) Const.zero\n    then loc2\n    else loc1\nend","hypotheses":"(regf regf' : RegFun.t value) (depf : RegFun.t (actid -> Prop)) (MOD : actid -> Prop) (expr : Instr.lexpr) (REGF : forall reg : BinNums.positive,\nRegFun.find reg regf = RegFun.find reg regf' \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)) (NDEP : forall a : actid,\nMOD a ->\n~\nmatch expr with\n| Instr.lexpr_loc _ => ∅\n| Instr.lexpr_choice reg _ _ => DepsFile.val_deps depf reg\nend a)","proofString":"desf; exfalso; apply n; erewrite regf_expr_helper; eauto.\nins; specialize (REGF reg); desf; eauto."},{"statement":"(regf regf' : RegFun.t value) (depf : RegFun.t (actid -> Prop)) (MOD : actid -> Prop) (REGF : forall reg : BinNums.positive,\nRegFun.find reg regf = RegFun.find reg regf' \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)) (r : Value.t) (loc1 loc2 : Loc.Loc.t) (NDEP : forall a : actid, MOD a -> ~ DepsFile.val_deps depf r a) (e : RegFile.eval_expr regf r = Const.zero) (n : RegFile.eval_expr regf' r <> Const.zero) : forall reg : BinNums.positive,\nRegFun.find reg regf' = RegFun.find reg regf \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a).","conclusion":"forall reg : BinNums.positive,\nRegFun.find reg regf' = RegFun.find reg regf \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)","hypotheses":"(regf regf' : RegFun.t value) (depf : RegFun.t (actid -> Prop)) (MOD : actid -> Prop) (REGF : forall reg : BinNums.positive,\nRegFun.find reg regf = RegFun.find reg regf' \\/\n(exists a : actid, RegFun.find reg depf a /\\ MOD a)) (r : Value.t) (loc1 loc2 : Loc.Loc.t) (NDEP : forall a : actid, MOD a -> ~ DepsFile.val_deps depf r a) (e : RegFile.eval_expr regf r = Const.zero) (n : RegFile.eval_expr regf' r <> Const.zero)","proofString":"ins; specialize (REGF reg); desf; eauto."},{"statement":"(G G' : execution) (MOD : actid -> Prop) (ACTS : acts_set G = acts_set G') (TS : threads_set G ≡₁ threads_set G') (SAME : same_lab_u2v (lab G') (lab G)) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab G') a = val (lab G) a) (RMW : rmw G ≡ rmw G') (DATA : data G ≡ data G') (ADDR : addr G ≡ addr G') (CTRL : ctrl G ≡ ctrl G') (FRMW : rmw_dep G ≡ rmw_dep G') (RRF : rf G ≡ rf G') (RCO : co G ≡ co G') : (fun a : actid => is_r (lab G') a) ≡₁ (fun a : actid => is_r (lab G) a).","conclusion":"(fun a : actid => is_r (lab G') a) ≡₁ (fun a : actid => is_r (lab G) a)","hypotheses":"(G G' : execution) (MOD : actid -> Prop) (ACTS : acts_set G = acts_set G') (TS : threads_set G ≡₁ threads_set G') (SAME : same_lab_u2v (lab G') (lab G)) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab G') a = val (lab G) a) (RMW : rmw G ≡ rmw G') (DATA : data G ≡ data G') (ADDR : addr G ≡ addr G') (CTRL : ctrl G ≡ ctrl G') (FRMW : rmw_dep G ≡ rmw_dep G') (RRF : rf G ≡ rf G') (RCO : co G ≡ co G')","proofString":"eby erewrite same_lab_u2v_is_r."},{"statement":"(G G' : execution) (MOD : actid -> Prop) (ACTS : acts_set G = acts_set G') (TS : threads_set G ≡₁ threads_set G') (SAME : same_lab_u2v (lab G') (lab G)) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab G') a = val (lab G) a) (RMW : rmw G ≡ rmw G') (DATA : data G ≡ data G') (ADDR : addr G ≡ addr G') (CTRL : ctrl G ≡ ctrl G') (FRMW : rmw_dep G ≡ rmw_dep G') (RRF : rf G ≡ rf G') (RCO : co G ≡ co G') : (fun a : actid => is_w (lab G') a) ≡₁ (fun a : actid => is_w (lab G) a).","conclusion":"(fun a : actid => is_w (lab G') a) ≡₁ (fun a : actid => is_w (lab G) a)","hypotheses":"(G G' : execution) (MOD : actid -> Prop) (ACTS : acts_set G = acts_set G') (TS : threads_set G ≡₁ threads_set G') (SAME : same_lab_u2v (lab G') (lab G)) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab G') a = val (lab G) a) (RMW : rmw G ≡ rmw G') (DATA : data G ≡ data G') (ADDR : addr G ≡ addr G') (CTRL : ctrl G ≡ ctrl G') (FRMW : rmw_dep G ≡ rmw_dep G') (RRF : rf G ≡ rf G') (RCO : co G ≡ co G')","proofString":"eby erewrite same_lab_u2v_is_w."},{"statement":"(G G' : execution) (MOD : actid -> Prop) (ACTS : acts_set G = acts_set G') (TS : threads_set G ≡₁ threads_set G') (SAME : same_lab_u2v (lab G') (lab G)) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab G') a = val (lab G) a) (RMW : rmw G ≡ rmw G') (DATA : data G ≡ data G') (ADDR : addr G ≡ addr G') (CTRL : ctrl G ≡ ctrl G') (FRMW : rmw_dep G ≡ rmw_dep G') (RRF : rf G ≡ rf G') (RCO : co G ≡ co G') : acts_set G ≡₁ acts_set G'.","conclusion":"acts_set G ≡₁ acts_set G'","hypotheses":"(G G' : execution) (MOD : actid -> Prop) (ACTS : acts_set G = acts_set G') (TS : threads_set G ≡₁ threads_set G') (SAME : same_lab_u2v (lab G') (lab G)) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab G') a = val (lab G) a) (RMW : rmw G ≡ rmw G') (DATA : data G ≡ data G') (ADDR : addr G ≡ addr G') (CTRL : ctrl G ≡ ctrl G') (FRMW : rmw_dep G ≡ rmw_dep G') (RRF : rf G ≡ rf G') (RCO : co G ≡ co G')","proofString":"by rewrite ACTS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neby eexists; splits; [ rewrite <- INSTRS, <- PC| eapply assign; reflexivity].\nins; congruence.\nins; congruence.\nins; congruence.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf.\ndestruct (classic ((exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a))) as [A|A].\nby auto.\nby left; apply (regf_expr_helper (regf s1) (regf s1') (depf s1) MOD expr REGF); eauto.\nins; congruence.\nins; congruence.\nby ins; apply NEW_VAL1; try done; rewrite <- UG.\nby ins; apply NEW_VAL2; try done; rewrite <- UG."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"do 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neby eexists; splits; [ rewrite <- INSTRS, <- PC| eapply assign; reflexivity].\nins; congruence.\nins; congruence.\nins; congruence.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf.\ndestruct (classic ((exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a))) as [A|A].\nby auto.\nby left; apply (regf_expr_helper (regf s1) (regf s1') (depf s1) MOD expr REGF); eauto.\nins; congruence.\nins; congruence.\nby ins; apply NEW_VAL1; try done; rewrite <- UG.\nby ins; apply NEW_VAL2; try done; rewrite <- UG."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (reg0 : BinNums.positive) : RegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) =\nRegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1') expr) (regf s1')) \\/\n(exists a : actid,\n   RegFun.find reg0\n     (RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) a /\\\n   MOD a).","conclusion":"RegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) =\nRegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1') expr) (regf s1')) \\/\n(exists a : actid,\n   RegFun.find reg0\n     (RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) a /\\\n   MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (reg0 : BinNums.positive)","proofString":"unfold RegFun.add, RegFun.find in *; desf.\ndestruct (classic ((exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a))) as [A|A].\nby auto.\nby left; apply (regf_expr_helper (regf s1) (regf s1') (depf s1) MOD expr REGF); eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then DepsFile.expr_deps (depf s1) expr\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : RegFile.eval_expr (regf s1) expr = RegFile.eval_expr (regf s1') expr \\/\n(exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a).","conclusion":"RegFile.eval_expr (regf s1) expr = RegFile.eval_expr (regf s1') expr \\/\n(exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then DepsFile.expr_deps (depf s1) expr\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"destruct (classic ((exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a))) as [A|A].\nby auto.\nby left; apply (regf_expr_helper (regf s1) (regf s1') (depf s1) MOD expr REGF); eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then DepsFile.expr_deps (depf s1) expr\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (A : exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a) : RegFile.eval_expr (regf s1) expr = RegFile.eval_expr (regf s1') expr \\/\n(exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a).","conclusion":"RegFile.eval_expr (regf s1) expr = RegFile.eval_expr (regf s1') expr \\/\n(exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then DepsFile.expr_deps (depf s1) expr\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (A : exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a)","proofString":"by auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then DepsFile.expr_deps (depf s1) expr\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (A : ~ (exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a)) : RegFile.eval_expr (regf s1) expr = RegFile.eval_expr (regf s1') expr \\/\n(exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a).","conclusion":"RegFile.eval_expr (regf s1) expr = RegFile.eval_expr (regf s1') expr \\/\n(exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then DepsFile.expr_deps (depf s1) expr\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (A : ~ (exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a))","proofString":"by left; apply (regf_expr_helper (regf s1) (regf s1') (depf s1) MOD expr REGF); eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\neexists.\nexists (if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0        then pc s1' + 1 else shift).\ndo 5 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC|].\neapply if_; try reflexivity; ins; desf.\nins; congruence.\nins.\nerewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver.\nins; congruence.\nins; congruence.\nins; rewrite UREGS, UDEPS; eauto.\nins; congruence.\nins; congruence.\nby ins; apply NEW_VAL1; try done; rewrite <- UG.\nby ins; apply NEW_VAL2; try done; rewrite <- UG."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"eexists.\nexists (if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0        then pc s1' + 1 else shift).\ndo 5 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC|].\neapply if_; try reflexivity; ins; desf.\nins; congruence.\nins.\nerewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver.\nins; congruence.\nins; congruence.\nins; rewrite UREGS, UDEPS; eauto.\nins; congruence.\nins; congruence.\nby ins; apply NEW_VAL1; try done; rewrite <- UG.\nby ins; apply NEW_VAL2; try done; rewrite <- UG."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0\n then pc s1' + 1\n else shift).","conclusion":"pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0\n then pc s1' + 1\n else shift)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"erewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1) expr) 0\n then pc s1' + 1\n else shift).","conclusion":"pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1) expr) 0\n then pc s1' + 1\n else shift)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (e : RegFile.eval_expr (regf s1) expr = 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"desf; congruence."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\neexists.\nexists (if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0        then pc s1' + 1 else shift).\ndo 5 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC|].\neapply if_; try reflexivity; ins; desf.\nins; congruence.\nins.\nerewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver.\nins; congruence.\nins; congruence.\nins; rewrite UREGS, UDEPS; eauto.\nins; congruence.\nins; congruence.\nby ins; apply NEW_VAL1; try done; rewrite <- UG.\nby ins; apply NEW_VAL2; try done; rewrite <- UG."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"eexists.\nexists (if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0        then pc s1' + 1 else shift).\ndo 5 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC|].\neapply if_; try reflexivity; ins; desf.\nins; congruence.\nins.\nerewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver.\nins; congruence.\nins; congruence.\nins; rewrite UREGS, UDEPS; eauto.\nins; congruence.\nins; congruence.\nby ins; apply NEW_VAL1; try done; rewrite <- UG.\nby ins; apply NEW_VAL2; try done; rewrite <- UG."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0\n then pc s1' + 1\n else shift).","conclusion":"pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0\n then pc s1' + 1\n else shift)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"erewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1) expr) 0\n then pc s1' + 1\n else shift).","conclusion":"pc s2 =\n(if Const.eq_dec (RegFile.eval_expr (regf s1) expr) 0\n then pc s1' + 1\n else shift)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (n : RegFile.eval_expr (regf s1) expr <> 0) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = shift) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"desf; congruence."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) : exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w.","conclusion":"exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid)","proofString":"destruct (classic ((codom_rel new_rfi) r)) as [X|X].\nunfolder in X; desf.\nexists x; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\neapply new_rfif; basic_solver.\nexfalso; eauto.\nexists r; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : codom_rel new_rfi r) : exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w.","conclusion":"exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : codom_rel new_rfi r)","proofString":"unfolder in X; desf.\nexists x; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\neapply new_rfif; basic_solver.\nexfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) : exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w.","conclusion":"exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r)","proofString":"exists x; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\neapply new_rfif; basic_solver.\nexfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) : (new_rfi_ex new_rfi)⁻¹ r x.","conclusion":"(new_rfi_ex new_rfi)⁻¹ r x","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r)","proofString":"unfold new_rfi_ex; basic_solver 12."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) : forall x' : actid, (new_rfi_ex new_rfi)⁻¹ r x' -> x = x'.","conclusion":"forall x' : actid, (new_rfi_ex new_rfi)⁻¹ r x' -> x = x'","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r)","proofString":"unfold new_rfi_ex; unfolder; ins; desf.\neapply new_rfif; basic_solver.\nexfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) (x' : actid) (H : new_rfi x' r) : x = x'.","conclusion":"x = x'","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) (x' : actid) (H : new_rfi x' r)","proofString":"eapply new_rfif; basic_solver."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) (H0 : ~ (exists x0 : actid, new_rfi x0 r)) : x = r.","conclusion":"x = r","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r x : actid) (X : new_rfi x r) (H0 : ~ (exists x0 : actid, new_rfi x0 r))","proofString":"exfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r) : exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w.","conclusion":"exists ! w : actid, (new_rfi_ex new_rfi)⁻¹ r w","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r)","proofString":"exists r; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r) : (new_rfi_ex new_rfi)⁻¹ r r.","conclusion":"(new_rfi_ex new_rfi)⁻¹ r r","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r)","proofString":"unfold new_rfi_ex; basic_solver 12."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r) : forall x' : actid, (new_rfi_ex new_rfi)⁻¹ r x' -> r = x'.","conclusion":"forall x' : actid, (new_rfi_ex new_rfi)⁻¹ r x' -> r = x'","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r)","proofString":"unfold new_rfi_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto."},{"statement":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r) (x' : actid) (H : new_rfi x' r) : r = x'.","conclusion":"r = x'","hypotheses":"(new_rfi : relation actid) (new_rfif : functional new_rfi⁻¹) (r : actid) (X : ~ codom_rel new_rfi r) (x' : actid) (H : new_rfi x' r)","proofString":"unfolder in X; exfalso; eauto."},{"statement":"(tid : thread_id) (s : state) (new_rfi : relation actid) (TWF : thread_wf tid s) (RFI_INDEX : new_rfi ⊆ ext_sb) (RFI : new_rfi (ThreadEvent tid (eindex s)) (ThreadEvent tid (eindex s))) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : state) (new_rfi : relation actid) (TWF : thread_wf tid s) (RFI_INDEX : new_rfi ⊆ ext_sb) (RFI : new_rfi (ThreadEvent tid (eindex s)) (ThreadEvent tid (eindex s)))","proofString":"apply RFI_INDEX in RFI.\neby eapply ext_sb_irr."},{"statement":"(tid : thread_id) (s : state) (new_rfi : relation actid) (TWF : thread_wf tid s) (RFI_INDEX : new_rfi ⊆ ext_sb) (RFI : ext_sb (ThreadEvent tid (eindex s)) (ThreadEvent tid (eindex s))) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : state) (new_rfi : relation actid) (TWF : thread_wf tid s) (RFI_INDEX : new_rfi ⊆ ext_sb) (RFI : ext_sb (ThreadEvent tid (eindex s)) (ThreadEvent tid (eindex s)))","proofString":"eby eapply ext_sb_irr."},{"statement":"(tid : thread_id) (s : state) (new_rfi : relation actid) (TWF : thread_wf tid s) (RFI_INDEX : new_rfi ⊆ ext_sb) (r : actid) (RFI : new_rfi (ThreadEvent tid (eindex s)) r) (IN : acts_set (G s) r) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : state) (new_rfi : relation actid) (TWF : thread_wf tid s) (RFI_INDEX : new_rfi ⊆ ext_sb) (r : actid) (RFI : new_rfi (ThreadEvent tid (eindex s)) r) (IN : acts_set (G s) r)","proofString":"specialize (TWF r IN); desf.\napply RFI_INDEX in RFI.\nunfold sb, ext_sb in RFI; unfolder in RFI; desf; lia."},{"statement":"(tid : thread_id) (s : state) (new_rfi : relation actid) (index : nat) (LT : index < eindex s) (RFI_INDEX : new_rfi ⊆ ext_sb) (IN : acts_set (G s) (ThreadEvent tid index)) (RFI : new_rfi (ThreadEvent tid (eindex s)) (ThreadEvent tid index)) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : state) (new_rfi : relation actid) (index : nat) (LT : index < eindex s) (RFI_INDEX : new_rfi ⊆ ext_sb) (IN : acts_set (G s) (ThreadEvent tid index)) (RFI : new_rfi (ThreadEvent tid (eindex s)) (ThreadEvent tid index))","proofString":"apply RFI_INDEX in RFI.\nunfold sb, ext_sb in RFI; unfolder in RFI; desf; lia."},{"statement":"(tid : thread_id) (s : state) (new_rfi : relation actid) (index : nat) (LT : index < eindex s) (RFI_INDEX : new_rfi ⊆ ext_sb) (IN : acts_set (G s) (ThreadEvent tid index)) (RFI : ext_sb (ThreadEvent tid (eindex s)) (ThreadEvent tid index)) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : state) (new_rfi : relation actid) (index : nat) (LT : index < eindex s) (RFI_INDEX : new_rfi ⊆ ext_sb) (IN : acts_set (G s) (ThreadEvent tid index)) (RFI : ext_sb (ThreadEvent tid (eindex s)) (ThreadEvent tid index))","proofString":"unfold sb, ext_sb in RFI; unfolder in RFI; desf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"assert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply store; reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nby ins; rewrite <- DEPF, <- UDEPS.\nins; congruence.\nsimpl; ins.\nunfold add, acts_set in INw; ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nexfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\ndestruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr.","conclusion":"RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"ins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : forall a : actid, MOD a -> ~ DepsFile.lexpr_deps (depf s1) lexpr a.","conclusion":"forall a : actid, MOD a -> ~ DepsFile.lexpr_deps (depf s1) lexpr a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"ins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a) : exists y : actid, addr (G s2) a y.","conclusion":"exists y : actid, addr (G s2) a y","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a)","proofString":"exists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a) : addr (G s2) a (ThreadEvent tid (eindex s1)).","conclusion":"addr (G s2) a (ThreadEvent tid (eindex s1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a)","proofString":"rewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply store; reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nby ins; rewrite <- DEPF, <- UDEPS.\nins; congruence.\nsimpl; ins.\nunfold add, acts_set in INw; ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nexfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\ndestruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"do 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply store; reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nby ins; rewrite <- DEPF, <- UDEPS.\nins; congruence.\nsimpl; ins.\nunfold add, acts_set in INw; ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nexfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\ndestruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution (G s2)\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD.","conclusion":"sim_execution (G s2)\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"destruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := acts2;\n      threads_set := lab2;\n      lab := rmw2;\n      rmw := data2;\n      data := addr2;\n      addr := ctrl2;\n      ctrl := rf2;\n      rmw_dep := co2;\n      rf := rf;\n      co := co\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |}\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |}\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := acts2;\n      threads_set := lab2;\n      lab := rmw2;\n      rmw := data2;\n      data := addr2;\n      addr := ctrl2;\n      ctrl := rf2;\n      rmw_dep := co2;\n      rf := rf;\n      co := co\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"inversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n                 (RegFile.eval_expr (regf s1) expr));\n          rmw := rmw (G s1);\n          data :=\n            data (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr\n              × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n      threads_set := eq tid ∪₁ threads_set (G s1);\n      lab :=\n        upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n          (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n             (RegFile.eval_expr (regf s1) expr));\n      rmw := rmw (G s1);\n      data :=\n        data (G s1)\n        ∪ DepsFile.expr_deps (depf s1) expr\n          × eq (ThreadEvent tid (eindex s1));\n      addr :=\n        addr (G s1)\n        ∪ DepsFile.lexpr_deps (depf s1) lexpr\n          × eq (ThreadEvent tid (eindex s1));\n      ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n      rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n      rf := ∅₂;\n      co := ∅₂\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr));\n    rmw := rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr));\n    rmw := rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n                 (RegFile.eval_expr (regf s1) expr));\n          rmw := rmw (G s1);\n          data :=\n            data (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr\n              × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n      threads_set := eq tid ∪₁ threads_set (G s1);\n      lab :=\n        upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n          (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n             (RegFile.eval_expr (regf s1) expr));\n      rmw := rmw (G s1);\n      data :=\n        data (G s1)\n        ∪ DepsFile.expr_deps (depf s1) expr\n          × eq (ThreadEvent tid (eindex s1));\n      addr :=\n        addr (G s1)\n        ∪ DepsFile.lexpr_deps (depf s1) lexpr\n          × eq (ThreadEvent tid (eindex s1));\n      ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n      rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n      rf := ∅₂;\n      co := ∅₂\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"red in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n                 (RegFile.eval_expr (regf s1) expr));\n          rmw := rmw (G s1);\n          data :=\n            data (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr\n              × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n      threads_set := eq tid ∪₁ threads_set (G s1);\n      lab :=\n        upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n          (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n             (RegFile.eval_expr (regf s1) expr));\n      rmw := rmw (G s1);\n      data :=\n        data (G s1)\n        ∪ DepsFile.expr_deps (depf s1) expr\n          × eq (ThreadEvent tid (eindex s1));\n      addr :=\n        addr (G s1)\n        ∪ DepsFile.lexpr_deps (depf s1) lexpr\n          × eq (ThreadEvent tid (eindex s1));\n      ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n      rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n      rf := ∅₂;\n      co := ∅₂\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr));\n    rmw := rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr));\n    rmw := rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))\n     (DepsFile.expr_deps (depf s1') expr)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n                 (RegFile.eval_expr (regf s1) expr));\n          rmw := rmw (G s1);\n          data :=\n            data (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr\n              × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n      threads_set := eq tid ∪₁ threads_set (G s1);\n      lab :=\n        upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n          (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n             (RegFile.eval_expr (regf s1) expr));\n      rmw := rmw (G s1);\n      data :=\n        data (G s1)\n        ∪ DepsFile.expr_deps (depf s1) expr\n          × eq (ThreadEvent tid (eindex s1));\n      addr :=\n        addr (G s1)\n        ∪ DepsFile.lexpr_deps (depf s1) lexpr\n          × eq (ThreadEvent tid (eindex s1));\n      ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n      rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n      rf := ∅₂;\n      co := ∅₂\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"red; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1').","conclusion":"eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite EINDEX, ACTS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1').","conclusion":"eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite TS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))).","conclusion":"same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))).","conclusion":"same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"unfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid)","proofString":"destruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (e0 : e = ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (e0 : e = ThreadEvent tid (eindex s1'))","proofString":"by subst; rewrite !upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr)) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1'))","proofString":"rewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a)","proofString":"rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a)","proofString":"destruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\ndesf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')) =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) (ThreadEvent tid (eindex s1')).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')) =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1')))","proofString":"desf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) : Some (RegFile.eval_expr (regf s1') expr) =\nSome (RegFile.eval_expr (regf s1) expr).","conclusion":"Some (RegFile.eval_expr (regf s1') expr) =\nSome (RegFile.eval_expr (regf s1) expr)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1')))","proofString":"erewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) (a : actid) (IN : MOD a) (DEPS : DepsFile.expr_deps (depf s1) expr a) : ~ MOD (ThreadEvent tid (eindex s1)).","conclusion":"~ MOD (ThreadEvent tid (eindex s1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) (a : actid) (IN : MOD a) (DEPS : DepsFile.expr_deps (depf s1) expr a)","proofString":"by rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1'))","proofString":"unfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1')) : match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1'))","proofString":"by apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : data (G s1)\n∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1))\n≡ data (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr × eq (ThreadEvent tid (eindex s1')).","conclusion":"data (G s1)\n∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1))\n≡ data (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite DATA, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : addr (G s1)\n∪ DepsFile.lexpr_deps (depf s1) lexpr × eq (ThreadEvent tid (eindex s1))\n≡ addr (G s1')\n  ∪ DepsFile.lexpr_deps (depf s1') lexpr × eq (ThreadEvent tid (eindex s1')).","conclusion":"addr (G s1)\n∪ DepsFile.lexpr_deps (depf s1) lexpr × eq (ThreadEvent tid (eindex s1))\n≡ addr (G s1')\n  ∪ DepsFile.lexpr_deps (depf s1') lexpr × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite ADDR, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1))\n≡ ctrl (G s1') ∪ ectrl s1' × eq (ThreadEvent tid (eindex s1')).","conclusion":"ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1))\n≡ ctrl (G s1') ∪ ectrl s1' × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite CTRL, EINDEX, ECTRL."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1')).","conclusion":"rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr × eq (ThreadEvent tid (eindex s1)))\n  ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (reg0 : BinNums.positive) : RegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a).","conclusion":"RegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (reg0 : BinNums.positive)","proofString":"unfold RegFun.add, RegFun.find in *; desf; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r)","proofString":"unfold add, acts_set in INw; ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nexfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\ndestruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r)","proofString":"destruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nexfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\ndestruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r)","proofString":"exfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r) : ThreadEvent tid (eindex s1) = r \\/ acts_set (G s1) r.","conclusion":"ThreadEvent tid (eindex s1) = r \\/ acts_set (G s1) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r)","proofString":"rewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (H : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r) : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1) r.","conclusion":"ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (H : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r)","proofString":"right; eapply sim_execution_same_acts; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"destruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')) =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')) =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"by unfold is_r in *; rewrite !upds in READ; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"eapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nby unfold is_r in *; rewrite updo in READ.\nby unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in INr; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"by unfold is_r in *; rewrite updo in READ."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : is_w (lab (G s1')) w.","conclusion":"is_w (lab (G s1')) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 ->\nmatch lab (G s1') r0 with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"by unfold is_w in *; rewrite updo in WRITE."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r = \nSome (new_val r).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r = \nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r)","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1'))) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')) =\nSome (new_val (ThreadEvent tid (eindex s1'))).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')) =\nSome (new_val (ThreadEvent tid (eindex s1')))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) (ThreadEvent tid (eindex s1')))","proofString":"by unfold is_r in *; rewrite upds in READ; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r = \nSome (new_val r).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r = \nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r).","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"apply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_r in *; rewrite updo in READ; try done."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1') r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Astore Xpln ord (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr))) r) (IN_MOD : MOD r) (IN : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1') r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply fence; reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nby ins; rewrite <- DEPF, <- UDEPS.\nins; congruence.\nins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"do 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply fence; reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nby ins; rewrite <- DEPF, <- UDEPS.\nins; congruence.\nins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : sim_execution (G s2)\n  (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD.","conclusion":"sim_execution (G s2)\n  (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"destruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |} (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |} (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"inversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab := upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr := addr (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |} (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab := upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr := addr (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |} (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"red in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab := upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr := addr (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |} (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab := upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr := addr (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep := rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |} (add (G s1') tid (eindex s1') (Afence ord) ∅ ∅ (ectrl s1') ∅) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"red; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1').","conclusion":"eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by rewrite EINDEX, ACTS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1').","conclusion":"eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by rewrite TS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : same_lab_u2v (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord)).","conclusion":"same_lab_u2v (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : same_lab_u2v (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)).","conclusion":"same_lab_u2v (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"unfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (e : actid) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (e : actid)","proofString":"destruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (e : actid) (e0 : e = ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (e : actid) (e0 : e = ThreadEvent tid (eindex s1'))","proofString":"by subst; rewrite !upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (e : actid) (n : e <> ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (e : actid) (n : e <> ThreadEvent tid (eindex s1'))","proofString":"rewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord)) a.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1)) (Afence ord)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a)","proofString":"rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)) a.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a)","proofString":"destruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1')) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)) a.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1'))","proofString":"by desf; unfold val; rewrite !upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1')) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)) a.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) a =\nval (upd (lab (G s1)) (ThreadEvent tid (eindex s1')) (Afence ord)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1')) : match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a0 : actid, RegFun.find reg (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1'))","proofString":"by apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ data (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1')).","conclusion":"data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ data (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by rewrite DATA, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : addr (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ addr (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1')).","conclusion":"addr (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ addr (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by rewrite ADDR, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1))\n≡ ctrl (G s1') ∪ ectrl s1' × eq (ThreadEvent tid (eindex s1')).","conclusion":"ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1))\n≡ ctrl (G s1') ∪ ectrl s1' × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by rewrite CTRL, EINDEX, ECTRL."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1')).","conclusion":"rmw_dep (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"by rewrite FRMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (reg : BinNums.positive) : RegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a).","conclusion":"RegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (reg : BinNums.positive)","proofString":"unfold RegFun.add, RegFun.find in *; desf; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r)","proofString":"destruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1')).","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r)","proofString":"by unfold is_w in WRITE; rewrite upds in WRITE; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1')) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1')) =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1')) =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"by unfold is_r in READ; rewrite upds in READ; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w.","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nval (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"eapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in INr; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') w.","conclusion":"acts_set (G s1') w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in INw; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_r in *; rewrite updo in READ; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : is_w (lab (G s1')) w.","conclusion":"is_w (lab (G s1')) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (WRITE : is_w (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nSome (new_val r).","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r)","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1'))) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1')) =\nSome (new_val (ThreadEvent tid (eindex s1'))).","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1')) =\nSome (new_val (ThreadEvent tid (eindex s1')))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord))\n  (ThreadEvent tid (eindex s1')))","proofString":"by unfold is_r in *; rewrite upds in READ; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nSome (new_val r).","conclusion":"val (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r =\nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r).","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"apply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_r in *; rewrite updo in READ; try done."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg : BinNums.positive,\nRegFun.find reg (regf s1) = RegFun.find reg (regf s1') \\/\n(exists a : actid, RegFun.find reg (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (r : actid) (READ : is_r (upd (lab (G s1')) (ThreadEvent tid (eindex s1')) (Afence ord)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"assert (rexmod = true); subst.\nclear -ISTEP CASREX.\nred in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf.\nassert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\neapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_un with (val := val_); try reflexivity.\nerewrite <- regf_expr_helper with (regf := (regf s1)); try edone.\nins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"clear -ISTEP CASREX.\nred in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1))","proofString":"red in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1))","proofString":"set (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1))","proofString":"symmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : nth_error (instrs s1) (pc s1) =\nSome\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : nth_error (instrs s1) (pc s1) =\nSome\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr))","proofString":"apply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : In\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)\n  (instrs s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : In\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)\n  (instrs s1))","proofString":"apply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : cas_produces_R_ex_instr\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : cas_produces_R_ex_instr\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr))","proofString":"red in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : if rexmod then True else False) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : if rexmod then True else False)","proofString":"desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"assert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\neapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_un with (val := val_); try reflexivity.\nerewrite <- regf_expr_helper with (regf := (regf s1)); try edone.\nins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr.","conclusion":"RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : forall a : actid, MOD a -> ~ DepsFile.lexpr_deps (depf s1) lexpr a.","conclusion":"forall a : actid, MOD a -> ~ DepsFile.lexpr_deps (depf s1) lexpr a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"ins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a) : exists y : actid, addr (G s2) a y.","conclusion":"exists y : actid, addr (G s2) a y","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a)","proofString":"exists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a) : addr (G s2) a (ThreadEvent tid (eindex s1)).","conclusion":"addr (G s2) a (ThreadEvent tid (eindex s1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a)","proofString":"rewrite UG; unfold add; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_un with (val := val_); try reflexivity.\nerewrite <- regf_expr_helper with (regf := (regf s1)); try edone.\nins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"do 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_un with (val := val_); try reflexivity.\nerewrite <- regf_expr_helper with (regf := (regf s1)); try edone.\nins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : val_ <> RegFile.eval_expr (regf s1') expr_old.","conclusion":"val_ <> RegFile.eval_expr (regf s1') expr_old","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"erewrite <- regf_expr_helper with (regf := (regf s1)); try edone.\nins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : forall a : actid, MOD a -> ~ DepsFile.expr_deps (depf s1) expr_old a.","conclusion":"forall a : actid, MOD a -> ~ DepsFile.expr_deps (depf s1) expr_old a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"ins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution (G s2)\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution (G s2)\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"destruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := acts2;\n       threads_set := lab2;\n       lab := rmw2;\n       rmw := data2;\n       data := addr2;\n       addr := ctrl2;\n       ctrl := rf2;\n       rmw_dep := co2;\n       rf := rf;\n       co := co\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := acts2;\n           threads_set := lab2;\n           lab := rmw2;\n           rmw := data2;\n           data := addr2;\n           addr := ctrl2;\n           ctrl := rf2;\n           rmw_dep := co2;\n           rf := rf;\n           co := co\n         |}) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |}\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |}\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := acts2;\n       threads_set := lab2;\n       lab := rmw2;\n       rmw := data2;\n       data := addr2;\n       addr := ctrl2;\n       ctrl := rf2;\n       rmw_dep := co2;\n       rf := rf;\n       co := co\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := acts2;\n           threads_set := lab2;\n           lab := rmw2;\n           rmw := data2;\n           data := addr2;\n           addr := ctrl2;\n           ctrl := rf2;\n           rmw_dep := co2;\n           rf := rf;\n           co := co\n         |}) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"inversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n       threads_set := eq tid ∪₁ threads_set (G s1);\n       lab :=\n         upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n       rmw := rmw (G s1);\n       data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n       addr :=\n         addr (G s1)\n         ∪ DepsFile.lexpr_deps (depf s1) lexpr\n           × eq (ThreadEvent tid (eindex s1));\n       ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n       rmw_dep :=\n         rmw_dep (G s1)\n         ∪ DepsFile.expr_deps (depf s1) expr_old\n           × eq (ThreadEvent tid (eindex s1));\n       rf := ∅₂;\n       co := ∅₂\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n           threads_set := eq tid ∪₁ threads_set (G s1);\n           lab :=\n             upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n               (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n           rmw := rmw (G s1);\n           data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n           addr :=\n             addr (G s1)\n             ∪ DepsFile.lexpr_deps (depf s1) lexpr\n               × eq (ThreadEvent tid (eindex s1));\n           ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n           rmw_dep :=\n             rmw_dep (G s1)\n             ∪ DepsFile.expr_deps (depf s1) expr_old\n               × eq (ThreadEvent tid (eindex s1));\n           rf := ∅₂;\n           co := ∅₂\n         |}) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n       threads_set := eq tid ∪₁ threads_set (G s1);\n       lab :=\n         upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n       rmw := rmw (G s1);\n       data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n       addr :=\n         addr (G s1)\n         ∪ DepsFile.lexpr_deps (depf s1) lexpr\n           × eq (ThreadEvent tid (eindex s1));\n       ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n       rmw_dep :=\n         rmw_dep (G s1)\n         ∪ DepsFile.expr_deps (depf s1) expr_old\n           × eq (ThreadEvent tid (eindex s1));\n       rf := ∅₂;\n       co := ∅₂\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n           threads_set := eq tid ∪₁ threads_set (G s1);\n           lab :=\n             upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n               (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n           rmw := rmw (G s1);\n           data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n           addr :=\n             addr (G s1)\n             ∪ DepsFile.lexpr_deps (depf s1) lexpr\n               × eq (ThreadEvent tid (eindex s1));\n           ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n           rmw_dep :=\n             rmw_dep (G s1)\n             ∪ DepsFile.expr_deps (depf s1) expr_old\n               × eq (ThreadEvent tid (eindex s1));\n           rf := ∅₂;\n           co := ∅₂\n         |}) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"red in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n       threads_set := eq tid ∪₁ threads_set (G s1);\n       lab :=\n         upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n       rmw := rmw (G s1);\n       data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n       addr :=\n         addr (G s1)\n         ∪ DepsFile.lexpr_deps (depf s1) lexpr\n           × eq (ThreadEvent tid (eindex s1));\n       ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n       rmw_dep :=\n         rmw_dep (G s1)\n         ∪ DepsFile.expr_deps (depf s1) expr_old\n           × eq (ThreadEvent tid (eindex s1));\n       rf := ∅₂;\n       co := ∅₂\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n           threads_set := eq tid ∪₁ threads_set (G s1);\n           lab :=\n             upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n               (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n           rmw := rmw (G s1);\n           data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n           addr :=\n             addr (G s1)\n             ∪ DepsFile.lexpr_deps (depf s1) lexpr\n               × eq (ThreadEvent tid (eindex s1));\n           ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n           rmw_dep :=\n             rmw_dep (G s1)\n             ∪ DepsFile.expr_deps (depf s1) expr_old\n               × eq (ThreadEvent tid (eindex s1));\n           rf := ∅₂;\n           co := ∅₂\n         |}) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n    rmw := rmw (G s1);\n    data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1));\n    ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) ∅\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n          threads_set := eq tid ∪₁ threads_set (G s1);\n          lab :=\n            upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n              (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n          rmw := rmw (G s1);\n          data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n          addr :=\n            addr (G s1)\n            ∪ DepsFile.lexpr_deps (depf s1) lexpr\n              × eq (ThreadEvent tid (eindex s1));\n          ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n          rmw_dep :=\n            rmw_dep (G s1)\n            ∪ DepsFile.expr_deps (depf s1) expr_old\n              × eq (ThreadEvent tid (eindex s1));\n          rf := ∅₂;\n          co := ∅₂\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n       threads_set := eq tid ∪₁ threads_set (G s1);\n       lab :=\n         upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n       rmw := rmw (G s1);\n       data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n       addr :=\n         addr (G s1)\n         ∪ DepsFile.lexpr_deps (depf s1) lexpr\n           × eq (ThreadEvent tid (eindex s1));\n       ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n       rmw_dep :=\n         rmw_dep (G s1)\n         ∪ DepsFile.expr_deps (depf s1) expr_old\n           × eq (ThreadEvent tid (eindex s1));\n       rf := ∅₂;\n       co := ∅₂\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n           threads_set := eq tid ∪₁ threads_set (G s1);\n           lab :=\n             upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n               (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_);\n           rmw := rmw (G s1);\n           data := data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1));\n           addr :=\n             addr (G s1)\n             ∪ DepsFile.lexpr_deps (depf s1) lexpr\n               × eq (ThreadEvent tid (eindex s1));\n           ctrl := ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1));\n           rmw_dep :=\n             rmw_dep (G s1)\n             ∪ DepsFile.expr_deps (depf s1) expr_old\n               × eq (ThreadEvent tid (eindex s1));\n           rf := ∅₂;\n           co := ∅₂\n         |}) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"red; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite DATA, EINDEX.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1').","conclusion":"eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite EINDEX, ACTS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1').","conclusion":"eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite TS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)).","conclusion":"same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)).","conclusion":"same_lab_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"unfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid)","proofString":"destruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (e0 : e = ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (e0 : e = ThreadEvent tid (eindex s1'))","proofString":"by subst; rewrite !upds; rewrite SAME_LOC."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_) e)\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1'))","proofString":"rewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a)","proofString":"rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a)","proofString":"destruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1'))","proofString":"rewrite SAME_LOC.\nby desf; unfold val; rewrite !upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1'))","proofString":"by desf; unfold val; rewrite !upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) a =\nval\n  (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1')) : match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a0 : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a0)\n⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1'))","proofString":"by apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ data (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1')).","conclusion":"data (G s1) ∪ ∅ × eq (ThreadEvent tid (eindex s1))\n≡ data (G s1') ∪ ∅ × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite DATA, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : addr (G s1)\n∪ DepsFile.lexpr_deps (depf s1) lexpr × eq (ThreadEvent tid (eindex s1))\n≡ addr (G s1')\n  ∪ DepsFile.lexpr_deps (depf s1') lexpr × eq (ThreadEvent tid (eindex s1')).","conclusion":"addr (G s1)\n∪ DepsFile.lexpr_deps (depf s1) lexpr × eq (ThreadEvent tid (eindex s1))\n≡ addr (G s1')\n  ∪ DepsFile.lexpr_deps (depf s1') lexpr × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite ADDR, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1))\n≡ ctrl (G s1') ∪ ectrl s1' × eq (ThreadEvent tid (eindex s1')).","conclusion":"ctrl (G s1) ∪ ectrl s1 × eq (ThreadEvent tid (eindex s1))\n≡ ctrl (G s1') ∪ ectrl s1' × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite CTRL, EINDEX, ECTRL."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : rmw_dep (G s1)\n∪ DepsFile.expr_deps (depf s1) expr_old × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr_old\n    × eq (ThreadEvent tid (eindex s1')).","conclusion":"rmw_dep (G s1)\n∪ DepsFile.expr_deps (depf s1) expr_old × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr_old\n    × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NREX : MOD ∩₁ (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n         (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (reg0 : BinNums.positive) : RegFun.find reg0 (RegFun.add reg val_ (regf s1)) =\nRegFun.find reg0 (RegFun.add reg val_ (regf s1')) \\/\n(exists a : actid,\n   RegFun.find reg0\n     (RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) a /\\ \n   MOD a).","conclusion":"RegFun.find reg0 (RegFun.add reg val_ (regf s1)) =\nRegFun.find reg0 (RegFun.add reg val_ (regf s1')) \\/\n(exists a : actid,\n   RegFun.find reg0\n     (RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) a /\\ \n   MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (reg0 : BinNums.positive)","proofString":"unfold RegFun.add, RegFun.find in *; desf; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r)","proofString":"destruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD r)","proofString":"by unfold is_w in WRITE; rewrite upds in WRITE; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')) =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')) =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"exfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"eapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1')) : (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n  (ThreadEvent tid (eindex s1')).","conclusion":"(eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n  (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"rewrite EINDEX; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1')) : match\n  upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend.","conclusion":"match\n  upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n : w <> ThreadEvent tid (eindex s1'))","proofString":"by rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w.","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nval\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"eapply NEW_VAL1; try edone.\nunfolder in INr.\ndesf.\nunfolder in INw.\ndesf.\nunfold is_r in *; rewrite updo in READ; try edone.\nunfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in INr.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1') r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1') r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') w.","conclusion":"acts_set (G s1') w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in INw.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : ThreadEvent tid (eindex s1') = w \\/ acts_set (G s1') w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') w.","conclusion":"acts_set (G s1') w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : ThreadEvent tid (eindex s1') = w \\/ acts_set (G s1') w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_r in *; rewrite updo in READ; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1')) : is_w (lab (G s1')) w.","conclusion":"is_w (lab (G s1')) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (INw : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) w) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (WRITE : is_w\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) w) (IN_MOD : MOD r) (n : w <> ThreadEvent tid (eindex s1')) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_w in *; rewrite updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nSome (new_val r).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r)","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')) =\nSome (new_val (ThreadEvent tid (eindex s1'))).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')) =\nSome (new_val (ThreadEvent tid (eindex s1')))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')))","proofString":"exfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')))","proofString":"eapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) : (eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n  (ThreadEvent tid (eindex s1')).","conclusion":"(eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1))\n  (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')))","proofString":"rewrite EINDEX; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1'))) : match\n  upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend.","conclusion":"match\n  upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_)\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1'))\n  (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_))\n  (ThreadEvent tid (eindex s1')))","proofString":"by rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nSome (new_val r).","conclusion":"val\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r =\nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r).","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"apply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_r in *; rewrite updo in READ; try done."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1')) ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in IN.\ndesf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1') r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val_ : value) (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val_ (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr) val_)) r) (IN_MOD : MOD r) (IN : ThreadEvent tid (eindex s1') = r \\/ acts_set (G s1') r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1'))","proofString":"desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"assert (rexmod = true); subst.\nclear -ISTEP CASREX.\nred in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf.\nassert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_suc; try reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nerewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby rewrite upds in READ; desf.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"clear -ISTEP CASREX.\nred in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1))","proofString":"red in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1))","proofString":"set (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1))","proofString":"symmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : nth_error (instrs s1) (pc s1) =\nSome\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : nth_error (instrs s1) (pc s1) =\nSome\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr))","proofString":"apply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : In\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)\n  (instrs s1)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : In\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)\n  (instrs s1))","proofString":"apply CASREX in AA.\nred in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : cas_produces_R_ex_instr\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr)) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : cas_produces_R_ex_instr\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr))","proofString":"red in AA.\ndesf."},{"statement":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : if rexmod then True else False) : rexmod = true.","conclusion":"rexmod = true","hypotheses":"(s1 : state) (CASREX : forall i : Instr.t, In i (instrs s1) -> cas_produces_R_ex_instr i) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (AA : if rexmod then True else False)","proofString":"desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"assert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_suc; try reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nerewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby rewrite upds in READ; desf.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr.","conclusion":"RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"ins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) : forall a : actid, MOD a -> ~ DepsFile.lexpr_deps (depf s1) lexpr a.","conclusion":"forall a : actid, MOD a -> ~ DepsFile.lexpr_deps (depf s1) lexpr a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r))","proofString":"ins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a) : exists y : actid, addr (G s2) a y.","conclusion":"exists y : actid, addr (G s2) a y","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a)","proofString":"exists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a) : addr (G s2) a (ThreadEvent tid (eindex s1)).","conclusion":"addr (G s2) a (ThreadEvent tid (eindex s1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a0 : actid => R_ex (lab (G s2)) a0) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (a : actid) (IN : MOD a) (H : DepsFile.lexpr_deps (depf s1) lexpr a)","proofString":"rewrite UG; unfold add_rmw; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"cut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_suc; try reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nerewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby rewrite upds in READ; desf.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : (exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"(exists\n   (instrs : list Instr.t) (pc : nat) (G_ : execution) \n (eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n (ectrl : actid -> Prop),\n   step tid s1'\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} /\\\n   sim_state s2\n     {|\n       instrs := instrs;\n       pc := pc;\n       G := G_;\n       eindex := eindex;\n       regf := regf;\n       depf := depf;\n       ectrl := ectrl\n     |} MOD new_rfi new_val) ->\nexists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by ins; desc; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val.","conclusion":"exists\n  (instrs : list Instr.t) (pc : nat) (G_ : execution) \n(eindex : nat) (regf : RegFile.t) (depf : DepsFile.t) \n(ectrl : actid -> Prop),\n  step tid s1'\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} /\\\n  sim_state s2\n    {|\n      instrs := instrs;\n      pc := pc;\n      G := G_;\n      eindex := eindex;\n      regf := regf;\n      depf := depf;\n      ectrl := ectrl\n    |} MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"do 7 eexists; splits; red; splits.\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_suc; try reflexivity.\nins; congruence.\nins; congruence.\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF.\nins; congruence.\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nerewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver.\neby ins; rewrite <- DEPF, <- EINDEX.\nins; congruence.\nins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby rewrite upds in READ; desf.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone.\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution (G s2)\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution (G s2)\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"destruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := acts2;\n       threads_set := lab2;\n       lab := rmw2;\n       rmw := data2;\n       data := addr2;\n       addr := ctrl2;\n       ctrl := rf2;\n       rmw_dep := co2;\n       rf := rf;\n       co := co\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := acts2;\n           threads_set := lab2;\n           lab := rmw2;\n           rmw := data2;\n           data := addr2;\n           addr := ctrl2;\n           ctrl := rf2;\n           rmw_dep := co2;\n           rf := rf;\n           co := co\n         |}) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := acts2;\n      threads_set := lab2;\n      lab := rmw2;\n      rmw := data2;\n      data := addr2;\n      addr := ctrl2;\n      ctrl := rf2;\n      rmw_dep := co2;\n      rf := rf;\n      co := co\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set := acts2;\n    threads_set := lab2;\n    lab := rmw2;\n    rmw := data2;\n    data := addr2;\n    addr := ctrl2;\n    ctrl := rf2;\n    rmw_dep := co2;\n    rf := rf;\n    co := co\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (acts2 : actid -> Prop) (lab2 : thread_id -> Prop) (rmw2 : actid -> label) (data2 addr2 ctrl2 rf2 co2 rf co : actid -> actid -> Prop) (UG : {|\n  acts_set := acts2;\n  threads_set := lab2;\n  lab := rmw2;\n  rmw := data2;\n  data := addr2;\n  addr := ctrl2;\n  ctrl := rf2;\n  rmw_dep := co2;\n  rf := rf;\n  co := co\n|} =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr\n        {|\n          acts_set := acts2;\n          threads_set := lab2;\n          lab := rmw2;\n          rmw := data2;\n          data := addr2;\n          addr := ctrl2;\n          ctrl := rf2;\n          rmw_dep := co2;\n          rf := rf;\n          co := co\n        |}) ⊆₁ ∅) (NREX : MOD\n∩₁ acts_set\n     {|\n       acts_set := acts2;\n       threads_set := lab2;\n       lab := rmw2;\n       rmw := data2;\n       data := addr2;\n       addr := ctrl2;\n       ctrl := rf2;\n       rmw_dep := co2;\n       rf := rf;\n       co := co\n     |}\n∩₁ (fun a : actid =>\n    R_ex\n      (lab\n         {|\n           acts_set := acts2;\n           threads_set := lab2;\n           lab := rmw2;\n           rmw := data2;\n           data := addr2;\n           addr := ctrl2;\n           ctrl := rf2;\n           rmw_dep := co2;\n           rf := rf;\n           co := co\n         |}) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ data\n    {|\n      acts_set := acts2;\n      threads_set := lab2;\n      lab := rmw2;\n      rmw := data2;\n      data := addr2;\n      addr := ctrl2;\n      ctrl := rf2;\n      rmw_dep := co2;\n      rf := rf;\n      co := co\n    |} ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"inversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd\n         (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n            (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n               (RegFile.eval_expr (regf s1) expr_old)))\n         (ThreadEvent tid (eindex s1 + 1))\n         (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n            (RegFile.eval_expr (regf s1) expr_new))) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set :=\n      eq (ThreadEvent tid (eindex s1 + 1))\n      ∪₁ eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new));\n    rmw :=\n      singl_rel (ThreadEvent tid (eindex s1))\n        (ThreadEvent tid (eindex s1 + 1)) ∪ rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_new\n        × eq (ThreadEvent tid (eindex s1 + 1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    ctrl :=\n      ctrl (G s1)\n      ∪ ectrl s1\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set :=\n      eq (ThreadEvent tid (eindex s1 + 1))\n      ∪₁ eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new));\n    rmw :=\n      singl_rel (ThreadEvent tid (eindex s1))\n        (ThreadEvent tid (eindex s1 + 1)) ∪ rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_new\n        × eq (ThreadEvent tid (eindex s1 + 1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    ctrl :=\n      ctrl (G s1)\n      ∪ ectrl s1\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ acts_set (G s1))\n∩₁ (fun a : actid =>\n    R_ex\n      (upd\n         (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n            (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n               (RegFile.eval_expr (regf s1) expr_old)))\n         (ThreadEvent tid (eindex s1 + 1))\n         (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n            (RegFile.eval_expr (regf s1) expr_new))) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"unfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set :=\n      eq (ThreadEvent tid (eindex s1 + 1))\n      ∪₁ eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new));\n    rmw :=\n      singl_rel (ThreadEvent tid (eindex s1))\n        (ThreadEvent tid (eindex s1 + 1)) ∪ rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_new\n        × eq (ThreadEvent tid (eindex s1 + 1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    ctrl :=\n      ctrl (G s1)\n      ∪ ectrl s1\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set :=\n      eq (ThreadEvent tid (eindex s1 + 1))\n      ∪₁ eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new));\n    rmw :=\n      singl_rel (ThreadEvent tid (eindex s1))\n        (ThreadEvent tid (eindex s1 + 1)) ∪ rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_new\n        × eq (ThreadEvent tid (eindex s1 + 1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    ctrl :=\n      ctrl (G s1)\n      ∪ ectrl s1\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"red in EXEC; desc.\nred; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : sim_execution\n  {|\n    acts_set :=\n      eq (ThreadEvent tid (eindex s1 + 1))\n      ∪₁ eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new));\n    rmw :=\n      singl_rel (ThreadEvent tid (eindex s1))\n        (ThreadEvent tid (eindex s1 + 1)) ∪ rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_new\n        × eq (ThreadEvent tid (eindex s1 + 1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    ctrl :=\n      ctrl (G s1)\n      ∪ ectrl s1\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD.","conclusion":"sim_execution\n  {|\n    acts_set :=\n      eq (ThreadEvent tid (eindex s1 + 1))\n      ∪₁ eq (ThreadEvent tid (eindex s1)) ∪₁ acts_set (G s1);\n    threads_set := eq tid ∪₁ threads_set (G s1);\n    lab :=\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new));\n    rmw :=\n      singl_rel (ThreadEvent tid (eindex s1))\n        (ThreadEvent tid (eindex s1 + 1)) ∪ rmw (G s1);\n    data :=\n      data (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_new\n        × eq (ThreadEvent tid (eindex s1 + 1));\n    addr :=\n      addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    ctrl :=\n      ctrl (G s1)\n      ∪ ectrl s1\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)));\n    rmw_dep :=\n      rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1));\n    rf := ∅₂;\n    co := ∅₂\n  |}\n  (add_rmw (G s1') tid (eindex s1')\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))\n     (DepsFile.expr_deps (depf s1') expr_new)\n     (DepsFile.lexpr_deps (depf s1') lexpr) (ectrl s1')\n     (DepsFile.expr_deps (depf s1') expr_old)) MOD","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"red; splits; ins.\nby rewrite EINDEX, ACTS.\nby rewrite TS.\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\nby rewrite RMW, EINDEX.\nby rewrite DATA, EINDEX, DEPF.\nby rewrite ADDR, EINDEX, DEPF.\nby rewrite CTRL, EINDEX, ECTRL.\nby rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n∪₁ acts_set (G s1').","conclusion":"eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n∪₁ acts_set (G s1) =\neq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n∪₁ acts_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite EINDEX, ACTS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1').","conclusion":"eq tid ∪₁ threads_set (G s1) ≡₁ eq tid ∪₁ threads_set (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite TS."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : same_lab_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1 + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))).","conclusion":"same_lab_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1 + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : same_lab_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))).","conclusion":"same_lab_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"unfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) : True ->\nsame_label_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid)","proofString":"destruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (e0 : e = ThreadEvent tid (eindex s1' + 1)) : True ->\nsame_label_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (e0 : e = ThreadEvent tid (eindex s1' + 1))","proofString":"by subst; rewrite !upds; rewrite SAME_LOC."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1)) : True ->\nsame_label_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1))","proofString":"rewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1)) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1))","proofString":"destruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1)) (e0 : e = ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1)) (e0 : e = ThreadEvent tid (eindex s1'))","proofString":"by subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1)) (n0 : e <> ThreadEvent tid (eindex s1')) : True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e).","conclusion":"True ->\nsame_label_u2v\n  (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n     (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_old)) e)\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)) e)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v_dom (fun _ : actid => True) (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (e : actid) (n : e <> ThreadEvent tid (eindex s1' + 1)) (n0 : e <> ThreadEvent tid (eindex s1'))","proofString":"rewrite !updo; auto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1 + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1 + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a)","proofString":"rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a)","proofString":"destruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1' + 1)) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (e : a = ThreadEvent tid (eindex s1' + 1))","proofString":"subst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1' + 1))) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)) =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)).","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)) =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1) expr_new)))\n  (ThreadEvent tid (eindex s1' + 1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1' + 1)))","proofString":"unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1' + 1))) : Some (RegFile.eval_expr (regf s1') expr_new) =\nSome (RegFile.eval_expr (regf s1) expr_new).","conclusion":"Some (RegFile.eval_expr (regf s1') expr_new) =\nSome (RegFile.eval_expr (regf s1) expr_new)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1' + 1)))","proofString":"erewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1' + 1))) (a : actid) (IN : MOD a) (DEPS : DepsFile.expr_deps (depf s1) expr_new a) : ~ MOD (ThreadEvent tid (eindex s1 + 1)).","conclusion":"~ MOD (ThreadEvent tid (eindex s1 + 1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN : ~ MOD (ThreadEvent tid (eindex s1' + 1))) (a : actid) (IN : MOD a) (DEPS : DepsFile.expr_deps (depf s1) expr_new a)","proofString":"by rewrite EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) a =\nval\n  (upd\n     (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n        (RegFile.eval_expr (regf s1) expr_new))) a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1))","proofString":"unfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1))","proofString":"destruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) (e : a = ThreadEvent tid (eindex s1')) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) (e : a = ThreadEvent tid (eindex s1'))","proofString":"subst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1')))","proofString":"rewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) : Some (RegFile.eval_expr (regf s1') expr_old) =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"Some (RegFile.eval_expr (regf s1') expr_old) =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1')))","proofString":"rewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) : Some (RegFile.eval_expr (regf s1') expr_old) =\nmatch\n  upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1) expr_old)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"Some (RegFile.eval_expr (regf s1') expr_old) =\nmatch\n  upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1) expr_old)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1')))","proofString":"rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1'))) : Some (RegFile.eval_expr (regf s1') expr_old) =\nSome (RegFile.eval_expr (regf s1) expr_old).","conclusion":"Some (RegFile.eval_expr (regf s1') expr_old) =\nSome (RegFile.eval_expr (regf s1) expr_old)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN : ~ MOD (ThreadEvent tid (eindex s1')))","proofString":"erewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) (n0 : a <> ThreadEvent tid (eindex s1')) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) a\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) (n0 : a <> ThreadEvent tid (eindex s1'))","proofString":"rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) (n0 : a <> ThreadEvent tid (eindex s1')) : match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1) a with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a0 : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a0\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a0 : actid, ~ MOD a0 -> val (lab (G s1')) a0 = val (lab (G s1)) a0) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a0 : actid, RegFun.find reg0 (depf s1) a0 /\\ MOD a0)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (a : actid) (NIN : ~ MOD a) (n : a <> ThreadEvent tid (eindex s1' + 1)) (n0 : a <> ThreadEvent tid (eindex s1'))","proofString":"by apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : singl_rel (ThreadEvent tid (eindex s1)) (ThreadEvent tid (eindex s1 + 1))\n∪ rmw (G s1)\n≡ singl_rel (ThreadEvent tid (eindex s1')) (ThreadEvent tid (eindex s1' + 1))\n  ∪ rmw (G s1').","conclusion":"singl_rel (ThreadEvent tid (eindex s1)) (ThreadEvent tid (eindex s1 + 1))\n∪ rmw (G s1)\n≡ singl_rel (ThreadEvent tid (eindex s1')) (ThreadEvent tid (eindex s1' + 1))\n  ∪ rmw (G s1')","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite RMW, EINDEX."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : data (G s1)\n∪ DepsFile.expr_deps (depf s1) expr_new\n  × eq (ThreadEvent tid (eindex s1 + 1))\n≡ data (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr_new\n    × eq (ThreadEvent tid (eindex s1' + 1)).","conclusion":"data (G s1)\n∪ DepsFile.expr_deps (depf s1) expr_new\n  × eq (ThreadEvent tid (eindex s1 + 1))\n≡ data (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr_new\n    × eq (ThreadEvent tid (eindex s1' + 1))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite DATA, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : addr (G s1)\n∪ DepsFile.lexpr_deps (depf s1) lexpr\n  × (eq (ThreadEvent tid (eindex s1)) ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))\n≡ addr (G s1')\n  ∪ DepsFile.lexpr_deps (depf s1') lexpr\n    × (eq (ThreadEvent tid (eindex s1'))\n       ∪₁ eq (ThreadEvent tid (eindex s1' + 1))).","conclusion":"addr (G s1)\n∪ DepsFile.lexpr_deps (depf s1) lexpr\n  × (eq (ThreadEvent tid (eindex s1)) ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))\n≡ addr (G s1')\n  ∪ DepsFile.lexpr_deps (depf s1') lexpr\n    × (eq (ThreadEvent tid (eindex s1'))\n       ∪₁ eq (ThreadEvent tid (eindex s1' + 1)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite ADDR, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : ctrl (G s1)\n∪ ectrl s1\n  × (eq (ThreadEvent tid (eindex s1)) ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))\n≡ ctrl (G s1')\n  ∪ ectrl s1'\n    × (eq (ThreadEvent tid (eindex s1'))\n       ∪₁ eq (ThreadEvent tid (eindex s1' + 1))).","conclusion":"ctrl (G s1)\n∪ ectrl s1\n  × (eq (ThreadEvent tid (eindex s1)) ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))\n≡ ctrl (G s1')\n  ∪ ectrl s1'\n    × (eq (ThreadEvent tid (eindex s1'))\n       ∪₁ eq (ThreadEvent tid (eindex s1' + 1)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite CTRL, EINDEX, ECTRL."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : rmw_dep (G s1)\n∪ DepsFile.expr_deps (depf s1) expr_old × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr_old\n    × eq (ThreadEvent tid (eindex s1')).","conclusion":"rmw_dep (G s1)\n∪ DepsFile.expr_deps (depf s1) expr_old × eq (ThreadEvent tid (eindex s1))\n≡ rmw_dep (G s1')\n  ∪ DepsFile.expr_deps (depf s1') expr_old\n    × eq (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD\n∩₁ dom_rel\n     (rmw_dep (G s1)\n      ∪ DepsFile.expr_deps (depf s1) expr_old\n        × eq (ThreadEvent tid (eindex s1))) ⊆₁ ∅) (NADDR : MOD\n∩₁ dom_rel\n     (addr (G s1)\n      ∪ DepsFile.lexpr_deps (depf s1) lexpr\n        × (eq (ThreadEvent tid (eindex s1))\n           ∪₁ eq (ThreadEvent tid (eindex s1 + 1)))) ⊆₁ ∅) (NREX : MOD\n∩₁ (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n    ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1 in acts_set))\n∩₁ (fun a : actid =>\n    match\n      upd\n        (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n           (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n              (RegFile.eval_expr (regf s1) expr_old)))\n        (ThreadEvent tid (eindex s1 + 1))\n        (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n           (RegFile.eval_expr (regf s1) expr_new)) a\n    with\n    | Aload r _ _ _ => r\n    | _ => false\n    end) ⊆₁ ∅) (NDATA : ⦗MOD⦘\n⨾ (data (G s1)\n   ∪ DepsFile.expr_deps (depf s1) expr_new\n     × eq (ThreadEvent tid (eindex s1 + 1))) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (ACTS : acts_set (G s1) = acts_set (G s1')) (TS : threads_set (G s1) ≡₁ threads_set (G s1')) (SAME : same_lab_u2v (lab (G s1')) (lab (G s1))) (OLD_VAL : forall a : actid, ~ MOD a -> val (lab (G s1')) a = val (lab (G s1)) a) (RMW : rmw (G s1) ≡ rmw (G s1')) (DATA : data (G s1) ≡ data (G s1')) (ADDR : addr (G s1) ≡ addr (G s1')) (CTRL : ctrl (G s1) ≡ ctrl (G s1')) (FRMW : rmw_dep (G s1) ≡ rmw_dep (G s1')) (RRF : rf (G s1) ≡ rf (G s1')) (RCO : co (G s1) ≡ co (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"by rewrite FRMW, EINDEX, DEPF."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (reg0 : BinNums.positive) : RegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) =\nRegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1') expr_old) (regf s1')) \\/\n(exists a : actid,\n   RegFun.find reg0\n     (RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) a /\\ \n   MOD a).","conclusion":"RegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) =\nRegFun.find reg0\n  (RegFun.add reg (RegFile.eval_expr (regf s1') expr_old) (regf s1')) \\/\n(exists a : actid,\n   RegFun.find reg0\n     (RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) a /\\ \n   MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg1 : BinNums.positive,\nRegFun.find reg1 (regf s1) = RegFun.find reg1 (regf s1') \\/\n(exists a : actid, RegFun.find reg1 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (reg0 : BinNums.positive)","proofString":"unfold RegFun.add, RegFun.find in *; desf; eauto.\nerewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr_old\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then eq (ThreadEvent tid (eindex s1))\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : RegFile.eval_expr (regf s1) expr_old = RegFile.eval_expr (regf s1') expr_old \\/\n(exists a : actid, ThreadEvent tid (eindex s1) = a /\\ MOD a).","conclusion":"RegFile.eval_expr (regf s1) expr_old = RegFile.eval_expr (regf s1') expr_old \\/\n(exists a : actid, ThreadEvent tid (eindex s1) = a /\\ MOD a)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr_old\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then eq (ThreadEvent tid (eindex s1))\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"erewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr_old\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then eq (ThreadEvent tid (eindex s1))\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) : forall a : actid, MOD a -> ~ DepsFile.expr_deps (depf s1) expr_old a.","conclusion":"forall a : actid, MOD a -> ~ DepsFile.expr_deps (depf s1) expr_old a","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then RegFile.eval_expr (regf s1) expr_old\n else regf s1 a')) (UDEPS : depf s2 =\n(fun a' : BinNums.positive =>\n if RegSet.Facts.eq_dec a' reg\n then eq (ThreadEvent tid (eindex s1))\n else depf s1 a')) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nregf s1 reg0 = regf s1' reg0 \\/ (exists a : actid, depf s1 reg0 a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr)","proofString":"ins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r)","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby rewrite upds in READ; desf.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (RF : new_rfi w (ThreadEvent tid (eindex s1' + 1))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent tid (eindex s1' + 1))) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)) =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)) =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (RF : new_rfi w (ThreadEvent tid (eindex s1' + 1))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent tid (eindex s1' + 1)))","proofString":"by rewrite upds in READ; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1))","proofString":"destruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')).","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1))","proofString":"rewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')).","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1')) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1))","proofString":"by rewrite upds in WRITE; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1'))","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1')) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')) =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')) =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1'))","proofString":"exfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1'))","proofString":"eapply NREX; split; [eauto|].\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1')) : (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n ∪₁ acts_set (G s1)) (ThreadEvent tid (eindex s1')).","conclusion":"(eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n ∪₁ acts_set (G s1)) (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1'))","proofString":"rewrite EINDEX; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1')) : match\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1 + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend.","conclusion":"match\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1 + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w0 : actid,\nnew_rfi w0 r ->\nacts_set (G s1') r ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w0 -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w0) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (w : actid) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1'))) (RF : new_rfi w (ThreadEvent tid (eindex s1'))) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (n0 : w <> ThreadEvent tid (eindex s1'))","proofString":"by rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w.","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r =\nval\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) r\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) r\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1'))","proofString":"rewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1'))","proofString":"destruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\nrewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1' + 1)) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1' + 1)) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1'))","proofString":"exfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1' + 1)) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : new_rfi (ThreadEvent tid (eindex s1' + 1)) r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1'))","proofString":"apply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : match r with\n| InitEvent _ => False\n| ThreadEvent t' i' => tid = t' /\\ eindex s1' + 1 < i'\nend) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (RF : match r with\n| InitEvent _ => False\n| ThreadEvent t' i' => tid = t' /\\ eindex s1' + 1 < i'\nend) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1'))","proofString":"destruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1'))","proofString":"destruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)\n  (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)\n  (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1'))","proofString":"apply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)\n  (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)\n  (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1'))","proofString":"apply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : acts_set (G s1) (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (INr : acts_set (G s1) (ThreadEvent thread index)) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1'))","proofString":"apply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (index0 : nat) (EE : ThreadEvent thread index = ThreadEvent tid index0) (LT : index0 < eindex s1) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1' + 1 < index) (index0 : nat) (EE : ThreadEvent thread index = ThreadEvent tid index0) (LT : index0 < eindex s1) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1'))","proofString":"rewrite <- EINDEX in RF0.\ndesf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1 + 1 < index) (index0 : nat) (EE : ThreadEvent thread index = ThreadEvent tid index0) (LT : index0 < eindex s1) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1')) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : acts_set (G s1) ≡₁ acts_set (G s1')) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (thread : thread_id) (index : nat) (RF : tid = thread) (RF0 : eindex s1 + 1 < index) (index0 : nat) (EE : ThreadEvent thread index = ThreadEvent tid index0) (LT : index0 < eindex s1) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set))\n  (ThreadEvent tid (eindex s1' + 1))) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) (ThreadEvent thread index)\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new))\n    (ThreadEvent tid (eindex s1' + 1))\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD (ThreadEvent thread index)) (n : ThreadEvent thread index <> ThreadEvent tid (eindex s1' + 1)) (n0 : ThreadEvent tid (eindex s1' + 1) <> ThreadEvent tid (eindex s1')) (n1 : ThreadEvent thread index <> ThreadEvent tid (eindex s1'))","proofString":"desf; lia."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1)) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1))","proofString":"rewrite !updo; try done.\neapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1)) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend.","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend =\nmatch lab (G s1') w with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1))","proofString":"eapply NEW_VAL1; try edone.\nunfolder in INr; desf.\nunfolder in INw; desf.\nby rewrite !updo in READ; try edone.\nby rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1)) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1))","proofString":"unfolder in INr; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1)) : acts_set (G s1') w.","conclusion":"acts_set (G s1') w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1))","proofString":"unfolder in INw; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1)) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1))","proofString":"by rewrite !updo in READ; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1)) : is_w (lab (G s1')) w.","conclusion":"is_w (lab (G s1')) w","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w0 : actid,\nnew_rfi w0 r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w0 ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w0 ->\nMOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w0) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r w : actid) (RF : new_rfi w r) (INr : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) r) (INw : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ (let (acts_set, _, _, _, _, _, _, _, _, _) := G s1' in acts_set)) w) (READ : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) r\nwith\n| Aload _ _ _ _ => true\n| _ => false\nend) (WRITE : match\n  upd\n    (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n          (RegFile.eval_expr (regf s1') expr_old)))\n    (ThreadEvent tid (eindex s1' + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_new)) w\nwith\n| Astore _ _ _ _ => true\n| _ => false\nend) (IN_MOD : MOD r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : w <> ThreadEvent tid (eindex s1')) (n1 : r <> ThreadEvent tid (eindex s1')) (n2 : w <> ThreadEvent tid (eindex s1' + 1))","proofString":"by rewrite !updo in WRITE; try edone."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r = \nSome (new_val r).","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r = \nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r)","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1' + 1))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1' + 1))) (IN_MOD : MOD (ThreadEvent tid (eindex s1' + 1))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1))) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)) =\nSome (new_val (ThreadEvent tid (eindex s1' + 1))).","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)) =\nSome (new_val (ThreadEvent tid (eindex s1' + 1)))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1' + 1))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1' + 1))) (IN_MOD : MOD (ThreadEvent tid (eindex s1' + 1))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1' + 1)))","proofString":"by unfold is_r in READ; rewrite upds in READ; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) : val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r = \nSome (new_val r).","conclusion":"val\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r = \nSome (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1))","proofString":"unfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) r\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r).","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) r\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1))","proofString":"destruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nexfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1'))) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val (ThreadEvent tid (eindex s1'))).","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old))\n    (ThreadEvent tid (eindex s1'))\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val (ThreadEvent tid (eindex s1')))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')))","proofString":"exfalso.\neapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1'))) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')))","proofString":"eapply NREX; split; [eauto|].\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1'))) : (eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n ∪₁ acts_set (G s1)) (ThreadEvent tid (eindex s1')).","conclusion":"(eq (ThreadEvent tid (eindex s1 + 1)) ∪₁ eq (ThreadEvent tid (eindex s1))\n ∪₁ acts_set (G s1)) (ThreadEvent tid (eindex s1'))","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')))","proofString":"rewrite EINDEX; basic_solver."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1'))) : match\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1 + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend.","conclusion":"match\n  upd\n    (upd (lab (G s1)) (ThreadEvent tid (eindex s1))\n       (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n          (RegFile.eval_expr (regf s1) expr_old)))\n    (ThreadEvent tid (eindex s1 + 1))\n    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n       (RegFile.eval_expr (regf s1) expr_new)) (ThreadEvent tid (eindex s1'))\nwith\n| Aload r _ _ _ => r\n| _ => false\nend","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r w : actid,\nnew_rfi w r ->\nacts_set (G s1') r ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r ->\nis_w (lab (G s1')) w -> MOD r -> val (lab (G s1')) r = val (lab (G s1')) w) (NEW_VAL2 : forall r : actid,\nis_r (lab (G s1')) r ->\nMOD r ->\nacts_set (G s1') r ->\n~ codom_rel new_rfi r -> val (lab (G s1')) r = Some (new_val r)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (n : ThreadEvent tid (eindex s1') <> ThreadEvent tid (eindex s1' + 1)) (NIN_NEW_RF : ~ codom_rel new_rfi (ThreadEvent tid (eindex s1'))) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) (ThreadEvent tid (eindex s1'))) (IN_MOD : MOD (ThreadEvent tid (eindex s1'))) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new)))\n  (ThreadEvent tid (eindex s1')))","proofString":"by rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1')) : match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) r\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r).","conclusion":"match\n  upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n    (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n       (RegFile.eval_expr (regf s1') expr_old)) r\nwith\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1')) : match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r).","conclusion":"match lab (G s1') r with\n| Aload _ _ _ v | Astore _ _ _ v => Some v\n| Afence _ => None\nend = Some (new_val r)","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"apply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1')) : is_r (lab (G s1')) r.","conclusion":"is_r (lab (G s1')) r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfold is_r in *; rewrite !updo in READ; try done."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1')) : acts_set (G s1') r.","conclusion":"acts_set (G s1') r","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS0 : instrs s1 = instrs s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (expr_old expr_new : Instr.expr) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) true xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload true ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (INSTRS : instrs s1 = instrs s1') (PC : pc s1 = pc s1') (EXEC : sim_execution (G s1) (G s1') MOD) (EINDEX : eindex s1 = eindex s1') (REGF : forall reg0 : BinNums.positive,\nRegFun.find reg0 (regf s1) = RegFun.find reg0 (regf s1') \\/\n(exists a : actid, RegFun.find reg0 (depf s1) a /\\ MOD a)) (DEPF : depf s1 = depf s1') (ECTRL : ectrl s1 = ectrl s1') (NEW_VAL1 : forall r0 w : actid,\nnew_rfi w r0 ->\nacts_set (G s1') r0 ->\nacts_set (G s1') w ->\nis_r (lab (G s1')) r0 ->\nis_w (lab (G s1')) w -> MOD r0 -> val (lab (G s1')) r0 = val (lab (G s1')) w) (NEW_VAL2 : forall r0 : actid,\nis_r (lab (G s1')) r0 ->\nMOD r0 ->\nacts_set (G s1') r0 ->\n~ codom_rel new_rfi r0 -> val (lab (G s1')) r0 = Some (new_val r0)) (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr) (r : actid) (READ : is_r\n  (upd\n     (upd (lab (G s1')) (ThreadEvent tid (eindex s1'))\n        (Aload true ordr (RegFile.eval_lexpr (regf s1') lexpr)\n           (RegFile.eval_expr (regf s1') expr_old)))\n     (ThreadEvent tid (eindex s1' + 1))\n     (Astore xmod ordw (RegFile.eval_lexpr (regf s1') lexpr)\n        (RegFile.eval_expr (regf s1') expr_new))) r) (IN_MOD : MOD r) (IN : (eq (ThreadEvent tid (eindex s1' + 1)) ∪₁ eq (ThreadEvent tid (eindex s1'))\n ∪₁ acts_set (G s1')) r) (NIN_NEW_RF : ~ codom_rel new_rfi r) (n : r <> ThreadEvent tid (eindex s1' + 1)) (n0 : r <> ThreadEvent tid (eindex s1'))","proofString":"unfolder in IN; desf."},{"statement":"(tid : thread_id) (s1 s2 : state) (x : list label) (INSTRS : instrs s1 = instrs s2) (instr : Instr.t) (ISTEP : Some instr = nth_error (instrs s1) (pc s1)) (ISTEP0 : istep_ tid x s1 s2 instr) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (x : list label) (INSTRS : instrs s1 = instrs s2) (instr : Instr.t) (ISTEP : Some instr = nth_error (instrs s1) (pc s1)) (ISTEP0 : istep_ tid x s1 s2 instr) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"destruct ISTEP0; desf.\neby eapply receptiveness_sim_assign.\neby eapply receptiveness_sim_if_else.\neby eapply receptiveness_sim_if_then.\neby eapply receptiveness_sim_load.\neby eapply receptiveness_sim_store.\neby eapply receptiveness_sim_fence.\neby eapply receptiveness_sim_cas_fail.\neby eapply receptiveness_sim_cas_suc.\neby eapply receptiveness_sim_inc.\neby eapply receptiveness_sim_exchange."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (reg : Reg.t) (expr : Instr.expr) (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_assign."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (e : RegFile.eval_expr (regf s1) expr = 0) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr : Instr.expr) (shift : nat) (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1)) (e : RegFile.eval_expr (regf s1) expr = 0) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_if_else."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr : Instr.expr) (ISTEP : Some (Instr.ifgoto expr (pc s2)) = nth_error (instrs s1) (pc s1)) (n : RegFile.eval_expr (regf s1) expr <> 0) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr : Instr.expr) (ISTEP : Some (Instr.ifgoto expr (pc s2)) = nth_error (instrs s1) (pc s1)) (n : RegFile.eval_expr (regf s1) expr <> 0) (UG : G s2 = G s1) (UINDEX : eindex s2 = eindex s1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_if_then."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some (Instr.load ord reg lexpr) = nth_error (instrs s1) (pc s1)) (val : value) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload false ord (RegFile.eval_lexpr (regf s1) lexpr) val) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (ord : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some (Instr.load ord reg lexpr) = nth_error (instrs s1) (pc s1)) (val : value) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload false ord (RegFile.eval_lexpr (regf s1) lexpr) val) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_load."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (ord : mode) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (ord : mode) (lexpr : Instr.lexpr) (expr : Instr.expr) (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr)) (DepsFile.expr_deps (depf s1) expr)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_store."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (ord : mode) (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = regf s1) (UDEPS : depf s2 = depf s1) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_fence."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val : value) (NEXPECTED : val <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val : value) (NEXPECTED : val <> RegFile.eval_expr (regf s1) expr_old) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val) ∅\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 1) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_cas_fail."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_old expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_old))\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n  (DepsFile.expr_deps (depf s1) expr_old)) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_cas_suc."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_add : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.fetch_add expr_add) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val : nat) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val)\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (val + RegFile.eval_expr (regf s1) expr_add))\n  (eq (ThreadEvent tid (eindex s1)) ∪₁ DepsFile.expr_deps (depf s1) expr_add)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_add : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some\n  (Instr.update (Instr.fetch_add expr_add) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val : nat) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val)\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (val + RegFile.eval_expr (regf s1) expr_add))\n  (eq (ThreadEvent tid (eindex s1)) ∪₁ DepsFile.expr_deps (depf s1) expr_add)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_inc."},{"statement":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some (Instr.update (Instr.exchange expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val : value) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val)\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state, step tid s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (INSTRS : instrs s1 = instrs s2) (expr_new : Instr.expr) (rexmod : bool) (xmod : x_mode) (ordr ordw : mode) (reg : Reg.t) (lexpr : Instr.lexpr) (ISTEP : Some (Instr.update (Instr.exchange expr_new) rexmod xmod ordr ordw reg lexpr) =\nnth_error (instrs s1) (pc s1)) (val : value) (UPC : pc s2 = pc s1 + 1) (UG : G s2 =\nadd_rmw (G s1) tid (eindex s1)\n  (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val)\n  (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n     (RegFile.eval_expr (regf s1) expr_new))\n  (DepsFile.expr_deps (depf s1) expr_new)\n  (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) (UINDEX : eindex s2 = eindex s1 + 2) (UREGS : regf s2 = RegFun.add reg val (regf s1)) (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1)) (UECTRL : ectrl s2 = ectrl s1) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"eby eapply receptiveness_sim_exchange."},{"statement":"(tid : thread_id) (s1 s2 : state) (STEPS : clos_refl_trans_n1 state (step tid) s1 s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 s2 : state) (STEPS : clos_refl_trans_n1 state (step tid) s1 s2) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s2)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s2)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s2) ∩₁ (fun a : actid => R_ex (lab (G s2)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s2) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"induction STEPS.\nby eexists; vauto.\nexploit IHSTEPS.\nunfolder; splits; ins; eauto; desf.\neapply ectrl_increasing in H1; eauto.\neapply NCTRL; basic_solver.\nunfolder; splits; ins; eauto; desf.\neapply rmw_dep_increasing in H1; eauto.\neapply NFRMW; basic_solver.\nunfolder; splits; ins; eauto; desf.\neapply addr_increasing in H1; eauto.\neapply NADDR; basic_solver.\nunfolder; splits; ins; eauto; desf.\neapply NREX; split; [split; [eauto |] |].\neapply acts_increasing; edone.\neapply is_r_ex_increasing; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt.\nbasic_solver.\nunfolder; splits; ins; eauto; desf.\neapply data_increasing in H1; eauto.\neapply NDATA; basic_solver.\nintro; desc.\neapply receptiveness_sim_step in x0; eauto; desf.\nexists s2'0; splits; eauto.\nby eapply rt_trans; [eauto | econs].\narewrite (instrs y = instrs s1); auto.\napply clos_rtn1_rt in STEPS.\neapply steps_preserve_instrs; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s1 : state) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s1 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s1)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s1)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s1) ∩₁ (fun a : actid => R_ex (lab (G s1)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s1) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) : exists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state s1 s2' MOD new_rfi new_val.","conclusion":"exists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state s1 s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 : state) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl s1 ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G s1)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G s1)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G s1) ∩₁ (fun a : actid => R_ex (lab (G s1)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G s1) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val)","proofString":"by eexists; vauto."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) : exists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state z s2' MOD new_rfi new_val.","conclusion":"exists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state z s2' MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val)","proofString":"exploit IHSTEPS.\nunfolder; splits; ins; eauto; desf.\neapply ectrl_increasing in H1; eauto.\neapply NCTRL; basic_solver.\nunfolder; splits; ins; eauto; desf.\neapply rmw_dep_increasing in H1; eauto.\neapply NFRMW; basic_solver.\nunfolder; splits; ins; eauto; desf.\neapply addr_increasing in H1; eauto.\neapply NADDR; basic_solver.\nunfolder; splits; ins; eauto; desf.\neapply NREX; split; [split; [eauto |] |].\neapply acts_increasing; edone.\neapply is_r_ex_increasing; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt.\nbasic_solver.\nunfolder; splits; ins; eauto; desf.\neapply data_increasing in H1; eauto.\neapply NDATA; basic_solver.\nintro; desc.\neapply receptiveness_sim_step in x0; eauto; desf.\nexists s2'0; splits; eauto.\nby eapply rt_trans; [eauto | econs].\narewrite (instrs y = instrs s1); auto.\napply clos_rtn1_rt in STEPS.\neapply steps_preserve_instrs; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) : MOD ∩₁ ectrl y ⊆₁ ∅.","conclusion":"MOD ∩₁ ectrl y ⊆₁ ∅","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val)","proofString":"unfolder; splits; ins; eauto; desf.\neapply ectrl_increasing in H1; eauto.\neapply NCTRL; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H1 : ectrl y x) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H1 : ectrl y x)","proofString":"eapply ectrl_increasing in H1; eauto.\neapply NCTRL; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H1 : ectrl z x) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H1 : ectrl z x)","proofString":"eapply NCTRL; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) : MOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅.","conclusion":"MOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val)","proofString":"unfolder; splits; ins; eauto; desf.\neapply rmw_dep_increasing in H1; eauto.\neapply NFRMW; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : rmw_dep (G y) x y0) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : rmw_dep (G y) x y0)","proofString":"eapply rmw_dep_increasing in H1; eauto.\neapply NFRMW; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : rmw_dep (G z) x y0) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : rmw_dep (G z) x y0)","proofString":"eapply NFRMW; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) : MOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅.","conclusion":"MOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val)","proofString":"unfolder; splits; ins; eauto; desf.\neapply addr_increasing in H1; eauto.\neapply NADDR; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : addr (G y) x y0) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : addr (G y) x y0)","proofString":"eapply addr_increasing in H1; eauto.\neapply NADDR; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : addr (G z) x y0) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (y0 : actid) (H1 : addr (G z) x y0)","proofString":"eapply NADDR; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) : MOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅.","conclusion":"MOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val)","proofString":"unfolder; splits; ins; eauto; desf.\neapply NREX; split; [split; [eauto |] |].\neapply acts_increasing; edone.\neapply is_r_ex_increasing; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt.\nbasic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x)","proofString":"eapply NREX; split; [split; [eauto |] |].\neapply acts_increasing; edone.\neapply is_r_ex_increasing; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt.\nbasic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x) : acts_set (G z) x.","conclusion":"acts_set (G z) x","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x)","proofString":"eapply acts_increasing; edone."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x) : R_ex (lab (G z)) x.","conclusion":"R_ex (lab (G z)) x","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x)","proofString":"eapply is_r_ex_increasing; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt.\nbasic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x) : thread_wf tid y.","conclusion":"thread_wf tid y","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x)","proofString":"eapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x) : (step tid)＊ s1 y.","conclusion":"(step tid)＊ s1 y","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x)","proofString":"by apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x) : (acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a)) x.","conclusion":"(acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a)) x","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x : actid) (H0 : MOD x) (H2 : acts_set (G y) x) (H1 : R_ex (lab (G y)) x)","proofString":"basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) : ⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂.","conclusion":"⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val)","proofString":"unfolder; splits; ins; eauto; desf.\neapply data_increasing in H1; eauto.\neapply NDATA; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x y0 : actid) (H0 : MOD x) (H1 : data (G y) x y0) (H2 : ~ MOD y0) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x y0 : actid) (H0 : MOD x) (H1 : data (G y) x y0) (H2 : ~ MOD y0)","proofString":"eapply data_increasing in H1; eauto.\neapply NDATA; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x y0 : actid) (H0 : MOD x) (H2 : ~ MOD y0) (H1 : data (G z) x y0) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2' : state,\n  (step tid)＊ s1' s2' /\\ sim_state y s2' MOD new_rfi new_val) (x y0 : actid) (H0 : MOD x) (H2 : ~ MOD y0) (H1 : data (G z) x y0)","proofString":"eapply NDATA; basic_solver."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val) : exists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state z s2'0 MOD new_rfi new_val.","conclusion":"exists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state z s2'0 MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val)","proofString":"eapply receptiveness_sim_step in x0; eauto; desf.\nexists s2'0; splits; eauto.\nby eapply rt_trans; [eauto | econs].\narewrite (instrs y = instrs s1); auto.\napply clos_rtn1_rt in STEPS.\neapply steps_preserve_instrs; eauto.\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'1 : state,\n  (step tid)＊ s1' s2'1 /\\ sim_state y s2'1 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (s2'0 : state) (x0 : step tid s2' s2'0) (x1 : sim_state z s2'0 MOD new_rfi new_val) : exists s2'1 : state,\n  (step tid)＊ s1' s2'1 /\\ sim_state z s2'1 MOD new_rfi new_val.","conclusion":"exists s2'1 : state,\n  (step tid)＊ s1' s2'1 /\\ sim_state z s2'1 MOD new_rfi new_val","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'1 : state,\n  (step tid)＊ s1' s2'1 /\\ sim_state y s2'1 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (s2'0 : state) (x0 : step tid s2' s2'0) (x1 : sim_state z s2'0 MOD new_rfi new_val)","proofString":"exists s2'0; splits; eauto.\nby eapply rt_trans; [eauto | econs]."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'1 : state,\n  (step tid)＊ s1' s2'1 /\\ sim_state y s2'1 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (s2'0 : state) (x0 : step tid s2' s2'0) (x1 : sim_state z s2'0 MOD new_rfi new_val) : (step tid)＊ s1' s2'0.","conclusion":"(step tid)＊ s1' s2'0","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'1 : state,\n  (step tid)＊ s1' s2'1 /\\ sim_state y s2'1 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (s2'0 : state) (x0 : step tid s2' s2'0) (x1 : sim_state z s2'0 MOD new_rfi new_val)","proofString":"by eapply rt_trans; [eauto | econs]."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val) : cas_produces_R_ex_instrs (instrs y).","conclusion":"cas_produces_R_ex_instrs (instrs y)","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val)","proofString":"arewrite (instrs y = instrs s1); auto.\napply clos_rtn1_rt in STEPS.\neapply steps_preserve_instrs; eauto."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val) : instrs y = instrs s1.","conclusion":"instrs y = instrs s1","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val)","proofString":"apply clos_rtn1_rt in STEPS.\neapply steps_preserve_instrs; eauto."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : (step tid)＊ s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val) : instrs y = instrs s1.","conclusion":"instrs y = instrs s1","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : (step tid)＊ s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val)","proofString":"eapply steps_preserve_instrs; eauto."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val) : thread_wf tid y.","conclusion":"thread_wf tid y","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val)","proofString":"eapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val) : (step tid)＊ s1 y.","conclusion":"(step tid)＊ s1 y","hypotheses":"(tid : thread_id) (s1 y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s1 y) (CASREX : cas_produces_R_ex_instrs (instrs s1)) (MOD : actid -> Prop) (new_rfi : relation actid) (new_val : actid -> value) (NCTRL : MOD ∩₁ ectrl z ⊆₁ ∅) (NFRMW : MOD ∩₁ dom_rel (rmw_dep (G z)) ⊆₁ ∅) (NADDR : MOD ∩₁ dom_rel (addr (G z)) ⊆₁ ∅) (NREX : MOD ∩₁ acts_set (G z) ∩₁ (fun a : actid => R_ex (lab (G z)) a) ⊆₁ ∅) (NDATA : ⦗MOD⦘ ⨾ data (G z) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) (new_rfif : functional new_rfi⁻¹) (RFI_INDEX : new_rfi ⊆ ext_sb) (TWF : thread_wf tid s1) (s1' : state) (SIM : sim_state s1 s1' MOD new_rfi new_val) (IHSTEPS : MOD ∩₁ ectrl y ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (rmw_dep (G y)) ⊆₁ ∅ ->\nMOD ∩₁ dom_rel (addr (G y)) ⊆₁ ∅ ->\nMOD ∩₁ acts_set (G y) ∩₁ (fun a : actid => R_ex (lab (G y)) a) ⊆₁ ∅ ->\n⦗MOD⦘ ⨾ data (G y) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂ ->\nexists s2'0 : state,\n  (step tid)＊ s1' s2'0 /\\ sim_state y s2'0 MOD new_rfi new_val) (s2' : state) (x : (step tid)＊ s1' s2') (x0 : sim_state y s2' MOD new_rfi new_val)","proofString":"by apply clos_rtn1_rt."},{"statement":"(tid : thread_id) (s_init s : state) (GPC : wf_thread_state tid s_init) (STEPS : clos_refl_trans_n1 state (step tid) s_init s) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G s)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G s.","conclusion":"exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G s","hypotheses":"(tid : thread_id) (s_init s : state) (GPC : wf_thread_state tid s_init) (STEPS : clos_refl_trans_n1 state (step tid) s_init s) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G s)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅)","proofString":"induction STEPS.\nexists s_init; splits; vauto.\nby rewrite (wft_ectrlE GPC).\nassert (A: MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅).\ngeneralize (ctrl_increasing H).\nrevert NCTRL; basic_solver 12.\napply IHSTEPS in A.\ndesc.\ndestruct  (classic (MOD ∩₁ ectrl z ⊆₁ ∅)).\nexists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step.\nexists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G s_init)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G s_init.","conclusion":"exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G s_init","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G s_init)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅)","proofString":"exists s_init; splits; vauto.\nby rewrite (wft_ectrlE GPC)."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G s_init)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) : MOD ∩₁ ectrl s_init ⊆₁ ∅.","conclusion":"MOD ∩₁ ectrl s_init ⊆₁ ∅","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G s_init)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅)","proofString":"by rewrite (wft_ectrlE GPC)."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G z.","conclusion":"exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y)","proofString":"assert (A: MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅).\ngeneralize (ctrl_increasing H).\nrevert NCTRL; basic_solver 12.\napply IHSTEPS in A.\ndesc.\ndestruct  (classic (MOD ∩₁ ectrl z ⊆₁ ∅)).\nexists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step.\nexists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅.","conclusion":"MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y)","proofString":"generalize (ctrl_increasing H).\nrevert NCTRL; basic_solver 12."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) : ctrl (G y) ⊆ ctrl (G z) -> MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅.","conclusion":"ctrl (G y) ⊆ ctrl (G z) -> MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y)","proofString":"revert NCTRL; basic_solver 12."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) (A : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅) : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G z.","conclusion":"exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) (A : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅)","proofString":"apply IHSTEPS in A.\ndesc.\ndestruct  (classic (MOD ∩₁ ectrl z ⊆₁ ∅)).\nexists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step.\nexists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) (A : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G z.","conclusion":"exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y) (A : exists s' : state,\n  (step tid)＊ s_init s' /\\ MOD ∩₁ ectrl s' ⊆₁ ∅ /\\ G s' = G y)","proofString":"desc.\ndestruct  (classic (MOD ∩₁ ectrl z ⊆₁ ∅)).\nexists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step.\nexists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) : exists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G z.","conclusion":"exists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y)","proofString":"destruct  (classic (MOD ∩₁ ectrl z ⊆₁ ∅)).\nexists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step.\nexists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : MOD ∩₁ ectrl z ⊆₁ ∅) : exists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G z.","conclusion":"exists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : MOD ∩₁ ectrl z ⊆₁ ∅)","proofString":"exists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : MOD ∩₁ ectrl z ⊆₁ ∅) : (step tid)＊ s_init z.","conclusion":"(step tid)＊ s_init z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : MOD ∩₁ ectrl z ⊆₁ ∅)","proofString":"eapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅) : exists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G z.","conclusion":"exists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅)","proofString":"exists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅) : G s' = G z.","conclusion":"G s' = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅)","proofString":"transitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅) : G y = G z.","conclusion":"G y = G z","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅)","proofString":"eapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅) : exists a : actid, (MOD ∩₁ ectrl z) a.","conclusion":"exists a : actid, (MOD ∩₁ ectrl z) a","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅)","proofString":"destruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver."},{"statement":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅) (H1 : ~ (exists a : actid, (MOD ∩₁ ectrl z) a)) : exists a : actid, (MOD ∩₁ ectrl z) a.","conclusion":"exists a : actid, (MOD ∩₁ ectrl z) a","hypotheses":"(tid : thread_id) (s_init : state) (GPC : wf_thread_state tid s_init) (y z : state) (H : step tid y z) (STEPS : clos_refl_trans_n1 state (step tid) s_init y) (MOD : actid -> Prop) (NCTRL : MOD ∩₁ dom_rel (ctrl (G z)) ⊆₁ ∅) (NMODINIT : MOD ∩₁ acts_set (G s_init) ⊆₁ ∅) (IHSTEPS : MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅ ->\nexists s'0 : state,\n  (step tid)＊ s_init s'0 /\\ MOD ∩₁ ectrl s'0 ⊆₁ ∅ /\\ G s'0 = G y) (s' : state) (A : (step tid)＊ s_init s') (A0 : MOD ∩₁ ectrl s' ⊆₁ ∅) (A1 : G s' = G y) (H0 : ~ MOD ∩₁ ectrl z ⊆₁ ∅) (H1 : ~ (exists a : actid, (MOD ∩₁ ectrl z) a))","proofString":"exfalso; apply H0; unfolder; ins; eapply H1; basic_solver."}]}