[{"statement":"Lemma trav_steps_left_decrease (T T' : trav_config)\n        (STEP : trav_step G sc T T') :\n    trav_steps_left T > trav_steps_left T'.","proof":"red in STEP.\ndesc.\nred in STEP.\ndesf.\n{\nunfold trav_steps_left.\nrewrite ISSEQ.\nassert (countP (E \\₁ (covered T)) findom >              countP (E \\₁ (covered T')) findom) as HH.\n2: lia.\nrewrite COVEQ.\nunfold countP.\nassert (E e) as EE by (by apply COV).\nassert (List.In e findom) as LL by (by apply AFINDOM).\nclear AFINDOM.\ninduction findom.\n{\ndone.\n}\ndestruct l as [|h l].\n{\nassert (a = e); subst.\n{\ninv LL.\n}\nsimpls.\ndesf.\n{\nexfalso; apply s0.\nby right.\n}\n{\nexfalso; apply s.\nby right.\n}\nexfalso.\napply n.\nby split.\n}\ndestruct LL as [|H]; subst.\n2: {\napply IHl in H.\nclear IHl.\nsimpls.\ndesf; simpls; try lia.\nall: try             by (exfalso; apply s0; left; apply NNPP;                 intros HH; apply n; split; auto; apply s0).\nall:             by (exfalso; apply s; left; apply NNPP;                 intros HH; apply n; split; auto; apply s).\n}\nclear IHl.\nassert (exists l', l' = h :: l) as [l' HH] by eauto.\nrewrite <- HH.\nclear h l HH.\nassert (length (filterP (E \\₁ (covered T ∪₁ eq e)) l') <=              length (filterP (E \\₁ (covered T)) l')).\n{\neapply countP_mori; auto.\nbasic_solver.\n}\nsimpls.\ndesf; simpls.\n{\nexfalso.\napply s0.\nby right.\n}\n{\nlia.\n}\n{\nexfalso.\napply s.\nby right.\n}\nexfalso.\napply n.\nby split.\n}\nunfold trav_steps_left.\nrewrite COVEQ.\nassert (countP (E ∩₁ W ∩₁ set_compl (issued T )) findom >            countP (E ∩₁ W ∩₁ set_compl (issued T')) findom) as HH.\n2: lia.\nrewrite ISSEQ.\nunfold countP.\nassert (E e) as EE.\n{\napply ISS.\n}\nassert (List.In e findom) as LL.\n{\nby apply AFINDOM.\n}\nassert (W e) as WE.\n{\napply ISS.\n}\nclear AFINDOM.\ninduction findom.\n{\ndone.\n}\ndestruct l as [|h l].\n{\nassert (a = e); subst.\n{\ninv LL.\n}\nsimpls.\ndesf.\n{\nexfalso.\napply s0.\nby right.\n}\nall: by exfalso; apply n; split.\n}\ndestruct LL as [|H]; subst.\n2: {\napply IHl in H.\nclear IHl.\nsimpls.\ndesf; simpls; try lia.\n1-2: by exfalso; apply n; destruct s0 as [H1 H2];           split; auto; intros HH; apply H2; left.\nall: by exfalso; apply n; destruct s as [H1 H2];           split; auto; intros HH; apply H2; left.\n}\nclear IHl.\nassert (exists l', l' = h :: l) as [l' HH] by eauto.\nrewrite <- HH.\nclear h l HH.\nsimpls.\ndesf; simpls.\n{\nexfalso.\napply s0.\nby right.\n}\n2: {\nexfalso.\napply s.\nby right.\n}\n2: {\nexfalso.\napply n.\nby split.\n}\nassert (length (filterP (E ∩₁ W ∩₁ set_compl (issued T ∪₁ eq e)) l') <=            length (filterP (E ∩₁ W ∩₁ set_compl (issued T)) l')).\n2: lia.\neapply countP_mori; auto.\nbasic_solver.\n"},{"statement":"Lemma trav_steps_left_decrease_sim (T T' : trav_config)\n        (STEP : sim_trav_step G sc T T') :\n    trav_steps_left T > trav_steps_left T'.","proof":"red in STEP.\ndesc.\ndestruct STEP.\n1-4: by apply trav_steps_left_decrease; red; eauto.\n{\neapply Nat.lt_trans.\nall: apply trav_steps_left_decrease; red; eauto.\n}\n{\neapply Nat.lt_trans.\nall: apply trav_steps_left_decrease; red; eauto.\n}\neapply Nat.lt_trans.\neapply Nat.lt_trans.\nall: apply trav_steps_left_decrease; red; eauto.\n"},{"statement":"Lemma trav_steps_left_null_cov (T : trav_config)\n        (NULL : trav_steps_left T = 0) :\n    E ⊆₁ covered T.","proof":"unfold trav_steps_left in *.\nassert (countP (E \\₁ (covered T)) findom = 0) as HH by lia.\nclear NULL.\nunfold countP in *.\napply length_zero_iff_nil in HH.\nintros x EX.\ndestruct (classic (covered T x)) as [|NN]; auto.\nexfalso.\nassert (In x (filterP (E \\₁ (covered T)) findom)) as UU.\n2: {\nrewrite HH in UU.\ninv UU.\n}\napply in_filterP_iff.\ndo 2 (split; auto).\n"},{"statement":"Lemma trav_steps_left_ncov_nnull (T : trav_config) e\n        (EE : E e) (NCOV : ~ covered T e):\n    trav_steps_left T <> 0.","proof":"destruct (classic (trav_steps_left T = 0)) as [EQ|NEQ]; auto.\nexfalso.\napply NCOV.\napply trav_steps_left_null_cov; auto.\n"},{"statement":"Lemma trav_steps_left_nnull_ncov (T : trav_config) (TCCOH : tc_coherent G sc T)\n        (NNULL : trav_steps_left T > 0):\n    exists e, E e /\\ ~ covered T e.","proof":"unfold trav_steps_left in *.\nassert (countP (E \\₁ (covered T)) findom > 0 \\/            countP (E ∩₁ W ∩₁ set_compl (issued T)) findom > 0) as YY by lia.\nassert (countP (E \\₁ (covered T)) findom > 0) as HH.\n{\ndestruct YY as [|YY]; auto.\nassert (countP (E \\₁  (covered T)) findom >=              countP (E ∩₁ W ∩₁ set_compl (issued T)) findom).\n2: lia.\napply countP_mori; auto.\nintros x [[EX WX] NN].\nsplit; auto.\nintros COV.\napply NN.\neapply w_covered_issued; eauto.\nby split.\n}\nclear YY.\nunfold countP in HH.\nassert (exists h l, filterP (E \\₁ (covered T)) findom = h :: l) as YY.\n{\ndestruct (filterP (E \\₁ (covered T)) findom); eauto.\ninv HH.\n}\ndesc.\nexists h.\nassert (In h (filterP (E \\₁ (covered T)) findom)) as GG.\n{\nrewrite YY.\nred.\nby left.\n}\napply in_filterP_iff in GG.\napply GG.\n"},{"statement":"Lemma trav_steps_left_decrease_sim_trans (T T' : trav_config)\n        (STEPS : (sim_trav_step G sc)⁺ T T') :\n    trav_steps_left T > trav_steps_left T'.","proof":"induction STEPS.\n{\nby apply trav_steps_left_decrease_sim.\n}\neapply Nat.lt_trans; eauto.\n"},{"statement":"Lemma sim_traversal_helper T\n        (FINDOM : set_finite E)\n        (IMMCON : imm_consistent G sc)\n        (TCCOH : tc_coherent G sc T)\n        (RELCOV :  W ∩₁ Rel ∩₁ issued T ⊆₁ covered T)\n        (RMWCOV : forall r w (RMW : rmw r w), covered T r <-> covered T w) :\n    exists T', (sim_trav_step G sc)＊ T T' /\\ ((acts_set G) ⊆₁ covered T').","proof":"cdes FINDOM.\nassert      (exists T' : trav_config, (sim_trav_step G sc)＊ T T' /\\                                trav_steps_left findom T' = 0).\n2: {\ndesc.\neexists.\nsplits; eauto.\neapply trav_steps_left_null_cov; eauto.\n}\nassert (exists n, n = trav_steps_left findom T) as [n NN] by eauto.\ngeneralize dependent T.\ngeneralize dependent n.\nset (P n :=           forall T,             tc_coherent G sc T ->             W ∩₁ Rel ∩₁ issued T ⊆₁ covered T ->             (forall r w, rmw r w -> covered T r <-> covered T w) ->             n = trav_steps_left findom T ->             exists T', (sim_trav_step G sc)＊ T T' /\\ trav_steps_left findom T' = 0).\nassert (forall n, P n) as YY.\n2: by apply YY.\napply nat_ind_lt.\nunfold P.\nins.\ndestruct (classic (trav_steps_left findom T = 0)) as [EQ|NEQ].\n{\neexists.\nsplits; eauto.\napply rt_refl.\n}\nassert (trav_steps_left findom T > 0) as HH by lia.\neapply trav_steps_left_nnull_ncov in HH; auto.\ndesc.\neapply exists_next in HH0; eauto.\ndesc.\neapply exists_trav_step in HH1; eauto.\n2: {\napply fsupp_ar_rf_ppo_loc_fin; auto.\neapply set_finite_mori; [| by apply FINDOM].\nred.\nbasic_solver.\n}\ndesc.\napply exists_sim_trav_step in HH1; eauto.\ndesc.\nclear T'.\nsubst.\nspecialize (H (trav_steps_left findom T'')).\nedestruct H as [T' [II OO]].\n{\nby apply trav_steps_left_decrease_sim.\n}\n{\neapply sim_trav_step_coherence; eauto.\n}\n{\neapply sim_trav_step_rel_covered; eauto.\n}\n{\neapply sim_trav_step_rmw_covered; eauto.\n}\n{\ndone.\n}\nexists T'.\nsplits; auto.\napply rt_begin.\nright.\neexists.\neauto.\n"},{"statement":"Lemma sim_traversal (FINDOM : set_finite E) (IMMCON : imm_consistent G sc) :\n    exists T, (sim_trav_step G sc)＊ (init_trav G) T /\\ (G.(acts_set) ⊆₁ covered T).","proof":"apply sim_traversal_helper; auto.\n{\nby apply init_trav_coherent.\n}\n{\nunfold init_trav.\nsimpls.\nbasic_solver.\n}\nins.\nsplit; intros [HH AA].\n{\napply (init_w WF) in HH.\napply (dom_l (wf_rmwD WF)) in RMW.\napply seq_eqv_l in RMW.\ntype_solver.\n}\napply (rmw_in_sb WF) in RMW.\napply no_sb_to_init in RMW.\napply seq_eqv_r in RMW.\ndesf.\n"},{"statement":"Lemma sim_step_cov_full_thread T T' thread thread'\n        (TCCOH : tc_coherent G sc T)\n        (TS : isim_trav_step G sc thread' T T')\n        (NCOV : NTid_ thread ∩₁ (acts_set G) ⊆₁ covered T) :\n    thread' = thread.","proof":"destruct (classic (thread' = thread)) as [|NEQ]; [by subst|].\nexfalso.\napply sim_trav_step_to_step in TS; auto.\ndesf.\nred in TS.\ndesf.\n{\napply NEXT.\napply NCOV.\nsplit; eauto.\napply COV.\n}\napply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\n{\napply ISS.\n}\napply NCOV.\nsplit; auto.\napply ISS.\n"},{"statement":"Lemma sim_step_cov_full_traversal T thread\n        (FINDOM : set_finite E)\n        (IMMCON : imm_consistent G sc)\n        (TCCOH : tc_coherent G sc T) (NCOV : NTid_ thread ∩₁ (acts_set G) ⊆₁ covered T)\n        (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T)\n        (RMWCOV : forall r w : actid, rmw r w -> covered T r <-> covered T w) : \n    exists T', (isim_trav_step G sc thread)＊ T T' /\\ ((acts_set G) ⊆₁ covered T').","proof":"edestruct sim_traversal_helper as [T']; eauto.\ndesc.\nexists T'.\nsplits; auto.\nclear H0.\ninduction H.\n2: ins; apply rt_refl.\n{\nins.\napply rt_step.\ndestruct H as [thread' H].\nassert (thread' = thread); [|by subst].\neapply sim_step_cov_full_thread; eauto.\n}\nins.\nset (NCOV' := NCOV).\napply IHclos_refl_trans1 in NCOV'; auto.\neapply rt_trans; eauto.\neapply IHclos_refl_trans2.\n{\neapply sim_trav_steps_coherence; eauto.\n}\n{\netransitivity; eauto.\neapply sim_trav_steps_covered_le; eauto.\n}\n{\neapply sim_trav_steps_rel_covered; eauto.\n}\neapply sim_trav_steps_rmw_covered; eauto.\n"}]