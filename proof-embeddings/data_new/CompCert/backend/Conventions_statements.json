{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Conventions.v","fileSamples":[{"statement":"(s : signature) (l : loc) : In l (regs_of_rpairs (loc_arguments s)) -> loc_argument_acceptable l.","conclusion":"In l (regs_of_rpairs (loc_arguments s)) -> loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc)","proofString":"generalize (loc_arguments_acceptable s).\ngeneralize (loc_arguments s).\ninduction l0 as [ | p pl]; simpl; intros.\ncontradiction.\nrewrite in_app_iff in H0.\ndestruct H0.\nexploit H; eauto.\ndestruct p; simpl in *; intuition congruence.\napply IHpl; auto."},{"statement":"(s : signature) (l : loc) : (forall p : rpair loc,\n In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p) ->\nIn l (regs_of_rpairs (loc_arguments s)) -> loc_argument_acceptable l.","conclusion":"(forall p : rpair loc,\n In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p) ->\nIn l (regs_of_rpairs (loc_arguments s)) -> loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc)","proofString":"generalize (loc_arguments s).\ninduction l0 as [ | p pl]; simpl; intros.\ncontradiction.\nrewrite in_app_iff in H0.\ndestruct H0.\nexploit H; eauto.\ndestruct p; simpl in *; intuition congruence.\napply IHpl; auto."},{"statement":"(s : signature) (l : loc) : forall l0 : list (rpair loc),\n(forall p : rpair loc, In p l0 -> forall_rpair loc_argument_acceptable p) ->\nIn l (regs_of_rpairs l0) -> loc_argument_acceptable l.","conclusion":"forall l0 : list (rpair loc),\n(forall p : rpair loc, In p l0 -> forall_rpair loc_argument_acceptable p) ->\nIn l (regs_of_rpairs l0) -> loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc)","proofString":"induction l0 as [ | p pl]; simpl; intros.\ncontradiction.\nrewrite in_app_iff in H0.\ndestruct H0.\nexploit H; eauto.\ndestruct p; simpl in *; intuition congruence.\napply IHpl; auto."},{"statement":"(s : signature) (l : loc) (H : forall p : rpair loc, False -> forall_rpair loc_argument_acceptable p) (H0 : False) : loc_argument_acceptable l.","conclusion":"loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc) (H : forall p : rpair loc, False -> forall_rpair loc_argument_acceptable p) (H0 : False)","proofString":"contradiction."},{"statement":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p ++ regs_of_rpairs pl)) : loc_argument_acceptable l.","conclusion":"loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p ++ regs_of_rpairs pl))","proofString":"rewrite in_app_iff in H0.\ndestruct H0.\nexploit H; eauto.\ndestruct p; simpl in *; intuition congruence.\napply IHpl; auto."},{"statement":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p) \\/ In l (regs_of_rpairs pl)) : loc_argument_acceptable l.","conclusion":"loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p) \\/ In l (regs_of_rpairs pl))","proofString":"destruct H0.\nexploit H; eauto.\ndestruct p; simpl in *; intuition congruence.\napply IHpl; auto."},{"statement":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p)) : loc_argument_acceptable l.","conclusion":"loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p))","proofString":"exploit H; eauto.\ndestruct p; simpl in *; intuition congruence."},{"statement":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p)) : forall_rpair loc_argument_acceptable p -> loc_argument_acceptable l.","conclusion":"forall_rpair loc_argument_acceptable p -> loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpair p))","proofString":"destruct p; simpl in *; intuition congruence."},{"statement":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpairs pl)) : loc_argument_acceptable l.","conclusion":"loc_argument_acceptable l","hypotheses":"(s : signature) (l : loc) (p : rpair loc) (pl : list (rpair loc)) (IHpl : (forall p0 : rpair loc, In p0 pl -> forall_rpair loc_argument_acceptable p0) ->\nIn l (regs_of_rpairs pl) -> loc_argument_acceptable l) (H : forall p0 : rpair loc,\np = p0 \\/ In p0 pl -> forall_rpair loc_argument_acceptable p0) (H0 : In l (regs_of_rpairs pl))","proofString":"apply IHpl; auto."},{"statement":"forall (n : Z) (l : loc), max_outgoing_1 n l >= n.","conclusion":"forall (n : Z) (l : loc), max_outgoing_1 n l >= n","hypotheses":"","proofString":"intros; unfold max_outgoing_1.\ndestruct l as [_ | []]; extlia."},{"statement":"(n : Z) (l : loc) : match l with\n| S Outgoing ofs ty => Z.max n (ofs + typesize ty)\n| _ => n\nend >= n.","conclusion":"match l with\n| S Outgoing ofs ty => Z.max n (ofs + typesize ty)\n| _ => n\nend >= n","hypotheses":"(n : Z) (l : loc)","proofString":"destruct l as [_ | []]; extlia."},{"statement":"(A : forall (n : Z) (l : loc), max_outgoing_1 n l >= n) : forall (l : list (rpair loc)) (n : Z), fold_left max_outgoing_2 l n >= n.","conclusion":"forall (l : list (rpair loc)) (n : Z), fold_left max_outgoing_2 l n >= n","hypotheses":"(A : forall (n : Z) (l : loc), max_outgoing_1 n l >= n)","proofString":"induction l; simpl; intros.\nlia.\neapply Zge_trans.\neauto.\ndestruct a; simpl.\napply A.\neapply Zge_trans; eauto."},{"statement":"(A : forall (n0 : Z) (l : loc), max_outgoing_1 n0 l >= n0) (n : Z) : n >= n.","conclusion":"n >= n","hypotheses":"(A : forall (n0 : Z) (l : loc), max_outgoing_1 n0 l >= n0) (n : Z)","proofString":"lia."},{"statement":"(A : forall (n0 : Z) (l0 : loc), max_outgoing_1 n0 l0 >= n0) (a : rpair loc) (l : list (rpair loc)) (IHl : forall n0 : Z, fold_left max_outgoing_2 l n0 >= n0) (n : Z) : fold_left max_outgoing_2 l (max_outgoing_2 n a) >= n.","conclusion":"fold_left max_outgoing_2 l (max_outgoing_2 n a) >= n","hypotheses":"(A : forall (n0 : Z) (l0 : loc), max_outgoing_1 n0 l0 >= n0) (a : rpair loc) (l : list (rpair loc)) (IHl : forall n0 : Z, fold_left max_outgoing_2 l n0 >= n0) (n : Z)","proofString":"eapply Zge_trans.\neauto.\ndestruct a; simpl.\napply A.\neapply Zge_trans; eauto."},{"statement":"(A : forall (n0 : Z) (l0 : loc), max_outgoing_1 n0 l0 >= n0) (r : loc) (l : list (rpair loc)) (IHl : forall n0 : Z, fold_left max_outgoing_2 l n0 >= n0) (n : Z) : max_outgoing_1 n r >= n.","conclusion":"max_outgoing_1 n r >= n","hypotheses":"(A : forall (n0 : Z) (l0 : loc), max_outgoing_1 n0 l0 >= n0) (r : loc) (l : list (rpair loc)) (IHl : forall n0 : Z, fold_left max_outgoing_2 l n0 >= n0) (n : Z)","proofString":"apply A."},{"statement":"(A : forall (n0 : Z) (l0 : loc), max_outgoing_1 n0 l0 >= n0) (rhi rlo : loc) (l : list (rpair loc)) (IHl : forall n0 : Z, fold_left max_outgoing_2 l n0 >= n0) (n : Z) : max_outgoing_1 (max_outgoing_1 n rhi) rlo >= n.","conclusion":"max_outgoing_1 (max_outgoing_1 n rhi) rlo >= n","hypotheses":"(A : forall (n0 : Z) (l0 : loc), max_outgoing_1 n0 l0 >= n0) (rhi rlo : loc) (l : list (rpair loc)) (IHl : forall n0 : Z, fold_left max_outgoing_2 l n0 >= n0) (n : Z)","proofString":"eapply Zge_trans; eauto."},{"statement":"(s : signature) : size_arguments s >= 0.","conclusion":"size_arguments s >= 0","hypotheses":"(s : signature)","proofString":"apply fold_max_outgoing_above."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)))","proofString":"replace (regs_of_rpairs (loc_parameters sg)) with (List.map parameter_of_argument (regs_of_rpairs (loc_arguments sg))) in H.\nchange (S Incoming ofs ty) with (parameter_of_argument (S Outgoing ofs ty)) in H.\nexploit list_in_map_inv.\neexact H.\nintros [x [A B]].\nsimpl in A.\nexploit loc_arguments_acceptable_2; eauto.\nunfold loc_argument_acceptable; intros.\ndestruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto.\nunfold loc_parameters.\ngeneralize (loc_arguments sg).\ninduction l as [ | p l]; simpl; intros.\nauto.\nrewrite map_app.\nf_equal; auto.\ndestruct p; auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty)\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty)\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg))))","proofString":"change (S Incoming ofs ty) with (parameter_of_argument (S Outgoing ofs ty)) in H.\nexploit list_in_map_inv.\neexact H.\nintros [x [A B]].\nsimpl in A.\nexploit loc_arguments_acceptable_2; eauto.\nunfold loc_argument_acceptable; intros.\ndestruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg))))","proofString":"exploit list_in_map_inv.\neexact H.\nintros [x [A B]].\nsimpl in A.\nexploit loc_arguments_acceptable_2; eauto.\nunfold loc_argument_acceptable; intros.\ndestruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : parameter_of_argument (S Outgoing ofs ty) = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg))) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : parameter_of_argument (S Outgoing ofs ty) = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg)))","proofString":"simpl in A.\nexploit loc_arguments_acceptable_2; eauto.\nunfold loc_argument_acceptable; intros.\ndestruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : S Incoming ofs ty = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg))) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : S Incoming ofs ty = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg)))","proofString":"exploit loc_arguments_acceptable_2; eauto.\nunfold loc_argument_acceptable; intros.\ndestruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : S Incoming ofs ty = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg))) : loc_argument_acceptable x ->\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"loc_argument_acceptable x ->\nIn (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : S Incoming ofs ty = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg)))","proofString":"unfold loc_argument_acceptable; intros.\ndestruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : S Incoming ofs ty = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg))) (H0 : match x with\n| R r => is_callee_save r = false\n| S Outgoing ofs0 ty0 => ofs0 >= 0 /\\ (typealign ty0 | ofs0)\n| _ => False\nend) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (x : loc) (A : S Incoming ofs ty = parameter_of_argument x) (B : In x (regs_of_rpairs (loc_arguments sg))) (H0 : match x with\n| R r => is_callee_save r = false\n| S Outgoing ofs0 ty0 => ofs0 >= 0 /\\ (typealign ty0 | ofs0)\n| _ => False\nend)","proofString":"destruct x; simpl in A; try discriminate.\ndestruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (sl : slot) (pos : Z) (ty0 : typ) (A : S Incoming ofs ty =\nmatch sl with\n| Outgoing => S Incoming pos ty0\n| _ => S sl pos ty0\nend) (B : In (S sl pos ty0) (regs_of_rpairs (loc_arguments sg))) (H0 : match sl with\n| Outgoing => pos >= 0 /\\ (typealign ty0 | pos)\n| _ => False\nend) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (sl : slot) (pos : Z) (ty0 : typ) (A : S Incoming ofs ty =\nmatch sl with\n| Outgoing => S Incoming pos ty0\n| _ => S sl pos ty0\nend) (B : In (S sl pos ty0) (regs_of_rpairs (loc_arguments sg))) (H0 : match sl with\n| Outgoing => pos >= 0 /\\ (typealign ty0 | pos)\n| _ => False\nend)","proofString":"destruct sl; try contradiction.\ninv A.\nauto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (pos : Z) (ty0 : typ) (A : S Incoming ofs ty = S Incoming pos ty0) (B : In (S Outgoing pos ty0) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty0 | pos)) : In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (parameter_of_argument (S Outgoing ofs ty))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (pos : Z) (ty0 : typ) (A : S Incoming ofs ty = S Incoming pos ty0) (B : In (S Outgoing pos ty0) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty0 | pos))","proofString":"inv A.\nauto."},{"statement":"(sg : signature) (pos : Z) (ty0 : typ) (H : In (parameter_of_argument (S Outgoing pos ty0))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (B : In (S Outgoing pos ty0) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty0 | pos)) : In (S Outgoing pos ty0) (regs_of_rpairs (loc_arguments sg)).","conclusion":"In (S Outgoing pos ty0) (regs_of_rpairs (loc_arguments sg))","hypotheses":"(sg : signature) (pos : Z) (ty0 : typ) (H : In (parameter_of_argument (S Outgoing pos ty0))\n  (map parameter_of_argument (regs_of_rpairs (loc_arguments sg)))) (B : In (S Outgoing pos ty0) (regs_of_rpairs (loc_arguments sg))) (H0 : pos >= 0 /\\ (typealign ty0 | pos))","proofString":"auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) : map parameter_of_argument (regs_of_rpairs (loc_arguments sg)) =\nregs_of_rpairs (loc_parameters sg).","conclusion":"map parameter_of_argument (regs_of_rpairs (loc_arguments sg)) =\nregs_of_rpairs (loc_parameters sg)","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)))","proofString":"unfold loc_parameters.\ngeneralize (loc_arguments sg).\ninduction l as [ | p l]; simpl; intros.\nauto.\nrewrite map_app.\nf_equal; auto.\ndestruct p; auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) : map parameter_of_argument (regs_of_rpairs (loc_arguments sg)) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) (loc_arguments sg)).","conclusion":"map parameter_of_argument (regs_of_rpairs (loc_arguments sg)) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) (loc_arguments sg))","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)))","proofString":"generalize (loc_arguments sg).\ninduction l as [ | p l]; simpl; intros.\nauto.\nrewrite map_app.\nf_equal; auto.\ndestruct p; auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) : forall l : list (rpair loc),\nmap parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l).","conclusion":"forall l : list (rpair loc),\nmap parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l)","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)))","proofString":"induction l as [ | p l]; simpl; intros.\nauto.\nrewrite map_app.\nf_equal; auto.\ndestruct p; auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) (p : rpair loc) (l : list (rpair loc)) (IHl : map parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l)) : map parameter_of_argument (regs_of_rpair p ++ regs_of_rpairs l) =\nregs_of_rpair (map_rpair parameter_of_argument p) ++\nregs_of_rpairs (map (map_rpair parameter_of_argument) l).","conclusion":"map parameter_of_argument (regs_of_rpair p ++ regs_of_rpairs l) =\nregs_of_rpair (map_rpair parameter_of_argument p) ++\nregs_of_rpairs (map (map_rpair parameter_of_argument) l)","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) (p : rpair loc) (l : list (rpair loc)) (IHl : map parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l))","proofString":"rewrite map_app.\nf_equal; auto.\ndestruct p; auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) (p : rpair loc) (l : list (rpair loc)) (IHl : map parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l)) : map parameter_of_argument (regs_of_rpair p) ++\nmap parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpair (map_rpair parameter_of_argument p) ++\nregs_of_rpairs (map (map_rpair parameter_of_argument) l).","conclusion":"map parameter_of_argument (regs_of_rpair p) ++\nmap parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpair (map_rpair parameter_of_argument p) ++\nregs_of_rpairs (map (map_rpair parameter_of_argument) l)","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) (p : rpair loc) (l : list (rpair loc)) (IHl : map parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l))","proofString":"f_equal; auto.\ndestruct p; auto."},{"statement":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) (p : rpair loc) (l : list (rpair loc)) (IHl : map parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l)) : map parameter_of_argument (regs_of_rpair p) =\nregs_of_rpair (map_rpair parameter_of_argument p).","conclusion":"map parameter_of_argument (regs_of_rpair p) =\nregs_of_rpair (map_rpair parameter_of_argument p)","hypotheses":"(ofs : Z) (ty : typ) (sg : signature) (H : In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg))) (p : rpair loc) (l : list (rpair loc)) (IHl : map parameter_of_argument (regs_of_rpairs l) =\nregs_of_rpairs (map (map_rpair parameter_of_argument) l))","proofString":"destruct p; auto."},{"statement":"(s : signature) (H : forallb (fun l : loc => match l with\n                        | R _ => true\n                        | S _ _ _ => false\n                        end) (regs_of_rpairs (loc_arguments s)) = true) : tailcall_possible s.","conclusion":"tailcall_possible s","hypotheses":"(s : signature) (H : forallb (fun l : loc => match l with\n                        | R _ => true\n                        | S _ _ _ => false\n                        end) (regs_of_rpairs (loc_arguments s)) = true)","proofString":"rewrite forallb_forall in H.\nred; intros.\napply H in H0.\ndestruct l; [auto|discriminate]."},{"statement":"(s : signature) (H : forall x : loc,\nIn x (regs_of_rpairs (loc_arguments s)) ->\nmatch x with\n| R _ => true\n| S _ _ _ => false\nend = true) : tailcall_possible s.","conclusion":"tailcall_possible s","hypotheses":"(s : signature) (H : forall x : loc,\nIn x (regs_of_rpairs (loc_arguments s)) ->\nmatch x with\n| R _ => true\n| S _ _ _ => false\nend = true)","proofString":"red; intros.\napply H in H0.\ndestruct l; [auto|discriminate]."},{"statement":"(s : signature) (H : forall x : loc,\nIn x (regs_of_rpairs (loc_arguments s)) ->\nmatch x with\n| R _ => true\n| S _ _ _ => false\nend = true) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments s))) : match l with\n| R _ => True\n| S _ _ _ => False\nend.","conclusion":"match l with\n| R _ => True\n| S _ _ _ => False\nend","hypotheses":"(s : signature) (H : forall x : loc,\nIn x (regs_of_rpairs (loc_arguments s)) ->\nmatch x with\n| R _ => true\n| S _ _ _ => false\nend = true) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments s)))","proofString":"apply H in H0.\ndestruct l; [auto|discriminate]."},{"statement":"(s : signature) (H : forall x : loc,\nIn x (regs_of_rpairs (loc_arguments s)) ->\nmatch x with\n| R _ => true\n| S _ _ _ => false\nend = true) (l : loc) (H0 : match l with\n| R _ => true\n| S _ _ _ => false\nend = true) : match l with\n| R _ => True\n| S _ _ _ => False\nend.","conclusion":"match l with\n| R _ => True\n| S _ _ _ => False\nend","hypotheses":"(s : signature) (H : forall x : loc,\nIn x (regs_of_rpairs (loc_arguments s)) ->\nmatch x with\n| R _ => true\n| S _ _ _ => false\nend = true) (l : loc) (H0 : match l with\n| R _ => true\n| S _ _ _ => false\nend = true)","proofString":"destruct l; [auto|discriminate]."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments sg))) : match l with\n| R _ => True\n| S _ _ _ => False\nend.","conclusion":"match l with\n| R _ => True\n| S _ _ _ => False\nend","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"exploit loc_arguments_acceptable_2; eauto.\nunfold loc_argument_acceptable.\ndestruct l; intros.\nauto.\ndestruct sl; try contradiction.\ndestruct H1.\ngeneralize (loc_arguments_bounded _ _ _ H0).\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments sg))) : loc_argument_acceptable l ->\nmatch l with\n| R _ => True\n| S _ _ _ => False\nend.","conclusion":"loc_argument_acceptable l ->\nmatch l with\n| R _ => True\n| S _ _ _ => False\nend","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"unfold loc_argument_acceptable.\ndestruct l; intros.\nauto.\ndestruct sl; try contradiction.\ndestruct H1.\ngeneralize (loc_arguments_bounded _ _ _ H0).\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments sg))) : match l with\n| R r => is_callee_save r = false\n| S Outgoing ofs ty => ofs >= 0 /\\ (typealign ty | ofs)\n| _ => False\nend -> match l with\n       | R _ => True\n       | S _ _ _ => False\n       end.","conclusion":"match l with\n| R r => is_callee_save r = false\n| S Outgoing ofs ty => ofs >= 0 /\\ (typealign ty | ofs)\n| _ => False\nend -> match l with\n       | R _ => True\n       | S _ _ _ => False\n       end","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (l : loc) (H0 : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"destruct l; intros.\nauto.\ndestruct sl; try contradiction.\ndestruct H1.\ngeneralize (loc_arguments_bounded _ _ _ H0).\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (r : mreg) (H0 : In (R r) (regs_of_rpairs (loc_arguments sg))) (H1 : is_callee_save r = false) : True.","conclusion":"True","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (r : mreg) (H0 : In (R r) (regs_of_rpairs (loc_arguments sg))) (H1 : is_callee_save r = false)","proofString":"auto."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (sl : slot) (pos : Z) (ty : typ) (H0 : In (S sl pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : match sl with\n| Outgoing => pos >= 0 /\\ (typealign ty | pos)\n| _ => False\nend) : False.","conclusion":"False","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (sl : slot) (pos : Z) (ty : typ) (H0 : In (S sl pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : match sl with\n| Outgoing => pos >= 0 /\\ (typealign ty | pos)\n| _ => False\nend)","proofString":"destruct sl; try contradiction.\ndestruct H1.\ngeneralize (loc_arguments_bounded _ _ _ H0).\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0 /\\ (typealign ty | pos)) : False.","conclusion":"False","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0 /\\ (typealign ty | pos))","proofString":"destruct H1.\ngeneralize (loc_arguments_bounded _ _ _ H0).\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0) (H2 : (typealign ty | pos)) : False.","conclusion":"False","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0) (H2 : (typealign ty | pos))","proofString":"generalize (loc_arguments_bounded _ _ _ H0).\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0) (H2 : (typealign ty | pos)) : pos + typesize ty <= size_arguments sg -> False.","conclusion":"pos + typesize ty <= size_arguments sg -> False","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0) (H2 : (typealign ty | pos))","proofString":"generalize (typesize_pos ty).\nlia."},{"statement":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0) (H2 : (typealign ty | pos)) : typesize ty > 0 -> pos + typesize ty <= size_arguments sg -> False.","conclusion":"typesize ty > 0 -> pos + typesize ty <= size_arguments sg -> False","hypotheses":"(sg : signature) (H : size_arguments sg = 0) (pos : Z) (ty : typ) (H0 : In (S Outgoing pos ty) (regs_of_rpairs (loc_arguments sg))) (H1 : pos >= 0) (H2 : (typealign ty | pos))","proofString":"lia."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) : Locmap.setpair (loc_result sg) v rs l = rs l.","conclusion":"Locmap.setpair (loc_result sg) v rs l = rs l","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend)","proofString":"apply Locmap.gpo.\nassert (X: forall r, is_callee_save r = false -> Loc.diff l (R r)).\nintros.\ndestruct l; simpl.\ncongruence.\nauto.\ngeneralize (loc_result_caller_save sg).\ndestruct (loc_result sg); simpl; intuition auto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) : forall_rpair (fun r : mreg => Loc.diff l (R r)) (loc_result sg).","conclusion":"forall_rpair (fun r : mreg => Loc.diff l (R r)) (loc_result sg)","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend)","proofString":"assert (X: forall r, is_callee_save r = false -> Loc.diff l (R r)).\nintros.\ndestruct l; simpl.\ncongruence.\nauto.\ngeneralize (loc_result_caller_save sg).\ndestruct (loc_result sg); simpl; intuition auto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) : forall r : mreg, is_callee_save r = false -> Loc.diff l (R r).","conclusion":"forall r : mreg, is_callee_save r = false -> Loc.diff l (R r)","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend)","proofString":"intros.\ndestruct l; simpl.\ncongruence.\nauto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r0 => is_callee_save r0 = true\n| S _ _ _ => True\nend) (r : mreg) (H0 : is_callee_save r = false) : Loc.diff l (R r).","conclusion":"Loc.diff l (R r)","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r0 => is_callee_save r0 = true\n| S _ _ _ => True\nend) (r : mreg) (H0 : is_callee_save r = false)","proofString":"destruct l; simpl.\ncongruence.\nauto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (r0 : mreg) (H : is_callee_save r0 = true) (r : mreg) (H0 : is_callee_save r = false) : r0 <> r.","conclusion":"r0 <> r","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (r0 : mreg) (H : is_callee_save r0 = true) (r : mreg) (H0 : is_callee_save r = false)","proofString":"congruence."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (sl : slot) (pos : Z) (ty : typ) (H : True) (r : mreg) (H0 : is_callee_save r = false) : True.","conclusion":"True","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (sl : slot) (pos : Z) (ty : typ) (H : True) (r : mreg) (H0 : is_callee_save r = false)","proofString":"auto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) (X : forall r : mreg, is_callee_save r = false -> Loc.diff l (R r)) : forall_rpair (fun r : mreg => Loc.diff l (R r)) (loc_result sg).","conclusion":"forall_rpair (fun r : mreg => Loc.diff l (R r)) (loc_result sg)","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) (X : forall r : mreg, is_callee_save r = false -> Loc.diff l (R r))","proofString":"generalize (loc_result_caller_save sg).\ndestruct (loc_result sg); simpl; intuition auto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) (X : forall r : mreg, is_callee_save r = false -> Loc.diff l (R r)) : forall_rpair (fun r : mreg => is_callee_save r = false) (loc_result sg) ->\nforall_rpair (fun r : mreg => Loc.diff l (R r)) (loc_result sg).","conclusion":"forall_rpair (fun r : mreg => is_callee_save r = false) (loc_result sg) ->\nforall_rpair (fun r : mreg => Loc.diff l (R r)) (loc_result sg)","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend) (X : forall r : mreg, is_callee_save r = false -> Loc.diff l (R r))","proofString":"destruct (loc_result sg); simpl; intuition auto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : callee_save_loc l) : Locmap.setpair (loc_result sg) v rs l = rs l.","conclusion":"Locmap.setpair (loc_result sg) v rs l = rs l","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : callee_save_loc l)","proofString":"apply locmap_get_set_loc_result.\nred in H; destruct l; auto."},{"statement":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : callee_save_loc l) : match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend.","conclusion":"match l with\n| R r => is_callee_save r = true\n| S _ _ _ => True\nend","hypotheses":"(sg : signature) (v : Values.val) (rs : Locmap.t) (l : loc) (H : callee_save_loc l)","proofString":"red in H; destruct l; auto."}]}