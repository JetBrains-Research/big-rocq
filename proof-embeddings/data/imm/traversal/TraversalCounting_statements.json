{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/traversal/TraversalCounting.v","fileSamples":[{"statement":"(T : trav_config) (HH : filterP (E \\₁ covered T) findom = []) (x : actid) (EX : E x) (NN : ~ covered T x) (UU : In x []) : False.","proofString":"inv UU."},{"statement":"(T : trav_config) (HH : filterP (E \\₁ covered T) findom = []) (x : actid) (EX : E x) (NN : ~ covered T x) : In x findom /\\ (E \\₁ covered T) x.","proofString":"do 2 (split; auto)."},{"statement":"(T : trav_config) (e : actid) (EE : E e) (NCOV : ~ covered T e) (EQ : trav_steps_left T = 0) : trav_steps_left T <> 0.","proofString":"exfalso.\napply NCOV.\napply trav_steps_left_null_cov; auto."},{"statement":"(T : trav_config) (e : actid) (EE : E e) (NCOV : ~ covered T e) (EQ : trav_steps_left T = 0) : False.","proofString":"apply NCOV.\napply trav_steps_left_null_cov; auto."},{"statement":"(T : trav_config) (e : actid) (EE : E e) (NCOV : ~ covered T e) (EQ : trav_steps_left T = 0) : covered T e.","proofString":"apply trav_steps_left_null_cov; auto."},{"statement":"(x y : trav_config) (H : sim_trav_step G sc x y) : trav_steps_left x > trav_steps_left y.","proofString":"by apply trav_steps_left_decrease_sim."},{"statement":"(x y z : trav_config) (STEPS1 : (sim_trav_step G sc)⁺ x y) (STEPS2 : (sim_trav_step G sc)⁺ y z) (IHSTEPS1 : trav_steps_left x > trav_steps_left y) (IHSTEPS2 : trav_steps_left y > trav_steps_left z) : trav_steps_left x > trav_steps_left z.","proofString":"eapply Nat.lt_trans; eauto."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) : tc_coherent G sc (init_trav G).","proofString":"by apply init_trav_coherent."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) : W ∩₁ Rel ∩₁ issued (init_trav G) ⊆₁ covered (init_trav G).","proofString":"unfold init_trav.\nsimpls.\nbasic_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) : W ∩₁ Rel\n∩₁ issued\n     {|\n       covered := (fun a : actid => is_init a) ∩₁ E;\n       issued := (fun a : actid => is_init a) ∩₁ E\n     |}\n⊆₁ covered\n     {|\n       covered := (fun a : actid => is_init a) ∩₁ E;\n       issued := (fun a : actid => is_init a) ∩₁ E\n     |}.","proofString":"simpls.\nbasic_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) : W ∩₁ Rel ∩₁ ((fun a : actid => is_init a) ∩₁ E)\n⊆₁ (fun a : actid => is_init a) ∩₁ E.","proofString":"basic_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : rmw r w) : ((fun a : actid => is_init a) ∩₁ E) r <->\n((fun a : actid => is_init a) ∩₁ E) w.","proofString":"split; intros [HH AA].\napply (init_w WF) in HH.\napply (dom_l (wf_rmwD WF)) in RMW.\napply seq_eqv_l in RMW.\ntype_solver.\napply (rmw_in_sb WF) in RMW.\napply no_sb_to_init in RMW.\napply seq_eqv_r in RMW.\ndesf."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : rmw r w) (HH : is_init r) (AA : E r) : ((fun a : actid => is_init a) ∩₁ E) w.","proofString":"apply (init_w WF) in HH.\napply (dom_l (wf_rmwD WF)) in RMW.\napply seq_eqv_l in RMW.\ntype_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : rmw r w) (HH : is_w lab r) (AA : E r) : ((fun a : actid => is_init a) ∩₁ E) w.","proofString":"apply (dom_l (wf_rmwD WF)) in RMW.\napply seq_eqv_l in RMW.\ntype_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : (⦗fun a : actid => is_r lab a⦘ ⨾ rmw) r w) (HH : is_w lab r) (AA : E r) : ((fun a : actid => is_init a) ∩₁ E) w.","proofString":"apply seq_eqv_l in RMW.\ntype_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : is_r lab r /\\ rmw r w) (HH : is_w lab r) (AA : E r) : ((fun a : actid => is_init a) ∩₁ E) w.","proofString":"type_solver."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : rmw r w) (HH : is_init w) (AA : E w) : ((fun a : actid => is_init a) ∩₁ E) r.","proofString":"apply (rmw_in_sb WF) in RMW.\napply no_sb_to_init in RMW.\napply seq_eqv_r in RMW.\ndesf."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : sb G r w) (HH : is_init w) (AA : E w) : ((fun a : actid => is_init a) ∩₁ E) r.","proofString":"apply no_sb_to_init in RMW.\napply seq_eqv_r in RMW.\ndesf."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : (sb G ⨾ ⦗fun x : actid => ~ is_init x⦘) r w) (HH : is_init w) (AA : E w) : ((fun a : actid => is_init a) ∩₁ E) r.","proofString":"apply seq_eqv_r in RMW.\ndesf."},{"statement":"(FINDOM : set_finite E) (IMMCON : imm_consistent G sc) (r w : actid) (RMW : sb G r w /\\ ~ is_init w) (HH : is_init w) (AA : E w) : ((fun a : actid => is_init a) ∩₁ E) r.","proofString":"desf."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (thread' : thread_id) (TCCOH : tc_coherent G sc T) (TS : isim_trav_step G sc thread' T T') (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : thread' <> thread) : thread' = thread.","proofString":"exfalso.\napply sim_trav_step_to_step in TS; auto.\ndesf.\nred in TS.\ndesf.\napply NEXT.\napply NCOV.\nsplit; eauto.\napply COV.\napply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (thread' : thread_id) (TCCOH : tc_coherent G sc T) (TS : isim_trav_step G sc thread' T T') (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : thread' <> thread) : False.","proofString":"apply sim_trav_step_to_step in TS; auto.\ndesf.\nred in TS.\ndesf.\napply NEXT.\napply NCOV.\nsplit; eauto.\napply COV.\napply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (thread' : thread_id) (TCCOH : tc_coherent G sc T) (TS : exists (e : actid) (T'' : trav_config),\n  itrav_step G sc e T T'' /\\ tid e = thread') (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : thread' <> thread) : False.","proofString":"desf.\nred in TS.\ndesf.\napply NEXT.\napply NCOV.\nsplit; eauto.\napply COV.\napply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (TS : itrav_step G sc e T T'') (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : False.","proofString":"red in TS.\ndesf.\napply NEXT.\napply NCOV.\nsplit; eauto.\napply COV.\napply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NEXT : ~ covered T e) (COV : coverable G sc T e) (COVEQ : covered T'' ≡₁ covered T ∪₁ eq e) (ISSEQ : issued T'' ≡₁ issued T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : False.","proofString":"apply NEXT.\napply NCOV.\nsplit; eauto.\napply COV."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NEXT : ~ covered T e) (COV : coverable G sc T e) (COVEQ : covered T'' ≡₁ covered T ∪₁ eq e) (ISSEQ : issued T'' ≡₁ issued T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : covered T e.","proofString":"apply NCOV.\nsplit; eauto.\napply COV."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NEXT : ~ covered T e) (COV : coverable G sc T e) (COVEQ : covered T'' ≡₁ covered T ∪₁ eq e) (ISSEQ : issued T'' ≡₁ issued T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : (NTid_ thread ∩₁ E) e.","proofString":"split; eauto.\napply COV."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NEXT : ~ covered T e) (COV : coverable G sc T e) (COVEQ : covered T'' ≡₁ covered T ∪₁ eq e) (ISSEQ : issued T'' ≡₁ issued T) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : E e.","proofString":"apply COV."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : False.","proofString":"apply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : issued T e.","proofString":"eapply w_covered_issued; eauto.\nsplit; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : (W ∩₁ covered T) e.","proofString":"split; auto.\napply ISS.\napply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : is_w lab e.","proofString":"apply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : covered T e.","proofString":"apply NCOV.\nsplit; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : (NTid_ thread ∩₁ E) e.","proofString":"split; auto.\napply ISS."},{"statement":"(T T' : trav_config) (thread : BinNums.positive) (TCCOH : tc_coherent G sc T) (e : actid) (T'' : trav_config) (NISS : ~ issued T e) (ISS : issuable G sc T e) (COVEQ : covered T'' ≡₁ covered T) (ISSEQ : issued T'' ≡₁ issued T ∪₁ eq e) (NCOV : NTid_ thread ∩₁ E ⊆₁ covered T) (NEQ : tid e <> thread) : E e.","proofString":"apply ISS."}]}