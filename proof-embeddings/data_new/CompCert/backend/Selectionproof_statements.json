{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Selectionproof.v","fileSamples":[{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) : dm ! id = Some gd.","conclusion":"dm ! id = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd)","proofString":"set (f := fun m id gd => if globdef_of_interest gd then PTree.set id gd m else m) in *.\nset (P := fun m m' => m'!id = Some gd -> m!id = Some gd).\nassert (X: P dm (PTree.fold f dm (PTree.empty _))).\napply PTree_Properties.fold_rec.\nunfold P; intros.\nrewrite <- H0; auto.\nred.\nrewrite ! PTree.gempty.\nauto.\nunfold P; intros.\nrewrite PTree.gsspec.\nunfold f in H3.\ndestruct (globdef_of_interest v).\nrewrite PTree.gsspec in H3.\ndestruct (peq id k); auto.\napply H2 in H3.\ndestruct (peq id k).\ncongruence.\nauto.\napply X.\nauto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m m' : PTree.t globdef) (a : PTree.tree globdef) (H0 : forall x : PTree.elt, m ! x = m' ! x) (H1 : a ! id = Some gd -> m ! id = Some gd) (H2 : a ! id = Some gd) : m' ! id = Some gd.","conclusion":"m' ! id = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m m' : PTree.t globdef) (a : PTree.tree globdef) (H0 : forall x : PTree.elt, m ! x = m' ! x) (H1 : a ! id = Some gd -> m ! id = Some gd) (H2 : a ! id = Some gd)","proofString":"rewrite <- H0; auto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) : (PTree.empty globdef) ! id = Some gd -> (PTree.empty globdef) ! id = Some gd.","conclusion":"(PTree.empty globdef) ! id = Some gd -> (PTree.empty globdef) ! id = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop)","proofString":"rewrite ! PTree.gempty.\nauto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) : None = Some gd -> None = Some gd.","conclusion":"None = Some gd -> None = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop)","proofString":"auto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : (if globdef_of_interest v then PTree.set k v a else a) ! id = Some gd) : (if peq id k then Some v else m ! id) = Some gd.","conclusion":"(if peq id k then Some v else m ! id) = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : (if globdef_of_interest v then PTree.set k v a else a) ! id = Some gd)","proofString":"destruct (globdef_of_interest v).\nrewrite PTree.gsspec in H3.\ndestruct (peq id k); auto.\napply H2 in H3.\ndestruct (peq id k).\ncongruence.\nauto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : (PTree.set k v a) ! id = Some gd) : (if peq id k then Some v else m ! id) = Some gd.","conclusion":"(if peq id k then Some v else m ! id) = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : (PTree.set k v a) ! id = Some gd)","proofString":"rewrite PTree.gsspec in H3.\ndestruct (peq id k); auto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : (if peq id k then Some v else a ! id) = Some gd) : (if peq id k then Some v else m ! id) = Some gd.","conclusion":"(if peq id k then Some v else m ! id) = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : (if peq id k then Some v else a ! id) = Some gd)","proofString":"destruct (peq id k); auto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : a ! id = Some gd) : (if peq id k then Some v else m ! id) = Some gd.","conclusion":"(if peq id k then Some v else m ! id) = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : a ! id = Some gd)","proofString":"apply H2 in H3.\ndestruct (peq id k).\ncongruence.\nauto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : m ! id = Some gd) : (if peq id k then Some v else m ! id) = Some gd.","conclusion":"(if peq id k then Some v else m ! id) = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : m ! id = Some gd)","proofString":"destruct (peq id k).\ncongruence.\nauto."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : m ! id = Some gd) (e : id = k) : Some v = Some gd.","conclusion":"Some v = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : m ! id = Some gd) (e : id = k)","proofString":"congruence."},{"statement":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : m ! id = Some gd) (n : id <> k) : m ! id = Some gd.","conclusion":"m ! id = Some gd","hypotheses":"(dm : PTree.t globdef) (id : positive) (gd : globdef) (H : (record_globdefs dm) ! id = Some gd) (f : PTree.tree globdef -> positive -> globdef -> PTree.tree globdef) (P : PTree.tree globdef -> PTree.tree globdef -> Prop) (m : PTree.t globdef) (a : PTree.tree globdef) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : dm ! k = Some v) (H2 : a ! id = Some gd -> m ! id = Some gd) (H3 : m ! id = Some gd) (n : id <> k)","proofString":"auto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) : globs ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"globs ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id)","proofString":"set (P := fun (m: PTree.t globdef) res => res = Some id -> m!id = Some(Gfun(External (EF_runtime name sg)))).\nassert (P globs (PTree.fold (lookup_helper_aux name sg) globs None)).\napply PTree_Properties.fold_rec; red; intros.\nrewrite <- H0.\napply H1; auto.\ndiscriminate.\nassert (EITHER: k = id /\\ v = Gfun (External (EF_runtime name sg))                \\/  a = Some id).\nunfold lookup_helper_aux in H3.\ndestruct v; auto.\ndestruct f; auto.\ndestruct e; auto.\ndestruct (String.string_dec name name0); auto.\ndestruct (signature_eq sg sg0); auto.\ninversion H3.\nleft; split; auto.\nrepeat f_equal; auto.\ndestruct EITHER as [[X Y] | X].\nsubst k v.\napply PTree.gss.\napply H2 in X.\nrewrite PTree.gso by congruence.\nauto.\nred in H0.\nunfold lookup_helper in H.\ndestruct (PTree.fold (lookup_helper_aux name sg) globs None); inv H.\nauto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (H0 : None = Some id) : (PTree.empty globdef) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(PTree.empty globdef) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (H0 : None = Some id)","proofString":"discriminate."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) : k = id /\\ v = Gfun (External (EF_runtime name sg)) \\/ a = Some id.","conclusion":"k = id /\\ v = Gfun (External (EF_runtime name sg)) \\/ a = Some id","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id)","proofString":"unfold lookup_helper_aux in H3.\ndestruct v; auto.\ndestruct f; auto.\ndestruct e; auto.\ndestruct (String.string_dec name name0); auto.\ndestruct (signature_eq sg sg0); auto.\ninversion H3.\nleft; split; auto.\nrepeat f_equal; auto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : match v with\n| Gfun (External (EF_runtime name' sg')) =>\n    if string_dec name name' && signature_eq sg sg' then Some k else a\n| _ => a\nend = Some id) : k = id /\\ v = Gfun (External (EF_runtime name sg)) \\/ a = Some id.","conclusion":"k = id /\\ v = Gfun (External (EF_runtime name sg)) \\/ a = Some id","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : match v with\n| Gfun (External (EF_runtime name' sg')) =>\n    if string_dec name name' && signature_eq sg sg' then Some k else a\n| _ => a\nend = Some id)","proofString":"destruct v; auto.\ndestruct f; auto.\ndestruct e; auto.\ndestruct (String.string_dec name name0); auto.\ndestruct (signature_eq sg sg0); auto.\ninversion H3.\nleft; split; auto.\nrepeat f_equal; auto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) (X : k = id) (Y : v = Gfun (External (EF_runtime name sg))) : (PTree.set k v m) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(PTree.set k v m) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) (X : k = id) (Y : v = Gfun (External (EF_runtime name sg)))","proofString":"subst k v.\napply PTree.gss."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (H1 : globs ! id = Some (Gfun (External (EF_runtime name sg)))) (H0 : m ! id = None) (H2 : P m a) (H3 : lookup_helper_aux name sg a id (Gfun (External (EF_runtime name sg))) =\nSome id) : (PTree.set id (Gfun (External (EF_runtime name sg))) m) ! id =\nSome (Gfun (External (EF_runtime name sg))).","conclusion":"(PTree.set id (Gfun (External (EF_runtime name sg))) m) ! id =\nSome (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (H1 : globs ! id = Some (Gfun (External (EF_runtime name sg)))) (H0 : m ! id = None) (H2 : P m a) (H3 : lookup_helper_aux name sg a id (Gfun (External (EF_runtime name sg))) =\nSome id)","proofString":"apply PTree.gss."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) (X : m ! id = Some (Gfun (External (EF_runtime name sg)))) : (PTree.set k v m) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(PTree.set k v m) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) (X : m ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"rewrite PTree.gso by congruence.\nauto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) (X : m ! id = Some (Gfun (External (EF_runtime name sg)))) : m ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"m ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (m : PTree.t globdef) (a : option ident) (k : PTree.elt) (v : globdef) (H0 : m ! k = None) (H1 : globs ! k = Some v) (H2 : P m a) (H3 : lookup_helper_aux name sg a k v = Some id) (X : m ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"auto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (H0 : PTree.fold (lookup_helper_aux name sg) globs None = Some id ->\nglobs ! id = Some (Gfun (External (EF_runtime name sg)))) : globs ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"globs ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : lookup_helper globs name sg = OK id) (P : PTree.t globdef -> option ident -> Prop) (H0 : PTree.fold (lookup_helper_aux name sg) globs None = Some id ->\nglobs ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"unfold lookup_helper in H.\ndestruct (PTree.fold (lookup_helper_aux name sg) globs None); inv H.\nauto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : match PTree.fold (lookup_helper_aux name sg) globs None with\n| Some id0 => OK id0\n| None => Error (MSG name :: MSG \": missing or incorrect declaration\" :: nil)\nend = OK id) (P : PTree.t globdef -> option ident -> Prop) (H0 : PTree.fold (lookup_helper_aux name sg) globs None = Some id ->\nglobs ! id = Some (Gfun (External (EF_runtime name sg)))) : globs ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"globs ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (H : match PTree.fold (lookup_helper_aux name sg) globs None with\n| Some id0 => OK id0\n| None => Error (MSG name :: MSG \": missing or incorrect declaration\" :: nil)\nend = OK id) (P : PTree.t globdef -> option ident -> Prop) (H0 : PTree.fold (lookup_helper_aux name sg) globs None = Some id ->\nglobs ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"destruct (PTree.fold (lookup_helper_aux name sg) globs None); inv H.\nauto."},{"statement":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (P : PTree.t globdef -> option ident -> Prop) (H0 : Some id = Some id -> globs ! id = Some (Gfun (External (EF_runtime name sg)))) : globs ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"globs ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(globs : PTree.t globdef) (name : string) (sg : signature) (id : ident) (P : PTree.t globdef -> option ident -> Prop) (H0 : Some id = Some id -> globs ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"auto."},{"statement":"(p : AST.program Cminor.fundef unit) (name : string) (sg : signature) (id : ident) (H : lookup_helper (record_globdefs (prog_defmap p)) name sg = OK id) : helper_declared p id name sg.","conclusion":"helper_declared p id name sg","hypotheses":"(p : AST.program Cminor.fundef unit) (name : string) (sg : signature) (id : ident) (H : lookup_helper (record_globdefs (prog_defmap p)) name sg = OK id)","proofString":"apply lookup_helper_correct_1 in H.\napply record_globdefs_sound in H.\nauto."},{"statement":"(p : AST.program Cminor.fundef unit) (name : string) (sg : signature) (id : ident) (H : (record_globdefs (prog_defmap p)) ! id =\nSome (Gfun (External (EF_runtime name sg)))) : helper_declared p id name sg.","conclusion":"helper_declared p id name sg","hypotheses":"(p : AST.program Cminor.fundef unit) (name : string) (sg : signature) (id : ident) (H : (record_globdefs (prog_defmap p)) ! id =\nSome (Gfun (External (EF_runtime name sg))))","proofString":"apply record_globdefs_sound in H.\nauto."},{"statement":"(p : AST.program Cminor.fundef unit) (name : string) (sg : signature) (id : ident) (H : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) : helper_declared p id name sg.","conclusion":"helper_declared p id name sg","hypotheses":"(p : AST.program Cminor.fundef unit) (name : string) (sg : signature) (id : ident) (H : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"auto."},{"statement":"(p : AST.program Cminor.fundef unit) (hf : helper_functions) (H : get_helpers (prog_defmap p) = OK hf) : helper_functions_declared p hf.","conclusion":"helper_functions_declared p hf","hypotheses":"(p : AST.program Cminor.fundef unit) (hf : helper_functions) (H : get_helpers (prog_defmap p) = OK hf)","proofString":"monadInv H.\nred; simpl.\nauto 20 using lookup_helper_correct."},{"statement":"(p : AST.program Cminor.fundef unit) (x : ident) (EQ : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtos\" sig_f_l =\nOK x) (x0 : ident) (EQ1 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtou\" sig_f_l =\nOK x0) (x1 : ident) (EQ0 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stod\" sig_l_f =\nOK x1) (x2 : ident) (EQ2 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utod\" sig_l_f =\nOK x2) (x3 : ident) (EQ3 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stof\" sig_l_s =\nOK x3) (x4 : ident) (EQ4 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utof\" sig_l_s =\nOK x4) (x5 : ident) (EQ5 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sdiv\"\n  sig_ll_l = OK x5) (x6 : ident) (EQ6 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_udiv\"\n  sig_ll_l = OK x6) (x7 : ident) (EQ7 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smod\"\n  sig_ll_l = OK x7) (x8 : ident) (EQ8 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umod\"\n  sig_ll_l = OK x8) (x9 : ident) (EQ9 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shl\" sig_li_l =\nOK x9) (x10 : ident) (EQ10 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shr\" sig_li_l =\nOK x10) (x11 : ident) (EQ11 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sar\" sig_li_l =\nOK x11) (x12 : ident) (EQ12 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umulh\"\n  sig_ll_l = OK x12) (x13 : ident) (EQ13 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smulh\"\n  sig_ll_l = OK x13) : helper_functions_declared p\n  {|\n    i64_dtos := x;\n    i64_dtou := x0;\n    i64_stod := x1;\n    i64_utod := x2;\n    i64_stof := x3;\n    i64_utof := x4;\n    i64_sdiv := x5;\n    i64_udiv := x6;\n    i64_smod := x7;\n    i64_umod := x8;\n    i64_shl := x9;\n    i64_shr := x10;\n    i64_sar := x11;\n    i64_umulh := x12;\n    i64_smulh := x13\n  |}.","conclusion":"helper_functions_declared p\n  {|\n    i64_dtos := x;\n    i64_dtou := x0;\n    i64_stod := x1;\n    i64_utod := x2;\n    i64_stof := x3;\n    i64_utof := x4;\n    i64_sdiv := x5;\n    i64_udiv := x6;\n    i64_smod := x7;\n    i64_umod := x8;\n    i64_shl := x9;\n    i64_shr := x10;\n    i64_sar := x11;\n    i64_umulh := x12;\n    i64_smulh := x13\n  |}","hypotheses":"(p : AST.program Cminor.fundef unit) (x : ident) (EQ : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtos\" sig_f_l =\nOK x) (x0 : ident) (EQ1 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtou\" sig_f_l =\nOK x0) (x1 : ident) (EQ0 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stod\" sig_l_f =\nOK x1) (x2 : ident) (EQ2 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utod\" sig_l_f =\nOK x2) (x3 : ident) (EQ3 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stof\" sig_l_s =\nOK x3) (x4 : ident) (EQ4 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utof\" sig_l_s =\nOK x4) (x5 : ident) (EQ5 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sdiv\"\n  sig_ll_l = OK x5) (x6 : ident) (EQ6 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_udiv\"\n  sig_ll_l = OK x6) (x7 : ident) (EQ7 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smod\"\n  sig_ll_l = OK x7) (x8 : ident) (EQ8 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umod\"\n  sig_ll_l = OK x8) (x9 : ident) (EQ9 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shl\" sig_li_l =\nOK x9) (x10 : ident) (EQ10 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shr\" sig_li_l =\nOK x10) (x11 : ident) (EQ11 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sar\" sig_li_l =\nOK x11) (x12 : ident) (EQ12 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umulh\"\n  sig_ll_l = OK x12) (x13 : ident) (EQ13 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smulh\"\n  sig_ll_l = OK x13)","proofString":"red; simpl.\nauto 20 using lookup_helper_correct."},{"statement":"(p : AST.program Cminor.fundef unit) (x : ident) (EQ : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtos\" sig_f_l =\nOK x) (x0 : ident) (EQ1 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtou\" sig_f_l =\nOK x0) (x1 : ident) (EQ0 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stod\" sig_l_f =\nOK x1) (x2 : ident) (EQ2 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utod\" sig_l_f =\nOK x2) (x3 : ident) (EQ3 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stof\" sig_l_s =\nOK x3) (x4 : ident) (EQ4 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utof\" sig_l_s =\nOK x4) (x5 : ident) (EQ5 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sdiv\"\n  sig_ll_l = OK x5) (x6 : ident) (EQ6 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_udiv\"\n  sig_ll_l = OK x6) (x7 : ident) (EQ7 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smod\"\n  sig_ll_l = OK x7) (x8 : ident) (EQ8 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umod\"\n  sig_ll_l = OK x8) (x9 : ident) (EQ9 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shl\" sig_li_l =\nOK x9) (x10 : ident) (EQ10 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shr\" sig_li_l =\nOK x10) (x11 : ident) (EQ11 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sar\" sig_li_l =\nOK x11) (x12 : ident) (EQ12 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umulh\"\n  sig_ll_l = OK x12) (x13 : ident) (EQ13 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smulh\"\n  sig_ll_l = OK x13) : helper_declared p x \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared p x0 \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared p x1 \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared p x2 \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared p x3 \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared p x4 \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared p x5 \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared p x6 \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared p x7 \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared p x8 \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared p x9 \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared p x10 \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared p x11 \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared p x12 \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared p x13 \"__compcert_i64_smulh\" sig_ll_l.","conclusion":"helper_declared p x \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared p x0 \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared p x1 \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared p x2 \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared p x3 \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared p x4 \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared p x5 \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared p x6 \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared p x7 \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared p x8 \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared p x9 \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared p x10 \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared p x11 \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared p x12 \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared p x13 \"__compcert_i64_smulh\" sig_ll_l","hypotheses":"(p : AST.program Cminor.fundef unit) (x : ident) (EQ : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtos\" sig_f_l =\nOK x) (x0 : ident) (EQ1 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_dtou\" sig_f_l =\nOK x0) (x1 : ident) (EQ0 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stod\" sig_l_f =\nOK x1) (x2 : ident) (EQ2 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utod\" sig_l_f =\nOK x2) (x3 : ident) (EQ3 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_stof\" sig_l_s =\nOK x3) (x4 : ident) (EQ4 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_utof\" sig_l_s =\nOK x4) (x5 : ident) (EQ5 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sdiv\"\n  sig_ll_l = OK x5) (x6 : ident) (EQ6 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_udiv\"\n  sig_ll_l = OK x6) (x7 : ident) (EQ7 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smod\"\n  sig_ll_l = OK x7) (x8 : ident) (EQ8 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umod\"\n  sig_ll_l = OK x8) (x9 : ident) (EQ9 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shl\" sig_li_l =\nOK x9) (x10 : ident) (EQ10 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_shr\" sig_li_l =\nOK x10) (x11 : ident) (EQ11 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_sar\" sig_li_l =\nOK x11) (x12 : ident) (EQ12 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_umulh\"\n  sig_ll_l = OK x12) (x13 : ident) (EQ13 : lookup_helper (record_globdefs (prog_defmap p)) \"__compcert_i64_smulh\"\n  sig_ll_l = OK x13)","proofString":"auto 20 using lookup_helper_correct."},{"statement":"(p : Cminor.program) (tp : program) (H : sel_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Cminor.program) (tp : program) (H : sel_program p = OK tp)","proofString":"monadInv H.\neapply match_transform_partial_program_contextual.\neexact EQ0.\nintros.\nexists x; split; auto.\napply get_helpers_correct; auto."},{"statement":"(p : Cminor.program) (tp : program) (x : helper_functions) (EQ : get_helpers (prog_defmap p) = OK x) (EQ0 : transform_partial_program (sel_fundef (prog_defmap p) x) p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Cminor.program) (tp : program) (x : helper_functions) (EQ : get_helpers (prog_defmap p) = OK x) (EQ0 : transform_partial_program (sel_fundef (prog_defmap p) x) p = OK tp)","proofString":"eapply match_transform_partial_program_contextual.\neexact EQ0.\nintros.\nexists x; split; auto.\napply get_helpers_correct; auto."},{"statement":"(p : Cminor.program) (tp : program) (x : helper_functions) (EQ : get_helpers (prog_defmap p) = OK x) (EQ0 : transform_partial_program (sel_fundef (prog_defmap p) x) p = OK tp) (f : Cminor.fundef) (tf : fundef) (H : sel_fundef (prog_defmap p) x f = OK tf) : match_fundef p f tf.","conclusion":"match_fundef p f tf","hypotheses":"(p : Cminor.program) (tp : program) (x : helper_functions) (EQ : get_helpers (prog_defmap p) = OK x) (EQ0 : transform_partial_program (sel_fundef (prog_defmap p) x) p = OK tp) (f : Cminor.fundef) (tf : fundef) (H : sel_fundef (prog_defmap p) x f = OK tf)","proofString":"exists x; split; auto.\napply get_helpers_correct; auto."},{"statement":"(p : Cminor.program) (tp : program) (x : helper_functions) (EQ : get_helpers (prog_defmap p) = OK x) (EQ0 : transform_partial_program (sel_fundef (prog_defmap p) x) p = OK tp) (f : Cminor.fundef) (tf : fundef) (H : sel_fundef (prog_defmap p) x f = OK tf) : helper_functions_declared p x.","conclusion":"helper_functions_declared p x","hypotheses":"(p : Cminor.program) (tp : program) (x : helper_functions) (EQ : get_helpers (prog_defmap p) = OK x) (EQ0 : transform_partial_program (sel_fundef (prog_defmap p) x) p = OK tp) (f : Cminor.fundef) (tf : fundef) (H : sel_fundef (prog_defmap p) x f = OK tf)","proofString":"apply get_helpers_correct; auto."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') : helper_functions_declared p' hf.","conclusion":"helper_functions_declared p' hf","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p')","proofString":"assert (X: forall id name sg, helper_declared p id name sg -> helper_declared p' id name sg).\nunfold helper_declared; intros.\ndestruct (prog_defmap_linkorder _ _ _ _ H0 H1) as (gd & P & Q).\ninv Q.\ninv H3.\nauto.\nred in H.\ndecompose [Logic.and] H; clear H.\nred; auto 20."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg.","conclusion":"forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p')","proofString":"unfold helper_declared; intros.\ndestruct (prog_defmap_linkorder _ _ _ _ H0 H1) as (gd & P & Q).\ninv Q.\ninv H3.\nauto."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) : (prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"destruct (prog_defmap_linkorder _ _ _ _ H0 H1) as (gd & P & Q).\ninv Q.\ninv H3.\nauto."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) (gd : AST.globdef Cminor.fundef unit) (P : (prog_defmap p') ! id = Some gd) (Q : linkorder (Gfun (External (EF_runtime name sg))) gd) : (prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) (gd : AST.globdef Cminor.fundef unit) (P : (prog_defmap p') ! id = Some gd) (Q : linkorder (Gfun (External (EF_runtime name sg))) gd)","proofString":"inv Q.\ninv H3.\nauto."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) (fd2 : Cminor.fundef) (P : (prog_defmap p') ! id = Some (Gfun fd2)) (H3 : linkorder (External (EF_runtime name sg)) fd2) : (prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) (fd2 : Cminor.fundef) (P : (prog_defmap p') ! id = Some (Gfun fd2)) (H3 : linkorder (External (EF_runtime name sg)) fd2)","proofString":"inv H3.\nauto."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) (P : (prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg)))) : (prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (id : ident) (name : string) (sg : signature) (H1 : (prog_defmap p) ! id = Some (Gfun (External (EF_runtime name sg)))) (P : (prog_defmap p') ! id = Some (Gfun (External (EF_runtime name sg))))","proofString":"auto."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg) : helper_functions_declared p' hf.","conclusion":"helper_functions_declared p' hf","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_functions_declared p hf) (H0 : linkorder p p') (X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg)","proofString":"red in H.\ndecompose [Logic.and] H; clear H.\nred; auto 20."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_declared p i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared p i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared p i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared p i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared p i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared p i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared p i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared p i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared p i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared p i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared p i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared p i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared p i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared p i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared p i64_smulh \"__compcert_i64_smulh\" sig_ll_l) (H0 : linkorder p p') (X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg) : helper_functions_declared p' hf.","conclusion":"helper_functions_declared p' hf","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H : helper_declared p i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared p i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared p i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared p i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared p i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared p i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared p i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared p i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared p i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared p i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared p i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared p i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared p i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared p i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared p i64_smulh \"__compcert_i64_smulh\" sig_ll_l) (H0 : linkorder p p') (X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg)","proofString":"decompose [Logic.and] H; clear H.\nred; auto 20."},{"statement":"(p p' : Cminor.program) (hf : helper_functions) (H0 : linkorder p p') (X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg) (H1 : helper_declared p i64_dtos \"__compcert_i64_dtos\" sig_f_l) (H3 : helper_declared p i64_dtou \"__compcert_i64_dtou\" sig_f_l) (H2 : helper_declared p i64_stod \"__compcert_i64_stod\" sig_l_f) (H4 : helper_declared p i64_utod \"__compcert_i64_utod\" sig_l_f) (H5 : helper_declared p i64_stof \"__compcert_i64_stof\" sig_l_s) (H6 : helper_declared p i64_utof \"__compcert_i64_utof\" sig_l_s) (H7 : helper_declared p i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l) (H8 : helper_declared p i64_udiv \"__compcert_i64_udiv\" sig_ll_l) (H9 : helper_declared p i64_smod \"__compcert_i64_smod\" sig_ll_l) (H10 : helper_declared p i64_umod \"__compcert_i64_umod\" sig_ll_l) (H11 : helper_declared p i64_shl \"__compcert_i64_shl\" sig_li_l) (H12 : helper_declared p i64_shr \"__compcert_i64_shr\" sig_li_l) (H13 : helper_declared p i64_sar \"__compcert_i64_sar\" sig_li_l) (H14 : helper_declared p i64_umulh \"__compcert_i64_umulh\" sig_ll_l) (H16 : helper_declared p i64_smulh \"__compcert_i64_smulh\" sig_ll_l) : helper_functions_declared p' hf.","conclusion":"helper_functions_declared p' hf","hypotheses":"(p p' : Cminor.program) (hf : helper_functions) (H0 : linkorder p p') (X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared p id name sg -> helper_declared p' id name sg) (H1 : helper_declared p i64_dtos \"__compcert_i64_dtos\" sig_f_l) (H3 : helper_declared p i64_dtou \"__compcert_i64_dtou\" sig_f_l) (H2 : helper_declared p i64_stod \"__compcert_i64_stod\" sig_l_f) (H4 : helper_declared p i64_utod \"__compcert_i64_utod\" sig_l_f) (H5 : helper_declared p i64_stof \"__compcert_i64_stof\" sig_l_s) (H6 : helper_declared p i64_utof \"__compcert_i64_utof\" sig_l_s) (H7 : helper_declared p i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l) (H8 : helper_declared p i64_udiv \"__compcert_i64_udiv\" sig_ll_l) (H9 : helper_declared p i64_smod \"__compcert_i64_smod\" sig_ll_l) (H10 : helper_declared p i64_umod \"__compcert_i64_umod\" sig_ll_l) (H11 : helper_declared p i64_shl \"__compcert_i64_shl\" sig_li_l) (H12 : helper_declared p i64_shr \"__compcert_i64_shr\" sig_li_l) (H13 : helper_declared p i64_sar \"__compcert_i64_sar\" sig_li_l) (H14 : helper_declared p i64_umulh \"__compcert_i64_umulh\" sig_ll_l) (H16 : helper_declared p i64_smulh \"__compcert_i64_smulh\" sig_ll_l)","proofString":"red; auto 20."},{"statement":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog))","proofString":"destruct TRANSF as [A _].\nexploit list_forall2_in_left; eauto.\nintros ((i' & gd') & B & (C & D)).\nsimpl in *.\ninv D.\ndestruct H2 as (hf & P & Q).\ndestruct f; monadInv Q.\nmonadInv EQ.\neconstructor; apply type_function_sound; eauto.\nconstructor."},{"statement":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog))","proofString":"exploit list_forall2_in_left; eauto.\nintros ((i' & gd') & B & (C & D)).\nsimpl in *.\ninv D.\ndestruct H2 as (hf & P & Q).\ndestruct f; monadInv Q.\nmonadInv EQ.\neconstructor; apply type_function_sound; eauto.\nconstructor."},{"statement":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) : (exists x2 : ident * AST.globdef fundef unit,\n   In x2 (prog_defs tprog) /\\\n   match_ident_globdef match_fundef eq prog (i, Gfun f) x2) -> \nwt_fundef f.","conclusion":"(exists x2 : ident * AST.globdef fundef unit,\n   In x2 (prog_defs tprog) /\\\n   match_ident_globdef match_fundef eq prog (i, Gfun f) x2) -> \nwt_fundef f","hypotheses":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog))","proofString":"intros ((i' & gd') & B & (C & D)).\nsimpl in *.\ninv D.\ndestruct H2 as (hf & P & Q).\ndestruct f; monadInv Q.\nmonadInv EQ.\neconstructor; apply type_function_sound; eauto.\nconstructor."},{"statement":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (i' : ident) (gd' : AST.globdef fundef unit) (B : In (i', gd') (prog_defs tprog)) (C : i = i') (D : match_globdef match_fundef eq prog (Gfun f) gd') : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(i : ident) (f : Cminor.fundef) (H : In (i, Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (i' : ident) (gd' : AST.globdef fundef unit) (B : In (i', gd') (prog_defs tprog)) (C : i = i') (D : match_globdef match_fundef eq prog (Gfun f) gd')","proofString":"inv D.\ndestruct H2 as (hf & P & Q).\ndestruct f; monadInv Q.\nmonadInv EQ.\neconstructor; apply type_function_sound; eauto.\nconstructor."},{"statement":"(f : Cminor.fundef) (i' : ident) (H : In (i', Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (f2 : fundef) (B : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (H2 : match_fundef ctx' f f2) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(f : Cminor.fundef) (i' : ident) (H : In (i', Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (f2 : fundef) (B : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (H2 : match_fundef ctx' f f2)","proofString":"destruct H2 as (hf & P & Q).\ndestruct f; monadInv Q.\nmonadInv EQ.\neconstructor; apply type_function_sound; eauto.\nconstructor."},{"statement":"(f : Cminor.fundef) (i' : ident) (H : In (i', Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (f2 : fundef) (B : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) (Q : sel_fundef (prog_defmap ctx') hf f = OK f2) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(f : Cminor.fundef) (i' : ident) (H : In (i', Gfun f) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (f2 : fundef) (B : In (i', Gfun f2) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) (Q : sel_fundef (prog_defmap ctx') hf f = OK f2)","proofString":"destruct f; monadInv Q.\nmonadInv EQ.\neconstructor; apply type_function_sound; eauto.\nconstructor."},{"statement":"(f : Cminor.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (x : function) (B : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) (EQ : sel_function (prog_defmap ctx') hf f = OK x) : wt_fundef (Internal f).","conclusion":"wt_fundef (Internal f)","hypotheses":"(f : Cminor.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (x : function) (B : In (i', Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) (EQ : sel_function (prog_defmap ctx') hf f = OK x)","proofString":"monadInv EQ.\neconstructor; apply type_function_sound; eauto."},{"statement":"(f : Cminor.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (x1 : stmt) (B : In\n  (i',\n   Gfun\n     (Internal\n        {|\n          fn_sig := Cminor.fn_sig f;\n          fn_params := Cminor.fn_params f;\n          fn_vars := Cminor.fn_vars f;\n          fn_stackspace := Cminor.fn_stackspace f;\n          fn_body := x1\n        |})) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ : sel_stmt (prog_defmap ctx') (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) : wt_fundef (Internal f).","conclusion":"wt_fundef (Internal f)","hypotheses":"(f : Cminor.function) (i' : ident) (H : In (i', Gfun (Internal f)) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (x1 : stmt) (B : In\n  (i',\n   Gfun\n     (Internal\n        {|\n          fn_sig := Cminor.fn_sig f;\n          fn_params := Cminor.fn_params f;\n          fn_vars := Cminor.fn_vars f;\n          fn_stackspace := Cminor.fn_stackspace f;\n          fn_body := x1\n        |})) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ : sel_stmt (prog_defmap ctx') (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1)","proofString":"econstructor; apply type_function_sound; eauto."},{"statement":"(e : external_function) (i' : ident) (H : In (i', Gfun (External e)) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (B : In (i', Gfun (External e)) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf) : wt_fundef (External e).","conclusion":"wt_fundef (External e)","hypotheses":"(e : external_function) (i' : ident) (H : In (i', Gfun (External e)) (prog_defs prog)) (A : list_forall2 (match_ident_globdef match_fundef eq prog) \n  (prog_defs prog) (prog_defs tprog)) (B : In (i', Gfun (External e)) (prog_defs tprog)) (ctx' : AST.program Cminor.fundef unit) (H1 : linkorder ctx' prog) (hf : helper_functions) (P : helper_functions_declared ctx' hf)","proofString":"constructor."},{"statement":"(v v' : val) (f : Cminor.fundef) (H : Genv.find_funct ge v = Some f) (H0 : Val.lessdef v v') : exists (cu : Cminor.program) (tf : fundef),\n  Genv.find_funct tge v' = Some tf /\\\n  match_fundef cu f tf /\\ linkorder cu prog.","conclusion":"exists (cu : Cminor.program) (tf : fundef),\n  Genv.find_funct tge v' = Some tf /\\\n  match_fundef cu f tf /\\ linkorder cu prog","hypotheses":"(v v' : val) (f : Cminor.fundef) (H : Genv.find_funct ge v = Some f) (H0 : Val.lessdef v v')","proofString":"inv H0.\neapply Genv.find_funct_match; eauto.\ndiscriminate."},{"statement":"(v' : val) (f : Cminor.fundef) (H : Genv.find_funct ge v' = Some f) : exists (cu : Cminor.program) (tf : fundef),\n  Genv.find_funct tge v' = Some tf /\\\n  match_fundef cu f tf /\\ linkorder cu prog.","conclusion":"exists (cu : Cminor.program) (tf : fundef),\n  Genv.find_funct tge v' = Some tf /\\\n  match_fundef cu f tf /\\ linkorder cu prog","hypotheses":"(v' : val) (f : Cminor.fundef) (H : Genv.find_funct ge v' = Some f)","proofString":"eapply Genv.find_funct_match; eauto."},{"statement":"(v' : val) (f : Cminor.fundef) (H : Genv.find_funct ge Vundef = Some f) : exists (cu : Cminor.program) (tf : fundef),\n  Genv.find_funct tge v' = Some tf /\\\n  match_fundef cu f tf /\\ linkorder cu prog.","conclusion":"exists (cu : Cminor.program) (tf : fundef),\n  Genv.find_funct tge v' = Some tf /\\\n  match_fundef cu f tf /\\ linkorder cu prog","hypotheses":"(v' : val) (f : Cminor.fundef) (H : Genv.find_funct ge Vundef = Some f)","proofString":"discriminate."},{"statement":"(cu : Cminor.program) (f : Cminor.fundef) (tf : fundef) (H : match_fundef cu f tf) : funsig tf = Cminor.funsig f.","conclusion":"funsig tf = Cminor.funsig f","hypotheses":"(cu : Cminor.program) (f : Cminor.fundef) (tf : fundef) (H : match_fundef cu f tf)","proofString":"destruct H as (hf & P & Q).\ndestruct f; monadInv Q; auto.\nmonadInv EQ; auto."},{"statement":"(cu : Cminor.program) (f : Cminor.fundef) (tf : fundef) (hf : helper_functions) (P : helper_functions_declared cu hf) (Q : sel_fundef (prog_defmap cu) hf f = OK tf) : funsig tf = Cminor.funsig f.","conclusion":"funsig tf = Cminor.funsig f","hypotheses":"(cu : Cminor.program) (f : Cminor.fundef) (tf : fundef) (hf : helper_functions) (P : helper_functions_declared cu hf) (Q : sel_fundef (prog_defmap cu) hf f = OK tf)","proofString":"destruct f; monadInv Q; auto.\nmonadInv EQ; auto."},{"statement":"(cu : Cminor.program) (f : Cminor.function) (hf : helper_functions) (P : helper_functions_declared cu hf) (x : function) (EQ : sel_function (prog_defmap cu) hf f = OK x) : funsig (Internal x) = Cminor.funsig (Internal f).","conclusion":"funsig (Internal x) = Cminor.funsig (Internal f)","hypotheses":"(cu : Cminor.program) (f : Cminor.function) (hf : helper_functions) (P : helper_functions_declared cu hf) (x : function) (EQ : sel_function (prog_defmap cu) hf f = OK x)","proofString":"monadInv EQ; auto."},{"statement":"(dm : PTree.t globdef) (hf : helper_functions) (f : Cminor.function) (tf : function) (H : sel_function dm hf f = OK tf) : fn_stackspace tf = Cminor.fn_stackspace f.","conclusion":"fn_stackspace tf = Cminor.fn_stackspace f","hypotheses":"(dm : PTree.t globdef) (hf : helper_functions) (f : Cminor.function) (tf : function) (H : sel_function dm hf f = OK tf)","proofString":"monadInv H.\nauto."},{"statement":"(dm : PTree.t globdef) (hf : helper_functions) (f : Cminor.function) (x : typenv) (EQ : type_function f = OK x) (x0 : stmt) (EQ1 : sel_stmt dm (known_id f) x (Cminor.fn_body f) Sskip = OK x0) : fn_stackspace\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x0\n  |} = Cminor.fn_stackspace f.","conclusion":"fn_stackspace\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x0\n  |} = Cminor.fn_stackspace f","hypotheses":"(dm : PTree.t globdef) (hf : helper_functions) (f : Cminor.function) (x : typenv) (EQ : type_function f = OK x) (x0 : stmt) (EQ1 : sel_stmt dm (known_id f) x (Cminor.fn_body f) Sskip = OK x0)","proofString":"auto."},{"statement":"forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg.","conclusion":"forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg","hypotheses":"","proofString":"unfold helper_declared; intros.\ngeneralize (match_program_defmap _ _ _ _ _ TRANSF id).\nunfold Cminor.fundef; rewrite H; intros R; inv R.\ninv H2.\ndestruct H4 as (cu & A & B).\nmonadInv B.\nauto."},{"statement":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (y : AST.globdef fundef unit) (H2 : match_globdef match_fundef eq prog (Gfun (External (EF_runtime name sg))) y) (H1 : Some y = (prog_defmap tprog) ! id) : (prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (y : AST.globdef fundef unit) (H2 : match_globdef match_fundef eq prog (Gfun (External (EF_runtime name sg))) y) (H1 : Some y = (prog_defmap tprog) ! id)","proofString":"inv H2.\ndestruct H4 as (cu & A & B).\nmonadInv B.\nauto."},{"statement":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (f2 : fundef) (H1 : Some (Gfun f2) = (prog_defmap tprog) ! id) (ctx' : AST.program (AST.fundef Cminor.function) unit) (H3 : linkorder ctx' prog) (H4 : match_fundef ctx' (External (EF_runtime name sg)) f2) : (prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (f2 : fundef) (H1 : Some (Gfun f2) = (prog_defmap tprog) ! id) (ctx' : AST.program (AST.fundef Cminor.function) unit) (H3 : linkorder ctx' prog) (H4 : match_fundef ctx' (External (EF_runtime name sg)) f2)","proofString":"destruct H4 as (cu & A & B).\nmonadInv B.\nauto."},{"statement":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (f2 : fundef) (H1 : Some (Gfun f2) = (prog_defmap tprog) ! id) (ctx' : AST.program (AST.fundef Cminor.function) unit) (H3 : linkorder ctx' prog) (cu : helper_functions) (A : helper_functions_declared ctx' cu) (B : sel_fundef (prog_defmap ctx') cu (External (EF_runtime name sg)) = OK f2) : (prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (f2 : fundef) (H1 : Some (Gfun f2) = (prog_defmap tprog) ! id) (ctx' : AST.program (AST.fundef Cminor.function) unit) (H3 : linkorder ctx' prog) (cu : helper_functions) (A : helper_functions_declared ctx' cu) (B : sel_fundef (prog_defmap ctx') cu (External (EF_runtime name sg)) = OK f2)","proofString":"monadInv B.\nauto."},{"statement":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (H1 : Some (Gfun (External (EF_runtime name sg))) = (prog_defmap tprog) ! id) (ctx' : AST.program (AST.fundef Cminor.function) unit) (H3 : linkorder ctx' prog) (cu : helper_functions) (A : helper_functions_declared ctx' cu) : (prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg))).","conclusion":"(prog_defmap tprog) ! id = Some (Gfun (External (EF_runtime name sg)))","hypotheses":"(id : ident) (name : string) (sg : signature) (H : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (H1 : Some (Gfun (External (EF_runtime name sg))) = (prog_defmap tprog) ! id) (ctx' : AST.program (AST.fundef Cminor.function) unit) (H3 : linkorder ctx' prog) (cu : helper_functions) (A : helper_functions_declared ctx' cu)","proofString":"auto."},{"statement":"(X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg) : forall hf : helper_functions,\nhelper_functions_declared prog hf -> helper_functions_declared tprog hf.","conclusion":"forall hf : helper_functions,\nhelper_functions_declared prog hf -> helper_functions_declared tprog hf","hypotheses":"(X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg)","proofString":"unfold helper_functions_declared; intros.\ndecompose [Logic.and] H; clear H.\nauto 20."},{"statement":"(X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg) (hf : helper_functions) (H : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l) : helper_declared tprog i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared tprog i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared tprog i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared tprog i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared tprog i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared tprog i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared tprog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared tprog i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared tprog i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared tprog i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared tprog i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared tprog i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared tprog i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared tprog i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared tprog i64_smulh \"__compcert_i64_smulh\" sig_ll_l.","conclusion":"helper_declared tprog i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared tprog i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared tprog i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared tprog i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared tprog i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared tprog i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared tprog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared tprog i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared tprog i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared tprog i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared tprog i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared tprog i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared tprog i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared tprog i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared tprog i64_smulh \"__compcert_i64_smulh\" sig_ll_l","hypotheses":"(X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg) (hf : helper_functions) (H : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l)","proofString":"decompose [Logic.and] H; clear H.\nauto 20."},{"statement":"(X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg) (hf : helper_functions) (H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l) (H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l) (H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f) (H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f) (H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s) (H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s) (H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l) (H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l) (H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l) (H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l) (H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l) (H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l) (H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l) (H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l) (H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l) : helper_declared tprog i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared tprog i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared tprog i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared tprog i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared tprog i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared tprog i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared tprog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared tprog i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared tprog i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared tprog i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared tprog i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared tprog i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared tprog i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared tprog i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared tprog i64_smulh \"__compcert_i64_smulh\" sig_ll_l.","conclusion":"helper_declared tprog i64_dtos \"__compcert_i64_dtos\" sig_f_l /\\\nhelper_declared tprog i64_dtou \"__compcert_i64_dtou\" sig_f_l /\\\nhelper_declared tprog i64_stod \"__compcert_i64_stod\" sig_l_f /\\\nhelper_declared tprog i64_utod \"__compcert_i64_utod\" sig_l_f /\\\nhelper_declared tprog i64_stof \"__compcert_i64_stof\" sig_l_s /\\\nhelper_declared tprog i64_utof \"__compcert_i64_utof\" sig_l_s /\\\nhelper_declared tprog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l /\\\nhelper_declared tprog i64_udiv \"__compcert_i64_udiv\" sig_ll_l /\\\nhelper_declared tprog i64_smod \"__compcert_i64_smod\" sig_ll_l /\\\nhelper_declared tprog i64_umod \"__compcert_i64_umod\" sig_ll_l /\\\nhelper_declared tprog i64_shl \"__compcert_i64_shl\" sig_li_l /\\\nhelper_declared tprog i64_shr \"__compcert_i64_shr\" sig_li_l /\\\nhelper_declared tprog i64_sar \"__compcert_i64_sar\" sig_li_l /\\\nhelper_declared tprog i64_umulh \"__compcert_i64_umulh\" sig_ll_l /\\\nhelper_declared tprog i64_smulh \"__compcert_i64_smulh\" sig_ll_l","hypotheses":"(X : forall (id : ident) (name : string) (sg : signature),\nhelper_declared prog id name sg -> helper_declared tprog id name sg) (hf : helper_functions) (H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l) (H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l) (H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f) (H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f) (H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s) (H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s) (H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l) (H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l) (H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l) (H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l) (H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l) (H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l) (H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l) (H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l) (H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l)","proofString":"auto 20."},{"statement":"helper_functions_declared prog hf.","conclusion":"helper_functions_declared prog hf","hypotheses":"","proofString":"eapply helper_functions_declared_linkorder; eauto."},{"statement":"(a : expr) : forall (le : letenv) (v : val) (b : bool),\neval_expr tge sp e m le a v ->\nVal.bool_of_val v b -> eval_condexpr tge sp e m le (condexpr_of_expr a) b.","conclusion":"forall (le : letenv) (v : val) (b : bool),\neval_expr tge sp e m le a v ->\nVal.bool_of_val v b -> eval_condexpr tge sp e m le (condexpr_of_expr a) b","hypotheses":"(a : expr)","proofString":"functional induction (condexpr_of_expr a); intros.\ninv H.\neconstructor; eauto.\nsimpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool.\nauto.\ninv H.\neconstructor; eauto.\ndestruct va; eauto.\ninv H.\neconstructor; eauto.\neconstructor.\nconstructor.\neauto.\nconstructor.\nsimpl.\ninv H0.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le (Eop (Ocmp c) el) v) (H0 : Val.bool_of_val v b) : eval_condexpr tge sp e m le (CEcond c el) b.","conclusion":"eval_condexpr tge sp e m le (CEcond c el) b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le (Eop (Ocmp c) el) v) (H0 : Val.bool_of_val v b)","proofString":"inv H.\neconstructor; eauto.\nsimpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v) : eval_condexpr tge sp e m le (CEcond c el) b.","conclusion":"eval_condexpr tge sp e m le (CEcond c el) b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v)","proofString":"econstructor; eauto.\nsimpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v)","proofString":"simpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : Some (Val.of_optbool (eval_condition c vl m)) = Some v) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : Some (Val.of_optbool (eval_condition c vl m)) = Some v)","proofString":"inv H6.\napply Val.bool_of_val_of_optbool.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b) (H4 : eval_exprlist tge sp e m le el vl) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b) (H4 : eval_exprlist tge sp e m le el vl)","proofString":"apply Val.bool_of_val_of_optbool.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b) (H4 : eval_exprlist tge sp e m le el vl) : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b.","conclusion":"Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b) (H4 : eval_exprlist tge sp e m le el vl)","proofString":"auto."},{"statement":"(a : condexpr) (b c : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (IHc0 : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 c v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr c) b1) (le : letenv) (v : val) (b0 : bool) (H : eval_expr tge sp e m le (Econdition a b c) v) (H0 : Val.bool_of_val v b0) : eval_condexpr tge sp e m le\n  (CEcondition a (condexpr_of_expr b) (condexpr_of_expr c)) b0.","conclusion":"eval_condexpr tge sp e m le\n  (CEcondition a (condexpr_of_expr b) (condexpr_of_expr c)) b0","hypotheses":"(a : condexpr) (b c : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (IHc0 : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 c v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr c) b1) (le : letenv) (v : val) (b0 : bool) (H : eval_expr tge sp e m le (Econdition a b c) v) (H0 : Val.bool_of_val v b0)","proofString":"inv H.\neconstructor; eauto.\ndestruct va; eauto."},{"statement":"(a : condexpr) (b c : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (IHc0 : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 c v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr c) b1) (le : letenv) (v : val) (b0 : bool) (H0 : Val.bool_of_val v b0) (va : bool) (H6 : eval_condexpr tge sp e m le a va) (H7 : eval_expr tge sp e m le (if va then b else c) v) : eval_condexpr tge sp e m le\n  (CEcondition a (condexpr_of_expr b) (condexpr_of_expr c)) b0.","conclusion":"eval_condexpr tge sp e m le\n  (CEcondition a (condexpr_of_expr b) (condexpr_of_expr c)) b0","hypotheses":"(a : condexpr) (b c : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (IHc0 : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 c v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr c) b1) (le : letenv) (v : val) (b0 : bool) (H0 : Val.bool_of_val v b0) (va : bool) (H6 : eval_condexpr tge sp e m le a va) (H7 : eval_expr tge sp e m le (if va then b else c) v)","proofString":"econstructor; eauto.\ndestruct va; eauto."},{"statement":"(a : condexpr) (b c : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (IHc0 : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 c v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr c) b1) (le : letenv) (v : val) (b0 : bool) (H0 : Val.bool_of_val v b0) (va : bool) (H6 : eval_condexpr tge sp e m le a va) (H7 : eval_expr tge sp e m le (if va then b else c) v) : eval_condexpr tge sp e m le\n  (if va then condexpr_of_expr b else condexpr_of_expr c) b0.","conclusion":"eval_condexpr tge sp e m le\n  (if va then condexpr_of_expr b else condexpr_of_expr c) b0","hypotheses":"(a : condexpr) (b c : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (IHc0 : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 c v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr c) b1) (le : letenv) (v : val) (b0 : bool) (H0 : Val.bool_of_val v b0) (va : bool) (H6 : eval_condexpr tge sp e m le a va) (H7 : eval_expr tge sp e m le (if va then b else c) v)","proofString":"destruct va; eauto."},{"statement":"(a b : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (le : letenv) (v : val) (b0 : bool) (H : eval_expr tge sp e m le (Elet a b) v) (H0 : Val.bool_of_val v b0) : eval_condexpr tge sp e m le (CElet a (condexpr_of_expr b)) b0.","conclusion":"eval_condexpr tge sp e m le (CElet a (condexpr_of_expr b)) b0","hypotheses":"(a b : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (le : letenv) (v : val) (b0 : bool) (H : eval_expr tge sp e m le (Elet a b) v) (H0 : Val.bool_of_val v b0)","proofString":"inv H.\neconstructor; eauto."},{"statement":"(a b : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (le : letenv) (v : val) (b0 : bool) (H0 : Val.bool_of_val v b0) (v1 : val) (H4 : eval_expr tge sp e m le a v1) (H6 : eval_expr tge sp e m (v1 :: le) b v) : eval_condexpr tge sp e m le (CElet a (condexpr_of_expr b)) b0.","conclusion":"eval_condexpr tge sp e m le (CElet a (condexpr_of_expr b)) b0","hypotheses":"(a b : expr) (IHc : forall (le0 : letenv) (v0 : val) (b1 : bool),\neval_expr tge sp e m le0 b v0 ->\nVal.bool_of_val v0 b1 -> eval_condexpr tge sp e m le0 (condexpr_of_expr b) b1) (le : letenv) (v : val) (b0 : bool) (H0 : Val.bool_of_val v b0) (v1 : val) (H4 : eval_expr tge sp e m le a v1) (H6 : eval_expr tge sp e m (v1 :: le) b v)","proofString":"econstructor; eauto."},{"statement":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ | Econdition _ _ _ | Elet _ _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b) : eval_condexpr tge sp e m le (CEcond (Ccompuimm Cne Int.zero) (e0 ::: Enil)) b.","conclusion":"eval_condexpr tge sp e m le (CEcond (Ccompuimm Cne Int.zero) (e0 ::: Enil)) b","hypotheses":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ | Econdition _ _ _ | Elet _ _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b)","proofString":"econstructor.\nconstructor.\neauto.\nconstructor.\nsimpl.\ninv H0.\nauto."},{"statement":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ | Econdition _ _ _ | Elet _ _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b) : Val.cmpu_bool (Mem.valid_pointer m) Cne v (Vint Int.zero) = Some b.","conclusion":"Val.cmpu_bool (Mem.valid_pointer m) Cne v (Vint Int.zero) = Some b","hypotheses":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ | Econdition _ _ _ | Elet _ _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b)","proofString":"inv H0.\nauto."},{"statement":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ | Econdition _ _ _ | Elet _ _ => False\n| _ => True\nend) (le : letenv) (n : int) (H : eval_expr tge sp e m le e0 (Vint n)) : Val.cmpu_bool (Mem.valid_pointer m) Cne (Vint n) (Vint Int.zero) =\nSome (negb (Int.eq n Int.zero)).","conclusion":"Val.cmpu_bool (Mem.valid_pointer m) Cne (Vint n) (Vint Int.zero) =\nSome (negb (Int.eq n Int.zero))","hypotheses":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ | Econdition _ _ _ | Elet _ _ => False\n| _ => True\nend) (le : letenv) (n : int) (H : eval_expr tge sp e m le e0 (Vint n))","proofString":"auto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le (Eop (Ocmp c) el) v) (H0 : Val.bool_of_val v b) : exists vl : list val,\n  eval_exprlist tge sp e m le el vl /\\ eval_condition c vl m = Some b.","conclusion":"exists vl : list val,\n  eval_exprlist tge sp e m le el vl /\\ eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le (Eop (Ocmp c) el) v) (H0 : Val.bool_of_val v b)","proofString":"inv H.\nexists vl; split; auto.\nsimpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool in H0.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v) : exists vl0 : list val,\n  eval_exprlist tge sp e m le el vl0 /\\ eval_condition c vl0 m = Some b.","conclusion":"exists vl0 : list val,\n  eval_exprlist tge sp e m le el vl0 /\\ eval_condition c vl0 m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v)","proofString":"exists vl; split; auto.\nsimpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool in H0.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : eval_operation tge sp (Ocmp c) vl m = Some v)","proofString":"simpl in H6.\ninv H6.\napply Val.bool_of_val_of_optbool in H0.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : Some (Val.of_optbool (eval_condition c vl m)) = Some v) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (v : val) (b : bool) (H0 : Val.bool_of_val v b) (vl : list val) (H4 : eval_exprlist tge sp e m le el vl) (H6 : Some (Val.of_optbool (eval_condition c vl m)) = Some v)","proofString":"inv H6.\napply Val.bool_of_val_of_optbool in H0.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b) (H4 : eval_exprlist tge sp e m le el vl) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : Val.bool_of_val (Val.of_optbool (eval_condition c vl m)) b) (H4 : eval_exprlist tge sp e m le el vl)","proofString":"apply Val.bool_of_val_of_optbool in H0.\nauto."},{"statement":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : eval_condition c vl m = Some b) (H4 : eval_exprlist tge sp e m le el vl) : eval_condition c vl m = Some b.","conclusion":"eval_condition c vl m = Some b","hypotheses":"(c : condition) (el : exprlist) (le : letenv) (b : bool) (vl : list val) (H0 : eval_condition c vl m = Some b) (H4 : eval_exprlist tge sp e m le el vl)","proofString":"auto."},{"statement":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b) : exists vl : list val,\n  eval_exprlist tge sp e m le (e0 ::: Enil) vl /\\\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) Cne v1 (Vint Int.zero)\n  | v1 :: _ :: _ => None\n  end = Some b.","conclusion":"exists vl : list val,\n  eval_exprlist tge sp e m le (e0 ::: Enil) vl /\\\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) Cne v1 (Vint Int.zero)\n  | v1 :: _ :: _ => None\n  end = Some b","hypotheses":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b)","proofString":"exists (v :: nil); split.\nconstructor; auto; constructor.\ninv H0; simpl; auto."},{"statement":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b) : eval_exprlist tge sp e m le (e0 ::: Enil) (v :: nil).","conclusion":"eval_exprlist tge sp e m le (e0 ::: Enil) (v :: nil)","hypotheses":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b)","proofString":"constructor; auto; constructor."},{"statement":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b) : Val.cmpu_bool (Mem.valid_pointer m) Cne v (Vint Int.zero) = Some b.","conclusion":"Val.cmpu_bool (Mem.valid_pointer m) Cne v (Vint Int.zero) = Some b","hypotheses":"(e0 : expr) (y : match e0 with\n| Eop (Ocmp _) _ => False\n| _ => True\nend) (le : letenv) (v : val) (b : bool) (H : eval_expr tge sp e m le e0 v) (H0 : Val.bool_of_val v b)","proofString":"inv H0; simpl; auto."},{"statement":"(le : letenv) (a : expr) (v : val) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a v) (H0 : Mem.loadv chunk m v = Some v') : eval_expr tge sp e m le (load chunk a) v'.","conclusion":"eval_expr tge sp e m le (load chunk a) v'","hypotheses":"(le : letenv) (a : expr) (v : val) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a v) (H0 : Mem.loadv chunk m v = Some v')","proofString":"generalize H0; destruct v; simpl; intro; try discriminate.\nunfold load.\ngeneralize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).\ndestruct (addressing chunk a).\nintros [vl [EV EQ]].\neapply eval_Eload; eauto."},{"statement":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') : eval_expr tge sp e m le (load chunk a) v'.","conclusion":"eval_expr tge sp e m le (load chunk a) v'","hypotheses":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v')","proofString":"unfold load.\ngeneralize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).\ndestruct (addressing chunk a).\nintros [vl [EV EQ]].\neapply eval_Eload; eauto."},{"statement":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') : eval_expr tge sp e m le\n  (let (mode, args) := addressing chunk a in Eload chunk mode args) v'.","conclusion":"eval_expr tge sp e m le\n  (let (mode, args) := addressing chunk a in Eload chunk mode args) v'","hypotheses":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v')","proofString":"generalize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).\ndestruct (addressing chunk a).\nintros [vl [EV EQ]].\neapply eval_Eload; eauto."},{"statement":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') : (let (mode, args) := addressing chunk a in\n exists vl : list val,\n   eval_exprlist tge sp e m le args vl /\\\n   Op.eval_addressing tge sp mode vl = Some (Vptr b i)) ->\neval_expr tge sp e m le\n  (let (mode, args) := addressing chunk a in Eload chunk mode args) v'.","conclusion":"(let (mode, args) := addressing chunk a in\n exists vl : list val,\n   eval_exprlist tge sp e m le args vl /\\\n   Op.eval_addressing tge sp mode vl = Some (Vptr b i)) ->\neval_expr tge sp e m le\n  (let (mode, args) := addressing chunk a in Eload chunk mode args) v'","hypotheses":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v')","proofString":"destruct (addressing chunk a).\nintros [vl [EV EQ]].\neapply eval_Eload; eauto."},{"statement":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') (a0 : Op.addressing) (e0 : exprlist) : (exists vl : list val,\n   eval_exprlist tge sp e m le e0 vl /\\\n   Op.eval_addressing tge sp a0 vl = Some (Vptr b i)) ->\neval_expr tge sp e m le (Eload chunk a0 e0) v'.","conclusion":"(exists vl : list val,\n   eval_exprlist tge sp e m le e0 vl /\\\n   Op.eval_addressing tge sp a0 vl = Some (Vptr b i)) ->\neval_expr tge sp e m le (Eload chunk a0 e0) v'","hypotheses":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') (a0 : Op.addressing) (e0 : exprlist)","proofString":"intros [vl [EV EQ]].\neapply eval_Eload; eauto."},{"statement":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') (a0 : Op.addressing) (e0 : exprlist) (vl : list val) (EV : eval_exprlist tge sp e m le e0 vl) (EQ : Op.eval_addressing tge sp a0 vl = Some (Vptr b i)) : eval_expr tge sp e m le (Eload chunk a0 e0) v'.","conclusion":"eval_expr tge sp e m le (Eload chunk a0 e0) v'","hypotheses":"(le : letenv) (a : expr) (b : block) (i : ptrofs) (chunk : memory_chunk) (v' : val) (H : eval_expr tge sp e m le a (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v') (H1 : Mem.load chunk m b (Ptrofs.unsigned i) = Some v') (a0 : Op.addressing) (e0 : exprlist) (vl : list val) (EV : eval_exprlist tge sp e m le e0 vl) (EQ : Op.eval_addressing tge sp a0 vl = Some (Vptr b i))","proofString":"eapply eval_Eload; eauto."},{"statement":"(chunk : memory_chunk) (a1 a2 : expr) (v1 v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 v1) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m v1 v2 = Some m') : step tge (State f (store chunk a1 a2) k sp e m) E0 (State f Sskip k sp e m').","conclusion":"step tge (State f (store chunk a1 a2) k sp e m) E0 (State f Sskip k sp e m')","hypotheses":"(chunk : memory_chunk) (a1 a2 : expr) (v1 v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 v1) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m v1 v2 = Some m')","proofString":"generalize H1; destruct v1; simpl; intro; try discriminate.\nunfold store.\ngeneralize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).\ndestruct (addressing chunk a1).\nintros [vl [EV EQ]].\neapply step_store; eauto."},{"statement":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') : step tge (State f (store chunk a1 a2) k sp e m) E0 (State f Sskip k sp e m').","conclusion":"step tge (State f (store chunk a1 a2) k sp e m) E0 (State f Sskip k sp e m')","hypotheses":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m')","proofString":"unfold store.\ngeneralize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).\ndestruct (addressing chunk a1).\nintros [vl [EV EQ]].\neapply step_store; eauto."},{"statement":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') : step tge\n  (State f\n     (let (mode, args) := addressing chunk a1 in Sstore chunk mode args a2) k\n     sp e m) E0 (State f Sskip k sp e m').","conclusion":"step tge\n  (State f\n     (let (mode, args) := addressing chunk a1 in Sstore chunk mode args a2) k\n     sp e m) E0 (State f Sskip k sp e m')","hypotheses":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m')","proofString":"generalize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).\ndestruct (addressing chunk a1).\nintros [vl [EV EQ]].\neapply step_store; eauto."},{"statement":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') : (let (mode, args) := addressing chunk a1 in\n exists vl : list val,\n   eval_exprlist tge sp e m nil args vl /\\\n   Op.eval_addressing tge sp mode vl = Some (Vptr b i)) ->\nstep tge\n  (State f\n     (let (mode, args) := addressing chunk a1 in Sstore chunk mode args a2) k\n     sp e m) E0 (State f Sskip k sp e m').","conclusion":"(let (mode, args) := addressing chunk a1 in\n exists vl : list val,\n   eval_exprlist tge sp e m nil args vl /\\\n   Op.eval_addressing tge sp mode vl = Some (Vptr b i)) ->\nstep tge\n  (State f\n     (let (mode, args) := addressing chunk a1 in Sstore chunk mode args a2) k\n     sp e m) E0 (State f Sskip k sp e m')","hypotheses":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m')","proofString":"destruct (addressing chunk a1).\nintros [vl [EV EQ]].\neapply step_store; eauto."},{"statement":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') (a : Op.addressing) (e0 : exprlist) : (exists vl : list val,\n   eval_exprlist tge sp e m nil e0 vl /\\\n   Op.eval_addressing tge sp a vl = Some (Vptr b i)) ->\nstep tge (State f (Sstore chunk a e0 a2) k sp e m) E0\n  (State f Sskip k sp e m').","conclusion":"(exists vl : list val,\n   eval_exprlist tge sp e m nil e0 vl /\\\n   Op.eval_addressing tge sp a vl = Some (Vptr b i)) ->\nstep tge (State f (Sstore chunk a e0 a2) k sp e m) E0\n  (State f Sskip k sp e m')","hypotheses":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') (a : Op.addressing) (e0 : exprlist)","proofString":"intros [vl [EV EQ]].\neapply step_store; eauto."},{"statement":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') (a : Op.addressing) (e0 : exprlist) (vl : list val) (EV : eval_exprlist tge sp e m nil e0 vl) (EQ : Op.eval_addressing tge sp a vl = Some (Vptr b i)) : step tge (State f (Sstore chunk a e0 a2) k sp e m) E0\n  (State f Sskip k sp e m').","conclusion":"step tge (State f (Sstore chunk a e0 a2) k sp e m) E0\n  (State f Sskip k sp e m')","hypotheses":"(chunk : memory_chunk) (a1 a2 : expr) (b : block) (i : ptrofs) (v2 : val) (f : function) (k : cont) (m' : mem) (H : eval_expr tge sp e m nil a1 (Vptr b i)) (H0 : eval_expr tge sp e m nil a2 v2) (H1 : Mem.storev chunk m (Vptr b i) v2 = Some m') (H2 : Mem.store chunk m b (Ptrofs.unsigned i) v2 = Some m') (a : Op.addressing) (e0 : exprlist) (vl : list val) (EV : eval_exprlist tge sp e m nil e0 vl) (EQ : Op.eval_addressing tge sp a vl = Some (Vptr b i))","proofString":"eapply step_store; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (cast8unsigned a1) v' /\\\n  Val.lessdef (Val.zero_ext 8 v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (cast8unsigned a1) v' /\\\n  Val.lessdef (Val.zero_ext 8 v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_cast8unsigned; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (cast8signed a1) v' /\\\n  Val.lessdef (Val.sign_ext 8 v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (cast8signed a1) v' /\\\n  Val.lessdef (Val.sign_ext 8 v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_cast8signed; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (cast16unsigned a1) v' /\\\n  Val.lessdef (Val.zero_ext 16 v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (cast16unsigned a1) v' /\\\n  Val.lessdef (Val.zero_ext 16 v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_cast16unsigned; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (cast16signed a1) v' /\\\n  Val.lessdef (Val.sign_ext 16 v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (cast16signed a1) v' /\\\n  Val.lessdef (Val.sign_ext 16 v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_cast16signed; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (negint a1) v' /\\ Val.lessdef (Val.negint v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (negint a1) v' /\\ Val.lessdef (Val.negint v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_negint; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (notint a1) v' /\\ Val.lessdef (Val.notint v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (notint a1) v' /\\ Val.lessdef (Val.notint v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_notint; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (negf a1) v' /\\ Val.lessdef (Val.negf v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (negf a1) v' /\\ Val.lessdef (Val.negf v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_negf; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (absf a1) v' /\\ Val.lessdef (Val.absf v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (absf a1) v' /\\ Val.lessdef (Val.absf v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_absf; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (negfs a1) v' /\\ Val.lessdef (Val.negfs v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (negfs a1) v' /\\ Val.lessdef (Val.negfs v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_negfs; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (absfs a1) v' /\\ Val.lessdef (Val.absfs v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (absfs a1) v' /\\ Val.lessdef (Val.absfs v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_absfs; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (singleoffloat a1) v' /\\\n  Val.lessdef (Val.singleoffloat v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (singleoffloat a1) v' /\\\n  Val.lessdef (Val.singleoffloat v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_singleoffloat; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (floatofsingle a1) v' /\\\n  Val.lessdef (Val.floatofsingle v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (floatofsingle a1) v' /\\\n  Val.lessdef (Val.floatofsingle v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_floatofsingle; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intoffloat v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (intoffloat a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (intoffloat a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intoffloat v1 = Some v)","proofString":"eapply eval_intoffloat; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intuoffloat v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (intuoffloat a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (intuoffloat a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intuoffloat v1 = Some v)","proofString":"eapply eval_intuoffloat; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatofint v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (floatofint a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (floatofint a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatofint v1 = Some v)","proofString":"eapply eval_floatofint; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatofintu v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (floatofintu a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (floatofintu a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatofintu v1 = Some v)","proofString":"eapply eval_floatofintu; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intofsingle v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (intofsingle a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (intofsingle a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intofsingle v1 = Some v)","proofString":"eapply eval_intofsingle; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intuofsingle v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (intuofsingle a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (intuofsingle a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.intuofsingle v1 = Some v)","proofString":"eapply eval_intuofsingle; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleofint v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (singleofint a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (singleofint a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleofint v1 = Some v)","proofString":"eapply eval_singleofint; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleofintu v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (singleofintu a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (singleofintu a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleofintu v1 = Some v)","proofString":"eapply eval_singleofintu; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (negl a1) v' /\\ Val.lessdef (Val.negl v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (negl a1) v' /\\ Val.lessdef (Val.negl v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"eapply eval_negl; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (notl a1) v' /\\ Val.lessdef (Val.notl v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (notl a1) v' /\\ Val.lessdef (Val.notl v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"eapply eval_notl; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (intoflong a1) v' /\\ Val.lessdef (Val.loword v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (intoflong a1) v' /\\ Val.lessdef (Val.loword v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"eapply eval_intoflong; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (longofint a1) v' /\\\n  Val.lessdef (Val.longofint v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (longofint a1) v' /\\\n  Val.lessdef (Val.longofint v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"eapply eval_longofint; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (longofintu a1) v' /\\\n  Val.lessdef (Val.longofintu v1) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (longofintu a1) v' /\\\n  Val.lessdef (Val.longofintu v1) v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"eapply eval_longofintu; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longoffloat v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (longoffloat a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (longoffloat a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longoffloat v1 = Some v)","proofString":"eapply eval_longoffloat; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longuoffloat v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (longuoffloat a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (longuoffloat a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longuoffloat v1 = Some v)","proofString":"eapply eval_longuoffloat; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatoflong v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (floatoflong a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (floatoflong a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatoflong v1 = Some v)","proofString":"eapply eval_floatoflong; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatoflongu v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (floatoflongu a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (floatoflongu a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.floatoflongu v1 = Some v)","proofString":"eapply eval_floatoflongu; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longofsingle v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (longofsingle a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (longofsingle a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longofsingle v1 = Some v)","proofString":"eapply eval_longofsingle; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longuofsingle v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (longuofsingle a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (longuofsingle a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.longuofsingle v1 = Some v)","proofString":"eapply eval_longuofsingle; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleoflong v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (singleoflong a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (singleoflong a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleoflong v1 = Some v)","proofString":"eapply eval_singleoflong; eauto."},{"statement":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleoflongu v1 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (singleoflongu a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (singleoflongu a1) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 : expr) (v1 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : Val.singleoflongu v1 = Some v)","proofString":"eapply eval_singleoflongu; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (add a1 a2) v' /\\ Val.lessdef (Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (add a1 a2) v' /\\ Val.lessdef (Val.add v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_add; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (sub a1 a2) v' /\\ Val.lessdef (Val.sub v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (sub a1 a2) v' /\\ Val.lessdef (Val.sub v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_sub; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (mul a1 a2) v' /\\ Val.lessdef (Val.mul v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (mul a1 a2) v' /\\ Val.lessdef (Val.mul v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_mul; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divs v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (divs a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (divs a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divs v1 v2 = Some v)","proofString":"eapply eval_divs; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divu v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (divu a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (divu a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divu v1 v2 = Some v)","proofString":"eapply eval_divu; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.mods v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (mods a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (mods a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.mods v1 v2 = Some v)","proofString":"eapply eval_mods; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.modu v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (modu a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (modu a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.modu v1 v2 = Some v)","proofString":"eapply eval_modu; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (and a1 a2) v' /\\ Val.lessdef (Val.and v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (and a1 a2) v' /\\ Val.lessdef (Val.and v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_and; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (or a1 a2) v' /\\ Val.lessdef (Val.or v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (or a1 a2) v' /\\ Val.lessdef (Val.or v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_or; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (xor a1 a2) v' /\\ Val.lessdef (Val.xor v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (xor a1 a2) v' /\\ Val.lessdef (Val.xor v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_xor; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (shl a1 a2) v' /\\ Val.lessdef (Val.shl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (shl a1 a2) v' /\\ Val.lessdef (Val.shl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_shl; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (shr a1 a2) v' /\\ Val.lessdef (Val.shr v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (shr a1 a2) v' /\\ Val.lessdef (Val.shr v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_shr; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (shru a1 a2) v' /\\ Val.lessdef (Val.shru v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (shru a1 a2) v' /\\ Val.lessdef (Val.shru v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_shru; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (addf a1 a2) v' /\\ Val.lessdef (Val.addf v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (addf a1 a2) v' /\\ Val.lessdef (Val.addf v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_addf; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (subf a1 a2) v' /\\ Val.lessdef (Val.subf v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (subf a1 a2) v' /\\ Val.lessdef (Val.subf v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_subf; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (mulf a1 a2) v' /\\ Val.lessdef (Val.mulf v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (mulf a1 a2) v' /\\ Val.lessdef (Val.mulf v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_mulf; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (divf a1 a2) v' /\\ Val.lessdef (Val.divf v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (divf a1 a2) v' /\\ Val.lessdef (Val.divf v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_divf; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (addfs a1 a2) v' /\\\n  Val.lessdef (Val.addfs v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (addfs a1 a2) v' /\\\n  Val.lessdef (Val.addfs v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_addfs; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (subfs a1 a2) v' /\\\n  Val.lessdef (Val.subfs v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (subfs a1 a2) v' /\\\n  Val.lessdef (Val.subfs v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_subfs; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (mulfs a1 a2) v' /\\\n  Val.lessdef (Val.mulfs v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (mulfs a1 a2) v' /\\\n  Val.lessdef (Val.mulfs v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_mulfs; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (divfs a1 a2) v' /\\\n  Val.lessdef (Val.divfs v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (divfs a1 a2) v' /\\\n  Val.lessdef (Val.divfs v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_divfs; auto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (addl a1 a2) v' /\\ Val.lessdef (Val.addl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (addl a1 a2) v' /\\ Val.lessdef (Val.addl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_addl; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (subl a1 a2) v' /\\ Val.lessdef (Val.subl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (subl a1 a2) v' /\\ Val.lessdef (Val.subl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_subl; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (mull a1 a2) v' /\\ Val.lessdef (Val.mull v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (mull a1 a2) v' /\\ Val.lessdef (Val.mull v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_mull; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divls v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (divls a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (divls a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divls v1 v2 = Some v)","proofString":"eapply eval_divls; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divlu v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (divlu a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (divlu a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.divlu v1 v2 = Some v)","proofString":"eapply eval_divlu; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.modls v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (modls a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (modls a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.modls v1 v2 = Some v)","proofString":"eapply eval_modls; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.modlu v1 v2 = Some v) : exists v' : val, eval_expr tge sp e m le (modlu a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (modlu a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.modlu v1 v2 = Some v)","proofString":"eapply eval_modlu; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (andl a1 a2) v' /\\ Val.lessdef (Val.andl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (andl a1 a2) v' /\\ Val.lessdef (Val.andl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_andl; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (orl a1 a2) v' /\\ Val.lessdef (Val.orl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (orl a1 a2) v' /\\ Val.lessdef (Val.orl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_orl; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (xorl a1 a2) v' /\\ Val.lessdef (Val.xorl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (xorl a1 a2) v' /\\ Val.lessdef (Val.xorl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_xorl; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (shll a1 a2) v' /\\ Val.lessdef (Val.shll v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (shll a1 a2) v' /\\ Val.lessdef (Val.shll v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_shll; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (shrl a1 a2) v' /\\ Val.lessdef (Val.shrl v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (shrl a1 a2) v' /\\ Val.lessdef (Val.shrl v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_shrl; eauto."},{"statement":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (shrlu a1 a2) v' /\\\n  Val.lessdef (Val.shrlu v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (shrlu a1 a2) v' /\\\n  Val.lessdef (Val.shrlu v1 v2) v'","hypotheses":"(le : letenv) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_shrlu; eauto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (comp c a1 a2) v' /\\\n  Val.lessdef (Val.cmp c v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (comp c a1 a2) v' /\\\n  Val.lessdef (Val.cmp c v1 v2) v'","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_comp; auto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (compu c a1 a2) v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (compu c a1 a2) v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v'","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_compu; auto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (compf c a1 a2) v' /\\\n  Val.lessdef (Val.cmpf c v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (compf c a1 a2) v' /\\\n  Val.lessdef (Val.cmpf c v1 v2) v'","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_compf; auto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (compfs c a1 a2) v' /\\\n  Val.lessdef (Val.cmpfs c v1 v2) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (compfs c a1 a2) v' /\\\n  Val.lessdef (Val.cmpfs c v1 v2) v'","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"apply eval_compfs; auto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmpl c v1 v2 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (cmpl c a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (cmpl c a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmpl c v1 v2 = Some v)","proofString":"exists v; split; auto.\neapply eval_cmpl; eauto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmpl c v1 v2 = Some v) : eval_expr tge sp e m le (cmpl c a1 a2) v.","conclusion":"eval_expr tge sp e m le (cmpl c a1 a2) v","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmpl c v1 v2 = Some v)","proofString":"eapply eval_cmpl; eauto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v) : exists v' : val,\n  eval_expr tge sp e m le (cmplu c a1 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (cmplu c a1 a2) v' /\\ Val.lessdef v v'","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v)","proofString":"exists v; split; auto.\neapply eval_cmplu; eauto."},{"statement":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v) : eval_expr tge sp e m le (cmplu c a1 a2) v.","conclusion":"eval_expr tge sp e m le (cmplu c a1 a2) v","hypotheses":"(le : letenv) (c : comparison) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v)","proofString":"eapply eval_cmplu; eauto."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) : exists v : val,\n  eval_expr tge sp e m le\n    (let (cond, args) := condition_of_expr a1 in\n     match select ty cond args a2 a3 with\n     | Some a => a\n     | None => Econdition (condexpr_of_expr a1) a2 a3\n     end) v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.","conclusion":"exists v : val,\n  eval_expr tge sp e m le\n    (let (cond, args) := condition_of_expr a1 in\n     match select ty cond args a2 a3 with\n     | Some a => a\n     | None => Econdition (condexpr_of_expr a1) a2 a3\n     end) v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b)","proofString":"specialize (eval_condition_of_expr _ _ _ _ H H2).\ndestruct (condition_of_expr a1) as [cond args]; simpl fst; simpl snd.\nintros (vl & A & B).\ndestruct (select ty cond args a2 a3) as [a|] eqn:SEL.\neapply eval_select; eauto.\nexists (if b then v2 else v3); split.\neconstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\ndestruct b; auto.\napply Val.lessdef_normalize."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) : (exists vl : list val,\n   eval_exprlist tge sp e m le (snd (condition_of_expr a1)) vl /\\\n   eval_condition (fst (condition_of_expr a1)) vl m = Some b) ->\nexists v : val,\n  eval_expr tge sp e m le\n    (let (cond, args) := condition_of_expr a1 in\n     match select ty cond args a2 a3 with\n     | Some a => a\n     | None => Econdition (condexpr_of_expr a1) a2 a3\n     end) v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.","conclusion":"(exists vl : list val,\n   eval_exprlist tge sp e m le (snd (condition_of_expr a1)) vl /\\\n   eval_condition (fst (condition_of_expr a1)) vl m = Some b) ->\nexists v : val,\n  eval_expr tge sp e m le\n    (let (cond, args) := condition_of_expr a1 in\n     match select ty cond args a2 a3 with\n     | Some a => a\n     | None => Econdition (condexpr_of_expr a1) a2 a3\n     end) v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b)","proofString":"destruct (condition_of_expr a1) as [cond args]; simpl fst; simpl snd.\nintros (vl & A & B).\ndestruct (select ty cond args a2 a3) as [a|] eqn:SEL.\neapply eval_select; eauto.\nexists (if b then v2 else v3); split.\neconstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\ndestruct b; auto.\napply Val.lessdef_normalize."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) : (exists vl : list val,\n   eval_exprlist tge sp e m le args vl /\\ eval_condition cond vl m = Some b) ->\nexists v : val,\n  eval_expr tge sp e m le\n    match select ty cond args a2 a3 with\n    | Some a => a\n    | None => Econdition (condexpr_of_expr a1) a2 a3\n    end v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.","conclusion":"(exists vl : list val,\n   eval_exprlist tge sp e m le args vl /\\ eval_condition cond vl m = Some b) ->\nexists v : val,\n  eval_expr tge sp e m le\n    match select ty cond args a2 a3 with\n    | Some a => a\n    | None => Econdition (condexpr_of_expr a1) a2 a3\n    end v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist)","proofString":"intros (vl & A & B).\ndestruct (select ty cond args a2 a3) as [a|] eqn:SEL.\neapply eval_select; eauto.\nexists (if b then v2 else v3); split.\neconstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\ndestruct b; auto.\napply Val.lessdef_normalize."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) : exists v : val,\n  eval_expr tge sp e m le\n    match select ty cond args a2 a3 with\n    | Some a => a\n    | None => Econdition (condexpr_of_expr a1) a2 a3\n    end v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.","conclusion":"exists v : val,\n  eval_expr tge sp e m le\n    match select ty cond args a2 a3 with\n    | Some a => a\n    | None => Econdition (condexpr_of_expr a1) a2 a3\n    end v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b)","proofString":"destruct (select ty cond args a2 a3) as [a|] eqn:SEL.\neapply eval_select; eauto.\nexists (if b then v2 else v3); split.\neconstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\ndestruct b; auto.\napply Val.lessdef_normalize."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (a : expr) (SEL : select ty cond args a2 a3 = Some a) : exists v : val,\n  eval_expr tge sp e m le a v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.","conclusion":"exists v : val,\n  eval_expr tge sp e m le a v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (a : expr) (SEL : select ty cond args a2 a3 = Some a)","proofString":"eapply eval_select; eauto."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (SEL : select ty cond args a2 a3 = None) : exists v : val,\n  eval_expr tge sp e m le (Econdition (condexpr_of_expr a1) a2 a3) v /\\\n  Val.lessdef (Val.select (Some b) v2 v3 ty) v.","conclusion":"exists v : val,\n  eval_expr tge sp e m le (Econdition (condexpr_of_expr a1) a2 a3) v /\\\n  Val.lessdef (Val.select (Some b) v2 v3 ty) v","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (SEL : select ty cond args a2 a3 = None)","proofString":"exists (if b then v2 else v3); split.\neconstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\ndestruct b; auto.\napply Val.lessdef_normalize."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (SEL : select ty cond args a2 a3 = None) : eval_expr tge sp e m le (Econdition (condexpr_of_expr a1) a2 a3)\n  (if b then v2 else v3).","conclusion":"eval_expr tge sp e m le (Econdition (condexpr_of_expr a1) a2 a3)\n  (if b then v2 else v3)","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (SEL : select ty cond args a2 a3 = None)","proofString":"econstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\ndestruct b; auto."},{"statement":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (SEL : select ty cond args a2 a3 = None) : Val.lessdef (Val.select (Some b) v2 v3 ty) (if b then v2 else v3).","conclusion":"Val.lessdef (Val.select (Some b) v2 v3 ty) (if b then v2 else v3)","hypotheses":"(le : letenv) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_expr tge sp e m le a2 v2) (H1 : eval_expr tge sp e m le a3 v3) (H2 : Val.bool_of_val v1 b) (cond : condition) (args : exprlist) (vl : list val) (A : eval_exprlist tge sp e m le args vl) (B : eval_condition cond vl m = Some b) (SEL : select ty cond args a2 a3 = None)","proofString":"apply Val.lessdef_normalize."},{"statement":"(bf : builtin_function) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : sel_known_builtin bf args = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem bf vl = Some v) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(bf : builtin_function) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : sel_known_builtin bf args = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem bf vl = Some v)","proofString":"destruct bf as [bf|bf]; simpl in SEL.\ndestruct bf; try discriminate.\ninv ARGS; try discriminate.\ninv H0; try discriminate.\ninv H2; try discriminate.\ninv H3; try discriminate.\ninv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor.\ninv ARGS; try discriminate.\ninv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absf; auto.\ninv ARGS; try discriminate.\ninv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absfs; auto.\neapply eval_platform_builtin; eauto."},{"statement":"(bf : standard_builtin) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match bf with\n| BI_select ty =>\n    match args with\n    | Enil => None\n    | a1 ::: Enil => None\n    | a1 ::: a2 ::: Enil => None\n    | a1 ::: a2 ::: a3 ::: Enil => Some (sel_select ty a1 a2 a3)\n    | a1 ::: a2 ::: a3 ::: _ ::: _ => None\n    end\n| BI_fabs =>\n    match args with\n    | Enil => None\n    | a1 ::: Enil => Some (absf a1)\n    | a1 ::: _ ::: _ => None\n    end\n| BI_fabsf =>\n    match args with\n    | Enil => None\n    | a1 ::: Enil => Some (absfs a1)\n    | a1 ::: _ ::: _ => None\n    end\n| _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard bf) vl = Some v) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(bf : standard_builtin) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match bf with\n| BI_select ty =>\n    match args with\n    | Enil => None\n    | a1 ::: Enil => None\n    | a1 ::: a2 ::: Enil => None\n    | a1 ::: a2 ::: a3 ::: Enil => Some (sel_select ty a1 a2 a3)\n    | a1 ::: a2 ::: a3 ::: _ ::: _ => None\n    end\n| BI_fabs =>\n    match args with\n    | Enil => None\n    | a1 ::: Enil => Some (absf a1)\n    | a1 ::: _ ::: _ => None\n    end\n| BI_fabsf =>\n    match args with\n    | Enil => None\n    | a1 ::: Enil => Some (absfs a1)\n    | a1 ::: _ ::: _ => None\n    end\n| _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard bf) vl = Some v)","proofString":"destruct bf; try discriminate.\ninv ARGS; try discriminate.\ninv H0; try discriminate.\ninv H2; try discriminate.\ninv H3; try discriminate.\ninv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor.\ninv ARGS; try discriminate.\ninv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absf; auto.\ninv ARGS; try discriminate.\ninv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absfs; auto."},{"statement":"(t : typ) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match args with\n| Enil => None\n| a1 ::: Enil => None\n| a1 ::: a2 ::: Enil => None\n| a1 ::: a2 ::: a3 ::: Enil => Some (sel_select t a1 a2 a3)\n| a1 ::: a2 ::: a3 ::: _ ::: _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard (BI_select t)) vl = Some v) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match args with\n| Enil => None\n| a1 ::: Enil => None\n| a1 ::: a2 ::: Enil => None\n| a1 ::: a2 ::: a3 ::: Enil => Some (sel_select t a1 a2 a3)\n| a1 ::: a2 ::: a3 ::: _ ::: _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard (BI_select t)) vl = Some v)","proofString":"inv ARGS; try discriminate.\ninv H0; try discriminate.\ninv H2; try discriminate.\ninv H3; try discriminate.\ninv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 : expr) (al : exprlist) (SEL : match al with\n| Enil => None\n| a2 ::: Enil => None\n| a2 ::: a3 ::: Enil => Some (sel_select t a1 a2 a3)\n| a2 ::: a3 ::: _ ::: _ => None\nend = Some a) (v1 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: vl0) = Some v) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_exprlist tge sp e m le al vl0) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 : expr) (al : exprlist) (SEL : match al with\n| Enil => None\n| a2 ::: Enil => None\n| a2 ::: a3 ::: Enil => Some (sel_select t a1 a2 a3)\n| a2 ::: a3 ::: _ ::: _ => None\nend = Some a) (v1 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: vl0) = Some v) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_exprlist tge sp e m le al vl0)","proofString":"inv H0; try discriminate.\ninv H2; try discriminate.\ninv H3; try discriminate.\ninv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 a0 : expr) (al0 : exprlist) (SEL : match al0 with\n| Enil => None\n| a3 ::: Enil => Some (sel_select t a1 a0 a3)\n| a3 ::: _ ::: _ => None\nend = Some a) (v1 v0 : val) (vl : list val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: vl) = Some v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H2 : eval_exprlist tge sp e m le al0 vl) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 a0 : expr) (al0 : exprlist) (SEL : match al0 with\n| Enil => None\n| a3 ::: Enil => Some (sel_select t a1 a0 a3)\n| a3 ::: _ ::: _ => None\nend = Some a) (v1 v0 : val) (vl : list val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: vl) = Some v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H2 : eval_exprlist tge sp e m le al0 vl)","proofString":"inv H2; try discriminate.\ninv H3; try discriminate.\ninv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 a0 a2 : expr) (al : exprlist) (SEL : match al with\n| Enil => Some (sel_select t a1 a0 a2)\n| _ ::: _ => None\nend = Some a) (v1 v0 v2 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: v2 :: vl0) =\nSome v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) (H3 : eval_exprlist tge sp e m le al vl0) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 a0 a2 : expr) (al : exprlist) (SEL : match al with\n| Enil => Some (sel_select t a1 a0 a2)\n| _ ::: _ => None\nend = Some a) (v1 v0 v2 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: v2 :: vl0) =\nSome v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) (H3 : eval_exprlist tge sp e m le al vl0)","proofString":"inv H3; try discriminate.\ninv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 a0 a2 : expr) (SEL : Some (sel_select t a1 a0 a2) = Some a) (v1 v0 v2 : val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: v2 :: nil) =\nSome v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (a : expr) (v : val) (le : letenv) (a1 a0 a2 : expr) (SEL : Some (sel_select t a1 a0 a2) = Some a) (v1 v0 v2 : val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: v2 :: nil) =\nSome v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"inv SEL.\nsimpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (v : val) (le : letenv) (a1 a0 a2 : expr) (v1 v0 v2 : val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: v2 :: nil) =\nSome v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (v : val) (le : letenv) (a1 a0 a2 : expr) (v1 v0 v2 : val) (SEM : builtin_function_sem (BI_standard (BI_select t)) (v1 :: v0 :: v2 :: nil) =\nSome v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"simpl in SEM.\ndestruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (v : val) (le : letenv) (a1 a0 a2 : expr) (v1 v0 v2 : val) (SEM : match v1 with\n| Vint n => Some (Val.normalize (if Int.eq n Int.zero then v2 else v0) t)\n| _ => None\nend = Some v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\ Val.lessdef v v'","hypotheses":"(t : typ) (v : val) (le : letenv) (a1 a0 a2 : expr) (v1 v0 v2 : val) (SEM : match v1 with\n| Vint n => Some (Val.normalize (if Int.eq n Int.zero then v2 else v0) t)\n| _ => None\nend = Some v) (H : eval_expr tge sp e m le a1 v1) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"destruct v1; inv SEM.\nreplace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (le : letenv) (a1 a0 a2 : expr) (i : int) (v0 v2 : val) (H : eval_expr tge sp e m le a1 (Vint i)) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\\n  Val.lessdef (Val.normalize (if Int.eq i Int.zero then v2 else v0) t) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\\n  Val.lessdef (Val.normalize (if Int.eq i Int.zero then v2 else v0) t) v'","hypotheses":"(t : typ) (le : letenv) (a1 a0 a2 : expr) (i : int) (v0 v2 : val) (H : eval_expr tge sp e m le a1 (Vint i)) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"replace (Val.normalize (if Int.eq i Int.zero then v2 else v0) t)     with (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t)       by (destruct (Int.eq i Int.zero); reflexivity).\neapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (le : letenv) (a1 a0 a2 : expr) (i : int) (v0 v2 : val) (H : eval_expr tge sp e m le a1 (Vint i)) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) : exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\\n  Val.lessdef (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (sel_select t a1 a0 a2) v' /\\\n  Val.lessdef (Val.select (Some (negb (Int.eq i Int.zero))) v0 v2 t) v'","hypotheses":"(t : typ) (le : letenv) (a1 a0 a2 : expr) (i : int) (v0 v2 : val) (H : eval_expr tge sp e m le a1 (Vint i)) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"eapply eval_sel_select; eauto.\nconstructor."},{"statement":"(t : typ) (le : letenv) (a1 a0 a2 : expr) (i : int) (v0 v2 : val) (H : eval_expr tge sp e m le a1 (Vint i)) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2) : Val.bool_of_val (Vint i) (negb (Int.eq i Int.zero)).","conclusion":"Val.bool_of_val (Vint i) (negb (Int.eq i Int.zero))","hypotheses":"(t : typ) (le : letenv) (a1 a0 a2 : expr) (i : int) (v0 v2 : val) (H : eval_expr tge sp e m le a1 (Vint i)) (H1 : eval_expr tge sp e m le a0 v0) (H0 : eval_expr tge sp e m le a2 v2)","proofString":"constructor."},{"statement":"(args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match args with\n| Enil => None\n| a1 ::: Enil => Some (absf a1)\n| a1 ::: _ ::: _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard BI_fabs) vl = Some v) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match args with\n| Enil => None\n| a1 ::: Enil => Some (absf a1)\n| a1 ::: _ ::: _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard BI_fabs) vl = Some v)","proofString":"inv ARGS; try discriminate.\ninv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absf; auto."},{"statement":"(a : expr) (v : val) (le : letenv) (a1 : expr) (al : exprlist) (SEL : match al with\n| Enil => Some (absf a1)\n| _ ::: _ => None\nend = Some a) (v1 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard BI_fabs) (v1 :: vl0) = Some v) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_exprlist tge sp e m le al vl0) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(a : expr) (v : val) (le : letenv) (a1 : expr) (al : exprlist) (SEL : match al with\n| Enil => Some (absf a1)\n| _ ::: _ => None\nend = Some a) (v1 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard BI_fabs) (v1 :: vl0) = Some v) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_exprlist tge sp e m le al vl0)","proofString":"inv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absf; auto."},{"statement":"(a : expr) (v : val) (le : letenv) (a1 : expr) (SEL : Some (absf a1) = Some a) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabs) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(a : expr) (v : val) (le : letenv) (a1 : expr) (SEL : Some (absf a1) = Some a) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabs) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1)","proofString":"inv SEL.\nsimpl in SEM; inv SEM.\napply eval_absf; auto."},{"statement":"(v : val) (le : letenv) (a1 : expr) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabs) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1) : exists v' : val, eval_expr tge sp e m le (absf a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (absf a1) v' /\\ Val.lessdef v v'","hypotheses":"(v : val) (le : letenv) (a1 : expr) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabs) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1)","proofString":"simpl in SEM; inv SEM.\napply eval_absf; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (absf a1) v' /\\\n  Val.lessdef\n    match v1 with\n    | Vfloat n => Vfloat (Floats.Float.abs n)\n    | _ => Vundef\n    end v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (absf a1) v' /\\\n  Val.lessdef\n    match v1 with\n    | Vfloat n => Vfloat (Floats.Float.abs n)\n    | _ => Vundef\n    end v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_absf; auto."},{"statement":"(args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match args with\n| Enil => None\n| a1 ::: Enil => Some (absfs a1)\n| a1 ::: _ ::: _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard BI_fabsf) vl = Some v) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : match args with\n| Enil => None\n| a1 ::: Enil => Some (absfs a1)\n| a1 ::: _ ::: _ => None\nend = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_standard BI_fabsf) vl = Some v)","proofString":"inv ARGS; try discriminate.\ninv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absfs; auto."},{"statement":"(a : expr) (v : val) (le : letenv) (a1 : expr) (al : exprlist) (SEL : match al with\n| Enil => Some (absfs a1)\n| _ ::: _ => None\nend = Some a) (v1 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard BI_fabsf) (v1 :: vl0) = Some v) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_exprlist tge sp e m le al vl0) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(a : expr) (v : val) (le : letenv) (a1 : expr) (al : exprlist) (SEL : match al with\n| Enil => Some (absfs a1)\n| _ ::: _ => None\nend = Some a) (v1 : val) (vl0 : list val) (SEM : builtin_function_sem (BI_standard BI_fabsf) (v1 :: vl0) = Some v) (H : eval_expr tge sp e m le a1 v1) (H0 : eval_exprlist tge sp e m le al vl0)","proofString":"inv H0; try discriminate.\ninv SEL.\nsimpl in SEM; inv SEM.\napply eval_absfs; auto."},{"statement":"(a : expr) (v : val) (le : letenv) (a1 : expr) (SEL : Some (absfs a1) = Some a) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabsf) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(a : expr) (v : val) (le : letenv) (a1 : expr) (SEL : Some (absfs a1) = Some a) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabsf) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1)","proofString":"inv SEL.\nsimpl in SEM; inv SEM.\napply eval_absfs; auto."},{"statement":"(v : val) (le : letenv) (a1 : expr) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabsf) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1) : exists v' : val, eval_expr tge sp e m le (absfs a1) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le (absfs a1) v' /\\ Val.lessdef v v'","hypotheses":"(v : val) (le : letenv) (a1 : expr) (v1 : val) (SEM : builtin_function_sem (BI_standard BI_fabsf) (v1 :: nil) = Some v) (H : eval_expr tge sp e m le a1 v1)","proofString":"simpl in SEM; inv SEM.\napply eval_absfs; auto."},{"statement":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1) : exists v' : val,\n  eval_expr tge sp e m le (absfs a1) v' /\\\n  Val.lessdef\n    match v1 with\n    | Vsingle n => Vsingle (Floats.Float32.abs n)\n    | _ => Vundef\n    end v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e m le (absfs a1) v' /\\\n  Val.lessdef\n    match v1 with\n    | Vsingle n => Vsingle (Floats.Float32.abs n)\n    | _ => Vundef\n    end v'","hypotheses":"(le : letenv) (a1 : expr) (v1 : val) (H : eval_expr tge sp e m le a1 v1)","proofString":"apply eval_absfs; auto."},{"statement":"(bf : Builtins1.platform_builtin) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : platform_builtin bf args = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_platform bf) vl = Some v) : exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e m le a v' /\\ Val.lessdef v v'","hypotheses":"(bf : Builtins1.platform_builtin) (args : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (SEL : platform_builtin bf args = Some a) (ARGS : eval_exprlist tge sp e m le args vl) (SEM : builtin_function_sem (BI_platform bf) vl = Some v)","proofString":"eapply eval_platform_builtin; eauto."},{"statement":"(e : Cminor.expr) (id : ident) : expr_is_addrof_ident e = Some id ->\ne = Econst (Cminor.Oaddrsymbol id Ptrofs.zero).","conclusion":"expr_is_addrof_ident e = Some id ->\ne = Econst (Cminor.Oaddrsymbol id Ptrofs.zero)","hypotheses":"(e : Cminor.expr) (id : ident)","proofString":"unfold expr_is_addrof_ident.\ndestruct e; try congruence.\ndestruct c; try congruence.\npredSpec Ptrofs.eq Ptrofs.eq_spec i0 Ptrofs.zero; congruence."},{"statement":"(e : Cminor.expr) (id : ident) : match e with\n| Econst (Cminor.Oaddrsymbol id0 ofs) =>\n    if Ptrofs.eq ofs Ptrofs.zero then Some id0 else None\n| _ => None\nend = Some id -> e = Econst (Cminor.Oaddrsymbol id Ptrofs.zero).","conclusion":"match e with\n| Econst (Cminor.Oaddrsymbol id0 ofs) =>\n    if Ptrofs.eq ofs Ptrofs.zero then Some id0 else None\n| _ => None\nend = Some id -> e = Econst (Cminor.Oaddrsymbol id Ptrofs.zero)","hypotheses":"(e : Cminor.expr) (id : ident)","proofString":"destruct e; try congruence.\ndestruct c; try congruence.\npredSpec Ptrofs.eq Ptrofs.eq_spec i0 Ptrofs.zero; congruence."},{"statement":"(c : constant) (id : ident) : match c with\n| Cminor.Oaddrsymbol id0 ofs =>\n    if Ptrofs.eq ofs Ptrofs.zero then Some id0 else None\n| _ => None\nend = Some id -> Econst c = Econst (Cminor.Oaddrsymbol id Ptrofs.zero).","conclusion":"match c with\n| Cminor.Oaddrsymbol id0 ofs =>\n    if Ptrofs.eq ofs Ptrofs.zero then Some id0 else None\n| _ => None\nend = Some id -> Econst c = Econst (Cminor.Oaddrsymbol id Ptrofs.zero)","hypotheses":"(c : constant) (id : ident)","proofString":"destruct c; try congruence.\npredSpec Ptrofs.eq Ptrofs.eq_spec i0 Ptrofs.zero; congruence."},{"statement":"(i : ident) (i0 : ptrofs) (id : ident) : (if Ptrofs.eq i0 Ptrofs.zero then Some i else None) = Some id ->\nEconst (Cminor.Oaddrsymbol i i0) = Econst (Cminor.Oaddrsymbol id Ptrofs.zero).","conclusion":"(if Ptrofs.eq i0 Ptrofs.zero then Some i else None) = Some id ->\nEconst (Cminor.Oaddrsymbol i i0) = Econst (Cminor.Oaddrsymbol id Ptrofs.zero)","hypotheses":"(i : ident) (i0 : ptrofs) (id : ident)","proofString":"predSpec Ptrofs.eq Ptrofs.eq_spec i0 Ptrofs.zero; congruence."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (a : Cminor.expr) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Genv.find_funct ge v = Some fd) : match\n  match expr_is_addrof_ident a with\n  | Some id =>\n      match (prog_defmap unit) ! id with\n      | Some (Gfun (External ef)) =>\n          if ef_inline ef then Call_builtin ef else Call_imm id\n      | _ => Call_imm id\n      end\n  | None => Call_default\n  end\nwith\n| Call_default => True\n| Call_imm id =>\n    exists b : block,\n      Genv.find_symbol ge id = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match expr_is_addrof_ident a with\n  | Some id =>\n      match (prog_defmap unit) ! id with\n      | Some (Gfun (External ef)) =>\n          if ef_inline ef then Call_builtin ef else Call_imm id\n      | _ => Call_imm id\n      end\n  | None => Call_default\n  end\nwith\n| Call_default => True\n| Call_imm id =>\n    exists b : block,\n      Genv.find_symbol ge id = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (a : Cminor.expr) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Genv.find_funct ge v = Some fd)","proofString":"destruct (expr_is_addrof_ident a) as [id|] eqn:EA; auto.\nexploit expr_is_addrof_ident_correct; eauto.\nintros EQ; subst a.\ninv H0.\ninv H3.\nunfold Genv.symbol_address in *.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (a : Cminor.expr) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Genv.find_funct ge v = Some fd) (id : ident) (EA : expr_is_addrof_ident a = Some id) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (a : Cminor.expr) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Genv.find_funct ge v = Some fd) (id : ident) (EA : expr_is_addrof_ident a = Some id)","proofString":"exploit expr_is_addrof_ident_correct; eauto.\nintros EQ; subst a.\ninv H0.\ninv H3.\nunfold Genv.symbol_address in *.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (a : Cminor.expr) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Genv.find_funct ge v = Some fd) (id : ident) (EA : expr_is_addrof_ident a = Some id) : a = Econst (Cminor.Oaddrsymbol id Ptrofs.zero) ->\nmatch\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"a = Econst (Cminor.Oaddrsymbol id Ptrofs.zero) ->\nmatch\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (a : Cminor.expr) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Genv.find_funct ge v = Some fd) (id : ident) (EA : expr_is_addrof_ident a = Some id)","proofString":"intros EQ; subst a.\ninv H0.\ninv H3.\nunfold Genv.symbol_address in *.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H0 : Cminor.eval_expr ge sp e m (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) v) (H1 : Genv.find_funct ge v = Some fd) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H0 : Cminor.eval_expr ge sp e m (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) v) (H1 : Genv.find_funct ge v = Some fd)","proofString":"inv H0.\ninv H3.\nunfold Genv.symbol_address in *.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H1 : Genv.find_funct ge v = Some fd) (H3 : eval_constant ge sp (Cminor.Oaddrsymbol id Ptrofs.zero) = Some v) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\ v = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (v : val) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H1 : Genv.find_funct ge v = Some fd) (H3 : eval_constant ge sp (Cminor.Oaddrsymbol id Ptrofs.zero) = Some v)","proofString":"inv H3.\nunfold Genv.symbol_address in *.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H1 : Genv.find_funct ge (Genv.symbol_address ge id Ptrofs.zero) = Some fd) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\\n      Genv.symbol_address ge id Ptrofs.zero = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\\n      Genv.symbol_address ge id Ptrofs.zero = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H1 : Genv.find_funct ge (Genv.symbol_address ge id Ptrofs.zero) = Some fd)","proofString":"unfold Genv.symbol_address in *.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H1 : Genv.find_funct ge\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b Ptrofs.zero\n  | None => Vundef\n  end = Some fd) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\\n      match Genv.find_symbol ge id with\n      | Some b0 => Vptr b0 Ptrofs.zero\n      | None => Vundef\n      end = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b : block,\n      Genv.find_symbol ge id0 = Some b /\\\n      match Genv.find_symbol ge id with\n      | Some b0 => Vptr b0 Ptrofs.zero\n      | None => Vundef\n      end = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (H1 : Genv.find_funct ge\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b Ptrofs.zero\n  | None => Vundef\n  end = Some fd)","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd)","proofString":"rewrite Genv.find_funct_find_funct_ptr in H1.\nassert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd)","proofString":"assert (DFL: exists b1, Genv.find_symbol ge id = Some b1 /\\ Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) by (exists b; auto).\nunfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) : match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend.","conclusion":"match\n  match (prog_defmap unit) ! id with\n  | Some (Gfun (External ef)) =>\n      if ef_inline ef then Call_builtin ef else Call_imm id\n  | _ => Call_imm id\n  end\nwith\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero)","proofString":"unfold globdef; destruct (prog_defmap unit)!id as [[[f|ef] |gv] |] eqn:G; auto.\ndestruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) : match (if ef_inline ef then Call_builtin ef else Call_imm id) with\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef0 => fd = External ef0\nend.","conclusion":"match (if ef_inline ef then Call_builtin ef else Call_imm id) with\n| Call_default => True\n| Call_imm id0 =>\n    exists b0 : block,\n      Genv.find_symbol ge id0 = Some b0 /\\\n      Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero\n| Call_builtin ef0 => fd = External ef0\nend","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef)))","proofString":"destruct (ef_inline ef) eqn:INLINE; auto.\ndestruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true)","proofString":"destruct (prog_defmap_linkorder _ _ _ _ H G) as (gd & P & Q).\ninv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (gd : AST.globdef Cminor.fundef Datatypes.unit) (P : (prog_defmap prog) ! id = Some gd) (Q : linkorder (Gfun (External ef)) gd) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (gd : AST.globdef Cminor.fundef Datatypes.unit) (P : (prog_defmap prog) ! id = Some gd) (Q : linkorder (Gfun (External ef)) gd)","proofString":"inv Q.\ninv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (fd2 : Cminor.fundef) (P : (prog_defmap prog) ! id = Some (Gfun fd2)) (H2 : linkorder (External ef) fd2) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (fd2 : Cminor.fundef) (P : (prog_defmap prog) ! id = Some (Gfun fd2)) (H2 : linkorder (External ef) fd2)","proofString":"inv H2.\napply Genv.find_def_symbol in P.\ndestruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence.\nsimpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (P : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv prog) b0 = Some (Gfun (External ef))) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (P : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv prog) b0 = Some (Gfun (External ef)))","proofString":"destruct P as (b' & X & Y).\nfold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (b' : block) (X : Genv.find_symbol (Genv.globalenv prog) id = Some b') (Y : Genv.find_def (Genv.globalenv prog) b' = Some (Gfun (External ef))) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (b' : block) (X : Genv.find_symbol (Genv.globalenv prog) id = Some b') (Y : Genv.find_def (Genv.globalenv prog) b' = Some (Gfun (External ef)))","proofString":"fold ge in X, Y.\nrewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (b' : block) (X : Genv.find_symbol ge id = Some b') (Y : Genv.find_def ge b' = Some (Gfun (External ef))) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (b' : block) (X : Genv.find_symbol ge id = Some b') (Y : Genv.find_def ge b' = Some (Gfun (External ef)))","proofString":"rewrite <- Genv.find_funct_ptr_iff in Y.\ncongruence."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (b' : block) (X : Genv.find_symbol ge id = Some b') (Y : Genv.find_funct_ptr ge b' = Some (External ef)) : fd = External ef.","conclusion":"fd = External ef","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (ef : external_function) (G : (prog_defmap unit) ! id = Some (Gfun (External ef))) (INLINE : ef_inline ef = true) (b' : block) (X : Genv.find_symbol ge id = Some b') (Y : Genv.find_funct_ptr ge b' = Some (External ef))","proofString":"congruence."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (id0 : string) (sg : signature) (INLINE : ef_inline (EF_external id0 sg) = true) (G : (prog_defmap unit) ! id = Some (Gfun (External (EF_external id0 sg)))) (f : Cminor.function) (P : (prog_defmap prog) ! id = Some (Gfun (Internal f))) : fd = External (EF_external id0 sg).","conclusion":"fd = External (EF_external id0 sg)","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (id0 : string) (sg : signature) (INLINE : ef_inline (EF_external id0 sg) = true) (G : (prog_defmap unit) ! id = Some (Gfun (External (EF_external id0 sg)))) (f : Cminor.function) (P : (prog_defmap prog) ! id = Some (Gfun (Internal f)))","proofString":"simpl in INLINE.\ndiscriminate."},{"statement":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (id0 : string) (sg : signature) (INLINE : false = true) (G : (prog_defmap unit) ! id = Some (Gfun (External (EF_external id0 sg)))) (f : Cminor.function) (P : (prog_defmap prog) ! id = Some (Gfun (Internal f))) : fd = External (EF_external id0 sg).","conclusion":"fd = External (EF_external id0 sg)","hypotheses":"(unit : Cminor.program) (sp : val) (e : env) (m : mem) (fd : Cminor.fundef) (H : linkorder unit prog) (id : ident) (EA : expr_is_addrof_ident (Econst (Cminor.Oaddrsymbol id Ptrofs.zero)) = Some id) (b : block) (FS : Genv.find_symbol ge id = Some b) (H1 : Genv.find_funct_ptr ge b = Some fd) (DFL : exists b1 : block,\n  Genv.find_symbol ge id = Some b1 /\\\n  Vptr b Ptrofs.zero = Vptr b1 Ptrofs.zero) (id0 : string) (sg : signature) (INLINE : false = true) (G : (prog_defmap unit) ! id = Some (Gfun (External (EF_external id0 sg)))) (f : Cminor.function) (P : (prog_defmap prog) ! id = Some (Gfun (Internal f)))","proofString":"discriminate."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) : forall (t : comptree) (arg : nat) (le : list val),\nwf_comptree modulus t ->\nnth_error le arg = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x.","conclusion":"forall (t : comptree) (arg : nat) (le : list val),\nwf_comptree modulus t ->\nnth_error le arg = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg)","proofString":"induction t; simpl; intros until le; intros WF ARG MATCH.\ninv MATCH.\nconstructor.\ninv WF.\nassert (eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key) (Val.of_bool (zeq i key))).\neapply eval_make_cmp_eq; eauto.\nconstructor; auto.\neapply eval_XEcondition with (va := zeq i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zeq i key); constructor; auto.\ndestruct (zeq i key); simpl.\ninv MATCH.\nconstructor.\neapply IHt; eauto.\ninv WF.\nassert (eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key) (Val.of_bool (zlt i key))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neapply eval_XEcondition with (va := zlt i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i key); constructor; auto.\ndestruct (zlt i key); simpl.\neapply IHt1; eauto.\neapply IHt2; eauto.\ninv WF.\nexploit (eval_make_sub sp e m le).\neapply eval_Eletvar.\neauto.\neauto.\ninstantiate (1 := ofs).\nauto.\nintros (v' & A & B).\nset (i' := (i - ofs) mod modulus) in *.\nassert (eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar O) sz) (Val.of_bool (zlt i' sz))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neconstructor.\neauto.\neapply eval_XEcondition with (va := zlt i' sz).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto.\ndestruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (act arg : nat) (le : list val) (WF : wf_comptree modulus (CTaction act)) (ARG : nth_error le arg = Some varg) (MATCH : Some act = Some x) : eval_exitexpr tge sp e m le (XEexit act) x.","conclusion":"eval_exitexpr tge sp e m le (XEexit act) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (act arg : nat) (le : list val) (WF : wf_comptree modulus (CTaction act)) (ARG : nth_error le arg = Some varg) (MATCH : Some act = Some x)","proofString":"inv MATCH.\nconstructor."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTaction x)) (ARG : nth_error le arg = Some varg) : eval_exitexpr tge sp e m le (XEexit x) x.","conclusion":"eval_exitexpr tge sp e m le (XEexit x) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTaction x)) (ARG : nth_error le arg = Some varg)","proofString":"constructor."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTifeq key act t)) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) : eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_eq (Eletvar arg) key))\n     (XEexit act)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t)) x.","conclusion":"eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_eq (Eletvar arg) key))\n     (XEexit act)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t)) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTifeq key act t)) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x)","proofString":"inv WF.\nassert (eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key) (Val.of_bool (zeq i key))).\neapply eval_make_cmp_eq; eauto.\nconstructor; auto.\neapply eval_XEcondition with (va := zeq i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zeq i key); constructor; auto.\ndestruct (zeq i key); simpl.\ninv MATCH.\nconstructor.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) : eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_eq (Eletvar arg) key))\n     (XEexit act)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t)) x.","conclusion":"eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_eq (Eletvar arg) key))\n     (XEexit act)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t)) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t)","proofString":"assert (eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key) (Val.of_bool (zeq i key))).\neapply eval_make_cmp_eq; eauto.\nconstructor; auto.\neapply eval_XEcondition with (va := zeq i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zeq i key); constructor; auto.\ndestruct (zeq i key); simpl.\ninv MATCH.\nconstructor.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key)).","conclusion":"eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key))","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t)","proofString":"eapply eval_make_cmp_eq; eauto.\nconstructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) : eval_expr tge sp e m le (Eletvar arg) varg.","conclusion":"eval_expr tge sp e m le (Eletvar arg) varg","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t)","proofString":"constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key))) : eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_eq (Eletvar arg) key))\n     (XEexit act)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t)) x.","conclusion":"eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_eq (Eletvar arg) key))\n     (XEexit act)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t)) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key)))","proofString":"eapply eval_XEcondition with (va := zeq i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zeq i key); constructor; auto.\ndestruct (zeq i key); simpl.\ninv MATCH.\nconstructor.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key))) : eval_condexpr tge sp e m le\n  (condexpr_of_expr (make_cmp_eq (Eletvar arg) key)) \n  (zeq i key).","conclusion":"eval_condexpr tge sp e m le\n  (condexpr_of_expr (make_cmp_eq (Eletvar arg) key)) \n  (zeq i key)","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key)))","proofString":"eapply eval_condexpr_of_expr; eauto.\ndestruct (zeq i key); constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key))) : Val.bool_of_val (Val.of_bool (zeq i key)) (zeq i key).","conclusion":"Val.bool_of_val (Val.of_bool (zeq i key)) (zeq i key)","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key)))","proofString":"destruct (zeq i key); constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key))) : eval_exitexpr tge sp e m le\n  (if proj_sumbool (zeq i key)\n   then XEexit act\n   else sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x.","conclusion":"eval_exitexpr tge sp e m le\n  (if proj_sumbool (zeq i key)\n   then XEexit act\n   else sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (act : nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zeq i key then Some act else comptree_match modulus i t) = Some x) (H1 : 0 <= key < modulus) (H3 : wf_comptree modulus t) (H : eval_expr tge sp e m le (make_cmp_eq (Eletvar arg) key)\n  (Val.of_bool (zeq i key)))","proofString":"destruct (zeq i key); simpl.\ninv MATCH.\nconstructor.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTiflt key t1 t2)) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) : eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key))\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2)) x.","conclusion":"eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key))\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2)) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTiflt key t1 t2)) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x)","proofString":"inv WF.\nassert (eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key) (Val.of_bool (zlt i key))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neapply eval_XEcondition with (va := zlt i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i key); constructor; auto.\ndestruct (zlt i key); simpl.\neapply IHt1; eauto.\neapply IHt2; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) : eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key))\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2)) x.","conclusion":"eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key))\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2)) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2)","proofString":"assert (eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key) (Val.of_bool (zlt i key))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neapply eval_XEcondition with (va := zlt i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i key); constructor; auto.\ndestruct (zlt i key); simpl.\neapply IHt1; eauto.\neapply IHt2; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key)).","conclusion":"eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key))","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2)","proofString":"eapply eval_make_cmp_ltu; eauto.\nconstructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) : eval_expr tge sp e m le (Eletvar arg) varg.","conclusion":"eval_expr tge sp e m le (Eletvar arg) varg","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2)","proofString":"constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key))) : eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key))\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2)) x.","conclusion":"eval_exitexpr tge sp e m le\n  (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key))\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1)\n     (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2)) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key)))","proofString":"eapply eval_XEcondition with (va := zlt i key).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i key); constructor; auto.\ndestruct (zlt i key); simpl.\neapply IHt1; eauto.\neapply IHt2; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key))) : eval_condexpr tge sp e m le\n  (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key)) \n  (zlt i key).","conclusion":"eval_condexpr tge sp e m le\n  (condexpr_of_expr (make_cmp_ltu (Eletvar arg) key)) \n  (zlt i key)","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key)))","proofString":"eapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i key); constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key))) : Val.bool_of_val (Val.of_bool (zlt i key)) (zlt i key).","conclusion":"Val.bool_of_val (Val.of_bool (zlt i key)) (zlt i key)","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key)))","proofString":"destruct (zlt i key); constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key))) : eval_exitexpr tge sp e m le\n  (if proj_sumbool (zlt i key)\n   then sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1\n   else sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2) x.","conclusion":"eval_exitexpr tge sp e m le\n  (if proj_sumbool (zlt i key)\n   then sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t1\n   else sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t2) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (key : Z) (t1 t2 : comptree) (IHt1 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t1 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t1 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t1) x) (IHt2 : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t2 ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t2 = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t2) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt i key\n then comptree_match modulus i t1\n else comptree_match modulus i t2) = Some x) (H2 : 0 <= key < modulus) (H3 : wf_comptree modulus t1) (H4 : wf_comptree modulus t2) (H : eval_expr tge sp e m le (make_cmp_ltu (Eletvar arg) key)\n  (Val.of_bool (zlt i key)))","proofString":"destruct (zlt i key); simpl.\neapply IHt1; eauto.\neapply IHt2; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTjumptable ofs sz acts t)) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) : eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x.","conclusion":"eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (WF : wf_comptree modulus (CTjumptable ofs sz acts t)) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x)","proofString":"inv WF.\nexploit (eval_make_sub sp e m le).\neapply eval_Eletvar.\neauto.\neauto.\ninstantiate (1 := ofs).\nauto.\nintros (v' & A & B).\nset (i' := (i - ofs) mod modulus) in *.\nassert (eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar O) sz) (Val.of_bool (zlt i' sz))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neconstructor.\neauto.\neapply eval_XEcondition with (va := zlt i' sz).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto.\ndestruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) : eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x.","conclusion":"eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t)","proofString":"exploit (eval_make_sub sp e m le).\neapply eval_Eletvar.\neauto.\neauto.\ninstantiate (1 := ofs).\nauto.\nintros (v' & A & B).\nset (i' := (i - ofs) mod modulus) in *.\nassert (eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar O) sz) (Val.of_bool (zlt i' sz))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neconstructor.\neauto.\neapply eval_XEcondition with (va := zlt i' sz).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto.\ndestruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) : 0 <= ofs < modulus.","conclusion":"0 <= ofs < modulus","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t)","proofString":"auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R ((i - ofs) mod modulus) v') : eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x.","conclusion":"eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (MATCH : (if zlt ((i - ofs) mod modulus) sz\n then list_nth_z acts (((i - ofs) mod modulus) mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R ((i - ofs) mod modulus) v')","proofString":"set (i' := (i - ofs) mod modulus) in *.\nassert (eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar O) sz) (Val.of_bool (zlt i' sz))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neconstructor.\neauto.\neapply eval_XEcondition with (va := zlt i' sz).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto.\ndestruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') : eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x.","conclusion":"eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v')","proofString":"assert (eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar O) sz) (Val.of_bool (zlt i' sz))).\neapply eval_make_cmp_ltu; eauto.\nconstructor; auto.\neconstructor.\neauto.\neapply eval_XEcondition with (va := zlt i' sz).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto.\ndestruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz)).","conclusion":"eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz))","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v')","proofString":"eapply eval_make_cmp_ltu; eauto.\nconstructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') : eval_expr tge sp e m (v' :: le) (Eletvar 0) v'.","conclusion":"eval_expr tge sp e m (v' :: le) (Eletvar 0) v'","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v')","proofString":"constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz))) : eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x.","conclusion":"eval_exitexpr tge sp e m le\n  (XElet (make_sub (Eletvar arg) ofs)\n     (XEcondition (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz))\n        (XEjumptable (make_to_int (Eletvar 0)) acts)\n        (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t)))\n  x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz)))","proofString":"econstructor.\neauto.\neapply eval_XEcondition with (va := zlt i' sz).\neapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto.\ndestruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz))) : eval_condexpr tge sp e m (v' :: le)\n  (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz)) \n  (zlt i' sz).","conclusion":"eval_condexpr tge sp e m (v' :: le)\n  (condexpr_of_expr (make_cmp_ltu (Eletvar 0) sz)) \n  (zlt i' sz)","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz)))","proofString":"eapply eval_condexpr_of_expr; eauto.\ndestruct (zlt i' sz); constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz))) : Val.bool_of_val (Val.of_bool (zlt i' sz)) (zlt i' sz).","conclusion":"Val.bool_of_val (Val.of_bool (zlt i' sz)) (zlt i' sz)","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz)))","proofString":"destruct (zlt i' sz); constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz))) : eval_exitexpr tge sp e m (v' :: le)\n  (if proj_sumbool (zlt i' sz)\n   then XEjumptable (make_to_int (Eletvar 0)) acts\n   else sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t) x.","conclusion":"eval_exitexpr tge sp e m (v' :: le)\n  (if proj_sumbool (zlt i' sz)\n   then XEjumptable (make_to_int (Eletvar 0)) acts\n   else sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int (S arg) t) x","hypotheses":"(sp : val) (e : env) (m : mem) (varg : val) (i : Z) (x : nat) (Ri : R i varg) (ofs sz : Z) (acts : list nat) (t : comptree) (IHt : forall (arg0 : nat) (le0 : list val),\nwf_comptree modulus t ->\nnth_error le0 arg0 = Some varg ->\ncomptree_match modulus i t = Some x ->\neval_exitexpr tge sp e m le0\n  (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg0 t) x) (arg : nat) (le : list val) (ARG : nth_error le arg = Some varg) (i' : Z) (MATCH : (if zlt i' sz\n then list_nth_z acts (i' mod Int.modulus)\n else comptree_match modulus i t) = Some x) (H2 : 0 <= ofs < modulus) (H4 : 0 <= sz < modulus) (H5 : wf_comptree modulus t) (v' : val) (A : eval_expr tge sp e m le (make_sub (Eletvar arg) ofs) v') (B : R i' v') (H : eval_expr tge sp e m (v' :: le) (make_cmp_ltu (Eletvar 0) sz)\n  (Val.of_bool (zlt i' sz)))","proofString":"destruct (zlt i' sz); simpl.\nexploit (eval_make_to_int sp e m (v' :: le) (Eletvar O)).\nconstructor.\nsimpl; eauto.\neauto.\nintros (v'' & C & D).\ninv D.\neconstructor; eauto.\ncongruence.\neapply IHt; eauto."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus) : eval_exitexpr tge sp e m le\n  (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int 0 t))\n  (switch_target i dfl cases).","conclusion":"eval_exitexpr tge sp e m le\n  (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int 0 t))\n  (switch_target i dfl cases)","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus)","proofString":"exploit validate_switch_correct; eauto.\nlia.\nintros [A B].\neconstructor.\neauto.\neapply sel_switch_correct_rec; eauto."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus) : modulus > 0.","conclusion":"modulus > 0","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus)","proofString":"lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus) : wf_comptree modulus t /\\ table_tree_agree modulus dfl cases t ->\neval_exitexpr tge sp e m le\n  (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int 0 t))\n  (switch_target i dfl cases).","conclusion":"wf_comptree modulus t /\\ table_tree_agree modulus dfl cases t ->\neval_exitexpr tge sp e m le\n  (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int 0 t))\n  (switch_target i dfl cases)","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus)","proofString":"intros [A B].\neconstructor.\neauto.\neapply sel_switch_correct_rec; eauto."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus) (A : wf_comptree modulus t) (B : table_tree_agree modulus dfl cases t) : eval_exitexpr tge sp e m le\n  (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int 0 t))\n  (switch_target i dfl cases).","conclusion":"eval_exitexpr tge sp e m le\n  (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int 0 t))\n  (switch_target i dfl cases)","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (varg : val) (i : Z) (t : comptree) (le : letenv) (H : validate_switch modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg varg) (H1 : R i varg) (H2 : 0 <= i < modulus) (A : wf_comptree modulus t) (B : table_tree_agree modulus dfl cases t)","proofString":"econstructor.\neauto.\neapply sel_switch_correct_rec; eauto."},{"statement":"helper_functions_declared prog hf.","conclusion":"helper_functions_declared prog hf","hypotheses":"","proofString":"eapply helper_functions_declared_linkorder; eauto."},{"statement":"forall (n : int) (sp : val) (e : env) (m : mem) (le : letenv),\neval_expr tge sp e m le (Eop (Ointconst n) Enil) (Vint n).","conclusion":"forall (n : int) (sp : val) (e : env) (m : mem) (le : letenv),\neval_expr tge sp e m le (Eop (Ointconst n) Enil) (Vint n)","hypotheses":"","proofString":"intros.\neconstructor.\nconstructor.\nauto."},{"statement":"(n : int) (sp : val) (e : env) (m : mem) (le : letenv) : eval_expr tge sp e m le (Eop (Ointconst n) Enil) (Vint n).","conclusion":"eval_expr tge sp e m le (Eop (Ointconst n) Enil) (Vint n)","hypotheses":"(n : int) (sp : val) (e : env) (m : mem) (le : letenv)","proofString":"econstructor.\nconstructor.\nauto."},{"statement":"(INTCONST : forall (n : int) (sp : val) (e : env) (m : mem) (le : letenv),\neval_expr tge sp e m le (Eop (Ointconst n) Enil) (Vint n)) : forall (dfl : nat) (cases : table) (arg : expr) (sp : val) \n  (e : env) (m : mem) (i : int) (t : comptree) (le : letenv),\nvalidate_switch Int.modulus dfl cases t = true ->\neval_expr tge sp e m le arg (Vint i) ->\neval_exitexpr tge sp e m le (XElet arg (sel_switch_int 0 t))\n  (switch_target (Int.unsigned i) dfl cases).","conclusion":"forall (dfl : nat) (cases : table) (arg : expr) (sp : val) \n  (e : env) (m : mem) (i : int) (t : comptree) (le : letenv),\nvalidate_switch Int.modulus dfl cases t = true ->\neval_expr tge sp e m le arg (Vint i) ->\neval_exitexpr tge sp e m le (XElet arg (sel_switch_int 0 t))\n  (switch_target (Int.unsigned i) dfl cases)","hypotheses":"(INTCONST : forall (n : int) (sp : val) (e : env) (m : mem) (le : letenv),\neval_expr tge sp e m le (Eop (Ointconst n) Enil) (Vint n))","proofString":"intros.\neapply sel_switch_correct with (R := Rint); eauto.\nintros until n; intros EVAL R RANGE.\nexploit eval_comp.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Ceq).\nintros (vb & A & B).\ninv R.\nunfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence.\nintros until n; intros EVAL R RANGE.\nexploit eval_compu.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Clt).\nintros (vb & A & B).\ninv R.\nunfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia.\nintros until n; intros EVAL R RANGE.\nexploit eval_sub.\neexact EVAL.\napply (INTCONST (Int.repr n)).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia.\nintros until i0; intros EVAL R.\nexists v; split; auto.\ninv R.\nrewrite Z.mod_small by (apply Int.unsigned_range).\nconstructor.\nconstructor.\napply Int.unsigned_range."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : eval_exitexpr tge sp e m le (XElet arg (sel_switch_int 0 t))\n  (switch_target (Int.unsigned i) dfl cases).","conclusion":"eval_exitexpr tge sp e m le (XElet arg (sel_switch_int 0 t))\n  (switch_target (Int.unsigned i) dfl cases)","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"eapply sel_switch_correct with (R := Rint); eauto.\nintros until n; intros EVAL R RANGE.\nexploit eval_comp.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Ceq).\nintros (vb & A & B).\ninv R.\nunfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence.\nintros until n; intros EVAL R RANGE.\nexploit eval_compu.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Clt).\nintros (vb & A & B).\ninv R.\nunfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia.\nintros until n; intros EVAL R RANGE.\nexploit eval_sub.\neexact EVAL.\napply (INTCONST (Int.repr n)).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia.\nintros until i0; intros EVAL R.\nexists v; split; auto.\ninv R.\nrewrite Z.mod_small by (apply Int.unsigned_range).\nconstructor.\nconstructor.\napply Int.unsigned_range."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\n0 <= n < Int.modulus ->\neval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n)).","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\n0 <= n < Int.modulus ->\neval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n))","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"intros until n; intros EVAL R RANGE.\nexploit eval_comp.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Ceq).\nintros (vb & A & B).\ninv R.\nunfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus)","proofString":"exploit eval_comp.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Ceq).\nintros (vb & A & B).\ninv R.\nunfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) : (exists v0 : val,\n   eval_expr tge sp0 e0 m0 le0\n     (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil)) v0 /\\\n   Val.lessdef (Val.cmp Ceq v (Vint (Int.repr n))) v0) ->\neval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n)).","conclusion":"(exists v0 : val,\n   eval_expr tge sp0 e0 m0 le0\n     (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil)) v0 /\\\n   Val.lessdef (Val.cmp Ceq v (Vint (Int.repr n))) v0) ->\neval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus)","proofString":"intros (vb & A & B).\ninv R.\nunfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.cmp Ceq v (Vint (Int.repr n))) vb) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq i0 n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.cmp Ceq v (Vint (Int.repr n))) vb)","proofString":"inv R.\nunfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.cmp Ceq (Vint n0) (Vint (Int.repr n))) vb) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.cmp Ceq (Vint n0) (Vint (Int.repr n))) vb)","proofString":"unfold Val.cmp in B.\nsimpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.of_optbool (Val.cmp_bool Ceq (Vint n0) (Vint (Int.repr n))))\n  vb) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.of_optbool (Val.cmp_bool Ceq (Vint n0) (Vint (Int.repr n))))\n  vb)","proofString":"simpl in B.\nrevert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (if Int.eq n0 (Int.repr n) then Vtrue else Vfalse) vb) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (if Int.eq n0 (Int.repr n) then Vtrue else Vfalse) vb)","proofString":"revert B.\npredSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) : Val.lessdef (if Int.eq n0 (Int.repr n) then Vtrue else Vfalse) vb ->\neval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n)).","conclusion":"Val.lessdef (if Int.eq n0 (Int.repr n) then Vtrue else Vfalse) vb ->\neval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  vb)","proofString":"predSpec Int.eq Int.eq_spec n0 (Int.repr n); intros B; inv B.\nrewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia.\nunfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint (Int.repr n))) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vtrue) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned (Int.repr n)) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned (Int.repr n)) n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint (Int.repr n))) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vtrue)","proofString":"rewrite Int.unsigned_repr.\nunfold proj_sumbool; rewrite zeq_true; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint (Int.repr n))) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vtrue) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq n n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq n n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint (Int.repr n))) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vtrue)","proofString":"unfold proj_sumbool; rewrite zeq_true; auto."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint (Int.repr n))) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vtrue) : 0 <= n <= Int.max_unsigned.","conclusion":"0 <= n <= Int.max_unsigned","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint (Int.repr n))) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vtrue)","proofString":"unfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n) : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zeq (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n)","proofString":"unfold proj_sumbool; rewrite zeq_false; auto.\nred; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n) : Int.unsigned n0 <> n.","conclusion":"Int.unsigned n0 <> n","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n)","proofString":"red; intros; elim H1.\nrewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n) (H2 : Int.unsigned n0 = n) : n0 = Int.repr n.","conclusion":"n0 = Int.repr n","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n) (H2 : Int.unsigned n0 = n)","proofString":"rewrite <- (Int.repr_unsigned n0).\ncongruence."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n) (H2 : Int.unsigned n0 = n) : Int.repr (Int.unsigned n0) = Int.repr n.","conclusion":"Int.repr (Int.unsigned n0) = Int.repr n","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (comp Ceq a (Eop (Ointconst (Int.repr n)) Enil))\n  Vfalse) (H1 : n0 <> Int.repr n) (H2 : Int.unsigned n0 = n)","proofString":"congruence."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\n0 <= n < Int.modulus ->\neval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n)).","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\n0 <= n < Int.modulus ->\neval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n))","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"intros until n; intros EVAL R RANGE.\nexploit eval_compu.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Clt).\nintros (vb & A & B).\ninv R.\nunfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus)","proofString":"exploit eval_compu.\neexact EVAL.\napply (INTCONST (Int.repr n)).\ninstantiate (1 := Clt).\nintros (vb & A & B).\ninv R.\nunfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) : (exists v0 : val,\n   eval_expr tge sp0 e0 m0 le0\n     (compu Clt a (Eop (Ointconst (Int.repr n)) Enil)) v0 /\\\n   Val.lessdef (Val.cmpu (Mem.valid_pointer m0) Clt v (Vint (Int.repr n))) v0) ->\neval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n)).","conclusion":"(exists v0 : val,\n   eval_expr tge sp0 e0 m0 le0\n     (compu Clt a (Eop (Ointconst (Int.repr n)) Enil)) v0 /\\\n   Val.lessdef (Val.cmpu (Mem.valid_pointer m0) Clt v (Vint (Int.repr n))) v0) ->\neval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus)","proofString":"intros (vb & A & B).\ninv R.\nunfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.cmpu (Mem.valid_pointer m0) Clt v (Vint (Int.repr n))) vb) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt i0 n))","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (Val.cmpu (Mem.valid_pointer m0) Clt v (Vint (Int.repr n))) vb)","proofString":"inv R.\nunfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (Val.cmpu (Mem.valid_pointer m0) Clt (Vint n0) (Vint (Int.repr n))) vb) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (Val.cmpu (Mem.valid_pointer m0) Clt (Vint n0) (Vint (Int.repr n))) vb)","proofString":"unfold Val.cmpu in B.\nsimpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m0) Clt (Vint n0) (Vint (Int.repr n))))\n  vb) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m0) Clt (Vint n0) (Vint (Int.repr n))))\n  vb)","proofString":"simpl in B.\nunfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (if Int.ltu n0 (Int.repr n) then Vtrue else Vfalse) vb) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef (if Int.ltu n0 (Int.repr n) then Vtrue else Vfalse) vb)","proofString":"unfold Int.ltu in B.\nrewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (if\n    if zlt (Int.unsigned n0) (Int.unsigned (Int.repr n)) then true else false\n   then Vtrue\n   else Vfalse) vb) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (if\n    if zlt (Int.unsigned n0) (Int.unsigned (Int.repr n)) then true else false\n   then Vtrue\n   else Vfalse) vb)","proofString":"rewrite Int.unsigned_repr in B.\ndestruct (zlt (Int.unsigned n0) n); inv B; auto.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (if if zlt (Int.unsigned n0) n then true else false then Vtrue else Vfalse)\n  vb) : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  (Val.of_bool (zlt (Int.unsigned n0) n))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (if if zlt (Int.unsigned n0) n then true else false then Vtrue else Vfalse)\n  vb)","proofString":"destruct (zlt (Int.unsigned n0) n); inv B; auto."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (if\n    if zlt (Int.unsigned n0) (Int.unsigned (Int.repr n)) then true else false\n   then Vtrue\n   else Vfalse) vb) : 0 <= n <= Int.max_unsigned.","conclusion":"0 <= n <= Int.max_unsigned","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (compu Clt a (Eop (Ointconst (Int.repr n)) Enil))\n  vb) (B : Val.lessdef\n  (if\n    if zlt (Int.unsigned n0) (Int.unsigned (Int.repr n)) then true else false\n   then Vtrue\n   else Vfalse) vb)","proofString":"unfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\n0 <= n < Int.modulus ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((i0 - n) mod Int.modulus) v'.","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\n0 <= n < Int.modulus ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((i0 - n) mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"intros until n; intros EVAL R RANGE.\nexploit eval_sub.\neexact EVAL.\napply (INTCONST (Int.repr n)).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((i0 - n) mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((i0 - n) mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus)","proofString":"exploit eval_sub.\neexact EVAL.\napply (INTCONST (Int.repr n)).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) vb) (B : Val.lessdef (Val.sub v (Vint (Int.repr n))) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((i0 - n) mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((i0 - n) mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) vb) (B : Val.lessdef (Val.sub v (Vint (Int.repr n))) vb)","proofString":"inv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) vb) (B : Val.lessdef (Val.sub (Vint n0) (Vint (Int.repr n))) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((Int.unsigned n0 - n) mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((Int.unsigned n0 - n) mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) vb) (B : Val.lessdef (Val.sub (Vint n0) (Vint (Int.repr n))) vb)","proofString":"simpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) vb) (B : Val.lessdef (Vint (Int.sub n0 (Int.repr n))) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((Int.unsigned n0 - n) mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((Int.unsigned n0 - n) mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) vb) (B : Val.lessdef (Vint (Int.sub n0 (Int.repr n))) vb)","proofString":"inv B.\neconstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((Int.unsigned n0 - n) mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil)) v' /\\\n  Rint ((Int.unsigned n0 - n) mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"econstructor; split; eauto.\nreplace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : Rint ((Int.unsigned n0 - n) mod Int.modulus) (Vint (Int.sub n0 (Int.repr n))).","conclusion":"Rint ((Int.unsigned n0 - n) mod Int.modulus) (Vint (Int.sub n0 (Int.repr n)))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"replace ((Int.unsigned n0 - n) mod Int.modulus)     with (Int.unsigned (Int.sub n0 (Int.repr n))).\nconstructor.\nunfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : Rint (Int.unsigned (Int.sub n0 (Int.repr n)))\n  (Vint (Int.sub n0 (Int.repr n))).","conclusion":"Rint (Int.unsigned (Int.sub n0 (Int.repr n)))\n  (Vint (Int.sub n0 (Int.repr n)))","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"constructor."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : Int.unsigned (Int.sub n0 (Int.repr n)) =\n(Int.unsigned n0 - n) mod Int.modulus.","conclusion":"Int.unsigned (Int.sub n0 (Int.repr n)) =\n(Int.unsigned n0 - n) mod Int.modulus","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"unfold Int.sub.\nrewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : Int.unsigned (Int.repr (Int.unsigned n0 - Int.unsigned (Int.repr n))) =\n(Int.unsigned n0 - n) mod Int.modulus.","conclusion":"Int.unsigned (Int.repr (Int.unsigned n0 - Int.unsigned (Int.repr n))) =\n(Int.unsigned n0 - n) mod Int.modulus","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"rewrite Int.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : (Int.unsigned n0 - Int.unsigned (Int.repr n)) mod Int.modulus =\n(Int.unsigned n0 - n) mod Int.modulus.","conclusion":"(Int.unsigned n0 - Int.unsigned (Int.repr n)) mod Int.modulus =\n(Int.unsigned n0 - n) mod Int.modulus","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"f_equal.\nf_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : Int.unsigned n0 - Int.unsigned (Int.repr n) = Int.unsigned n0 - n.","conclusion":"Int.unsigned n0 - Int.unsigned (Int.repr n) = Int.unsigned n0 - n","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"f_equal.\napply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : Int.unsigned (Int.repr n) = n.","conclusion":"Int.unsigned (Int.repr n) = n","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"apply Int.unsigned_repr.\nunfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n)))) : 0 <= n <= Int.max_unsigned.","conclusion":"0 <= n <= Int.max_unsigned","hypotheses":"(INTCONST : forall (n1 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n1) Enil) (Vint n1)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n0)) (RANGE : 0 <= n < Int.modulus) (A : eval_expr tge sp0 e0 m0 le0 (sub a (Eop (Ointconst (Int.repr n)) Enil))\n  (Vint (Int.sub n0 (Int.repr n))))","proofString":"unfold Int.max_unsigned; lia."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 a v' /\\ Rint (i0 mod Int.modulus) v'.","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRint i0 v ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 a v' /\\ Rint (i0 mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"intros until i0; intros EVAL R.\nexists v; split; auto.\ninv R.\nrewrite Z.mod_small by (apply Int.unsigned_range).\nconstructor."},{"statement":"(INTCONST : forall (n : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 a v' /\\ Rint (i0 mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 a v' /\\ Rint (i0 mod Int.modulus) v'","hypotheses":"(INTCONST : forall (n : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v)","proofString":"exists v; split; auto.\ninv R.\nrewrite Z.mod_small by (apply Int.unsigned_range).\nconstructor."},{"statement":"(INTCONST : forall (n : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v) : Rint (i0 mod Int.modulus) v.","conclusion":"Rint (i0 mod Int.modulus) v","hypotheses":"(INTCONST : forall (n : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rint i0 v)","proofString":"inv R.\nrewrite Z.mod_small by (apply Int.unsigned_range).\nconstructor."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n)) : Rint (Int.unsigned n mod Int.modulus) (Vint n).","conclusion":"Rint (Int.unsigned n mod Int.modulus) (Vint n)","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n))","proofString":"rewrite Z.mod_small by (apply Int.unsigned_range).\nconstructor."},{"statement":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n)) : Rint (Int.unsigned n) (Vint n).","conclusion":"Rint (Int.unsigned n) (Vint n)","hypotheses":"(INTCONST : forall (n0 : int) (sp1 : val) (e1 : env) (m1 : mem) (le1 : letenv),\neval_expr tge sp1 e1 m1 le1 (Eop (Ointconst n0) Enil) (Vint n0)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vint n))","proofString":"constructor."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : Rint (Int.unsigned i) (Vint i).","conclusion":"Rint (Int.unsigned i) (Vint i)","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"constructor."},{"statement":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i)) : 0 <= Int.unsigned i < Int.modulus.","conclusion":"0 <= Int.unsigned i < Int.modulus","hypotheses":"(INTCONST : forall (n : int) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv),\neval_expr tge sp0 e0 m0 le0 (Eop (Ointconst n) Enil) (Vint n)) (dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : letenv) (H : validate_switch Int.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vint i))","proofString":"apply Int.unsigned_range."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : eval_exitexpr tge sp e m le (XElet arg (sel_switch_long 0 t))\n  (switch_target (Int64.unsigned i) dfl cases).","conclusion":"eval_exitexpr tge sp e m le (XElet arg (sel_switch_long 0 t))\n  (switch_target (Int64.unsigned i) dfl cases)","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"eapply sel_switch_correct with (R := Rlong); eauto.\nintros until n; intros EVAL R RANGE.\neapply eval_cmpl.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\ninv R.\nunfold Val.cmpl.\nsimpl.\nf_equal; f_equal.\nunfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia.\nintros until n; intros EVAL R RANGE.\neapply eval_cmplu; auto.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\ninv R.\nunfold Val.cmplu.\nsimpl.\nf_equal; f_equal.\nunfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia.\nintros until n; intros EVAL R RANGE.\nexploit eval_subl; auto; try apply HF'.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia.\nintros until i0; intros EVAL R.\nexploit eval_lowlong.\neexact EVAL.\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq.\nconstructor.\napply Int64.unsigned_range."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\n0 <= n < Int64.modulus ->\neval_expr tge sp0 e0 m0 le0 (cmpl Ceq a (longconst (Int64.repr n)))\n  (Val.of_bool (zeq i0 n)).","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\n0 <= n < Int64.modulus ->\neval_expr tge sp0 e0 m0 le0 (cmpl Ceq a (longconst (Int64.repr n)))\n  (Val.of_bool (zeq i0 n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"intros until n; intros EVAL R RANGE.\neapply eval_cmpl.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\ninv R.\nunfold Val.cmpl.\nsimpl.\nf_equal; f_equal.\nunfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus) : eval_expr tge sp0 e0 m0 le0 (cmpl Ceq a (longconst (Int64.repr n)))\n  (Val.of_bool (zeq i0 n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (cmpl Ceq a (longconst (Int64.repr n)))\n  (Val.of_bool (zeq i0 n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus)","proofString":"eapply eval_cmpl.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\ninv R.\nunfold Val.cmpl.\nsimpl.\nf_equal; f_equal.\nunfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : Val.cmpl Ceq (Vlong n0) (Vlong (Int64.repr n)) =\nSome (Val.of_bool (zeq (Int64.unsigned n0) n)).","conclusion":"Val.cmpl Ceq (Vlong n0) (Vlong (Int64.repr n)) =\nSome (Val.of_bool (zeq (Int64.unsigned n0) n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"unfold Val.cmpl.\nsimpl.\nf_equal; f_equal.\nunfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : option_map Val.of_bool (Val.cmpl_bool Ceq (Vlong n0) (Vlong (Int64.repr n))) =\nSome (Val.of_bool (zeq (Int64.unsigned n0) n)).","conclusion":"option_map Val.of_bool (Val.cmpl_bool Ceq (Vlong n0) (Vlong (Int64.repr n))) =\nSome (Val.of_bool (zeq (Int64.unsigned n0) n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"simpl.\nf_equal; f_equal.\nunfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : Some (Val.of_bool (Int64.eq n0 (Int64.repr n))) =\nSome (Val.of_bool (zeq (Int64.unsigned n0) n)).","conclusion":"Some (Val.of_bool (Int64.eq n0 (Int64.repr n))) =\nSome (Val.of_bool (zeq (Int64.unsigned n0) n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"f_equal; f_equal.\nunfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : Int64.eq n0 (Int64.repr n) = zeq (Int64.unsigned n0) n.","conclusion":"Int64.eq n0 (Int64.repr n) = zeq (Int64.unsigned n0) n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"unfold Int64.eq.\nrewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : (if zeq (Int64.unsigned n0) (Int64.unsigned (Int64.repr n))\n then true\n else false) = zeq (Int64.unsigned n0) n.","conclusion":"(if zeq (Int64.unsigned n0) (Int64.unsigned (Int64.repr n))\n then true\n else false) = zeq (Int64.unsigned n0) n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"rewrite Int64.unsigned_repr.\ndestruct (zeq (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : (if zeq (Int64.unsigned n0) n then true else false) =\nzeq (Int64.unsigned n0) n.","conclusion":"(if zeq (Int64.unsigned n0) n then true else false) =\nzeq (Int64.unsigned n0) n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"destruct (zeq (Int64.unsigned n0) n); auto."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : 0 <= n <= Int64.max_unsigned.","conclusion":"0 <= n <= Int64.max_unsigned","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"unfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\n0 <= n < Int64.modulus ->\neval_expr tge sp0 e0 m0 le0 (cmplu Clt a (longconst (Int64.repr n)))\n  (Val.of_bool (zlt i0 n)).","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\n0 <= n < Int64.modulus ->\neval_expr tge sp0 e0 m0 le0 (cmplu Clt a (longconst (Int64.repr n)))\n  (Val.of_bool (zlt i0 n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"intros until n; intros EVAL R RANGE.\neapply eval_cmplu; auto.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\ninv R.\nunfold Val.cmplu.\nsimpl.\nf_equal; f_equal.\nunfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus) : eval_expr tge sp0 e0 m0 le0 (cmplu Clt a (longconst (Int64.repr n)))\n  (Val.of_bool (zlt i0 n)).","conclusion":"eval_expr tge sp0 e0 m0 le0 (cmplu Clt a (longconst (Int64.repr n)))\n  (Val.of_bool (zlt i0 n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus)","proofString":"eapply eval_cmplu; auto.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\ninv R.\nunfold Val.cmplu.\nsimpl.\nf_equal; f_equal.\nunfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : Val.cmplu (Mem.valid_pointer m0) Clt (Vlong n0) (Vlong (Int64.repr n)) =\nSome (Val.of_bool (zlt (Int64.unsigned n0) n)).","conclusion":"Val.cmplu (Mem.valid_pointer m0) Clt (Vlong n0) (Vlong (Int64.repr n)) =\nSome (Val.of_bool (zlt (Int64.unsigned n0) n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"unfold Val.cmplu.\nsimpl.\nf_equal; f_equal.\nunfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : option_map Val.of_bool\n  (Val.cmplu_bool (Mem.valid_pointer m0) Clt (Vlong n0)\n     (Vlong (Int64.repr n))) = Some (Val.of_bool (zlt (Int64.unsigned n0) n)).","conclusion":"option_map Val.of_bool\n  (Val.cmplu_bool (Mem.valid_pointer m0) Clt (Vlong n0)\n     (Vlong (Int64.repr n))) = Some (Val.of_bool (zlt (Int64.unsigned n0) n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"simpl.\nf_equal; f_equal.\nunfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : Some (Val.of_bool (Int64.ltu n0 (Int64.repr n))) =\nSome (Val.of_bool (zlt (Int64.unsigned n0) n)).","conclusion":"Some (Val.of_bool (Int64.ltu n0 (Int64.repr n))) =\nSome (Val.of_bool (zlt (Int64.unsigned n0) n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"f_equal; f_equal.\nunfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : Int64.ltu n0 (Int64.repr n) = zlt (Int64.unsigned n0) n.","conclusion":"Int64.ltu n0 (Int64.repr n) = zlt (Int64.unsigned n0) n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"unfold Int64.ltu.\nrewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : (if zlt (Int64.unsigned n0) (Int64.unsigned (Int64.repr n))\n then true\n else false) = zlt (Int64.unsigned n0) n.","conclusion":"(if zlt (Int64.unsigned n0) (Int64.unsigned (Int64.repr n))\n then true\n else false) = zlt (Int64.unsigned n0) n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"rewrite Int64.unsigned_repr.\ndestruct (zlt (Int64.unsigned n0) n); auto.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : (if zlt (Int64.unsigned n0) n then true else false) =\nzlt (Int64.unsigned n0) n.","conclusion":"(if zlt (Int64.unsigned n0) n then true else false) =\nzlt (Int64.unsigned n0) n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"destruct (zlt (Int64.unsigned n0) n); auto."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) : 0 <= n <= Int64.max_unsigned.","conclusion":"0 <= n <= Int64.max_unsigned","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus)","proofString":"unfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\n0 <= n < Int64.modulus ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((i0 - n) mod Int64.modulus) v'.","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 n : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\n0 <= n < Int64.modulus ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((i0 - n) mod Int64.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"intros until n; intros EVAL R RANGE.\nexploit eval_subl; auto; try apply HF'.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((i0 - n) mod Int64.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((i0 - n) mod Int64.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus)","proofString":"exploit eval_subl; auto; try apply HF'.\neexact EVAL.\napply eval_longconst with (n := Int64.repr n).\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) vb) (B : Val.lessdef (Val.subl v (Vlong (Int64.repr n))) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((i0 - n) mod Int64.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((i0 - n) mod Int64.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 n : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (RANGE : 0 <= n < Int64.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) vb) (B : Val.lessdef (Val.subl v (Vlong (Int64.repr n))) vb)","proofString":"inv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) vb) (B : Val.lessdef (Val.subl (Vlong n0) (Vlong (Int64.repr n))) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((Int64.unsigned n0 - n) mod Int64.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((Int64.unsigned n0 - n) mod Int64.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) vb) (B : Val.lessdef (Val.subl (Vlong n0) (Vlong (Int64.repr n))) vb)","proofString":"simpl in B.\ninv B.\neconstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) vb) (B : Val.lessdef (Vlong (Int64.sub n0 (Int64.repr n))) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((Int64.unsigned n0 - n) mod Int64.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((Int64.unsigned n0 - n) mod Int64.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (vb : val) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) vb) (B : Val.lessdef (Vlong (Int64.sub n0 (Int64.repr n))) vb)","proofString":"inv B.\neconstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((Int64.unsigned n0 - n) mod Int64.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n))) v' /\\\n  Rlong ((Int64.unsigned n0 - n) mod Int64.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"econstructor; split; eauto.\nreplace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : Rlong ((Int64.unsigned n0 - n) mod Int64.modulus)\n  (Vlong (Int64.sub n0 (Int64.repr n))).","conclusion":"Rlong ((Int64.unsigned n0 - n) mod Int64.modulus)\n  (Vlong (Int64.sub n0 (Int64.repr n)))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"replace ((Int64.unsigned n0 - n) mod Int64.modulus)     with (Int64.unsigned (Int64.sub n0 (Int64.repr n))).\nconstructor.\nunfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : Rlong (Int64.unsigned (Int64.sub n0 (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))).","conclusion":"Rlong (Int64.unsigned (Int64.sub n0 (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"constructor."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : Int64.unsigned (Int64.sub n0 (Int64.repr n)) =\n(Int64.unsigned n0 - n) mod Int64.modulus.","conclusion":"Int64.unsigned (Int64.sub n0 (Int64.repr n)) =\n(Int64.unsigned n0 - n) mod Int64.modulus","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"unfold Int64.sub.\nrewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : Int64.unsigned\n  (Int64.repr (Int64.unsigned n0 - Int64.unsigned (Int64.repr n))) =\n(Int64.unsigned n0 - n) mod Int64.modulus.","conclusion":"Int64.unsigned\n  (Int64.repr (Int64.unsigned n0 - Int64.unsigned (Int64.repr n))) =\n(Int64.unsigned n0 - n) mod Int64.modulus","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"rewrite Int64.unsigned_repr_eq.\nf_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : (Int64.unsigned n0 - Int64.unsigned (Int64.repr n)) mod Int64.modulus =\n(Int64.unsigned n0 - n) mod Int64.modulus.","conclusion":"(Int64.unsigned n0 - Int64.unsigned (Int64.repr n)) mod Int64.modulus =\n(Int64.unsigned n0 - n) mod Int64.modulus","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"f_equal.\nf_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : Int64.unsigned n0 - Int64.unsigned (Int64.repr n) = Int64.unsigned n0 - n.","conclusion":"Int64.unsigned n0 - Int64.unsigned (Int64.repr n) = Int64.unsigned n0 - n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"f_equal.\napply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : Int64.unsigned (Int64.repr n) = n.","conclusion":"Int64.unsigned (Int64.repr n) = n","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"apply Int64.unsigned_repr.\nunfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n)))) : 0 <= n <= Int64.max_unsigned.","conclusion":"0 <= n <= Int64.max_unsigned","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : Z) (n0 : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n0)) (RANGE : 0 <= n < Int64.modulus) (A : eval_expr tge sp0 e0 m0 le0 (subl a (longconst (Int64.repr n)))\n  (Vlong (Int64.sub n0 (Int64.repr n))))","proofString":"unfold Int64.max_unsigned; lia."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\ Rint (i0 mod Int.modulus) v'.","conclusion":"forall (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) \n  (a : expr) (v : val) (i0 : Z),\neval_expr tge sp0 e0 m0 le0 a v ->\nRlong i0 v ->\nexists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\ Rint (i0 mod Int.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"intros until i0; intros EVAL R.\nexploit eval_lowlong.\neexact EVAL.\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\ Rint (i0 mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\ Rint (i0 mod Int.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v)","proofString":"exploit eval_lowlong.\neexact EVAL.\nintros (vb & A & B).\ninv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (vb : val) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a) vb) (B : Val.lessdef (Val.loword v) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\ Rint (i0 mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\ Rint (i0 mod Int.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (v : val) (i0 : Z) (EVAL : eval_expr tge sp0 e0 m0 le0 a v) (R : Rlong i0 v) (vb : val) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a) vb) (B : Val.lessdef (Val.loword v) vb)","proofString":"inv R.\nsimpl in B.\ninv B.\neconstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (vb : val) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a) vb) (B : Val.lessdef (Val.loword (Vlong n)) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\\n  Rint (Int64.unsigned n mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\\n  Rint (Int64.unsigned n mod Int.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (vb : val) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a) vb) (B : Val.lessdef (Val.loword (Vlong n)) vb)","proofString":"simpl in B.\ninv B.\neconstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (vb : val) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a) vb) (B : Val.lessdef (Vint (Int64.loword n)) vb) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\\n  Rint (Int64.unsigned n mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\\n  Rint (Int64.unsigned n mod Int.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (vb : val) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a) vb) (B : Val.lessdef (Vint (Int64.loword n)) vb)","proofString":"inv B.\neconstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n))) : exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\\n  Rint (Int64.unsigned n mod Int.modulus) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp0 e0 m0 le0 (lowlong a) v' /\\\n  Rint (Int64.unsigned n mod Int.modulus) v'","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n)))","proofString":"econstructor; split; eauto.\nreplace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n))) : Rint (Int64.unsigned n mod Int.modulus) (Vint (Int64.loword n)).","conclusion":"Rint (Int64.unsigned n mod Int.modulus) (Vint (Int64.loword n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n)))","proofString":"replace (Int64.unsigned n mod Int.modulus) with (Int.unsigned (Int64.loword n)).\nconstructor.\nunfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n))) : Rint (Int.unsigned (Int64.loword n)) (Vint (Int64.loword n)).","conclusion":"Rint (Int.unsigned (Int64.loword n)) (Vint (Int64.loword n))","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n)))","proofString":"constructor."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n))) : Int.unsigned (Int64.loword n) = Int64.unsigned n mod Int.modulus.","conclusion":"Int.unsigned (Int64.loword n) = Int64.unsigned n mod Int.modulus","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n)))","proofString":"unfold Int64.loword.\napply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n))) : Int.unsigned (Int.repr (Int64.unsigned n)) = Int64.unsigned n mod Int.modulus.","conclusion":"Int.unsigned (Int.repr (Int64.unsigned n)) = Int64.unsigned n mod Int.modulus","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) (sp0 : val) (e0 : env) (m0 : mem) (le0 : letenv) (a : expr) (n : int64) (EVAL : eval_expr tge sp0 e0 m0 le0 a (Vlong n)) (A : eval_expr (Genv.globalenv tprog) sp0 e0 m0 le0 (lowlong a)\n  (Vint (Int64.loword n)))","proofString":"apply Int.unsigned_repr_eq."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : Rlong (Int64.unsigned i) (Vlong i).","conclusion":"Rlong (Int64.unsigned i) (Vlong i)","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"constructor."},{"statement":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i)) : 0 <= Int64.unsigned i < Int64.modulus.","conclusion":"0 <= Int64.unsigned i < Int64.modulus","hypotheses":"(dfl : nat) (cases : table) (arg : expr) (sp : val) (e : env) (m : mem) (i : int64) (t : comptree) (le : letenv) (H : validate_switch Int64.modulus dfl cases t = true) (H0 : eval_expr tge sp e m le arg (Vlong i))","proofString":"apply Int64.unsigned_range."},{"statement":"(op : unary_operation) (v1 v1' v : val) (EV : eval_unop op v1 = Some v) (LD : Val.lessdef v1 v1') : exists v' : val, eval_unop op v1' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_unop op v1' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : unary_operation) (v1 v1' v : val) (EV : eval_unop op v1 = Some v) (LD : Val.lessdef v1 v1')","proofString":"inv LD.\nexists v; auto.\ndestruct op; simpl in *; inv EV; TrivialExists."},{"statement":"(op : unary_operation) (v1' v : val) (EV : eval_unop op v1' = Some v) : exists v' : val, eval_unop op v1' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_unop op v1' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : unary_operation) (v1' v : val) (EV : eval_unop op v1' = Some v)","proofString":"exists v; auto."},{"statement":"(op : unary_operation) (v1' v : val) (EV : eval_unop op Vundef = Some v) : exists v' : val, eval_unop op v1' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_unop op v1' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : unary_operation) (v1' v : val) (EV : eval_unop op Vundef = Some v)","proofString":"destruct op; simpl in *; inv EV; TrivialExists."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') : exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m')","proofString":"assert (exists v', eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v').\ninv LD1.\ninv LD2.\nexists v; auto.\ndestruct op; destruct v1'; simpl in *; inv EV; TrivialExists.\ndestruct op; simpl in *; inv EV; TrivialExists.\nassert (CMPU: forall c,    eval_binop (Ocmpu c) v1 v2 m = Some v ->    exists v' : val, eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v').\nintros c A.\nsimpl in *.\ninv A.\neconstructor; split.\neauto.\napply Val.of_optbool_lessdef.\nintros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto.\nassert (CMPLU: forall c,    eval_binop (Ocmplu c) v1 v2 m = Some v ->    exists v' : val, eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v').\nintros c A.\nsimpl in *.\nunfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto.\ndestruct op; auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m')","proofString":"inv LD1.\ninv LD2.\nexists v; auto.\ndestruct op; destruct v1'; simpl in *; inv EV; TrivialExists.\ndestruct op; simpl in *; inv EV; TrivialExists."},{"statement":"(op : binary_operation) (v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1' v2 m = Some v) (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1' v2 m = Some v) (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m')","proofString":"inv LD2.\nexists v; auto.\ndestruct op; destruct v1'; simpl in *; inv EV; TrivialExists."},{"statement":"(op : binary_operation) (v1' v2' v : val) (m m' : mem) (EV : eval_binop op v1' v2' m = Some v) (ME : Mem.extends m m') : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1' v2' v : val) (m m' : mem) (EV : eval_binop op v1' v2' m = Some v) (ME : Mem.extends m m')","proofString":"exists v; auto."},{"statement":"(op : binary_operation) (v1' v2' v : val) (m m' : mem) (EV : eval_binop op v1' Vundef m = Some v) (ME : Mem.extends m m') : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1' v2' v : val) (m m' : mem) (EV : eval_binop op v1' Vundef m = Some v) (ME : Mem.extends m m')","proofString":"destruct op; destruct v1'; simpl in *; inv EV; TrivialExists."},{"statement":"(op : binary_operation) (v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op Vundef v2 m = Some v) (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op Vundef v2 m = Some v) (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m')","proofString":"destruct op; simpl in *; inv EV; TrivialExists."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') : exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v')","proofString":"assert (CMPU: forall c,    eval_binop (Ocmpu c) v1 v2 m = Some v ->    exists v' : val, eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v').\nintros c A.\nsimpl in *.\ninv A.\neconstructor; split.\neauto.\napply Val.of_optbool_lessdef.\nintros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto.\nassert (CMPLU: forall c,    eval_binop (Ocmplu c) v1 v2 m = Some v ->    exists v' : val, eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v').\nintros c A.\nsimpl in *.\nunfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto.\ndestruct op; auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v')","proofString":"intros c A.\nsimpl in *.\ninv A.\neconstructor; split.\neauto.\napply Val.of_optbool_lessdef.\nintros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (c : comparison) (A : eval_binop (Ocmpu c) v1 v2 m = Some v) : exists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (c : comparison) (A : eval_binop (Ocmpu c) v1 v2 m = Some v)","proofString":"simpl in *.\ninv A.\neconstructor; split.\neauto.\napply Val.of_optbool_lessdef.\nintros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (c : comparison) (A : Some (Val.cmpu (Mem.valid_pointer m) c v1 v2) = Some v) : exists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c v1' v2') = Some v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c v1' v2') = Some v' /\\\n  Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (c : comparison) (A : Some (Val.cmpu (Mem.valid_pointer m) c v1 v2) = Some v)","proofString":"inv A.\neconstructor; split.\neauto.\napply Val.of_optbool_lessdef.\nintros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v') : exists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c v1' v2') = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v'.","conclusion":"exists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c v1' v2') = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v')","proofString":"econstructor; split.\neauto.\napply Val.of_optbool_lessdef.\nintros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v') : forall b : bool,\nVal.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b ->\nVal.cmpu_bool (Mem.valid_pointer m') c v1' v2' = Some b.","conclusion":"forall b : bool,\nVal.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b ->\nVal.cmpu_bool (Mem.valid_pointer m') c v1' v2' = Some b","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v')","proofString":"intros.\napply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v') (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Val.cmpu_bool (Mem.valid_pointer m') c v1' v2' = Some b.","conclusion":"Val.cmpu_bool (Mem.valid_pointer m') c v1' v2' = Some b","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v') (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b)","proofString":"apply Val.cmpu_bool_lessdef with (Mem.valid_pointer m) v1 v2; auto.\nintros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v') (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b0 : block) (ofs : Z),\nMem.valid_pointer m b0 ofs = true -> Mem.valid_pointer m' b0 ofs = true.","conclusion":"forall (b0 : block) (ofs : Z),\nMem.valid_pointer m b0 ofs = true -> Mem.valid_pointer m' b0 ofs = true","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (c : comparison) (EV : eval_binop op v1 v2 m = Some (Val.cmpu (Mem.valid_pointer m) c v1 v2)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c v1 v2) v') (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b)","proofString":"intros; eapply Mem.valid_pointer_extends; eauto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v') : exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v')","proofString":"assert (CMPLU: forall c,    eval_binop (Ocmplu c) v1 v2 m = Some v ->    exists v' : val, eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v').\nintros c A.\nsimpl in *.\nunfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto.\ndestruct op; auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v') : forall c : comparison,\neval_binop (Ocmplu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"forall c : comparison,\neval_binop (Ocmplu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v')","proofString":"intros c A.\nsimpl in *.\nunfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c0 : comparison,\neval_binop (Ocmpu c0) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c0) v1' v2' m' = Some v' /\\ Val.lessdef v v') (c : comparison) (A : eval_binop (Ocmplu c) v1 v2 m = Some v) : exists v' : val,\n  eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c0 : comparison,\neval_binop (Ocmpu c0) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c0) v1' v2' m' = Some v' /\\ Val.lessdef v v') (c : comparison) (A : eval_binop (Ocmplu c) v1 v2 m = Some v)","proofString":"simpl in *.\nunfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some v ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef v v') (c : comparison) (A : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v) : exists v' : val,\n  Val.cmplu (Mem.valid_pointer m') c v1' v2' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  Val.cmplu (Mem.valid_pointer m') c v1' v2' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some v ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef v v') (c : comparison) (A : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v)","proofString":"unfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some v ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef v v') (c : comparison) (A : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) =\nSome v) : exists v' : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c v1' v2') =\n  Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c v1' v2') =\n  Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some v ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef v v') (c : comparison) (A : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) =\nSome v)","proofString":"destruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:C; simpl in A; inv A.\neapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (b : bool) (EV : eval_binop op v1 v2 m = Some (Val.of_bool b)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some (Val.of_bool b) ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef (Val.of_bool b) v') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\ Val.lessdef (Val.of_bool b) v') (c : comparison) (C : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : exists v' : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c v1' v2') =\n  Some v' /\\ Val.lessdef (Val.of_bool b) v'.","conclusion":"exists v' : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c v1' v2') =\n  Some v' /\\ Val.lessdef (Val.of_bool b) v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (b : bool) (EV : eval_binop op v1 v2 m = Some (Val.of_bool b)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some (Val.of_bool b) ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef (Val.of_bool b) v') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\ Val.lessdef (Val.of_bool b) v') (c : comparison) (C : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b)","proofString":"eapply Val.cmplu_bool_lessdef with (valid_ptr' := (Mem.valid_pointer m')) in C;    eauto using Mem.valid_pointer_extends.\nrewrite C.\nexists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (b : bool) (EV : eval_binop op v1 v2 m = Some (Val.of_bool b)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some (Val.of_bool b) ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef (Val.of_bool b) v') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\ Val.lessdef (Val.of_bool b) v') (c : comparison) (C : Val.cmplu_bool (Mem.valid_pointer m') c v1' v2' = Some b) : exists v' : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c v1' v2') =\n  Some v' /\\ Val.lessdef (Val.of_bool b) v'.","conclusion":"exists v' : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m') c v1' v2') =\n  Some v' /\\ Val.lessdef (Val.of_bool b) v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (b : bool) (EV : eval_binop op v1 v2 m = Some (Val.of_bool b)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some (Val.of_bool b) ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef (Val.of_bool b) v') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\ Val.lessdef (Val.of_bool b) v') (c : comparison) (C : Val.cmplu_bool (Mem.valid_pointer m') c v1' v2' = Some b)","proofString":"rewrite C.\nexists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (b : bool) (EV : eval_binop op v1 v2 m = Some (Val.of_bool b)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some (Val.of_bool b) ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef (Val.of_bool b) v') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\ Val.lessdef (Val.of_bool b) v') (c : comparison) (C : Val.cmplu_bool (Mem.valid_pointer m') c v1' v2' = Some b) : exists v' : val,\n  option_map Val.of_bool (Some b) = Some v' /\\ Val.lessdef (Val.of_bool b) v'.","conclusion":"exists v' : val,\n  option_map Val.of_bool (Some b) = Some v' /\\ Val.lessdef (Val.of_bool b) v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' : val) (m m' : mem) (b : bool) (EV : eval_binop op v1 v2 m = Some (Val.of_bool b)) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (CMPU : forall c0 : comparison,\nSome (Val.cmpu (Mem.valid_pointer m) c0 v1 v2) = Some (Val.of_bool b) ->\nexists v' : val,\n  Some (Val.cmpu (Mem.valid_pointer m') c0 v1' v2') = Some v' /\\\n  Val.lessdef (Val.of_bool b) v') (H : exists v' : val,\n  eval_binop op v1' v2' m = Some v' /\\ Val.lessdef (Val.of_bool b) v') (c : comparison) (C : Val.cmplu_bool (Mem.valid_pointer m') c v1' v2' = Some b)","proofString":"exists (Val.of_bool b); auto."},{"statement":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v') (CMPLU : forall c : comparison,\neval_binop (Ocmplu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v') : exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'","hypotheses":"(op : binary_operation) (v1 v1' v2 v2' v : val) (m m' : mem) (EV : eval_binop op v1 v2 m = Some v) (LD1 : Val.lessdef v1 v1') (LD2 : Val.lessdef v2 v2') (ME : Mem.extends m m') (H : exists v' : val, eval_binop op v1' v2' m = Some v' /\\ Val.lessdef v v') (CMPU : forall c : comparison,\neval_binop (Ocmpu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmpu c) v1' v2' m' = Some v' /\\ Val.lessdef v v') (CMPLU : forall c : comparison,\neval_binop (Ocmplu c) v1 v2 m = Some v ->\nexists v' : val,\n  eval_binop (Ocmplu c) v1' v2' m' = Some v' /\\ Val.lessdef v v')","proofString":"destruct op; auto."},{"statement":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (H1 : (PTree.set id v1 e1) ! id0 = Some v0) : exists v3 : val, (PTree.set id v2 e2) ! id0 = Some v3 /\\ Val.lessdef v0 v3.","conclusion":"exists v3 : val, (PTree.set id v2 e2) ! id0 = Some v3 /\\ Val.lessdef v0 v3","hypotheses":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (H1 : (PTree.set id v1 e1) ! id0 = Some v0)","proofString":"rewrite PTree.gsspec in *.\ndestruct (peq id0 id).\nexists v2; split; congruence.\nauto."},{"statement":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (H1 : (if peq id0 id then Some v1 else e1 ! id0) = Some v0) : exists v3 : val,\n  (if peq id0 id then Some v2 else e2 ! id0) = Some v3 /\\ Val.lessdef v0 v3.","conclusion":"exists v3 : val,\n  (if peq id0 id then Some v2 else e2 ! id0) = Some v3 /\\ Val.lessdef v0 v3","hypotheses":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (H1 : (if peq id0 id then Some v1 else e1 ! id0) = Some v0)","proofString":"destruct (peq id0 id).\nexists v2; split; congruence.\nauto."},{"statement":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (e : id0 = id) (H1 : Some v1 = Some v0) : exists v3 : val, Some v2 = Some v3 /\\ Val.lessdef v0 v3.","conclusion":"exists v3 : val, Some v2 = Some v3 /\\ Val.lessdef v0 v3","hypotheses":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (e : id0 = id) (H1 : Some v1 = Some v0)","proofString":"exists v2; split; congruence."},{"statement":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (n : id0 <> id) (H1 : e1 ! id0 = Some v0) : exists v3 : val, e2 ! id0 = Some v3 /\\ Val.lessdef v0 v3.","conclusion":"exists v3 : val, e2 ! id0 = Some v3 /\\ Val.lessdef v0 v3","hypotheses":"(e1 e2 : env) (id : positive) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) (id0 : positive) (v0 : val) (n : id0 <> id) (H1 : e1 ! id0 = Some v0)","proofString":"auto."},{"statement":"(e1 e2 : env) (optid : option ident) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) : env_lessdef match optid with\n            | Some id => PTree.set id v1 e1\n            | None => e1\n            end\n  match optid with\n  | Some id => PTree.set id v2 e2\n  | None => e2\n  end.","conclusion":"env_lessdef match optid with\n            | Some id => PTree.set id v1 e1\n            | None => e1\n            end\n  match optid with\n  | Some id => PTree.set id v2 e2\n  | None => e2\n  end","hypotheses":"(e1 e2 : env) (optid : option ident) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2)","proofString":"destruct optid; auto.\napply set_var_lessdef; auto."},{"statement":"(e1 e2 : env) (i : ident) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2) : env_lessdef (PTree.set i v1 e1) (PTree.set i v2 e2).","conclusion":"env_lessdef (PTree.set i v1 e1) (PTree.set i v2 e2)","hypotheses":"(e1 e2 : env) (i : ident) (v1 v2 : val) (H : env_lessdef e1 e2) (H0 : Val.lessdef v1 v2)","proofString":"apply set_var_lessdef; auto."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) : env_lessdef (PTree.empty val) (PTree.empty val).","conclusion":"env_lessdef (PTree.empty val) (PTree.empty val)","hypotheses":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2)","proofString":"red; intros.\nrewrite PTree.gempty in H0; congruence."},{"statement":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) (id : positive) (v1 : val) (H0 : (PTree.empty val) ! id = Some v1) : exists v2 : val, (PTree.empty val) ! id = Some v2 /\\ Val.lessdef v1 v2.","conclusion":"exists v2 : val, (PTree.empty val) ! id = Some v2 /\\ Val.lessdef v1 v2","hypotheses":"(vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) (id : positive) (v1 : val) (H0 : (PTree.empty val) ! id = Some v1)","proofString":"rewrite PTree.gempty in H0; congruence."},{"statement":"(a : ident) (il : list ident) (IHil : forall vl0 vl3 : list val,\nVal.lessdef_list vl0 vl3 ->\nenv_lessdef (set_params vl0 il) (set_params vl3 il)) (vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2) : env_lessdef\n  match vl1 with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end\n  match vl2 with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end.","conclusion":"env_lessdef\n  match vl1 with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end\n  match vl2 with\n  | nil => PTree.set a Vundef (set_params nil il)\n  | v1 :: vs => PTree.set a v1 (set_params vs il)\n  end","hypotheses":"(a : ident) (il : list ident) (IHil : forall vl0 vl3 : list val,\nVal.lessdef_list vl0 vl3 ->\nenv_lessdef (set_params vl0 il) (set_params vl3 il)) (vl1 vl2 : list val) (H : Val.lessdef_list vl1 vl2)","proofString":"inv H; apply set_var_lessdef; auto."},{"statement":"(e1 e2 : env) (H : env_lessdef e1 e2) : env_lessdef e1 e2.","conclusion":"env_lessdef e1 e2","hypotheses":"(e1 e2 : env) (H : env_lessdef e1 e2)","proofString":"auto."},{"statement":"(e1 e2 : env) (H : env_lessdef e1 e2) (a : ident) (il : list ident) (IHil : env_lessdef (set_locals il e1) (set_locals il e2)) : env_lessdef (PTree.set a Vundef (set_locals il e1))\n  (PTree.set a Vundef (set_locals il e2)).","conclusion":"env_lessdef (PTree.set a Vundef (set_locals il e1))\n  (PTree.set a Vundef (set_locals il e2))","hypotheses":"(e1 e2 : env) (H : env_lessdef e1 e2) (a : ident) (il : list ident) (IHil : env_lessdef (set_locals il e1) (set_locals il e2))","proofString":"apply set_var_lessdef; auto."},{"statement":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val, eval_expr tge sp e' m' le (Evar id) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, eval_expr tge sp e' m' le (Evar id) v' /\\ Val.lessdef v v'","hypotheses":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"exploit H0; eauto.\nintros [v' [A B]].\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : (exists v2 : val, e' ! id = Some v2 /\\ Val.lessdef v v2) ->\nexists v' : val, eval_expr tge sp e' m' le (Evar id) v' /\\ Val.lessdef v v'.","conclusion":"(exists v2 : val, e' ! id = Some v2 /\\ Val.lessdef v v2) ->\nexists v' : val, eval_expr tge sp e' m' le (Evar id) v' /\\ Val.lessdef v v'","hypotheses":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"intros [v' [A B]].\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') (v' : val) (A : e' ! id = Some v') (B : Val.lessdef v v') : exists v'0 : val,\n  eval_expr tge sp e' m' le (Evar id) v'0 /\\ Val.lessdef v v'0.","conclusion":"exists v'0 : val,\n  eval_expr tge sp e' m' le (Evar id) v'0 /\\ Val.lessdef v v'0","hypotheses":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') (v' : val) (A : e' ! id = Some v') (B : Val.lessdef v v')","proofString":"exists v'; split; auto.\nconstructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') (v' : val) (A : e' ! id = Some v') (B : Val.lessdef v v') : eval_expr tge sp e' m' le (Evar id) v'.","conclusion":"eval_expr tge sp e' m' le (Evar id) v'","hypotheses":"(sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') (v' : val) (A : e' ! id = Some v') (B : Val.lessdef v v')","proofString":"constructor; auto."},{"statement":"(sp : val) (e : env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (sel_constant cst) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (sel_constant cst) v' /\\ Val.lessdef v v'","hypotheses":"(sp : val) (e : env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"destruct cst; simpl in *; inv H.\nexists (Vint i); split; auto.\neconstructor.\nconstructor.\nauto.\nexists (Vfloat f); split; auto.\neconstructor.\nconstructor.\nauto.\nexists (Vsingle f); split; auto.\neconstructor.\nconstructor.\nauto.\nexists (Vlong i); split; auto.\napply eval_longconst.\nunfold Genv.symbol_address; rewrite <- symbols_preserved; fold (Genv.symbol_address tge i i0).\napply eval_addrsymbol.\napply eval_addrstack."},{"statement":"(sp : val) (e : env) (m : mem) (i : int) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (Eop (Ointconst i) Enil) v' /\\\n  Val.lessdef (Vint i) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (Eop (Ointconst i) Enil) v' /\\\n  Val.lessdef (Vint i) v'","hypotheses":"(sp : val) (e : env) (m : mem) (i : int) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"exists (Vint i); split; auto.\neconstructor.\nconstructor.\nauto."},{"statement":"(sp : val) (e : env) (m : mem) (i : int) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : eval_expr tge sp e' m' le (Eop (Ointconst i) Enil) (Vint i).","conclusion":"eval_expr tge sp e' m' le (Eop (Ointconst i) Enil) (Vint i)","hypotheses":"(sp : val) (e : env) (m : mem) (i : int) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"econstructor.\nconstructor.\nauto."},{"statement":"(sp : val) (e : env) (m : mem) (f : Floats.float) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (Eop (Ofloatconst f) Enil) v' /\\\n  Val.lessdef (Vfloat f) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (Eop (Ofloatconst f) Enil) v' /\\\n  Val.lessdef (Vfloat f) v'","hypotheses":"(sp : val) (e : env) (m : mem) (f : Floats.float) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"exists (Vfloat f); split; auto.\neconstructor.\nconstructor.\nauto."},{"statement":"(sp : val) (e : env) (m : mem) (f : Floats.float) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : eval_expr tge sp e' m' le (Eop (Ofloatconst f) Enil) (Vfloat f).","conclusion":"eval_expr tge sp e' m' le (Eop (Ofloatconst f) Enil) (Vfloat f)","hypotheses":"(sp : val) (e : env) (m : mem) (f : Floats.float) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"econstructor.\nconstructor.\nauto."},{"statement":"(sp : val) (e : env) (m : mem) (f : Floats.float32) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (Eop (Osingleconst f) Enil) v' /\\\n  Val.lessdef (Vsingle f) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (Eop (Osingleconst f) Enil) v' /\\\n  Val.lessdef (Vsingle f) v'","hypotheses":"(sp : val) (e : env) (m : mem) (f : Floats.float32) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"exists (Vsingle f); split; auto.\neconstructor.\nconstructor.\nauto."},{"statement":"(sp : val) (e : env) (m : mem) (f : Floats.float32) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : eval_expr tge sp e' m' le (Eop (Osingleconst f) Enil) (Vsingle f).","conclusion":"eval_expr tge sp e' m' le (Eop (Osingleconst f) Enil) (Vsingle f)","hypotheses":"(sp : val) (e : env) (m : mem) (f : Floats.float32) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"econstructor.\nconstructor.\nauto."},{"statement":"(sp : val) (e : env) (m : mem) (i : int64) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (longconst i) v' /\\ Val.lessdef (Vlong i) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (longconst i) v' /\\ Val.lessdef (Vlong i) v'","hypotheses":"(sp : val) (e : env) (m : mem) (i : int64) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"exists (Vlong i); split; auto.\napply eval_longconst."},{"statement":"(sp : val) (e : env) (m : mem) (i : int64) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : eval_expr tge sp e' m' le (longconst i) (Vlong i).","conclusion":"eval_expr tge sp e' m' le (longconst i) (Vlong i)","hypotheses":"(sp : val) (e : env) (m : mem) (i : int64) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"apply eval_longconst."},{"statement":"(sp : val) (e : env) (m : mem) (i : ident) (i0 : ptrofs) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (addrsymbol i i0) v' /\\\n  Val.lessdef (Genv.symbol_address ge i i0) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (addrsymbol i i0) v' /\\\n  Val.lessdef (Genv.symbol_address ge i i0) v'","hypotheses":"(sp : val) (e : env) (m : mem) (i : ident) (i0 : ptrofs) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"unfold Genv.symbol_address; rewrite <- symbols_preserved; fold (Genv.symbol_address tge i i0).\napply eval_addrsymbol."},{"statement":"(sp : val) (e : env) (m : mem) (i : ident) (i0 : ptrofs) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (addrsymbol i i0) v' /\\\n  Val.lessdef (Genv.symbol_address tge i i0) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (addrsymbol i i0) v' /\\\n  Val.lessdef (Genv.symbol_address tge i i0) v'","hypotheses":"(sp : val) (e : env) (m : mem) (i : ident) (i0 : ptrofs) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"apply eval_addrsymbol."},{"statement":"(sp : val) (e : env) (m : mem) (i : ptrofs) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (addrstack i) v' /\\\n  Val.lessdef (Val.offset_ptr sp i) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (addrstack i) v' /\\\n  Val.lessdef (Val.offset_ptr sp i) v'","hypotheses":"(sp : val) (e : env) (m : mem) (i : ptrofs) (e' : env) (le : letenv) (m' : mem) (H0 : env_lessdef e e') (H1 : Mem.extends m m')","proofString":"apply eval_addrstack."},{"statement":"(sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : Cminor.expr) (v1 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v' /\\ Val.lessdef v1 v') (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (sel_unop op (sel_expr a1)) v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (sel_unop op (sel_expr a1)) v' /\\\n  Val.lessdef v v'","hypotheses":"(sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : Cminor.expr) (v1 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v' /\\ Val.lessdef v1 v') (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m')","proofString":"exploit IHeval_expr; eauto.\nintros [v1' [A B]].\nexploit eval_unop_lessdef; eauto.\nintros [v' [C D]].\nexploit eval_sel_unop; eauto.\nintros [v'' [E F]].\nexists v''; split; eauto.\neapply Val.lessdef_trans; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : Cminor.expr) (v1 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v' : val) (C : eval_unop op v1' = Some v') (D : Val.lessdef v v') (v'' : val) (E : eval_expr tge sp e' m' le (sel_unop op (sel_expr a1)) v'') (F : Val.lessdef v' v'') : Val.lessdef v v''.","conclusion":"Val.lessdef v v''","hypotheses":"(sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : Cminor.expr) (v1 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v' : val) (C : eval_unop op v1' = Some v') (D : Val.lessdef v v') (v'' : val) (E : eval_expr tge sp e' m' le (sel_unop op (sel_expr a1)) v'') (F : Val.lessdef v' v'')","proofString":"eapply Val.lessdef_trans; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v' /\\ Val.lessdef v1 v') (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v' /\\ Val.lessdef v2 v') (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v' /\\\n  Val.lessdef v v'","hypotheses":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v' /\\ Val.lessdef v1 v') (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v' /\\ Val.lessdef v2 v') (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m')","proofString":"exploit IHeval_expr1; eauto.\nintros [v1' [A B]].\nexploit IHeval_expr2; eauto.\nintros [v2' [C D]].\nexploit eval_binop_lessdef; eauto.\nintros [v' [E F]].\nassert (G: exists v'', eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'' /\\ Val.lessdef v' v'')  by (eapply eval_sel_binop; eauto).\ndestruct G as [v'' [P Q]].\nexists v''; split; eauto.\neapply Val.lessdef_trans; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v'0 /\\ Val.lessdef v2 v'0) (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_expr tge sp e' m' le (sel_expr a2) v2') (D : Val.lessdef v2 v2') (v' : val) (E : eval_binop op v1' v2' m' = Some v') (F : Val.lessdef v v') (G : exists v'' : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'' /\\\n  Val.lessdef v' v'') : exists v'0 : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'0 /\\\n  Val.lessdef v v'0.","conclusion":"exists v'0 : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'0 /\\\n  Val.lessdef v v'0","hypotheses":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v'0 /\\ Val.lessdef v2 v'0) (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_expr tge sp e' m' le (sel_expr a2) v2') (D : Val.lessdef v2 v2') (v' : val) (E : eval_binop op v1' v2' m' = Some v') (F : Val.lessdef v v') (G : exists v'' : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'' /\\\n  Val.lessdef v' v'')","proofString":"destruct G as [v'' [P Q]].\nexists v''; split; eauto.\neapply Val.lessdef_trans; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v'0 /\\ Val.lessdef v2 v'0) (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_expr tge sp e' m' le (sel_expr a2) v2') (D : Val.lessdef v2 v2') (v' : val) (E : eval_binop op v1' v2' m' = Some v') (F : Val.lessdef v v') (v'' : val) (P : eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'') (Q : Val.lessdef v' v'') : exists v'0 : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'0 /\\\n  Val.lessdef v v'0.","conclusion":"exists v'0 : val,\n  eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'0 /\\\n  Val.lessdef v v'0","hypotheses":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v'0 /\\ Val.lessdef v2 v'0) (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_expr tge sp e' m' le (sel_expr a2) v2') (D : Val.lessdef v2 v2') (v' : val) (E : eval_binop op v1' v2' m' = Some v') (F : Val.lessdef v v') (v'' : val) (P : eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'') (Q : Val.lessdef v' v'')","proofString":"exists v''; split; eauto.\neapply Val.lessdef_trans; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v'0 /\\ Val.lessdef v2 v'0) (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_expr tge sp e' m' le (sel_expr a2) v2') (D : Val.lessdef v2 v2') (v' : val) (E : eval_binop op v1' v2' m' = Some v') (F : Val.lessdef v v') (v'' : val) (P : eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'') (Q : Val.lessdef v' v'') : Val.lessdef v v''.","conclusion":"Val.lessdef v v''","hypotheses":"(sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : Cminor.expr) (v1 v2 v : val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a1) v'0 /\\ Val.lessdef v1 v'0) (IHeval_expr2 : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v'0 : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr a2) v'0 /\\ Val.lessdef v2 v'0) (e' : env) (le : letenv) (m' : mem) (H2 : env_lessdef e e') (H3 : Mem.extends m m') (v1' : val) (A : eval_expr tge sp e' m' le (sel_expr a1) v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_expr tge sp e' m' le (sel_expr a2) v2') (D : Val.lessdef v2 v2') (v' : val) (E : eval_binop op v1' v2' m' = Some v') (F : Val.lessdef v v') (v'' : val) (P : eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'') (Q : Val.lessdef v' v'')","proofString":"eapply Val.lessdef_trans; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr : Cminor.expr) (vaddr v : val) (H : Cminor.eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr addr) v' /\\ Val.lessdef vaddr v') (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le (load chunk (sel_expr addr)) v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le (load chunk (sel_expr addr)) v' /\\\n  Val.lessdef v v'","hypotheses":"(sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr : Cminor.expr) (vaddr v : val) (H : Cminor.eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : val,\n  eval_expr tge sp e'0 m'0 le0 (sel_expr addr) v' /\\ Val.lessdef vaddr v') (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m')","proofString":"exploit IHeval_expr; eauto.\nintros [vaddr' [A B]].\nexploit Mem.loadv_extends; eauto.\nintros [v' [C D]].\nexists v'; split; auto.\neapply eval_load; eauto."},{"statement":"(sp : val) (e : env) (m : mem) (e' : env) (le : letenv) (m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m') : exists v' : list val,\n  eval_exprlist tge sp e' m' le Enil v' /\\ Val.lessdef_list nil v'.","conclusion":"exists v' : list val,\n  eval_exprlist tge sp e' m' le Enil v' /\\ Val.lessdef_list nil v'","hypotheses":"(sp : val) (e : env) (m : mem) (e' : env) (le : letenv) (m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m')","proofString":"exists (@nil val); split; auto.\nconstructor."},{"statement":"(sp : val) (e : env) (m : mem) (e' : env) (le : letenv) (m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m') : eval_exprlist tge sp e' m' le Enil nil.","conclusion":"eval_exprlist tge sp e' m' le Enil nil","hypotheses":"(sp : val) (e : env) (m : mem) (e' : env) (le : letenv) (m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m')","proofString":"constructor."},{"statement":"(sp : val) (e : env) (m : mem) (a1 : Cminor.expr) (al : list Cminor.expr) (v1 : val) (vl : list val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : list val,\n  eval_exprlist tge sp e'0 m'0 le0 (sel_exprlist al) v' /\\\n  Val.lessdef_list vl v') (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m') : exists v' : list val,\n  eval_exprlist tge sp e' m' le (sel_expr a1 ::: sel_exprlist al) v' /\\\n  Val.lessdef_list (v1 :: vl) v'.","conclusion":"exists v' : list val,\n  eval_exprlist tge sp e' m' le (sel_expr a1 ::: sel_exprlist al) v' /\\\n  Val.lessdef_list (v1 :: vl) v'","hypotheses":"(sp : val) (e : env) (m : mem) (a1 : Cminor.expr) (al : list Cminor.expr) (v1 : val) (vl : list val) (H : Cminor.eval_expr ge sp e m a1 v1) (H0 : Cminor.eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall (e'0 : env) (le0 : letenv) (m'0 : mem),\nenv_lessdef e e'0 ->\nMem.extends m m'0 ->\nexists v' : list val,\n  eval_exprlist tge sp e'0 m'0 le0 (sel_exprlist al) v' /\\\n  Val.lessdef_list vl v') (e' : env) (le : letenv) (m' : mem) (H1 : env_lessdef e e') (H2 : Mem.extends m m')","proofString":"exploit sel_expr_correct; eauto.\nintros [v1' [A B]].\nexploit IHeval_exprlist; eauto.\nintros [vl' [C D]].\nexists (v1' :: vl'); split; auto.\nconstructor; eauto."},{"statement":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (H : (let (cond0, args) := condition_of_expr (sel_expr cond) in\n select ty cond0 args (sel_expr a1) (sel_expr a2)) = \nSome a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le a v' /\\\n  Val.lessdef (Val.select (Some b) v1 v2 ty) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le a v' /\\\n  Val.lessdef (Val.select (Some b) v1 v2 ty) v'","hypotheses":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (H : (let (cond0, args) := condition_of_expr (sel_expr cond) in\n select ty cond0 args (sel_expr a1) (sel_expr a2)) = \nSome a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m')","proofString":"destruct (condition_of_expr (sel_expr cond)) as [cnd args] eqn:C.\nexploit sel_expr_correct.\neexact H0.\neauto.\neauto.\nintros (vcond' & EVC & LDC).\nexploit sel_expr_correct.\neexact H1.\neauto.\neauto.\nintros (v1' & EV1 & LD1).\nexploit sel_expr_correct.\neexact H2.\neauto.\neauto.\nintros (v2' & EV2 & LD2).\nassert (Val.bool_of_val vcond' b) by (inv H3; inv LDC; constructor).\nexploit eval_condition_of_expr.\neexact EVC.\neauto.\nrewrite C.\nintros (vargs' & EVARGS & EVCOND).\nexploit eval_select; eauto.\nintros (v' & X & Y).\nexists v'; split; eauto.\neapply Val.lessdef_trans; [|eexact Y].\napply Val.select_lessdef; auto."},{"statement":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (cnd : condition) (args : exprlist) (C : condition_of_expr (sel_expr cond) = (cnd, args)) (H : select ty cnd args (sel_expr a1) (sel_expr a2) = Some a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m') : exists v' : val,\n  eval_expr tge sp e' m' le a v' /\\\n  Val.lessdef (Val.select (Some b) v1 v2 ty) v'.","conclusion":"exists v' : val,\n  eval_expr tge sp e' m' le a v' /\\\n  Val.lessdef (Val.select (Some b) v1 v2 ty) v'","hypotheses":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (cnd : condition) (args : exprlist) (C : condition_of_expr (sel_expr cond) = (cnd, args)) (H : select ty cnd args (sel_expr a1) (sel_expr a2) = Some a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m')","proofString":"exploit sel_expr_correct.\neexact H0.\neauto.\neauto.\nintros (vcond' & EVC & LDC).\nexploit sel_expr_correct.\neexact H1.\neauto.\neauto.\nintros (v1' & EV1 & LD1).\nexploit sel_expr_correct.\neexact H2.\neauto.\neauto.\nintros (v2' & EV2 & LD2).\nassert (Val.bool_of_val vcond' b) by (inv H3; inv LDC; constructor).\nexploit eval_condition_of_expr.\neexact EVC.\neauto.\nrewrite C.\nintros (vargs' & EVARGS & EVCOND).\nexploit eval_select; eauto.\nintros (v' & X & Y).\nexists v'; split; eauto.\neapply Val.lessdef_trans; [|eexact Y].\napply Val.select_lessdef; auto."},{"statement":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (cnd : condition) (args : exprlist) (C : condition_of_expr (sel_expr cond) = (cnd, args)) (H : select ty cnd args (sel_expr a1) (sel_expr a2) = Some a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m') (vcond' : val) (EVC : eval_expr tge sp e' m' le (sel_expr cond) vcond') (LDC : Val.lessdef vcond vcond') (v1' : val) (EV1 : eval_expr tge sp e' m' le (sel_expr a1) v1') (LD1 : Val.lessdef v1 v1') (v2' : val) (EV2 : eval_expr tge sp e' m' le (sel_expr a2) v2') (LD2 : Val.lessdef v2 v2') (H6 : Val.bool_of_val vcond' b) (vargs' : list val) (EVARGS : eval_exprlist tge sp e' m' le (snd (cnd, args)) vargs') (EVCOND : eval_condition (fst (cnd, args)) vargs' m' = Some b) (v' : val) (X : eval_expr tge sp e' m' le a v') (Y : Val.lessdef (Val.select (Some b) v1' v2' ty) v') : Val.lessdef (Val.select (Some b) v1 v2 ty) v'.","conclusion":"Val.lessdef (Val.select (Some b) v1 v2 ty) v'","hypotheses":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (cnd : condition) (args : exprlist) (C : condition_of_expr (sel_expr cond) = (cnd, args)) (H : select ty cnd args (sel_expr a1) (sel_expr a2) = Some a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m') (vcond' : val) (EVC : eval_expr tge sp e' m' le (sel_expr cond) vcond') (LDC : Val.lessdef vcond vcond') (v1' : val) (EV1 : eval_expr tge sp e' m' le (sel_expr a1) v1') (LD1 : Val.lessdef v1 v1') (v2' : val) (EV2 : eval_expr tge sp e' m' le (sel_expr a2) v2') (LD2 : Val.lessdef v2 v2') (H6 : Val.bool_of_val vcond' b) (vargs' : list val) (EVARGS : eval_exprlist tge sp e' m' le (snd (cnd, args)) vargs') (EVCOND : eval_condition (fst (cnd, args)) vargs' m' = Some b) (v' : val) (X : eval_expr tge sp e' m' le a v') (Y : Val.lessdef (Val.select (Some b) v1' v2' ty) v')","proofString":"eapply Val.lessdef_trans; [|eexact Y].\napply Val.select_lessdef; auto."},{"statement":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (cnd : condition) (args : exprlist) (C : condition_of_expr (sel_expr cond) = (cnd, args)) (H : select ty cnd args (sel_expr a1) (sel_expr a2) = Some a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m') (vcond' : val) (EVC : eval_expr tge sp e' m' le (sel_expr cond) vcond') (LDC : Val.lessdef vcond vcond') (v1' : val) (EV1 : eval_expr tge sp e' m' le (sel_expr a1) v1') (LD1 : Val.lessdef v1 v1') (v2' : val) (EV2 : eval_expr tge sp e' m' le (sel_expr a2) v2') (LD2 : Val.lessdef v2 v2') (H6 : Val.bool_of_val vcond' b) (vargs' : list val) (EVARGS : eval_exprlist tge sp e' m' le (snd (cnd, args)) vargs') (EVCOND : eval_condition (fst (cnd, args)) vargs' m' = Some b) (v' : val) (X : eval_expr tge sp e' m' le a v') (Y : Val.lessdef (Val.select (Some b) v1' v2' ty) v') : Val.lessdef (Val.select (Some b) v1 v2 ty) (Val.select (Some b) v1' v2' ty).","conclusion":"Val.lessdef (Val.select (Some b) v1 v2 ty) (Val.select (Some b) v1' v2' ty)","hypotheses":"(ty : typ) (cond a1 a2 : Cminor.expr) (a : expr) (sp : val) (e : env) (m : mem) (vcond v1 v2 : val) (b : bool) (e' : env) (m' : mem) (le : letenv) (cnd : condition) (args : exprlist) (C : condition_of_expr (sel_expr cond) = (cnd, args)) (H : select ty cnd args (sel_expr a1) (sel_expr a2) = Some a) (H0 : Cminor.eval_expr ge sp e m cond vcond) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_expr ge sp e m a2 v2) (H3 : Val.bool_of_val vcond b) (H4 : env_lessdef e e') (H5 : Mem.extends m m') (vcond' : val) (EVC : eval_expr tge sp e' m' le (sel_expr cond) vcond') (LDC : Val.lessdef vcond vcond') (v1' : val) (EV1 : eval_expr tge sp e' m' le (sel_expr a1) v1') (LD1 : Val.lessdef v1 v1') (v2' : val) (EV2 : eval_expr tge sp e' m' le (sel_expr a2) v2') (LD2 : Val.lessdef v2 v2') (H6 : Val.bool_of_val vcond' b) (vargs' : list val) (EVARGS : eval_exprlist tge sp e' m' le (snd (cnd, args)) vargs') (EVCOND : eval_condition (fst (cnd, args)) vargs' m' = Some b) (v' : val) (X : eval_expr tge sp e' m' le a v') (Y : Val.lessdef (Val.select (Some b) v1' v2' ty) v')","proofString":"apply Val.select_lessdef; auto."},{"statement":"(sp : val) (e e' : env) (m m' : mem) (a : Cminor.expr) (v : val) (c : builtin_arg_constraint) (H : env_lessdef e e') (H0 : Mem.extends m m') (H1 : Cminor.eval_expr ge sp e m a v) : exists v' : val,\n  CminorSel.eval_builtin_arg tge sp e' m' (sel_builtin_arg a c) v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  CminorSel.eval_builtin_arg tge sp e' m' (sel_builtin_arg a c) v' /\\\n  Val.lessdef v v'","hypotheses":"(sp : val) (e e' : env) (m m' : mem) (a : Cminor.expr) (v : val) (c : builtin_arg_constraint) (H : env_lessdef e e') (H0 : Mem.extends m m') (H1 : Cminor.eval_expr ge sp e m a v)","proofString":"unfold sel_builtin_arg.\nexploit sel_expr_correct; eauto.\nintros (v1 & A & B).\nexists v1; split; auto.\ndestruct (builtin_arg_ok (builtin_arg (sel_expr a)) c).\napply eval_builtin_arg; eauto.\nconstructor; auto."},{"statement":"(sp : val) (e e' : env) (m m' : mem) (a : Cminor.expr) (v : val) (c : builtin_arg_constraint) (H : env_lessdef e e') (H0 : Mem.extends m m') (H1 : Cminor.eval_expr ge sp e m a v) : exists v' : val,\n  CminorSel.eval_builtin_arg tge sp e' m'\n    (if builtin_arg_ok (builtin_arg (sel_expr a)) c\n     then builtin_arg (sel_expr a)\n     else BA (sel_expr a)) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  CminorSel.eval_builtin_arg tge sp e' m'\n    (if builtin_arg_ok (builtin_arg (sel_expr a)) c\n     then builtin_arg (sel_expr a)\n     else BA (sel_expr a)) v' /\\ Val.lessdef v v'","hypotheses":"(sp : val) (e e' : env) (m m' : mem) (a : Cminor.expr) (v : val) (c : builtin_arg_constraint) (H : env_lessdef e e') (H0 : Mem.extends m m') (H1 : Cminor.eval_expr ge sp e m a v)","proofString":"exploit sel_expr_correct; eauto.\nintros (v1 & A & B).\nexists v1; split; auto.\ndestruct (builtin_arg_ok (builtin_arg (sel_expr a)) c).\napply eval_builtin_arg; eauto.\nconstructor; auto."},{"statement":"(sp : val) (e e' : env) (m m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m') (cl : list builtin_arg_constraint) : exists vl' : list val,\n  list_forall2 (CminorSel.eval_builtin_arg tge sp e' m') nil vl' /\\\n  Val.lessdef_list nil vl'.","conclusion":"exists vl' : list val,\n  list_forall2 (CminorSel.eval_builtin_arg tge sp e' m') nil vl' /\\\n  Val.lessdef_list nil vl'","hypotheses":"(sp : val) (e e' : env) (m m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m') (cl : list builtin_arg_constraint)","proofString":"exists (@nil val); split; constructor."},{"statement":"(sp : val) (e e' : env) (m m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m') (a1 : Cminor.expr) (al : list Cminor.expr) (v1 : val) (vl : list val) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall cl0 : list builtin_arg_constraint,\nexists vl' : list val,\n  list_forall2 (CminorSel.eval_builtin_arg tge sp e' m')\n    (sel_builtin_args al cl0) vl' /\\ Val.lessdef_list vl vl') (cl : list builtin_arg_constraint) : exists vl' : list val,\n  list_forall2 (CminorSel.eval_builtin_arg tge sp e' m')\n    (sel_builtin_arg a1 (hd OK_default cl) :: sel_builtin_args al (tl cl))\n    vl' /\\ Val.lessdef_list (v1 :: vl) vl'.","conclusion":"exists vl' : list val,\n  list_forall2 (CminorSel.eval_builtin_arg tge sp e' m')\n    (sel_builtin_arg a1 (hd OK_default cl) :: sel_builtin_args al (tl cl))\n    vl' /\\ Val.lessdef_list (v1 :: vl) vl'","hypotheses":"(sp : val) (e e' : env) (m m' : mem) (H : env_lessdef e e') (H0 : Mem.extends m m') (a1 : Cminor.expr) (al : list Cminor.expr) (v1 : val) (vl : list val) (H1 : Cminor.eval_expr ge sp e m a1 v1) (H2 : Cminor.eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall cl0 : list builtin_arg_constraint,\nexists vl' : list val,\n  list_forall2 (CminorSel.eval_builtin_arg tge sp e' m')\n    (sel_builtin_args al cl0) vl' /\\ Val.lessdef_list vl vl') (cl : list builtin_arg_constraint)","proofString":"exploit sel_builtin_arg_correct; eauto.\nintros (v1' & A & B).\nedestruct IHeval_exprlist as (vl' & C & D).\nexists (v1' :: vl'); split; auto.\nconstructor; eauto."},{"statement":"(oid : option ident) (v : val) (e : env) (v' : val) (e' : env) (H : env_lessdef e e') (H0 : Val.lessdef v v') : env_lessdef (set_optvar oid v e)\n  (set_builtin_res (sel_builtin_res oid) v' e').","conclusion":"env_lessdef (set_optvar oid v e)\n  (set_builtin_res (sel_builtin_res oid) v' e')","hypotheses":"(oid : option ident) (v : val) (e : env) (v' : val) (e' : env) (H : env_lessdef e e') (H0 : Val.lessdef v v')","proofString":"destruct oid; simpl; auto.\napply set_var_lessdef; auto."},{"statement":"(i : ident) (v : val) (e : env) (v' : val) (e' : env) (H : env_lessdef e e') (H0 : Val.lessdef v v') : env_lessdef (PTree.set i v e) (PTree.set i v' e').","conclusion":"env_lessdef (PTree.set i v e) (PTree.set i v' e')","hypotheses":"(i : ident) (v : val) (e : env) (v' : val) (e' : env) (H : env_lessdef e e') (H0 : Val.lessdef v v')","proofString":"apply set_var_lessdef; auto."},{"statement":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1') : exists (e2' : env) (m2' : mem),\n  plus step tge (State f (sel_builtin_default optid ef al) k sp e1' m1') t\n    (State f Sskip k sp e2' m2') /\\\n  env_lessdef (set_optvar optid v e1) e2' /\\ Mem.extends m2 m2'.","conclusion":"exists (e2' : env) (m2' : mem),\n  plus step tge (State f (sel_builtin_default optid ef al) k sp e1' m1') t\n    (State f Sskip k sp e2' m2') /\\\n  env_lessdef (set_optvar optid v e1) e2' /\\ Mem.extends m2 m2'","hypotheses":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1')","proofString":"unfold sel_builtin_default.\nexploit sel_builtin_args_correct; eauto.\nintros (vl' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (v' & m2' & D & E & F & _).\neconstructor; exists m2'; split.\napply plus_one.\neconstructor.\neexact A.\neapply external_call_symbols_preserved.\neexact senv_preserved.\neexact D.\nsplit; auto.\napply sel_builtin_res_correct; auto."},{"statement":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1') : exists (e2' : env) (m2' : mem),\n  plus step tge\n    (State f\n       (Sbuiltin (sel_builtin_res optid) ef\n          (sel_builtin_args al (Machregs.builtin_constraints ef))) k sp e1'\n       m1') t (State f Sskip k sp e2' m2') /\\\n  env_lessdef (set_optvar optid v e1) e2' /\\ Mem.extends m2 m2'.","conclusion":"exists (e2' : env) (m2' : mem),\n  plus step tge\n    (State f\n       (Sbuiltin (sel_builtin_res optid) ef\n          (sel_builtin_args al (Machregs.builtin_constraints ef))) k sp e1'\n       m1') t (State f Sskip k sp e2' m2') /\\\n  env_lessdef (set_optvar optid v e1) e2' /\\ Mem.extends m2 m2'","hypotheses":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1')","proofString":"exploit sel_builtin_args_correct; eauto.\nintros (vl' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (v' & m2' & D & E & F & _).\neconstructor; exists m2'; split.\napply plus_one.\neconstructor.\neexact A.\neapply external_call_symbols_preserved.\neexact senv_preserved.\neexact D.\nsplit; auto.\napply sel_builtin_res_correct; auto."},{"statement":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1') (vl' : list val) (A : list_forall2 (CminorSel.eval_builtin_arg tge sp e1' m1')\n  (sel_builtin_args al (Machregs.builtin_constraints ef)) vl') (B : Val.lessdef_list vl vl') (v' : val) (m2' : mem) (D : external_call ef ge vl' m1' t v' m2') (E : Val.lessdef v v') (F : Mem.extends m2 m2') : env_lessdef (set_optvar optid v e1)\n  (set_builtin_res (sel_builtin_res optid) v' e1').","conclusion":"env_lessdef (set_optvar optid v e1)\n  (set_builtin_res (sel_builtin_res optid) v' e1')","hypotheses":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1') (vl' : list val) (A : list_forall2 (CminorSel.eval_builtin_arg tge sp e1' m1')\n  (sel_builtin_args al (Machregs.builtin_constraints ef)) vl') (B : Val.lessdef_list vl vl') (v' : val) (m2' : mem) (D : external_call ef ge vl' m1' t v' m2') (E : Val.lessdef v v') (F : Mem.extends m2 m2')","proofString":"apply sel_builtin_res_correct; auto."},{"statement":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1') : exists (e2' : env) (m2' : mem),\n  plus step tge (State f (sel_builtin optid ef al) k sp e1' m1') t\n    (State f Sskip k sp e2' m2') /\\\n  env_lessdef (set_optvar optid v e1) e2' /\\ Mem.extends m2 m2'.","conclusion":"exists (e2' : env) (m2' : mem),\n  plus step tge (State f (sel_builtin optid ef al) k sp e1' m1') t\n    (State f Sskip k sp e2' m2') /\\\n  env_lessdef (set_optvar optid v e1) e2' /\\ Mem.extends m2 m2'","hypotheses":"(optid : option ident) (ef : external_function) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (t : trace) (v : val) (m2 : mem) (e1' : env) (m1' : mem) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call ef ge vl m1 t v m2) (H1 : env_lessdef e1 e1') (H2 : Mem.extends m1 m1')","proofString":"exploit sel_exprlist_correct; eauto.\nintros (vl' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (v' & m2' & D & E & F & _).\nunfold sel_builtin.\ndestruct ef; eauto using sel_builtin_default_correct.\ndestruct (lookup_builtin_function name sg) as [bf|] eqn:LKUP; eauto using sel_builtin_default_correct.\nsimpl in D.\nred in D.\nrewrite LKUP in D.\ninv D.\ndestruct optid as [id|]; eauto using sel_builtin_default_correct.\ndestruct (sel_known_builtin bf (sel_exprlist al)) as [a|] eqn:SKB; eauto using sel_builtin_default_correct.\nexploit eval_sel_known_builtin; eauto.\nintros (v'' & U & V).\neconstructor; exists m2'; split.\napply plus_one.\neconstructor.\neexact U.\nsplit; auto.\napply set_var_lessdef; auto.\napply Val.lessdef_trans with v'; auto.\nexists e1', m2'; split.\neapply plus_two.\nconstructor.\nconstructor.\nauto.\nsimpl; auto."},{"statement":"(id : ident) (name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v') (a : expr) (SKB : sel_known_builtin bf (sel_exprlist al) = Some a) (v'' : val) (U : eval_expr tge sp e1' m2' nil a v'') (V : Val.lessdef v' v'') : env_lessdef (set_optvar (Some id) v e1) (PTree.set id v'' e1').","conclusion":"env_lessdef (set_optvar (Some id) v e1) (PTree.set id v'' e1')","hypotheses":"(id : ident) (name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v') (a : expr) (SKB : sel_known_builtin bf (sel_exprlist al) = Some a) (v'' : val) (U : eval_expr tge sp e1' m2' nil a v'') (V : Val.lessdef v' v'')","proofString":"apply set_var_lessdef; auto.\napply Val.lessdef_trans with v'; auto."},{"statement":"(id : ident) (name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v') (a : expr) (SKB : sel_known_builtin bf (sel_exprlist al) = Some a) (v'' : val) (U : eval_expr tge sp e1' m2' nil a v'') (V : Val.lessdef v' v'') : Val.lessdef v v''.","conclusion":"Val.lessdef v v''","hypotheses":"(id : ident) (name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v') (a : expr) (SKB : sel_known_builtin bf (sel_exprlist al) = Some a) (v'' : val) (U : eval_expr tge sp e1' m2' nil a v'') (V : Val.lessdef v' v'')","proofString":"apply Val.lessdef_trans with v'; auto."},{"statement":"(name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v') : plus step tge (State f Sno_op k sp e1' m2') E0 (State f Sskip k sp e1' m2').","conclusion":"plus step tge (State f Sno_op k sp e1' m2') E0 (State f Sskip k sp e1' m2')","hypotheses":"(name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v')","proofString":"eapply plus_two.\nconstructor.\nconstructor.\nauto."},{"statement":"(name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v') : env_lessdef (set_optvar None v e1) e1' /\\ Mem.extends m2 m2'.","conclusion":"env_lessdef (set_optvar None v e1) e1' /\\ Mem.extends m2 m2'","hypotheses":"(name : string) (sg : signature) (al : list Cminor.expr) (sp : val) (e1 : env) (m1 : mem) (vl : list val) (v : val) (m2 : mem) (e1' : env) (f : function) (k : cont) (H : Cminor.eval_exprlist ge sp e1 m1 al vl) (H0 : external_call (EF_builtin name sg) ge vl m1 E0 v m2) (H1 : env_lessdef e1 e1') (m2' : mem) (H2 : Mem.extends m1 m2') (vl' : list val) (A : eval_exprlist tge sp e1' m2' nil (sel_exprlist al) vl') (B : Val.lessdef_list vl vl') (v' : val) (bf : builtin_function) (E : Val.lessdef v v') (F : Mem.extends m2 m2') (LKUP : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf vl' = Some v')","proofString":"simpl; auto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (n : nat) (P : Cminor.state -> Prop) (H : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f s k sp e m) t S' ->\nt = E0 /\\ eventually n S' P) : eventually (S n) (Cminor.State f s k sp e m) P.","conclusion":"eventually (S n) (Cminor.State f s k sp e m) P","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (n : nat) (P : Cminor.state -> Prop) (H : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f s k sp e m) t S' ->\nt = E0 /\\ eventually n S' P)","proofString":"apply Smallstep.eventually_later; auto.\nintros r FS.\ninv FS."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (n : nat) (P : Cminor.state -> Prop) (H : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f s k sp e m) t S' ->\nt = E0 /\\ eventually n S' P) : forall r : int, ~ Cminor.final_state (Cminor.State f s k sp e m) r.","conclusion":"forall r : int, ~ Cminor.final_state (Cminor.State f s k sp e m) r","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (n : nat) (P : Cminor.state -> Prop) (H : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f s k sp e m) t S' ->\nt = E0 /\\ eventually n S' P)","proofString":"intros r FS.\ninv FS."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (n : nat) (P : Cminor.state -> Prop) (H : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f s k sp e m) t S' ->\nt = E0 /\\ eventually n S' P) (r : int) (FS : Cminor.final_state (Cminor.State f s k sp e m) r) : False.","conclusion":"False","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (n : nat) (P : Cminor.state -> Prop) (H : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f s k sp e m) t S' ->\nt = E0 /\\ eventually n S' P) (r : int) (FS : Cminor.final_state (Cminor.State f s k sp e m) r)","proofString":"inv FS."},{"statement":"exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e : env) (m : mem),\n  eventually n (Cminor.State f Cminor.Sskip k sp e m)\n    (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e : env) (m : mem),\n  eventually n (Cminor.State f Cminor.Sskip k sp e m)\n    (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"","proofString":"exists O; intros.\nconstructor; auto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem) : eventually 0 (Cminor.State f Cminor.Sskip k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"eventually 0 (Cminor.State f Cminor.Sskip k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem)","proofString":"constructor; auto."},{"statement":"(i : ident) (e : Cminor.expr) : match\n  match e with\n  | Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n  | _ => SCassign i e\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend.","conclusion":"match\n  match e with\n  | Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n  | _ => SCassign i e\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend","hypotheses":"(i : ident) (e : Cminor.expr)","proofString":"assert (BASE:           exists n : nat,           forall (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val),           Cminor.eval_expr ge sp e0 m e v ->           eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m) (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))).\nexists 1%nat; intros.\napply eventually_step; intros.\ninv H0.\nassert (v0 = v) by eauto using eval_expr_determ.\nsubst v0.\nsplit; auto.\napply eventually_now.\nauto.\ndestruct e; try destruct (ident_eq i i0); auto.\nexists 1%nat.\nintros.\napply eventually_step; intros.\ninv H.\nrewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m e v ->\n  eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m e v ->\n  eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr)","proofString":"exists 1%nat; intros.\napply eventually_step; intros.\ninv H0.\nassert (v0 = v) by eauto using eval_expr_determ.\nsubst v0.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) : eventually 1 (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"eventually 1 (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v)","proofString":"apply eventually_step; intros.\ninv H0.\nassert (v0 = v) by eauto using eval_expr_determ.\nsubst v0.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) (t : trace) (S' : Cminor.state) (H0 : Cminor.step ge (Cminor.State f (Cminor.Sassign i e) k sp e0 m) t S') : t = E0 /\\\neventually 0 S' (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"t = E0 /\\\neventually 0 S' (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) (t : trace) (S' : Cminor.state) (H0 : Cminor.step ge (Cminor.State f (Cminor.Sassign i e) k sp e0 m) t S')","proofString":"inv H0.\nassert (v0 = v) by eauto using eval_expr_determ.\nsubst v0.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) (v0 : val) (H10 : Cminor.eval_expr ge sp e0 m e v0) : E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v0 e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v0 e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) (v0 : val) (H10 : Cminor.eval_expr ge sp e0 m e v0)","proofString":"assert (v0 = v) by eauto using eval_expr_determ.\nsubst v0.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) (v0 : val) (H10 : Cminor.eval_expr ge sp e0 m e v0) (H0 : v0 = v) : E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v0 e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v0 e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e0 m e v) (v0 : val) (H10 : Cminor.eval_expr ge sp e0 m e v0) (H0 : v0 = v)","proofString":"subst v0.\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H H10 : Cminor.eval_expr ge sp e0 m e v) : E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H H10 : Cminor.eval_expr ge sp e0 m e v)","proofString":"split; auto.\napply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H H10 : Cminor.eval_expr ge sp e0 m e v) : eventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)).","conclusion":"eventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H H10 : Cminor.eval_expr ge sp e0 m e v)","proofString":"apply eventually_now.\nauto."},{"statement":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H H10 : Cminor.eval_expr ge sp e0 m e v) : Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m =\nCminor.State f Cminor.Sskip k sp (PTree.set i v e0) m.","conclusion":"Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m =\nCminor.State f Cminor.Sskip k sp (PTree.set i v e0) m","hypotheses":"(i : ident) (e : Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H H10 : Cminor.eval_expr ge sp e0 m e v)","proofString":"auto."},{"statement":"(i : ident) (e : Cminor.expr) (BASE : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m e v ->\n  eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))) : match\n  match e with\n  | Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n  | _ => SCassign i e\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend.","conclusion":"match\n  match e with\n  | Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n  | _ => SCassign i e\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend","hypotheses":"(i : ident) (e : Cminor.expr) (BASE : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m e v ->\n  eventually n (Cminor.State f (Cminor.Sassign i e) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m)))","proofString":"destruct e; try destruct (ident_eq i i0); auto.\nexists 1%nat.\nintros.\napply eventually_step; intros.\ninv H.\nrewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v ->\n  eventually n (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))) (e : i = i0) : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem),\n  eventually n (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem),\n  eventually n (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v ->\n  eventually n (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))) (e : i = i0)","proofString":"exists 1%nat.\nintros.\napply eventually_step; intros.\ninv H.\nrewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v ->\n  eventually n (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))) (e : i = i0) : forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n  (e0 : env) (m : mem),\neventually 1 (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n  (e0 : env) (m : mem),\neventually 1 (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e0 : env) (m : mem) (v : val),\n  Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v ->\n  eventually n (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n    (eq (Cminor.State f Cminor.Sskip k sp (PTree.set i v e0) m))) (e : i = i0)","proofString":"intros.\napply eventually_step; intros.\ninv H.\nrewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i v e1) m0))) (e : i = i0) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) : eventually 1 (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"eventually 1 (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i v e1) m0))) (e : i = i0) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem)","proofString":"apply eventually_step; intros.\ninv H.\nrewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i v e1) m0))) (e : i = i0) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (t : trace) (S' : Cminor.state) (H : Cminor.step ge (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n  t S') : t = E0 /\\ eventually 0 S' (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"t = E0 /\\ eventually 0 S' (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i v e1) m0))) (e : i = i0) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (t : trace) (S' : Cminor.state) (H : Cminor.step ge (Cminor.State f (Cminor.Sassign i (Cminor.Evar i0)) k sp e0 m)\n  t S')","proofString":"inv H.\nrewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v) : E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i0 v e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (PTree.set i0 v e0) m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v)","proofString":"rewrite PTree.gsident by (inv H9; auto).\nsplit; auto.\napply eventually_now.\nauto."},{"statement":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v) : E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v)","proofString":"split; auto.\napply eventually_now.\nauto."},{"statement":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v) : eventually 0 (Cminor.State f Cminor.Sskip k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m)).","conclusion":"eventually 0 (Cminor.State f Cminor.Sskip k sp e0 m)\n  (eq (Cminor.State f Cminor.Sskip k sp e0 m))","hypotheses":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v)","proofString":"apply eventually_now.\nauto."},{"statement":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v) : Cminor.State f Cminor.Sskip k sp e0 m = Cminor.State f Cminor.Sskip k sp e0 m.","conclusion":"Cminor.State f Cminor.Sskip k sp e0 m = Cminor.State f Cminor.Sskip k sp e0 m","hypotheses":"(i0 : ident) (BASE : exists n : nat,\n  forall (f0 : Cminor.function) (k0 : Cminor.cont) \n    (sp0 : val) (e1 : env) (m0 : mem) (v0 : val),\n  Cminor.eval_expr ge sp0 e1 m0 (Cminor.Evar i0) v0 ->\n  eventually n\n    (Cminor.State f0 (Cminor.Sassign i0 (Cminor.Evar i0)) k0 sp0 e1 m0)\n    (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set i0 v0 e1) m0))) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e0 : env) (m : mem) (v : val) (H9 : Cminor.eval_expr ge sp e0 m (Cminor.Evar i0) v)","proofString":"auto."},{"statement":"(o : option ident) (e : external_function) (l : list Cminor.expr) : match\n  match o with\n  | Some _ => SCother\n  | None => match e with\n            | EF_debug _ _ _ => SCskip\n            | _ => SCother\n            end\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sbuiltin o e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sbuiltin o e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend.","conclusion":"match\n  match o with\n  | Some _ => SCother\n  | None => match e with\n            | EF_debug _ _ _ => SCskip\n            | _ => SCother\n            end\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sbuiltin o e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sbuiltin o e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend","hypotheses":"(o : option ident) (e : external_function) (l : list Cminor.expr)","proofString":"destruct o; auto.\ndestruct e; auto.\nexists 1%nat; intros.\napply eventually_step; intros.\ninv H.\ninv H11.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(e : external_function) (l : list Cminor.expr) : match match e with\n      | EF_debug _ _ _ => SCskip\n      | _ => SCother\n      end with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sbuiltin None e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sbuiltin None e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend.","conclusion":"match match e with\n      | EF_debug _ _ _ => SCskip\n      | _ => SCother\n      end with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sbuiltin None e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp e0 m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e0 : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e0 m a v ->\n      eventually n (Cminor.State f (Cminor.Sbuiltin None e l) k sp e0 m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e0) m))\n| SCother => True\nend","hypotheses":"(e : external_function) (l : list Cminor.expr)","proofString":"destruct e; auto.\nexists 1%nat; intros.\napply eventually_step; intros.\ninv H.\ninv H11.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) : exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e : env) (m : mem),\n  eventually n\n    (Cminor.State f (Cminor.Sbuiltin None (EF_debug kind text targs) l) k sp\n       e m) (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"exists n : nat,\n  forall (f : Cminor.function) (k : Cminor.cont) (sp : val) \n    (e : env) (m : mem),\n  eventually n\n    (Cminor.State f (Cminor.Sbuiltin None (EF_debug kind text targs) l) k sp\n       e m) (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr)","proofString":"exists 1%nat; intros.\napply eventually_step; intros.\ninv H.\ninv H11.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem) : eventually 1\n  (Cminor.State f (Cminor.Sbuiltin None (EF_debug kind text targs) l) k sp e\n     m) (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"eventually 1\n  (Cminor.State f (Cminor.Sbuiltin None (EF_debug kind text targs) l) k sp e\n     m) (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem)","proofString":"apply eventually_step; intros.\ninv H.\ninv H11.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (t : trace) (S' : Cminor.state) (H : Cminor.step ge\n  (Cminor.State f (Cminor.Sbuiltin None (EF_debug kind text targs) l) k sp e\n     m) t S') : t = E0 /\\ eventually 0 S' (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"t = E0 /\\ eventually 0 S' (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (t : trace) (S' : Cminor.state) (H : Cminor.step ge\n  (Cminor.State f (Cminor.Sbuiltin None (EF_debug kind text targs) l) k sp e\n     m) t S')","proofString":"inv H.\ninv H11.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (t : trace) (vargs : list val) (vres : val) (m' : mem) (H10 : Cminor.eval_exprlist ge sp e m l vargs) (H11 : external_call (EF_debug kind text targs) ge vargs m t vres m') : t = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (set_optvar None vres e) m')\n  (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"t = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (set_optvar None vres e) m')\n  (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (m : mem) (t : trace) (vargs : list val) (vres : val) (m' : mem) (H10 : Cminor.eval_exprlist ge sp e m l vargs) (H11 : external_call (EF_debug kind text targs) ge vargs m t vres m')","proofString":"inv H11.\nsplit; auto.\napply eventually_now; auto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (vargs : list val) (m' : mem) (H10 : Cminor.eval_exprlist ge sp e m' l vargs) : E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (set_optvar None Vundef e) m')\n  (eq (Cminor.State f Cminor.Sskip k sp e m')).","conclusion":"E0 = E0 /\\\neventually 0 (Cminor.State f Cminor.Sskip k sp (set_optvar None Vundef e) m')\n  (eq (Cminor.State f Cminor.Sskip k sp e m'))","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (vargs : list val) (m' : mem) (H10 : Cminor.eval_exprlist ge sp e m' l vargs)","proofString":"split; auto.\napply eventually_now; auto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (vargs : list val) (m' : mem) (H10 : Cminor.eval_exprlist ge sp e m' l vargs) : eventually 0 (Cminor.State f Cminor.Sskip k sp (set_optvar None Vundef e) m')\n  (eq (Cminor.State f Cminor.Sskip k sp e m')).","conclusion":"eventually 0 (Cminor.State f Cminor.Sskip k sp (set_optvar None Vundef e) m')\n  (eq (Cminor.State f Cminor.Sskip k sp e m'))","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (l : list Cminor.expr) (f : Cminor.function) (k : Cminor.cont) (sp : val) (e : env) (vargs : list val) (m' : mem) (H10 : Cminor.eval_exprlist ge sp e m' l vargs)","proofString":"apply eventually_now; auto."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) : match\n  match classify_stmt s1 with\n  | SCskip => classify_stmt s2\n  | SCassign id a =>\n      match classify_stmt s2 with\n      | SCskip => SCassign id a\n      | _ => SCother\n      end\n  | SCother => match classify_stmt s2 with\n               | SCskip | _ => SCother\n               end\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend.","conclusion":"match\n  match classify_stmt s1 with\n  | SCskip => classify_stmt s2\n  | SCassign id a =>\n      match classify_stmt s2 with\n      | SCskip => SCassign id a\n      | _ => SCother\n      end\n  | SCother => match classify_stmt s2 with\n               | SCskip | _ => SCother\n               end\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend)","proofString":"assert (ESEQ: forall n1 n2 f sp m e e' e'',    (forall k, eventually n1 (Cminor.State f s1 k sp e m) (eq (Cminor.State f Cminor.Sskip k sp e' m))) ->    (forall k, eventually n2 (Cminor.State f s2 k sp e' m) (eq (Cminor.State f Cminor.Sskip k sp e'' m))) ->    (forall k, eventually (S (n1 + S n2))%nat                           (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)                          (eq (Cminor.State f Cminor.Sskip k sp e'' m)))).\nintros.\napply eventually_step.\nintros t S' ST; inv ST.\nsplit; auto.\neapply eventually_trans.\neapply H.\nintros S' EQ; subst S'.\napply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8].\ndestruct (classify_stmt s1), (classify_stmt s2); auto;  destruct IHs1 as (n1 & E1), IHs2 as (n2 & E2);  exists (S (n1 + (S n2)))%nat; intros;  eapply ESEQ; eauto."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) : forall (n1 n2 : nat) (f : Cminor.function) (sp : val) \n  (m : mem) (e e' e'' : env),\n(forall k : Cminor.cont,\n eventually n1 (Cminor.State f s1 k sp e m)\n   (eq (Cminor.State f Cminor.Sskip k sp e' m))) ->\n(forall k : Cminor.cont,\n eventually n2 (Cminor.State f s2 k sp e' m)\n   (eq (Cminor.State f Cminor.Sskip k sp e'' m))) ->\nforall k : Cminor.cont,\neventually (S (n1 + S n2)) (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"forall (n1 n2 : nat) (f : Cminor.function) (sp : val) \n  (m : mem) (e e' e'' : env),\n(forall k : Cminor.cont,\n eventually n1 (Cminor.State f s1 k sp e m)\n   (eq (Cminor.State f Cminor.Sskip k sp e' m))) ->\n(forall k : Cminor.cont,\n eventually n2 (Cminor.State f s2 k sp e' m)\n   (eq (Cminor.State f Cminor.Sskip k sp e'' m))) ->\nforall k : Cminor.cont,\neventually (S (n1 + S n2)) (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend)","proofString":"intros.\napply eventually_step.\nintros t S' ST; inv ST.\nsplit; auto.\neapply eventually_trans.\neapply H.\nintros S' EQ; subst S'.\napply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont) : eventually (S (n1 + S n2)) (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"eventually (S (n1 + S n2)) (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont)","proofString":"apply eventually_step.\nintros t S' ST; inv ST.\nsplit; auto.\neapply eventually_trans.\neapply H.\nintros S' EQ; subst S'.\napply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont) : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f (Cminor.Sseq s1 s2) k sp e m) t S' ->\nt = E0 /\\\neventually (n1 + S n2) S' (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f (Cminor.Sseq s1 s2) k sp e m) t S' ->\nt = E0 /\\\neventually (n1 + S n2) S' (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont)","proofString":"intros t S' ST; inv ST.\nsplit; auto.\neapply eventually_trans.\neapply H.\nintros S' EQ; subst S'.\napply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont) : E0 = E0 /\\\neventually (n1 + S n2) (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"E0 = E0 /\\\neventually (n1 + S n2) (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont)","proofString":"split; auto.\neapply eventually_trans.\neapply H.\nintros S' EQ; subst S'.\napply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont) : eventually (n1 + S n2) (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"eventually (n1 + S n2) (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont)","proofString":"eapply eventually_trans.\neapply H.\nintros S' EQ; subst S'.\napply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont) : Smallstep.eventually Cminor.step Cminor.final_state ge \n  (S n2) (Cminor.State f Cminor.Sskip (Cminor.Kseq s2 k) sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"Smallstep.eventually Cminor.step Cminor.final_state ge \n  (S n2) (Cminor.State f Cminor.Sskip (Cminor.Kseq s2 k) sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont)","proofString":"apply eventually_step.\nintros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont) : forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f Cminor.Sskip (Cminor.Kseq s2 k) sp e' m) t S' ->\nt = E0 /\\ eventually n2 S' (eq (Cminor.State f Cminor.Sskip k sp e'' m)).","conclusion":"forall (t : trace) (S' : Cminor.state),\nCminor.step ge (Cminor.State f Cminor.Sskip (Cminor.Kseq s2 k) sp e' m) t S' ->\nt = E0 /\\ eventually n2 S' (eq (Cminor.State f Cminor.Sskip k sp e'' m))","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s1 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem),\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))\n| SCassign id a =>\n    exists n : nat,\n      forall (f0 : Cminor.function) (k0 : Cminor.cont) \n        (sp0 : val) (e0 : env) (m0 : mem) (v : val),\n      Cminor.eval_expr ge sp0 e0 m0 a v ->\n      eventually n (Cminor.State f0 s2 k0 sp0 e0 m0)\n        (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))\n| SCother => True\nend) (n1 n2 : nat) (f : Cminor.function) (sp : val) (m : mem) (e e' e'' : env) (H : forall k0 : Cminor.cont,\neventually n1 (Cminor.State f s1 k0 sp e m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e' m))) (H0 : forall k0 : Cminor.cont,\neventually n2 (Cminor.State f s2 k0 sp e' m)\n  (eq (Cminor.State f Cminor.Sskip k0 sp e'' m))) (k : Cminor.cont)","proofString":"intros t S' ST; inv ST; [auto | inv H8]."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (ESEQ : forall (n1 n2 : nat) (f : Cminor.function) (sp : val) \n  (m : mem) (e e' e'' : env),\n(forall k : Cminor.cont,\n eventually n1 (Cminor.State f s1 k sp e m)\n   (eq (Cminor.State f Cminor.Sskip k sp e' m))) ->\n(forall k : Cminor.cont,\n eventually n2 (Cminor.State f s2 k sp e' m)\n   (eq (Cminor.State f Cminor.Sskip k sp e'' m))) ->\nforall k : Cminor.cont,\neventually (S (n1 + S n2)) (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m))) : match\n  match classify_stmt s1 with\n  | SCskip => classify_stmt s2\n  | SCassign id a =>\n      match classify_stmt s2 with\n      | SCskip => SCassign id a\n      | _ => SCother\n      end\n  | SCother => match classify_stmt s2 with\n               | SCskip | _ => SCother\n               end\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend.","conclusion":"match\n  match classify_stmt s1 with\n  | SCskip => classify_stmt s2\n  | SCassign id a =>\n      match classify_stmt s2 with\n      | SCskip => SCassign id a\n      | _ => SCother\n      end\n  | SCother => match classify_stmt s2 with\n               | SCskip | _ => SCother\n               end\n  end\nwith\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : match classify_stmt s1 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s1 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (IHs2 : match classify_stmt s2 with\n| SCskip =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem),\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp e m))\n| SCassign id a =>\n    exists n : nat,\n      forall (f : Cminor.function) (k : Cminor.cont) \n        (sp : val) (e : env) (m : mem) (v : val),\n      Cminor.eval_expr ge sp e m a v ->\n      eventually n (Cminor.State f s2 k sp e m)\n        (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m))\n| SCother => True\nend) (ESEQ : forall (n1 n2 : nat) (f : Cminor.function) (sp : val) \n  (m : mem) (e e' e'' : env),\n(forall k : Cminor.cont,\n eventually n1 (Cminor.State f s1 k sp e m)\n   (eq (Cminor.State f Cminor.Sskip k sp e' m))) ->\n(forall k : Cminor.cont,\n eventually n2 (Cminor.State f s2 k sp e' m)\n   (eq (Cminor.State f Cminor.Sskip k sp e'' m))) ->\nforall k : Cminor.cont,\neventually (S (n1 + S n2)) (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e'' m)))","proofString":"destruct (classify_stmt s1), (classify_stmt s2); auto;  destruct IHs1 as (n1 & E1), IHs2 as (n2 & E2);  exists (S (n1 + (S n2)))%nat; intros;  eapply ESEQ; eauto."},{"statement":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (i : ident) (e : Cminor.expr) (CL : match e with\n| Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n| _ => SCassign i e\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sassign i e)) : wt_expr env a (env id).","conclusion":"wt_expr env a (env id)","hypotheses":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (i : ident) (e : Cminor.expr) (CL : match e with\n| Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n| _ => SCassign i e\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sassign i e))","proofString":"destruct e; try destruct (ident_eq i i0); inv CL; inv WT; auto."},{"statement":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (o : option ident) (e : external_function) (l : list Cminor.expr) (CL : match o with\n| Some _ => SCother\n| None => match e with\n          | EF_debug _ _ _ => SCskip\n          | _ => SCother\n          end\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sbuiltin o e l)) : wt_expr env a (env id).","conclusion":"wt_expr env a (env id)","hypotheses":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (o : option ident) (e : external_function) (l : list Cminor.expr) (CL : match o with\n| Some _ => SCother\n| None => match e with\n          | EF_debug _ _ _ => SCskip\n          | _ => SCother\n          end\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sbuiltin o e l))","proofString":"destruct o; try discriminate.\ndestruct e; discriminate."},{"statement":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (e : external_function) (l : list Cminor.expr) (CL : match e with\n| EF_debug _ _ _ => SCskip\n| _ => SCother\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sbuiltin None e l)) : wt_expr env a (env id).","conclusion":"wt_expr env a (env id)","hypotheses":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (e : external_function) (l : list Cminor.expr) (CL : match e with\n| EF_debug _ _ _ => SCskip\n| _ => SCother\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sbuiltin None e l))","proofString":"destruct e; discriminate."},{"statement":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 = SCassign id a ->\nwt_stmt env tyret s1 -> wt_expr env a (env id)) (IHs2 : classify_stmt s2 = SCassign id a ->\nwt_stmt env tyret s2 -> wt_expr env a (env id)) (CL : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id0 a0 =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id0 a0\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sseq s1 s2)) : wt_expr env a (env id).","conclusion":"wt_expr env a (env id)","hypotheses":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 = SCassign id a ->\nwt_stmt env tyret s1 -> wt_expr env a (env id)) (IHs2 : classify_stmt s2 = SCassign id a ->\nwt_stmt env tyret s2 -> wt_expr env a (env id)) (CL : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id0 a0 =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id0 a0\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend = SCassign id a) (WT : wt_stmt env tyret (Cminor.Sseq s1 s2))","proofString":"inv WT.\ndestruct (classify_stmt s1), (classify_stmt s2); try discriminate; eauto."},{"statement":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 = SCassign id a ->\nwt_stmt env tyret s1 -> wt_expr env a (env id)) (IHs2 : classify_stmt s2 = SCassign id a ->\nwt_stmt env tyret s2 -> wt_expr env a (env id)) (CL : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id0 a0 =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id0 a0\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend = SCassign id a) (H1 : wt_stmt env tyret s1) (H2 : wt_stmt env tyret s2) : wt_expr env a (env id).","conclusion":"wt_expr env a (env id)","hypotheses":"(env : ident -> typ) (tyret : xtype) (id : ident) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 = SCassign id a ->\nwt_stmt env tyret s1 -> wt_expr env a (env id)) (IHs2 : classify_stmt s2 = SCassign id a ->\nwt_stmt env tyret s2 -> wt_expr env a (env id)) (CL : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id0 a0 =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id0 a0\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend = SCassign id a) (H1 : wt_stmt env tyret s1) (H2 : wt_stmt env tyret s2)","proofString":"destruct (classify_stmt s1), (classify_stmt s2); try discriminate; eauto."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (H : (if\n  is_known (known_id f) id && safe_expr (known_id f) ifso &&\n  safe_expr (known_id f) ifnot &&\n  if_conversion_heuristic id cond ifso ifnot (env id) kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt (env id) cond ifso ifnot)\n else None) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H2 : env id = ty) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') : exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (H : (if\n  is_known (known_id f) id && safe_expr (known_id f) ifso &&\n  safe_expr (known_id f) ifnot &&\n  if_conversion_heuristic id cond ifso ifnot (env id) kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt (env id) cond ifso ifnot)\n else None) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H2 : env id = ty) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m')","proofString":"rewrite H2 in H.\nclear H2.\ndestruct andb eqn:C; try discriminate.\ndestruct (sel_select_opt ty cond ifso ifnot) as [a'|] eqn:SSO; simpl in H; inv H.\nInvBooleans.\ndestruct (eval_safe_expr ge f sp e m ifso) as (v1 & EV1); auto.\ndestruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (H : (if\n  is_known (known_id f) id && safe_expr (known_id f) ifso &&\n  safe_expr (known_id f) ifnot &&\n  if_conversion_heuristic id cond ifso ifnot ty kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt ty cond ifso ifnot)\n else None) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H2 : env id = ty) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') : exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (H : (if\n  is_known (known_id f) id && safe_expr (known_id f) ifso &&\n  safe_expr (known_id f) ifnot &&\n  if_conversion_heuristic id cond ifso ifnot ty kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt ty cond ifso ifnot)\n else None) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H2 : env id = ty) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m')","proofString":"clear H2.\ndestruct andb eqn:C; try discriminate.\ndestruct (sel_select_opt ty cond ifso ifnot) as [a'|] eqn:SSO; simpl in H; inv H.\nInvBooleans.\ndestruct (eval_safe_expr ge f sp e m ifso) as (v1 & EV1); auto.\ndestruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (H : (if\n  is_known (known_id f) id && safe_expr (known_id f) ifso &&\n  safe_expr (known_id f) ifnot &&\n  if_conversion_heuristic id cond ifso ifnot ty kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt ty cond ifso ifnot)\n else None) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') : exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (H : (if\n  is_known (known_id f) id && safe_expr (known_id f) ifso &&\n  safe_expr (known_id f) ifnot &&\n  if_conversion_heuristic id cond ifso ifnot ty kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt ty cond ifso ifnot)\n else None) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m')","proofString":"destruct andb eqn:C; try discriminate.\ndestruct (sel_select_opt ty cond ifso ifnot) as [a'|] eqn:SSO; simpl in H; inv H.\nInvBooleans.\ndestruct (eval_safe_expr ge f sp e m ifso) as (v1 & EV1); auto.\ndestruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (C : is_known (known_id f) id && safe_expr (known_id f) ifso &&\nsafe_expr (known_id f) ifnot &&\nif_conversion_heuristic id cond ifso ifnot ty kont = true) (H : option_map (fun sel : expr => Sassign id sel)\n  (sel_select_opt ty cond ifso ifnot) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') : exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf s tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont s : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (C : is_known (known_id f) id && safe_expr (known_id f) ifso &&\nsafe_expr (known_id f) ifnot &&\nif_conversion_heuristic id cond ifso ifnot ty kont = true) (H : option_map (fun sel : expr => Sassign id sel)\n  (sel_select_opt ty cond ifso ifnot) = Some s) (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m')","proofString":"destruct (sel_select_opt ty cond ifso ifnot) as [a'|] eqn:SSO; simpl in H; inv H.\nInvBooleans.\ndestruct (eval_safe_expr ge f sp e m ifso) as (v1 & EV1); auto.\ndestruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (C : is_known (known_id f) id && safe_expr (known_id f) ifso &&\nsafe_expr (known_id f) ifnot &&\nif_conversion_heuristic id cond ifso ifnot ty kont = true) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') : exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (C : is_known (known_id f) id && safe_expr (known_id f) ifso &&\nsafe_expr (known_id f) ifnot &&\nif_conversion_heuristic id cond ifso ifnot ty kont = true) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m')","proofString":"InvBooleans.\ndestruct (eval_safe_expr ge f sp e m ifso) as (v1 & EV1); auto.\ndestruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) : exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v1 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v1 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v1 else v2) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true)","proofString":"destruct (eval_safe_expr ge f sp e m ifso) as (v1 & EV1); auto.\ndestruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) : exists v0 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v0 else v2) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v0 v2 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v2 /\\\n  Val.lessdef (if b then v0 else v2) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1)","proofString":"destruct (eval_safe_expr ge f sp e m ifnot) as (v2 & EV2); auto.\nassert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) (v2 : val) (EV2 : Cminor.eval_expr ge sp e m ifnot v2) : exists v0 v3 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v3 /\\\n  Val.lessdef (if b then v0 else v3) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v0 v3 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v3 /\\\n  Val.lessdef (if b then v0 else v3) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) (v2 : val) (EV2 : Cminor.eval_expr ge sp e m ifnot v2)","proofString":"assert (TY1: Val.has_type v1 ty) by (eapply wt_eval_expr; eauto).\nassert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) (v2 : val) (EV2 : Cminor.eval_expr ge sp e m ifnot v2) (TY1 : Val.has_type v1 ty) : exists v0 v3 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v3 /\\\n  Val.lessdef (if b then v0 else v3) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v0 v3 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v3 /\\\n  Val.lessdef (if b then v0 else v3) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) (v2 : val) (EV2 : Cminor.eval_expr ge sp e m ifnot v2) (TY1 : Val.has_type v1 ty)","proofString":"assert (TY2: Val.has_type v2 ty) by (eapply wt_eval_expr; eauto).\nexploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) (v2 : val) (EV2 : Cminor.eval_expr ge sp e m ifnot v2) (TY1 : Val.has_type v1 ty) (TY2 : Val.has_type v2 ty) : exists v0 v3 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v3 /\\\n  Val.lessdef (if b then v0 else v3) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m').","conclusion":"exists v0 v3 v' : val,\n  Cminor.eval_expr ge sp e m ifso v0 /\\\n  Cminor.eval_expr ge sp e m ifnot v3 /\\\n  Val.lessdef (if b then v0 else v3) v' /\\\n  step tge (State tf (Sassign id a') tk sp e' m') E0\n    (State tf Sskip tk sp (PTree.set id v' e') m')","hypotheses":"(f : Cminor.function) (env : typenv) (cond : Cminor.expr) (id : ident) (ifso ifnot : Cminor.expr) (kont : stmt) (e : Cminor.env) (ty : typ) (vb : val) (b : bool) (sp : val) (m : mem) (tf : function) (tk : cont) (e' : Cminor.env) (m' : mem) (a' : expr) (SSO : sel_select_opt ty cond ifso ifnot = Some a') (H0 : def_env f e) (H1 : wt_env env e) (H3 : wt_expr env ifso ty) (H4 : wt_expr env ifnot ty) (H5 : Cminor.eval_expr ge sp e m cond vb) (H6 : Val.bool_of_val vb b) (H7 : env_lessdef e e') (H8 : Mem.extends m m') (H2 : if_conversion_heuristic id cond ifso ifnot ty kont = true) (H10 : safe_expr (known_id f) ifnot = true) (H : is_known (known_id f) id = true) (H11 : safe_expr (known_id f) ifso = true) (v1 : val) (EV1 : Cminor.eval_expr ge sp e m ifso v1) (v2 : val) (EV2 : Cminor.eval_expr ge sp e m ifnot v2) (TY1 : Val.has_type v1 ty) (TY2 : Val.has_type v2 ty)","proofString":"exploit sel_select_opt_correct; eauto.\nintros (v' & EV' & LD).\nsimpl in LD.\nrewrite Val.normalize_idem in LD by (destruct b; auto).\nexists v1, v2, v'; intuition auto.\nconstructor.\neexact EV'."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (IFC : match classify_stmt ifso with\n| SCskip =>\n    match classify_stmt ifnot with\n    | SCassign id a =>\n        if_conversion_base (known_id f) env cond id (Cminor.Evar id) a kont\n    | _ => None\n    end\n| SCassign id1 a1 =>\n    match classify_stmt ifnot with\n    | SCskip =>\n        if_conversion_base (known_id f) env cond id1 a1 \n          (Cminor.Evar id1) kont\n    | SCassign id2 a2 =>\n        if ident_eq id1 id2\n        then if_conversion_base (known_id f) env cond id1 a1 a2 kont\n        else None\n    | SCother => None\n    end\n| SCother => None\nend = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') : exists (n : nat) (e1 e1' : Cminor.env),\n  step tge (State f' s k' sp e' m') E0 (State f' Sskip k' sp e1' m') /\\\n  eventually n (Cminor.State f (if b then ifso else ifnot) k sp e m)\n    (eq (Cminor.State f Cminor.Sskip k sp e1 m)) /\\ \n  env_lessdef e1 e1'.","conclusion":"exists (n : nat) (e1 e1' : Cminor.env),\n  step tge (State f' s k' sp e' m') E0 (State f' Sskip k' sp e1' m') /\\\n  eventually n (Cminor.State f (if b then ifso else ifnot) k sp e m)\n    (eq (Cminor.State f Cminor.Sskip k sp e1 m)) /\\ \n  env_lessdef e1 e1'","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (IFC : match classify_stmt ifso with\n| SCskip =>\n    match classify_stmt ifnot with\n    | SCassign id a =>\n        if_conversion_base (known_id f) env cond id (Cminor.Evar id) a kont\n    | _ => None\n    end\n| SCassign id1 a1 =>\n    match classify_stmt ifnot with\n    | SCskip =>\n        if_conversion_base (known_id f) env cond id1 a1 \n          (Cminor.Evar id1) kont\n    | SCassign id2 a2 =>\n        if ident_eq id1 id2\n        then if_conversion_base (known_id f) env cond id1 a1 a2 kont\n        else None\n    | SCother => None\n    end\n| SCother => None\nend = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m')","proofString":"set (s0 := if b then ifso else ifnot).\nset (ki := known_id f) in *.\ngeneralize (classify_stmt_sound ifso) (classify_stmt_sound ifnot).\ndestruct (classify_stmt ifso) eqn:IFSO; try discriminate;  destruct (classify_stmt ifnot) eqn:IFNOT; try discriminate;  intros (n1 & EV1) (n2 & EV2).\nexploit if_conversion_base_correct; eauto using wt_expr, classify_stmt_wt.\nintros (v1 & v2 & v' & E1 & E2 & VLD & STEP).\nexists (if b then n1 else n2), (PTree.set id (if b then v1 else v2) e), (PTree.set id v' e').\nsplit.\neexact STEP.\nsplit.\nunfold s0; destruct b.\nrewrite PTree.gsident by (inv E1; auto).\neapply EV1.\neapply EV2; eauto.\napply set_var_lessdef; auto.\nexploit if_conversion_base_correct; eauto using wt_expr, classify_stmt_wt.\nintros (v1 & v2 & v' & E1 & E2 & VLD & STEP).\nexists (if b then n1 else n2), (PTree.set id (if b then v1 else v2) e), (PTree.set id v' e').\nsplit.\neexact STEP.\nsplit.\nunfold s0; destruct b.\neapply EV1; eauto.\nrewrite PTree.gsident by (inv E2; auto).\neapply EV2.\napply set_var_lessdef; auto.\ndestruct (ident_eq id id0); try discriminate.\nsubst id0.\nexploit if_conversion_base_correct; eauto using wt_expr, classify_stmt_wt.\nintros (v1 & v2 & v' & E1 & E2 & VLD & STEP).\nexists (if b then n1 else n2), (PTree.set id (if b then v1 else v2) e), (PTree.set id v' e').\nsplit.\neexact STEP.\nsplit.\nunfold s0; destruct b.\neapply EV1; eauto.\neapply EV2; eauto.\napply set_var_lessdef; auto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v1 e) m)).","conclusion":"eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v1 e) m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"rewrite PTree.gsident by (inv E1; auto).\neapply EV1."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"eapply EV1."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v2 e) m)).","conclusion":"eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v2 e) m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"eapply EV2; eauto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef (if b then v1 else v2) v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : env_lessdef (PTree.set id (if b then v1 else v2) e) (PTree.set id v' e').","conclusion":"env_lessdef (PTree.set id (if b then v1 else v2) e) (PTree.set id v' e')","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (IFSO : classify_stmt ifso = SCskip) (id : ident) (a : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a) (IFC : if_conversion_base ki env cond id (Cminor.Evar id) a kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v1) (E2 : Cminor.eval_expr ge sp e m a v2) (VLD : Val.lessdef (if b then v1 else v2) v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"apply set_var_lessdef; auto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v1 e) m)).","conclusion":"eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v1 e) m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"eapply EV1; eauto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v2 e) m)).","conclusion":"eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v2 e) m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"rewrite PTree.gsident by (inv E2; auto).\neapply EV2."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e m)).","conclusion":"eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"eapply EV2."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef (if b then v1 else v2) v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : env_lessdef (PTree.set id (if b then v1 else v2) e) (PTree.set id v' e').","conclusion":"env_lessdef (PTree.set id (if b then v1 else v2) e) (PTree.set id v' e')","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (IFNOT : classify_stmt ifnot = SCskip) (IFC : if_conversion_base ki env cond id a (Cminor.Evar id) kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem),\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 e0 m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m (Cminor.Evar id) v2) (VLD : Val.lessdef (if b then v1 else v2) v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"apply set_var_lessdef; auto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (a0 : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a0) (IFC : if_conversion_base ki env cond id a a0 kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a0 v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m a0 v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v1 e) m)).","conclusion":"eventually n1 (Cminor.State f ifso k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v1 e) m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (a0 : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a0) (IFC : if_conversion_base ki env cond id a a0 kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb true) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a0 v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m a0 v2) (VLD : Val.lessdef v1 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"eapply EV1; eauto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (a0 : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a0) (IFC : if_conversion_base ki env cond id a a0 kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a0 v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m a0 v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v2 e) m)).","conclusion":"eventually n2 (Cminor.State f ifnot k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp (PTree.set id v2 e) m))","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (a0 : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a0) (IFC : if_conversion_base ki env cond id a a0 kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb false) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a0 v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m a0 v2) (VLD : Val.lessdef v2 v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"eapply EV2; eauto."},{"statement":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (a0 : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a0) (IFC : if_conversion_base ki env cond id a a0 kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a0 v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m a0 v2) (VLD : Val.lessdef (if b then v1 else v2) v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m')) : env_lessdef (PTree.set id (if b then v1 else v2) e) (PTree.set id v' e').","conclusion":"env_lessdef (PTree.set id (if b then v1 else v2) e) (PTree.set id v' e')","hypotheses":"(f : Cminor.function) (env : typenv) (tyret : xtype) (cond : Cminor.expr) (ifso ifnot : Cminor.stmt) (kont s : stmt) (vb : val) (b : bool) (k : Cminor.cont) (f' : function) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (ki : known_idents) (id : ident) (a : Cminor.expr) (IFSO : classify_stmt ifso = SCassign id a) (a0 : Cminor.expr) (IFNOT : classify_stmt ifnot = SCassign id a0) (IFC : if_conversion_base ki env cond id a a0 kont = Some s) (DE : def_env f e) (WTE : wt_env env e) (WT1 : wt_stmt env tyret ifso) (WT2 : wt_stmt env tyret ifnot) (EVC : Cminor.eval_expr ge sp e m cond vb) (BOV : Val.bool_of_val vb b) (ELD : env_lessdef e e') (MEXT : Mem.extends m m') (s0 : Cminor.stmt) (n1 : nat) (EV1 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a v ->\neventually n1 (Cminor.State f0 ifso k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (n2 : nat) (EV2 : forall (f0 : Cminor.function) (k0 : Cminor.cont) (sp0 : val)\n  (e0 : Cminor.env) (m0 : mem) (v : val),\nCminor.eval_expr ge sp0 e0 m0 a0 v ->\neventually n2 (Cminor.State f0 ifnot k0 sp0 e0 m0)\n  (eq (Cminor.State f0 Cminor.Sskip k0 sp0 (PTree.set id v e0) m0))) (v1 v2 v' : val) (E1 : Cminor.eval_expr ge sp e m a v1) (E2 : Cminor.eval_expr ge sp e m a0 v2) (VLD : Val.lessdef (if b then v1 else v2) v') (STEP : step tge (State f' s k' sp e' m') E0\n  (State f' Sskip k' sp (PTree.set id v' e') m'))","proofString":"apply set_var_lessdef; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (f : Cminor.function) (f' : function) (k : Cminor.cont) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME : Mem.extends m m') : match_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip k' sp e' m').","conclusion":"match_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip k' sp e' m')","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (f : Cminor.function) (f' : function) (k : Cminor.cont) (k' : cont) (sp : val) (e : Cminor.env) (m : mem) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME : Mem.extends m m')","proofString":"eapply match_state with (kont := Sskip); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (k : Cminor.cont) (k' : cont) (H : match_call_cont k k') : match_call_cont (Cminor.call_cont k) (call_cont k').","conclusion":"match_call_cont (Cminor.call_cont k) (call_cont k')","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (k : Cminor.cont) (k' : cont) (H : match_call_cont k k')","proofString":"inversion H; subst; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (k : Cminor.cont) (k' : cont) (H : match_call_cont k k') (H0 : Cminor.is_call_cont k) : match_call_cont k k' /\\ is_call_cont k'.","conclusion":"match_call_cont k k' /\\ is_call_cont k'","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (k : Cminor.cont) (k' : cont) (H : match_call_cont k k') (H0 : Cminor.is_call_cont k)","proofString":"split; auto.\ninv H; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (k : Cminor.cont) (k' : cont) (H : match_call_cont k k') (H0 : Cminor.is_call_cont k) : is_call_cont k'.","conclusion":"is_call_cont k'","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (k : Cminor.cont) (k' : cont) (H : match_call_cont k k') (H0 : Cminor.is_call_cont k)","proofString":"inv H; auto."},{"statement":"(DIFF : SCskip <> SCother) : nolabel Cminor.Sskip.","conclusion":"nolabel Cminor.Sskip","hypotheses":"(DIFF : SCskip <> SCother)","proofString":"red; auto."},{"statement":"(i : ident) (e : Cminor.expr) (DIFF : match e with\n| Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n| _ => SCassign i e\nend <> SCother) : nolabel (Cminor.Sassign i e).","conclusion":"nolabel (Cminor.Sassign i e)","hypotheses":"(i : ident) (e : Cminor.expr) (DIFF : match e with\n| Cminor.Evar id2 => if ident_eq i id2 then SCskip else SCassign i e\n| _ => SCassign i e\nend <> SCother)","proofString":"red; auto."},{"statement":"(o : option ident) (e : external_function) (l : list Cminor.expr) (DIFF : match o with\n| Some _ => SCother\n| None => match e with\n          | EF_debug _ _ _ => SCskip\n          | _ => SCother\n          end\nend <> SCother) : nolabel (Cminor.Sbuiltin o e l).","conclusion":"nolabel (Cminor.Sbuiltin o e l)","hypotheses":"(o : option ident) (e : external_function) (l : list Cminor.expr) (DIFF : match o with\n| Some _ => SCother\n| None => match e with\n          | EF_debug _ _ _ => SCskip\n          | _ => SCother\n          end\nend <> SCother)","proofString":"red; auto."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) : nolabel (Cminor.Sseq s1 s2).","conclusion":"nolabel (Cminor.Sseq s1 s2)","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother)","proofString":"assert (CL: classify_stmt s1 <> SCother /\\ classify_stmt s2 <> SCother).\ndestruct (classify_stmt s1), (classify_stmt s2); intuition congruence.\ndestruct CL as [CL1 CL2].\napply IHs1 in CL1; apply IHs2 in CL2.\nred; intros; simpl.\nrewrite CL1; apply CL2."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) : classify_stmt s1 <> SCother /\\ classify_stmt s2 <> SCother.","conclusion":"classify_stmt s1 <> SCother /\\ classify_stmt s2 <> SCother","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother)","proofString":"destruct (classify_stmt s1), (classify_stmt s2); intuition congruence."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL : classify_stmt s1 <> SCother /\\ classify_stmt s2 <> SCother) : nolabel (Cminor.Sseq s1 s2).","conclusion":"nolabel (Cminor.Sseq s1 s2)","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL : classify_stmt s1 <> SCother /\\ classify_stmt s2 <> SCother)","proofString":"destruct CL as [CL1 CL2].\napply IHs1 in CL1; apply IHs2 in CL2.\nred; intros; simpl.\nrewrite CL1; apply CL2."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL1 : classify_stmt s1 <> SCother) (CL2 : classify_stmt s2 <> SCother) : nolabel (Cminor.Sseq s1 s2).","conclusion":"nolabel (Cminor.Sseq s1 s2)","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL1 : classify_stmt s1 <> SCother) (CL2 : classify_stmt s2 <> SCother)","proofString":"apply IHs1 in CL1; apply IHs2 in CL2.\nred; intros; simpl.\nrewrite CL1; apply CL2."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL1 : nolabel s1) (CL2 : nolabel s2) : nolabel (Cminor.Sseq s1 s2).","conclusion":"nolabel (Cminor.Sseq s1 s2)","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL1 : nolabel s1) (CL2 : nolabel s2)","proofString":"red; intros; simpl.\nrewrite CL1; apply CL2."},{"statement":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL1 : nolabel s1) (CL2 : nolabel s2) (lbl : label) (k : Cminor.cont) : match Cminor.find_label lbl s1 (Cminor.Kseq s2 k) with\n| Some sk => Some sk\n| None => Cminor.find_label lbl s2 k\nend = None.","conclusion":"match Cminor.find_label lbl s1 (Cminor.Kseq s2 k) with\n| Some sk => Some sk\n| None => Cminor.find_label lbl s2 k\nend = None","hypotheses":"(s1 s2 : Cminor.stmt) (IHs1 : classify_stmt s1 <> SCother -> nolabel s1) (IHs2 : classify_stmt s2 <> SCother -> nolabel s2) (DIFF : match classify_stmt s1 with\n| SCskip => classify_stmt s2\n| SCassign id a =>\n    match classify_stmt s2 with\n    | SCskip => SCassign id a\n    | _ => SCother\n    end\n| SCother => match classify_stmt s2 with\n             | SCskip | _ => SCother\n             end\nend <> SCother) (CL1 : nolabel s1) (CL2 : nolabel s2) (lbl : label) (k : Cminor.cont)","proofString":"rewrite CL1; apply CL2."},{"statement":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (id : ident) (a1 a2 : Cminor.expr) (kont s : stmt) (H : (if\n  is_known ki id && safe_expr ki a1 && safe_expr ki a2 &&\n  if_conversion_heuristic id a a1 a2 (env id) kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt (env id) a a1 a2)\n else None) = Some s) : nolabel' s.","conclusion":"nolabel' s","hypotheses":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (id : ident) (a1 a2 : Cminor.expr) (kont s : stmt) (H : (if\n  is_known ki id && safe_expr ki a1 && safe_expr ki a2 &&\n  if_conversion_heuristic id a a1 a2 (env id) kont\n then\n  option_map (fun sel : expr => Sassign id sel)\n    (sel_select_opt (env id) a a1 a2)\n else None) = Some s)","proofString":"destruct andb; try discriminate.\ndestruct (sel_select_opt (env id) a a1 a2); inv H.\nred; auto."},{"statement":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (id : ident) (a1 a2 : Cminor.expr) (kont s : stmt) (H : option_map (fun sel : expr => Sassign id sel)\n  (sel_select_opt (env id) a a1 a2) = Some s) : nolabel' s.","conclusion":"nolabel' s","hypotheses":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (id : ident) (a1 a2 : Cminor.expr) (kont s : stmt) (H : option_map (fun sel : expr => Sassign id sel)\n  (sel_select_opt (env id) a a1 a2) = Some s)","proofString":"destruct (sel_select_opt (env id) a a1 a2); inv H.\nred; auto."},{"statement":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (id : ident) (a1 a2 : Cminor.expr) (kont : stmt) (e : expr) : nolabel' (Sassign id e).","conclusion":"nolabel' (Sassign id e)","hypotheses":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (id : ident) (a1 a2 : Cminor.expr) (kont : stmt) (e : expr)","proofString":"red; auto."},{"statement":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (kont s : stmt) (H : match classify_stmt s1 with\n| SCskip =>\n    match classify_stmt s2 with\n    | SCassign id a0 =>\n        if_conversion_base ki env a id (Cminor.Evar id) a0 kont\n    | _ => None\n    end\n| SCassign id1 a1 =>\n    match classify_stmt s2 with\n    | SCskip => if_conversion_base ki env a id1 a1 (Cminor.Evar id1) kont\n    | SCassign id2 a2 =>\n        if ident_eq id1 id2\n        then if_conversion_base ki env a id1 a1 a2 kont\n        else None\n    | SCother => None\n    end\n| SCother => None\nend = Some s) : nolabel s1 /\\ nolabel s2 /\\ nolabel' s.","conclusion":"nolabel s1 /\\ nolabel s2 /\\ nolabel' s","hypotheses":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (kont s : stmt) (H : match classify_stmt s1 with\n| SCskip =>\n    match classify_stmt s2 with\n    | SCassign id a0 =>\n        if_conversion_base ki env a id (Cminor.Evar id) a0 kont\n    | _ => None\n    end\n| SCassign id1 a1 =>\n    match classify_stmt s2 with\n    | SCskip => if_conversion_base ki env a id1 a1 (Cminor.Evar id1) kont\n    | SCassign id2 a2 =>\n        if ident_eq id1 id2\n        then if_conversion_base ki env a id1 a1 a2 kont\n        else None\n    | SCother => None\n    end\n| SCother => None\nend = Some s)","proofString":"Ltac conclude :=    split; [apply classify_stmt_nolabel;congruence           |split; [apply classify_stmt_nolabel;congruence                   |eapply if_conversion_base_nolabel; eauto]].\ndestruct (classify_stmt s1) eqn:C1; try discriminate;  destruct (classify_stmt s2) eqn:C2; try discriminate.\nconclude.\nconclude.\ndestruct (ident_eq id id0).\nconclude.\ndiscriminate."},{"statement":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (kont s : stmt) (id : ident) (a0 : Cminor.expr) (C1 : classify_stmt s1 = SCassign id a0) (id0 : ident) (a1 : Cminor.expr) (C2 : classify_stmt s2 = SCassign id0 a1) (n : id <> id0) (H : None = Some s) : nolabel s1 /\\ nolabel s2 /\\ nolabel' s.","conclusion":"nolabel s1 /\\ nolabel s2 /\\ nolabel' s","hypotheses":"(hf : helper_functions) (ki : known_idents) (env : typenv) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (kont s : stmt) (id : ident) (a0 : Cminor.expr) (C1 : classify_stmt s1 = SCassign id a0) (id0 : ident) (a1 : Cminor.expr) (C2 : classify_stmt s2 = SCassign id0 a1) (n : id <> id0) (H : None = Some s)","proofString":"discriminate."},{"statement":"(hf : helper_functions) (optid : option ident) (ef : external_function) (args : list Cminor.expr) (lbl : label) (k : cont) : find_label lbl\n  match ef with\n  | EF_builtin name sg =>\n      match lookup_builtin_function name sg with\n      | Some bf =>\n          match optid with\n          | Some id =>\n              match sel_known_builtin bf (sel_exprlist args) with\n              | Some a => Sassign id a\n              | None => sel_builtin_default optid ef args\n              end\n          | None => Sno_op\n          end\n      | None => sel_builtin_default optid ef args\n      end\n  | _ => sel_builtin_default optid ef args\n  end k = None.","conclusion":"find_label lbl\n  match ef with\n  | EF_builtin name sg =>\n      match lookup_builtin_function name sg with\n      | Some bf =>\n          match optid with\n          | Some id =>\n              match sel_known_builtin bf (sel_exprlist args) with\n              | Some a => Sassign id a\n              | None => sel_builtin_default optid ef args\n              end\n          | None => Sno_op\n          end\n      | None => sel_builtin_default optid ef args\n      end\n  | _ => sel_builtin_default optid ef args\n  end k = None","hypotheses":"(hf : helper_functions) (optid : option ident) (ef : external_function) (args : list Cminor.expr) (lbl : label) (k : cont)","proofString":"destruct ef; auto.\ndestruct lookup_builtin_function; auto.\ndestruct optid; auto.\ndestruct sel_known_builtin; auto."},{"statement":"(hf : helper_functions) (optid : option ident) (name : string) (sg : signature) (args : list Cminor.expr) (lbl : label) (k : cont) : find_label lbl\n  match lookup_builtin_function name sg with\n  | Some bf =>\n      match optid with\n      | Some id =>\n          match sel_known_builtin bf (sel_exprlist args) with\n          | Some a => Sassign id a\n          | None => sel_builtin_default optid (EF_builtin name sg) args\n          end\n      | None => Sno_op\n      end\n  | None => sel_builtin_default optid (EF_builtin name sg) args\n  end k = None.","conclusion":"find_label lbl\n  match lookup_builtin_function name sg with\n  | Some bf =>\n      match optid with\n      | Some id =>\n          match sel_known_builtin bf (sel_exprlist args) with\n          | Some a => Sassign id a\n          | None => sel_builtin_default optid (EF_builtin name sg) args\n          end\n      | None => Sno_op\n      end\n  | None => sel_builtin_default optid (EF_builtin name sg) args\n  end k = None","hypotheses":"(hf : helper_functions) (optid : option ident) (name : string) (sg : signature) (args : list Cminor.expr) (lbl : label) (k : cont)","proofString":"destruct lookup_builtin_function; auto.\ndestruct optid; auto.\ndestruct sel_known_builtin; auto."},{"statement":"(hf : helper_functions) (optid : option ident) (name : string) (sg : signature) (args : list Cminor.expr) (lbl : label) (k : cont) (b : builtin_function) : find_label lbl\n  match optid with\n  | Some id =>\n      match sel_known_builtin b (sel_exprlist args) with\n      | Some a => Sassign id a\n      | None => sel_builtin_default optid (EF_builtin name sg) args\n      end\n  | None => Sno_op\n  end k = None.","conclusion":"find_label lbl\n  match optid with\n  | Some id =>\n      match sel_known_builtin b (sel_exprlist args) with\n      | Some a => Sassign id a\n      | None => sel_builtin_default optid (EF_builtin name sg) args\n      end\n  | None => Sno_op\n  end k = None","hypotheses":"(hf : helper_functions) (optid : option ident) (name : string) (sg : signature) (args : list Cminor.expr) (lbl : label) (k : cont) (b : builtin_function)","proofString":"destruct optid; auto.\ndestruct sel_known_builtin; auto."},{"statement":"(hf : helper_functions) (i : ident) (name : string) (sg : signature) (args : list Cminor.expr) (lbl : label) (k : cont) (b : builtin_function) : find_label lbl\n  match sel_known_builtin b (sel_exprlist args) with\n  | Some a => Sassign i a\n  | None => sel_builtin_default (Some i) (EF_builtin name sg) args\n  end k = None.","conclusion":"find_label lbl\n  match sel_known_builtin b (sel_exprlist args) with\n  | Some a => Sassign i a\n  | None => sel_builtin_default (Some i) (EF_builtin name sg) args\n  end k = None","hypotheses":"(hf : helper_functions) (i : ident) (name : string) (sg : signature) (args : list Cminor.expr) (lbl : label) (k : cont) (b : builtin_function)","proofString":"destruct sel_known_builtin; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (m : memory_chunk) (e e0 : Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match find_label lbl (store m (sel_expr e) (sel_expr e0)) k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl (store m (sel_expr e) (sel_expr e0)) k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (m : memory_chunk) (e e0 : Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"unfold store.\ndestruct (addressing m (sel_expr e)); simpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (m : memory_chunk) (e e0 : Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match\n  find_label lbl\n    (let (mode, args) := addressing m (sel_expr e) in\n     Sstore m mode args (sel_expr e0)) k'\nwith\n| Some _ => False\n| None => True\nend.","conclusion":"match\n  find_label lbl\n    (let (mode, args) := addressing m (sel_expr e) in\n     Sstore m mode args (sel_expr e0)) k'\nwith\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (m : memory_chunk) (e e0 : Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"destruct (addressing m (sel_expr e)); simpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option ident) (s : signature) (e : Cminor.expr) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match\n  find_label lbl\n    match classify_call (prog_defmap cunit) e with\n    | Call_default => Scall o s (inl (sel_expr e)) (sel_exprlist l)\n    | Call_imm id => Scall o s (inr id) (sel_exprlist l)\n    | Call_builtin ef => sel_builtin o ef l\n    end k'\nwith\n| Some _ => False\n| None => True\nend.","conclusion":"match\n  find_label lbl\n    match classify_call (prog_defmap cunit) e with\n    | Call_default => Scall o s (inl (sel_expr e)) (sel_exprlist l)\n    | Call_imm id => Scall o s (inr id) (sel_exprlist l)\n    | Call_builtin ef => sel_builtin o ef l\n    end k'\nwith\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option ident) (s : signature) (e : Cminor.expr) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"destruct (classify_call (prog_defmap cunit) e); simpl; auto.\nrewrite sel_builtin_nolabel; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option ident) (s : signature) (e : Cminor.expr) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (ef : external_function) : match find_label lbl (sel_builtin o ef l) k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl (sel_builtin o ef l) k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option ident) (s : signature) (e : Cminor.expr) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (ef : external_function)","proofString":"rewrite sel_builtin_nolabel; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : signature) (e : Cminor.expr) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match\n  find_label lbl\n    match classify_call (prog_defmap cunit) e with\n    | Call_imm id => Stailcall s (inr id) (sel_exprlist l)\n    | _ => Stailcall s (inl (sel_expr e)) (sel_exprlist l)\n    end k'\nwith\n| Some _ => False\n| None => True\nend.","conclusion":"match\n  find_label lbl\n    match classify_call (prog_defmap cunit) e with\n    | Call_imm id => Stailcall s (inr id) (sel_exprlist l)\n    | _ => Stailcall s (inl (sel_expr e)) (sel_exprlist l)\n    end k'\nwith\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : signature) (e : Cminor.expr) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"destruct (classify_call (prog_defmap cunit) e); simpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option ident) (e : external_function) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match find_label lbl (sel_builtin o e l) k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl (sel_builtin o e l) k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option ident) (e : external_function) (l : list Cminor.expr) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"rewrite sel_builtin_nolabel; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s1 x = OK x0) : match\n  match Cminor.find_label lbl s1 (Cminor.Kseq s2 k) with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match\n      match find_label lbl x0 (Kseq x k') with\n      | Some sk => Some sk\n      | None => find_label lbl x k'\n      end\n    with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match\n      match find_label lbl x0 (Kseq x k') with\n      | Some sk => Some sk\n      | None => find_label lbl x k'\n      end\n    with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 (Cminor.Kseq s2 k) with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match\n      match find_label lbl x0 (Kseq x k') with\n      | Some sk => Some sk\n      | None => find_label lbl x k'\n      end\n    with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match\n      match find_label lbl x0 (Kseq x k') with\n      | Some sk => Some sk\n      | None => find_label lbl x k'\n      end\n    with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s1 x = OK x0)","proofString":"exploit (IHs1 x (Cminor.Kseq s2 k)).\neconstructor; eauto.\neauto.\ndestruct (Cminor.find_label lbl s1 (Cminor.Kseq s2 k)) as [[sx kx] | ];  destruct (find_label lbl x0 (Kseq x k')) as [[sy ky] | ];  intuition.\napply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s1 x = OK x0) (H : True) : match Cminor.find_label lbl s2 k with\n| Some (s0, k1) =>\n    match find_label lbl x k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None => match find_label lbl x k' with\n          | Some _ => False\n          | None => True\n          end\nend.","conclusion":"match Cminor.find_label lbl s2 k with\n| Some (s0, k1) =>\n    match find_label lbl x k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None => match find_label lbl x k' with\n          | Some _ => False\n          | None => True\n          end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s1 x = OK x0) (H : True)","proofString":"apply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : match if_conversion ki env e s1 s2 kont with\n| Some s => OK s\n| None =>\n    do ifso' <- sel_stmt (prog_defmap cunit) ki env s1 kont;\n    do ifnot' <- sel_stmt (prog_defmap cunit) ki env s2 kont;\n    OK (Sifthenelse (condexpr_of_expr (sel_expr e)) ifso' ifnot')\nend = OK s') : match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : match if_conversion ki env e s1 s2 kont with\n| Some s => OK s\n| None =>\n    do ifso' <- sel_stmt (prog_defmap cunit) ki env s1 kont;\n    do ifnot' <- sel_stmt (prog_defmap cunit) ki env s2 kont;\n    OK (Sifthenelse (condexpr_of_expr (sel_expr e)) ifso' ifnot')\nend = OK s')","proofString":"destruct if_conversion as [s|] eqn:IFC.\ninv SE.\nexploit if_conversion_nolabel; eauto.\nintros (A & B & C).\nrewrite A, B, C.\nauto.\nmonadInv SE; simpl.\nexploit (IHs1 kont k); eauto.\ndestruct (Cminor.find_label lbl s1 k) as [[sx kx] | ];  destruct (find_label lbl x k') as [[sy ky] | ];  intuition.\napply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (s : stmt) (IFC : if_conversion ki env e s1 s2 kont = Some s) (SE : OK s = OK s') : match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (s : stmt) (IFC : if_conversion ki env e s1 s2 kont = Some s) (SE : OK s = OK s')","proofString":"inv SE.\nexploit if_conversion_nolabel; eauto.\nintros (A & B & C).\nrewrite A, B, C.\nauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s') : match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s')","proofString":"exploit if_conversion_nolabel; eauto.\nintros (A & B & C).\nrewrite A, B, C.\nauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s') : nolabel s1 /\\ nolabel s2 /\\ nolabel' s' ->\nmatch\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"nolabel s1 /\\ nolabel s2 /\\ nolabel' s' ->\nmatch\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s')","proofString":"intros (A & B & C).\nrewrite A, B, C.\nauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s') (A : nolabel s1) (B : nolabel s2) (C : nolabel' s') : match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s') (A : nolabel s1) (B : nolabel s2) (C : nolabel' s')","proofString":"rewrite A, B, C.\nauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s') (A : nolabel s1) (B : nolabel s2) (C : nolabel' s') : True.","conclusion":"True","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = Some s') (A : nolabel s1) (B : nolabel s2) (C : nolabel' s')","proofString":"auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (SE : (do ifso' <- sel_stmt (prog_defmap cunit) ki env s1 kont;\n do ifnot' <- sel_stmt (prog_defmap cunit) ki env s2 kont;\n OK (Sifthenelse (condexpr_of_expr (sel_expr e)) ifso' ifnot')) = \nOK s') : match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match find_label lbl s' k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s'0 : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s'0 ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s'0 k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s'0 k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (SE : (do ifso' <- sel_stmt (prog_defmap cunit) ki env s1 kont;\n do ifnot' <- sel_stmt (prog_defmap cunit) ki env s2 kont;\n OK (Sifthenelse (condexpr_of_expr (sel_expr e)) ifso' ifnot')) = \nOK s')","proofString":"monadInv SE; simpl.\nexploit (IHs1 kont k); eauto.\ndestruct (Cminor.find_label lbl s1 k) as [[sx kx] | ];  destruct (find_label lbl x k') as [[sy ky] | ];  intuition.\napply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x0) : match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x0)","proofString":"exploit (IHs1 kont k); eauto.\ndestruct (Cminor.find_label lbl s1 k) as [[sx kx] | ];  destruct (find_label lbl x k') as [[sy ky] | ];  intuition.\napply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x0) : match Cminor.find_label lbl s1 k with\n| Some (s3, k1) =>\n    match find_label lbl x k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s3 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None => match find_label lbl x k' with\n          | Some _ => False\n          | None => True\n          end\nend ->\nmatch\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match Cminor.find_label lbl s1 k with\n| Some (s3, k1) =>\n    match find_label lbl x k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s3 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None => match find_label lbl x k' with\n          | Some _ => False\n          | None => True\n          end\nend ->\nmatch\n  match Cminor.find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => Cminor.find_label lbl s2 k\n  end\nwith\n| Some (s0, k1) =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match\n      match find_label lbl x k' with\n      | Some sk => Some sk\n      | None => find_label lbl x0 k'\n      end\n    with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x0)","proofString":"destruct (Cminor.find_label lbl s1 k) as [[sx kx] | ];  destruct (find_label lbl x k') as [[sy ky] | ];  intuition.\napply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x0) (H : True) : match Cminor.find_label lbl s2 k with\n| Some (s0, k1) =>\n    match find_label lbl x0 k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl x0 k' with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match Cminor.find_label lbl s2 k with\n| Some (s0, k1) =>\n    match find_label lbl x0 k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl x0 k' with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (s1 s2 : Cminor.stmt) (IHs1 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s1 kont0 = OK s' ->\nmatch Cminor.find_label lbl s1 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (IHs2 : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s2 kont0 = OK s' ->\nmatch Cminor.find_label lbl s2 k0 with\n| Some (s0, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s0 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (IFC : if_conversion ki env e s1 s2 kont = None) (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) ki env s2 kont = OK x0) (H : True)","proofString":"apply (IHs2 kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x) : match Cminor.find_label lbl s (Cminor.Kseq (Cminor.Sloop s) k) with\n| Some (s1, k1) =>\n    match find_label lbl x (Kseq (Sloop x) k') with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl x (Kseq (Sloop x) k') with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match Cminor.find_label lbl s (Cminor.Kseq (Cminor.Sloop s) k) with\n| Some (s1, k1) =>\n    match find_label lbl x (Kseq (Sloop x) k') with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl x (Kseq (Sloop x) k') with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x)","proofString":"apply (IHs Sskip).\napply match_cont_seq with (kont := Sskip); auto.\nsimpl; rewrite EQ; auto.\nauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x) : match_cont cunit hf ki env (Cminor.Kseq (Cminor.Sloop s) k)\n  (Kseq (Sloop x) k').","conclusion":"match_cont cunit hf ki env (Cminor.Kseq (Cminor.Sloop s) k)\n  (Kseq (Sloop x) k')","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x)","proofString":"apply match_cont_seq with (kont := Sskip); auto.\nsimpl; rewrite EQ; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x) : sel_stmt (prog_defmap cunit) ki env (Cminor.Sloop s) Sskip = OK (Sloop x).","conclusion":"sel_stmt (prog_defmap cunit) ki env (Cminor.Sloop s) Sskip = OK (Sloop x)","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x)","proofString":"simpl; rewrite EQ; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x) : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x.","conclusion":"sel_stmt (prog_defmap cunit) ki env s Sskip = OK x","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s Sskip = OK x)","proofString":"auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) : match Cminor.find_label lbl s (Cminor.Kblock k) with\n| Some (s1, k1) =>\n    match find_label lbl x (Kblock k') with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl x (Kblock k') with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match Cminor.find_label lbl s (Cminor.Kblock k) with\n| Some (s1, k1) =>\n    match find_label lbl x (Kblock k') with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl x (Kblock k') with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x)","proofString":"apply (IHs kont).\nconstructor; auto.\nauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) : match_cont cunit hf ki env (Cminor.Kblock k) (Kblock k').","conclusion":"match_cont cunit hf ki env (Cminor.Kblock k) (Kblock k')","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x)","proofString":"constructor; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) : sel_stmt (prog_defmap cunit) ki env s kont = OK x.","conclusion":"sel_stmt (prog_defmap cunit) ki env s kont = OK x","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x)","proofString":"auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (b : bool) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : (if b\n then\n  if validate_switch Int64.modulus n l (compile_switch Int64.modulus n l)\n  then\n   OK\n     (Sswitch\n        (XElet (sel_expr e)\n           (sel_switch_long 0 (compile_switch Int64.modulus n l))))\n  else Error (msg \"Selection: bad switch (long)\")\n else\n  if validate_switch Int.modulus n l (compile_switch Int.modulus n l)\n  then\n   OK\n     (Sswitch\n        (XElet (sel_expr e)\n           (sel_switch_int 0 (compile_switch Int.modulus n l))))\n  else Error (msg \"Selection: bad switch (int)\")) = \nOK s') : match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (b : bool) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : (if b\n then\n  if validate_switch Int64.modulus n l (compile_switch Int64.modulus n l)\n  then\n   OK\n     (Sswitch\n        (XElet (sel_expr e)\n           (sel_switch_long 0 (compile_switch Int64.modulus n l))))\n  else Error (msg \"Selection: bad switch (long)\")\n else\n  if validate_switch Int.modulus n l (compile_switch Int.modulus n l)\n  then\n   OK\n     (Sswitch\n        (XElet (sel_expr e)\n           (sel_switch_int 0 (compile_switch Int.modulus n l))))\n  else Error (msg \"Selection: bad switch (int)\")) = \nOK s')","proofString":"destruct b.\ndestruct (validate_switch Int64.modulus n l (compile_switch Int64.modulus n l)); inv SE.\nsimpl; auto.\ndestruct (validate_switch Int.modulus n l (compile_switch Int.modulus n l)); inv SE.\nsimpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : (if validate_switch Int64.modulus n l (compile_switch Int64.modulus n l)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_long 0 (compile_switch Int64.modulus n l))))\n else Error (msg \"Selection: bad switch (long)\")) = \nOK s') : match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : (if validate_switch Int64.modulus n l (compile_switch Int64.modulus n l)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_long 0 (compile_switch Int64.modulus n l))))\n else Error (msg \"Selection: bad switch (long)\")) = \nOK s')","proofString":"destruct (validate_switch Int64.modulus n l (compile_switch Int64.modulus n l)); inv SE.\nsimpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match\n  find_label lbl\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_long 0 (compile_switch Int64.modulus n l)))) k'\nwith\n| Some _ => False\n| None => True\nend.","conclusion":"match\n  find_label lbl\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_long 0 (compile_switch Int64.modulus n l)))) k'\nwith\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"simpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : (if validate_switch Int.modulus n l (compile_switch Int.modulus n l)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_int 0 (compile_switch Int.modulus n l))))\n else Error (msg \"Selection: bad switch (int)\")) = \nOK s') : match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : (if validate_switch Int.modulus n l (compile_switch Int.modulus n l)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_int 0 (compile_switch Int.modulus n l))))\n else Error (msg \"Selection: bad switch (int)\")) = \nOK s')","proofString":"destruct (validate_switch Int.modulus n l (compile_switch Int.modulus n l)); inv SE.\nsimpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') : match\n  find_label lbl\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_int 0 (compile_switch Int.modulus n l)))) k'\nwith\n| Some _ => False\n| None => True\nend.","conclusion":"match\n  find_label lbl\n    (Sswitch\n       (XElet (sel_expr e)\n          (sel_switch_int 0 (compile_switch Int.modulus n l)))) k'\nwith\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (e : Cminor.expr) (l : list (Z * nat)) (n : nat) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k')","proofString":"simpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option Cminor.expr) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : match o with\n| Some e => OK (Sreturn (Some (sel_expr e)))\n| None => OK (Sreturn None)\nend = OK s') : match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend.","conclusion":"match find_label lbl s' k' with\n| Some _ => False\n| None => True\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl : label) (o : option Cminor.expr) (kont : stmt) (k : Cminor.cont) (s' : stmt) (k' : cont) (MC : match_cont cunit hf ki env k k') (SE : match o with\n| Some e => OK (Sreturn (Some (sel_expr e)))\n| None => OK (Sreturn None)\nend = OK s')","proofString":"destruct o; inv SE; simpl; auto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl l : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) : match\n  (if ident_eq lbl l then Some (s, k) else Cminor.find_label lbl s k)\nwith\n| Some (s1, k1) =>\n    match (if ident_eq lbl l then Some (x, k') else find_label lbl x k') with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match (if ident_eq lbl l then Some (x, k') else find_label lbl x k') with\n    | Some _ => False\n    | None => True\n    end\nend.","conclusion":"match\n  (if ident_eq lbl l then Some (s, k) else Cminor.find_label lbl s k)\nwith\n| Some (s1, k1) =>\n    match (if ident_eq lbl l then Some (x, k') else find_label lbl x k') with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match (if ident_eq lbl l then Some (x, k') else find_label lbl x k') with\n    | Some _ => False\n    | None => True\n    end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl l : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x)","proofString":"destruct (ident_eq lbl l).\neauto.\napply (IHs kont); eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl l : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) (e : lbl = l) : exists kont1 : stmt,\n  sel_stmt (prog_defmap cunit) ki env s kont1 = OK x /\\\n  match_cont cunit hf ki env k k'.","conclusion":"exists kont1 : stmt,\n  sel_stmt (prog_defmap cunit) ki env s kont1 = OK x /\\\n  match_cont cunit hf ki env k k'","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl l : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) (e : lbl = l)","proofString":"eauto."},{"statement":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl l : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) (n : lbl <> l) : match Cminor.find_label lbl s k with\n| Some (s1, k1) =>\n    match find_label lbl x k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None => match find_label lbl x k' with\n          | Some _ => False\n          | None => True\n          end\nend.","conclusion":"match Cminor.find_label lbl s k with\n| Some (s1, k1) =>\n    match find_label lbl x k' with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None => match find_label lbl x k' with\n          | Some _ => False\n          | None => True\n          end\nend","hypotheses":"(cunit : Cminor.program) (hf : helper_functions) (ki : known_idents) (env : typenv) (lbl l : label) (s : Cminor.stmt) (IHs : forall (kont0 : stmt) (k0 : Cminor.cont) (s' : stmt) (k'0 : cont),\nmatch_cont cunit hf ki env k0 k'0 ->\nsel_stmt (prog_defmap cunit) ki env s kont0 = OK s' ->\nmatch Cminor.find_label lbl s k0 with\n| Some (s1, k1) =>\n    match find_label lbl s' k'0 with\n    | Some (s1', k1') =>\n        exists kont1 : stmt,\n          sel_stmt (prog_defmap cunit) ki env s1 kont1 = OK s1' /\\\n          match_cont cunit hf ki env k1 k1'\n    | None => False\n    end\n| None =>\n    match find_label lbl s' k'0 with\n    | Some _ => False\n    | None => True\n    end\nend) (kont : stmt) (k : Cminor.cont) (k' : cont) (MC : match_cont cunit hf ki env k k') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) ki env s kont = OK x) (n : lbl <> l)","proofString":"apply (IHs kont); eauto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kseq s k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m) (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m) (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kseq s k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv MC.\nleft; econstructor; split.\napply plus_one; econstructor.\neconstructor; eauto.\ninv H."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (kont0 s' : stmt) (k'0 : cont) (H5 : sel_stmt (prog_defmap cunit) (known_id f) env s kont0 = OK s') (H7 : match_cont cunit hf (known_id f) env k k'0) : (exists T2 : state,\n   plus step tge (State f' Sskip (Kseq s' k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m)\n  (State f' Sskip (Kseq s' k'0) sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip (Kseq s' k'0) sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip (Kseq s' k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m)\n  (State f' Sskip (Kseq s' k'0) sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip (Kseq s' k'0) sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (kont0 s' : stmt) (k'0 : cont) (H5 : sel_stmt (prog_defmap cunit) (known_id f) env s kont0 = OK s') (H7 : match_cont cunit hf (known_id f) env k k'0)","proofString":"left; econstructor; split.\napply plus_one; econstructor.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kseq s k) k') : (exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m) (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m) (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kseq s k) k')","proofString":"inv H."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kblock k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kblock k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv MC.\nleft; econstructor; split.\napply plus_one; econstructor.\neauto using match_states_skip.\ninv H."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (k'0 : cont) (H4 : match_cont cunit hf (known_id f) env k k'0) : (exists T2 : state,\n   plus step tge (State f' Sskip (Kblock k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip (Kblock k'0) sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip (Kblock k'0) sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip (Kblock k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip (Kblock k'0) sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip (Kblock k'0) sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (k'0 : cont) (H4 : match_cont cunit hf (known_id f) env k k'0)","proofString":"left; econstructor; split.\napply plus_one; econstructor.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kblock k) k') : (exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f Cminor.Sskip (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kblock k) k')","proofString":"inv H."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Returnstate Vundef k m') T2) \\/\n(measure (Cminor.Returnstate Vundef k m') <\n measure (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef k m')\n  (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Returnstate Vundef k m') T2) \\/\n(measure (Cminor.Returnstate Vundef k m') <\n measure (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef k m')\n  (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m2' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor.\neapply match_is_call_cont; eauto.\nerewrite stackspace_function_translated; eauto.\neconstructor; eauto.\neapply match_is_call_cont; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Returnstate Vundef k m') T2) \\/\n(measure (Cminor.Returnstate Vundef k m') <\n measure (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef k m')\n  (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Returnstate Vundef k m') T2) \\/\n(measure (Cminor.Returnstate Vundef k m') <\n measure (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef k m')\n  (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"intros [m2' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor.\neapply match_is_call_cont; eauto.\nerewrite stackspace_function_translated; eauto.\neconstructor; eauto.\neapply match_is_call_cont; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (A : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (B : Mem.extends m' m2') : (exists T2 : state,\n   plus step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Returnstate Vundef k m') T2) \\/\n(measure (Cminor.Returnstate Vundef k m') <\n measure (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef k m')\n  (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Returnstate Vundef k m') T2) \\/\n(measure (Cminor.Returnstate Vundef k m') <\n measure (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef k m')\n  (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (A : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (B : Mem.extends m' m2')","proofString":"left; econstructor; split.\napply plus_one; econstructor.\neapply match_is_call_cont; eauto.\nerewrite stackspace_function_translated; eauto.\neconstructor; eauto.\neapply match_is_call_cont; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (A : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (B : Mem.extends m' m2') : is_call_cont k'.","conclusion":"is_call_cont k'","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (A : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (B : Mem.extends m' m2')","proofString":"eapply match_is_call_cont; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (A : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (B : Mem.extends m' m2') : match_call_cont k k'.","conclusion":"match_call_cont k k'","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Cminor.is_call_cont k) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f Cminor.Sskip k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (A : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (B : Mem.extends m' m2')","proofString":"eapply match_is_call_cont; eauto."},{"statement":"(f : Cminor.function) (id : ident) (a : Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e m a v) (WTS : wt_state (Cminor.State f (Cminor.Sassign id a) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' (Sassign id (sel_expr a)) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m) <\n measure (Cminor.State f (Cminor.Sassign id a) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m)\n  (State f' (Sassign id (sel_expr a)) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sassign id (sel_expr a)) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sassign id (sel_expr a)) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m) <\n measure (Cminor.State f (Cminor.Sassign id a) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m)\n  (State f' (Sassign id (sel_expr a)) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sassign id (sel_expr a)) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (id : ident) (a : Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e m a v) (WTS : wt_state (Cminor.State f (Cminor.Sassign id a) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"exploit sel_expr_correct; eauto.\nintros [v' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neapply match_states_skip; eauto.\napply set_var_lessdef; auto."},{"statement":"(f : Cminor.function) (id : ident) (a : Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e m a v) (WTS : wt_state (Cminor.State f (Cminor.Sassign id a) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (v' : val) (A : eval_expr tge sp e' m' nil (sel_expr a) v') (B : Val.lessdef v v') : env_lessdef (PTree.set id v e) (PTree.set id v' e').","conclusion":"env_lessdef (PTree.set id v e) (PTree.set id v' e')","hypotheses":"(f : Cminor.function) (id : ident) (a : Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : Cminor.eval_expr ge sp e m a v) (WTS : wt_state (Cminor.State f (Cminor.Sassign id a) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (v' : val) (A : eval_expr tge sp e' m' nil (sel_expr a) v') (B : Val.lessdef v v')","proofString":"apply set_var_lessdef; auto."},{"statement":"(f : Cminor.function) (chunk : memory_chunk) (addr a : Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vaddr v : val) (m' : mem) (H : Cminor.eval_expr ge sp e m addr vaddr) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Mem.storev chunk m vaddr v = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sstore chunk addr a) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge\n     (State f' (store chunk (sel_expr addr) (sel_expr a)) k' sp e' m'0) E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m') T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m') <\n measure (Cminor.State f (Cminor.Sstore chunk addr a) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m')\n  (State f' (store chunk (sel_expr addr) (sel_expr a)) k' sp e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (store chunk (sel_expr addr) (sel_expr a)) k' sp e' m'0) E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (store chunk (sel_expr addr) (sel_expr a)) k' sp e' m'0) E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m') T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m') <\n measure (Cminor.State f (Cminor.Sstore chunk addr a) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m')\n  (State f' (store chunk (sel_expr addr) (sel_expr a)) k' sp e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (store chunk (sel_expr addr) (sel_expr a)) k' sp e' m'0) E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (chunk : memory_chunk) (addr a : Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vaddr v : val) (m' : mem) (H : Cminor.eval_expr ge sp e m addr vaddr) (H0 : Cminor.eval_expr ge sp e m a v) (H1 : Mem.storev chunk m vaddr v = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sstore chunk addr a) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit sel_expr_correct.\ntry apply LINK.\ntry apply HF.\neexact H.\neauto.\neauto.\nintros [vaddr' [A B]].\nexploit sel_expr_correct.\ntry apply LINK.\ntry apply HF.\neexact H0.\neauto.\neauto.\nintros [v' [C D]].\nexploit Mem.storev_extends; eauto.\nintros [m2' [P Q]].\nleft; econstructor; split.\napply plus_one; eapply eval_store; eauto.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_default =>\n         Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     | Call_imm id =>\n         Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | Call_builtin ef => sel_builtin optid ef bl\n     end k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_default =>\n         Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     | Call_imm id =>\n         Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | Call_builtin ef => sel_builtin optid ef bl\n     end k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"exploit classify_call_correct; eauto.\ndestruct (classify_call (prog_defmap cunit) a) as [ | id | ef].\nexploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & U & V & W).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto.\nintros [b [U V]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & X & Y & Z).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\nsubst vf.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto.\nintros EQ.\nsubst fd.\nright; left; split.\nsimpl; lia.\nsplit; auto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : match classify_call (prog_defmap cunit) a with\n| Call_default => True\n| Call_imm id =>\n    exists b : block,\n      Genv.find_symbol ge id = Some b /\\ vf = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend ->\n(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_default =>\n         Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     | Call_imm id =>\n         Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | Call_builtin ef => sel_builtin optid ef bl\n     end k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"match classify_call (prog_defmap cunit) a with\n| Call_default => True\n| Call_imm id =>\n    exists b : block,\n      Genv.find_symbol ge id = Some b /\\ vf = Vptr b Ptrofs.zero\n| Call_builtin ef => fd = External ef\nend ->\n(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_default =>\n         Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     | Call_imm id =>\n         Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | Call_builtin ef => sel_builtin optid ef bl\n     end k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_default =>\n            Scall optid (Cminor.funsig fd) (inl (sel_expr a))\n              (sel_exprlist bl)\n        | Call_imm id =>\n            Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | Call_builtin ef => sel_builtin optid ef bl\n        end k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"destruct (classify_call (prog_defmap cunit) a) as [ | id | ef].\nexploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & U & V & W).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto.\nintros [b [U V]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & X & Y & Z).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\nsubst vf.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto.\nintros EQ.\nsubst fd.\nright; left; split.\nsimpl; lia.\nsplit; auto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : True ->\n(exists T2 : state,\n   plus step tge\n     (State f'\n        (Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl))\n        k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f'\n     (Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)) k'\n     sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        (Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl))\n        k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"True ->\n(exists T2 : state,\n   plus step tge\n     (State f'\n        (Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl))\n        k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f'\n     (Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)) k'\n     sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        (Scall optid (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl))\n        k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"exploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & U & V & W).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (vf' : val) (A : eval_expr tge sp e' m' nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (U : Genv.find_funct tge vf' = Some fd') (V : match_fundef cunit' fd fd') (W : linkorder cunit' prog) (H2 : True) : match_call_cont (Cminor.Kcall optid f sp e k) (Kcall optid f' sp e' k').","conclusion":"match_call_cont (Cminor.Kcall optid f sp e k) (Kcall optid f' sp e' k')","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (vf' : val) (A : eval_expr tge sp e' m' nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (U : Genv.find_funct tge vf' = Some fd') (V : match_fundef cunit' fd fd') (W : linkorder cunit' prog) (H2 : True)","proofString":"eapply match_cont_call with (cunit := cunit) (hf := hf); eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) : (exists b : block, Genv.find_symbol ge id = Some b /\\ vf = Vptr b Ptrofs.zero) ->\n(exists T2 : state,\n   plus step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k' sp\n     e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists b : block, Genv.find_symbol ge id = Some b /\\ vf = Vptr b Ptrofs.zero) ->\n(exists T2 : state,\n   plus step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k' sp\n     e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident)","proofString":"intros [b [U V]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & X & Y & Z).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\nsubst vf.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) : (exists T2 : state,\n   plus step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k' sp\n     e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k' sp\n     e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Scall optid (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n        sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero)","proofString":"exploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & X & Y & Z).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\nsubst vf.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply match_cont_call with (cunit := cunit) (hf := hf); eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge vf = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog) : eval_expr_or_symbol tge sp e' m' nil (inr id) vf.","conclusion":"eval_expr_or_symbol tge sp e' m' nil (inr id) vf","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge vf = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog)","proofString":"subst vf.\neconstructor; eauto.\nrewrite symbols_preserved; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (b : block) (H : Cminor.eval_expr ge sp e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (U : Genv.find_symbol ge id = Some b) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog) : eval_expr_or_symbol tge sp e' m' nil (inr id) (Vptr b Ptrofs.zero).","conclusion":"eval_expr_or_symbol tge sp e' m' nil (inr id) (Vptr b Ptrofs.zero)","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (b : block) (H : Cminor.eval_expr ge sp e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (U : Genv.find_symbol ge id = Some b) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog)","proofString":"econstructor; eauto.\nrewrite symbols_preserved; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (b : block) (H : Cminor.eval_expr ge sp e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (U : Genv.find_symbol ge id = Some b) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog) : Genv.find_symbol tge id = Some b.","conclusion":"Genv.find_symbol tge id = Some b","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (b : block) (H : Cminor.eval_expr ge sp e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (U : Genv.find_symbol ge id = Some b) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog)","proofString":"rewrite symbols_preserved; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge vf = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog) : funsig fd' = Cminor.funsig fd.","conclusion":"funsig fd' = Cminor.funsig fd","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge vf = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog)","proofString":"eapply sig_function_translated; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge vf = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog) : match_call_cont (Cminor.Kcall optid f sp e k) (Kcall optid f' sp e' k').","conclusion":"match_call_cont (Cminor.Kcall optid f sp e k) (Kcall optid f' sp e' k')","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) (vargs' : list val) (C : eval_exprlist tge sp e' m' nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (X : Genv.find_funct tge vf = Some fd') (Y : match_fundef cunit' fd fd') (Z : linkorder cunit' prog)","proofString":"eapply match_cont_call with (cunit := cunit) (hf := hf); eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (ef : external_function) : fd = External ef ->\n(exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"fd = External ef ->\n(exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (ef : external_function)","proofString":"intros EQ.\nsubst fd.\nright; left; split.\nsimpl; lia.\nsplit; auto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (ef : external_function) (EQ : fd = External ef) : (exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig fd) a bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (ef : external_function) (EQ : fd = External ef)","proofString":"subst fd.\nright; left; split.\nsimpl; lia.\nsplit; auto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure\n   (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n      sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n     T2) \\/\n(measure\n   (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n      sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"right; left; split.\nsimpl; lia.\nsplit; auto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (measure\n   (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n      sp e m))%nat.","conclusion":"(measure\n   (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m) <\n measure\n   (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n      sp e m))%nat","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"simpl; lia."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : E0 = E0 /\\\nmatch_states\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m').","conclusion":"E0 = E0 /\\\nmatch_states\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m')","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"split; auto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : match_states\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m').","conclusion":"match_states\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k) m)\n  (State f' (sel_builtin optid ef bl) k' sp e' m')","hypotheses":"(f : Cminor.function) (optid : option ident) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (H : Cminor.eval_expr ge sp e m a vf) (H0 : Cminor.eval_exprlist ge sp e m bl vargs) (ef : external_function) (WTS : wt_state\n  (Cminor.State f (Cminor.Scall optid (Cminor.funsig (External ef)) a bl) k\n     sp e m)) (H1 : Genv.find_funct ge vf = Some (External ef)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"econstructor; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m2' [P Q]].\nerewrite <- stackspace_function_translated in P by eauto.\nexploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & E & F & G).\nleft; econstructor; split.\napply plus_one.\nexploit classify_call_correct.\neexact LINK.\neauto.\neauto.\ndestruct (classify_call (prog_defmap cunit)) as [ | id | ef]; intros.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\ndestruct H2 as [b [U V]].\nsubst vf.\ninv B.\neconstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"intros [m2' [P Q]].\nerewrite <- stackspace_function_translated in P by eauto.\nexploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & E & F & G).\nleft; econstructor; split.\napply plus_one.\nexploit classify_call_correct.\neexact LINK.\neauto.\neauto.\ndestruct (classify_call (prog_defmap cunit)) as [ | id | ef]; intros.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\ndestruct H2 as [b [U V]].\nsubst vf.\ninv B.\neconstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (P : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (Q : Mem.extends m' m2') : (exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (P : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (Q : Mem.extends m' m2')","proofString":"erewrite <- stackspace_function_translated in P by eauto.\nexploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & E & F & G).\nleft; econstructor; split.\napply plus_one.\nexploit classify_call_correct.\neexact LINK.\neauto.\neauto.\ndestruct (classify_call (prog_defmap cunit)) as [ | id | ef]; intros.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\ndestruct H2 as [b [U V]].\nsubst vf.\ninv B.\neconstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') : (exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   match_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Callstate fd vargs (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n      (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n  (State f'\n     match classify_call (prog_defmap cunit) a with\n     | Call_imm id => Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n     | _ => Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n     end k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f'\n        match classify_call (prog_defmap cunit) a with\n        | Call_imm id =>\n            Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)\n        | _ =>\n            Stailcall (Cminor.funsig fd) (inl (sel_expr a)) (sel_exprlist bl)\n        end k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Callstate fd vargs (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2')","proofString":"exploit sel_expr_correct; eauto.\nintros [vf' [A B]].\nexploit sel_exprlist_correct; eauto.\nintros [vargs' [C D]].\nexploit functions_translated; eauto.\nintros (cunit' & fd' & E & F & G).\nleft; econstructor; split.\napply plus_one.\nexploit classify_call_correct.\neexact LINK.\neauto.\neauto.\ndestruct (classify_call (prog_defmap cunit)) as [ | id | ef]; intros.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\ndestruct H2 as [b [U V]].\nsubst vf.\ninv B.\neconstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto.\neconstructor; eauto.\neconstructor; eauto.\neapply sig_function_translated; eauto.\neapply match_callstate with (cunit := cunit'); eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero) : step tge\n  (State f' (Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n     (Vptr sp Ptrofs.zero) e' m'0) E0\n  (Callstate fd' vargs' (call_cont k') m2').","conclusion":"step tge\n  (State f' (Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n     (Vptr sp Ptrofs.zero) e' m'0) E0\n  (Callstate fd' vargs' (call_cont k') m2')","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (b : block) (U : Genv.find_symbol ge id = Some b) (V : vf = Vptr b Ptrofs.zero)","proofString":"subst vf.\ninv B.\neconstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef (Vptr b Ptrofs.zero) vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b) : step tge\n  (State f' (Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n     (Vptr sp Ptrofs.zero) e' m'0) E0\n  (Callstate fd' vargs' (call_cont k') m2').","conclusion":"step tge\n  (State f' (Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n     (Vptr sp Ptrofs.zero) e' m'0) E0\n  (Callstate fd' vargs' (call_cont k') m2')","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef (Vptr b Ptrofs.zero) vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b)","proofString":"inv B.\neconstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b) : step tge\n  (State f' (Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n     (Vptr sp Ptrofs.zero) e' m'0) E0\n  (Callstate fd' vargs' (call_cont k') m2').","conclusion":"step tge\n  (State f' (Stailcall (Cminor.funsig fd) (inr id) (sel_exprlist bl)) k'\n     (Vptr sp Ptrofs.zero) e' m'0) E0\n  (Callstate fd' vargs' (call_cont k') m2')","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b)","proofString":"econstructor; eauto.\neconstructor; eauto.\nrewrite symbols_preserved; eauto.\neapply sig_function_translated; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b) : eval_expr_or_symbol tge (Vptr sp Ptrofs.zero) e' m'0 nil \n  (inr id) (Vptr b Ptrofs.zero).","conclusion":"eval_expr_or_symbol tge (Vptr sp Ptrofs.zero) e' m'0 nil \n  (inr id) (Vptr b Ptrofs.zero)","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b)","proofString":"econstructor; eauto.\nrewrite symbols_preserved; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b) : Genv.find_symbol tge id = Some b.","conclusion":"Genv.find_symbol tge id = Some b","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b)","proofString":"rewrite symbols_preserved; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b) : funsig fd' = Cminor.funsig fd.","conclusion":"funsig fd' = Cminor.funsig fd","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (b : block) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a (Vptr b Ptrofs.zero)) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a)\n  (Vptr b Ptrofs.zero)) (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge (Vptr b Ptrofs.zero) = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (id : ident) (U : Genv.find_symbol ge id = Some b)","proofString":"eapply sig_function_translated; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (ef : external_function) (H2 : fd = External ef) : eval_expr_or_symbol tge (Vptr sp Ptrofs.zero) e' m'0 nil \n  (inl (sel_expr a)) vf'.","conclusion":"eval_expr_or_symbol tge (Vptr sp Ptrofs.zero) e' m'0 nil \n  (inl (sel_expr a)) vf'","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (ef : external_function) (H2 : fd = External ef)","proofString":"econstructor; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (ef : external_function) (H2 : fd = External ef) : funsig fd' = Cminor.funsig fd.","conclusion":"funsig fd' = Cminor.funsig fd","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) (ef : external_function) (H2 : fd = External ef)","proofString":"eapply sig_function_translated; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog) : match_call_cont (Cminor.call_cont k) (call_cont k').","conclusion":"match_call_cont (Cminor.call_cont k) (call_cont k')","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (bl : list Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : Cminor.fundef) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : Cminor.eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Stailcall (Cminor.funsig fd) a bl) k\n     (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (vf' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) vf') (B : Val.lessdef vf vf') (vargs' : list val) (C : eval_exprlist tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_exprlist bl) vargs') (D : Val.lessdef_list vargs vargs') (cunit' : Cminor.program) (fd' : fundef) (E : Genv.find_funct tge vf' = Some fd') (F : match_fundef cunit' fd fd') (G : linkorder cunit' prog)","proofString":"eapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (optid : option ident) (ef : external_function) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : Cminor.eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.State f (Cminor.Sbuiltin optid ef bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m'0) t T2 /\\\n   match_states\n     (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m') T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m') <\n measure (Cminor.State f (Cminor.Sbuiltin optid ef bl) k sp e m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m')\n  (State f' (sel_builtin optid ef bl) k' sp e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m'0) t T2 /\\\n   eventually n\n     (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef bl) k' sp e' m'0) t T2 /\\\n   match_states\n     (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m') T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m') <\n measure (Cminor.State f (Cminor.Sbuiltin optid ef bl) k sp e m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m')\n  (State f' (sel_builtin optid ef bl) k' sp e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef bl) k' sp e' m'0) t T2 /\\\n   eventually n\n     (Cminor.State f Cminor.Sskip k sp (set_optvar optid vres e) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (optid : option ident) (ef : external_function) (bl : list Cminor.expr) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : Cminor.eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.State f (Cminor.Sbuiltin optid ef bl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit sel_builtin_correct; eauto.\nintros (e2' & m2' & P & Q & R).\nleft; econstructor; split.\neexact P.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) env s1 x = OK x0) : (exists T2 : state,\n   plus step tge (State f' (Sseq x0 x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m) T2) \\/\n(measure (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m) <\n measure (Cminor.State f (Cminor.Sseq s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n  (State f' (Sseq x0 x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sseq x0 x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sseq x0 x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m) T2) \\/\n(measure (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m) <\n measure (Cminor.State f (Cminor.Sseq s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n  (State f' (Sseq x0 x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sseq x0 x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s1 (Cminor.Kseq s2 k) sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) env s1 x = OK x0)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) env s1 x = OK x0) : match_cont cunit hf (known_id f) env (Cminor.Kseq s2 k) (Kseq x k').","conclusion":"match_cont cunit hf (known_id f) env (Cminor.Kseq s2 k) (Kseq x k')","hypotheses":"(f : Cminor.function) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sseq s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s2 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) env s1 x = OK x0)","proofString":"econstructor; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.Sifthenelse a s1 s2)\n  kont = OK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.Sifthenelse a s1 s2)\n  kont = OK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"simpl in TS.\ndestruct if_conversion as [s|] eqn:IFC; monadInv TS.\ninv WTS.\ninv WT_FN.\nassert (env0 = env) by congruence.\nsubst env0.\ninv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\nassert (Val.bool_of_val v' b).\ninv B.\nauto.\ninv H0.\nleft; exists (State f' (if b then x else x0) k' sp e' m'); split.\napply plus_one; econstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\neconstructor; eauto.\ndestruct b; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : match if_conversion (known_id f) env a s1 s2 kont with\n| Some s => OK s\n| None =>\n    do ifso' <- sel_stmt (prog_defmap cunit) (known_id f) env s1 kont;\n    do ifnot' <- sel_stmt (prog_defmap cunit) (known_id f) env s2 kont;\n    OK (Sifthenelse (condexpr_of_expr (sel_expr a)) ifso' ifnot')\nend = OK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : match if_conversion (known_id f) env a s1 s2 kont with\n| Some s => OK s\n| None =>\n    do ifso' <- sel_stmt (prog_defmap cunit) (known_id f) env s1 kont;\n    do ifnot' <- sel_stmt (prog_defmap cunit) (known_id f) env s2 kont;\n    OK (Sifthenelse (condexpr_of_expr (sel_expr a)) ifso' ifnot')\nend = OK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"destruct if_conversion as [s|] eqn:IFC; monadInv TS.\ninv WTS.\ninv WT_FN.\nassert (env0 = env) by congruence.\nsubst env0.\ninv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\nassert (Val.bool_of_val v' b).\ninv B.\nauto.\ninv H0.\nleft; exists (State f' (if b then x else x0) k' sp e' m'); split.\napply plus_one; econstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\neconstructor; eauto.\ndestruct b; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv WTS.\ninv WT_FN.\nassert (env0 = env) by congruence.\nsubst env0.\ninv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (env0 : typenv) (WT_FN : wt_function env0 f) (WT_STMT : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (WT_CONT : wt_cont env0 (sig_res (Cminor.fn_sig f)) k) (WT_ENV : wt_env env0 e) (DEF_ENV : def_env f e) : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (env0 : typenv) (WT_FN : wt_function env0 f) (WT_STMT : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (WT_CONT : wt_cont env0 (sig_res (Cminor.fn_sig f)) k) (WT_ENV : wt_env env0 e) (DEF_ENV : def_env f e)","proofString":"inv WT_FN.\nassert (env0 = env) by congruence.\nsubst env0.\ninv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (env0 : typenv) (WT_STMT : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (WT_CONT : wt_cont env0 (sig_res (Cminor.fn_sig f)) k) (WT_ENV : wt_env env0 e) (DEF_ENV : def_env f e) (H1 : type_function f = OK env0) (H2 : map env0 (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H3 : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (env0 : typenv) (WT_STMT : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (WT_CONT : wt_cont env0 (sig_res (Cminor.fn_sig f)) k) (WT_ENV : wt_env env0 e) (DEF_ENV : def_env f e) (H1 : type_function f = OK env0) (H2 : map env0 (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H3 : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f))","proofString":"assert (env0 = env) by congruence.\nsubst env0.\ninv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (env0 : typenv) (WT_STMT : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (WT_CONT : wt_cont env0 (sig_res (Cminor.fn_sig f)) k) (WT_ENV : wt_env env0 e) (DEF_ENV : def_env f e) (H1 : type_function f = OK env0) (H2 : map env0 (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H3 : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H4 : env0 = env) : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (env0 : typenv) (WT_STMT : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (WT_CONT : wt_cont env0 (sig_res (Cminor.fn_sig f)) k) (WT_ENV : wt_env env0 e) (DEF_ENV : def_env f e) (H1 : type_function f = OK env0) (H2 : map env0 (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H3 : wt_stmt env0 (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H4 : env0 = env)","proofString":"subst env0.\ninv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (WT_ENV : wt_env env e) (WT_CONT : wt_cont env (sig_res (Cminor.fn_sig f)) k) (WT_STMT : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H2 : map env (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H1 : type_function f = OK env) : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (WT_ENV : wt_env env e) (WT_CONT : wt_cont env (sig_res (Cminor.fn_sig f)) k) (WT_STMT : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.Sifthenelse a s1 s2)) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H2 : map env (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H1 : type_function f = OK env)","proofString":"inv WT_STMT.\nexploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (WT_ENV : wt_env env e) (WT_CONT : wt_cont env (sig_res (Cminor.fn_sig f)) k) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H2 : map env (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H1 : type_function f = OK env) (H7 : wt_expr env a Tint) (H8 : wt_stmt env (sig_res (Cminor.fn_sig f)) s1) (H9 : wt_stmt env (sig_res (Cminor.fn_sig f)) s2) : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (WT_ENV : wt_env env e) (WT_CONT : wt_cont env (sig_res (Cminor.fn_sig f)) k) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H2 : map env (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H1 : type_function f = OK env) (H7 : wt_expr env a Tint) (H8 : wt_stmt env (sig_res (Cminor.fn_sig f)) s1) (H9 : wt_stmt env (sig_res (Cminor.fn_sig f)) s2)","proofString":"exploit if_conversion_correct; eauto.\nset (s0 := if b then s1 else s2).\nintros (n & e1 & e1' & A & B & C).\nright; right.\neconstructor; exists n.\nsplit.\neexact A.\neapply eventually_implies.\neexact B.\nintros S3 EQ; subst S3.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (WT_ENV : wt_env env e) (WT_CONT : wt_cont env (sig_res (Cminor.fn_sig f)) k) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H2 : map env (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H1 : type_function f = OK env) (H7 : wt_expr env a Tint) (H8 : wt_stmt env (sig_res (Cminor.fn_sig f)) s1) (H9 : wt_stmt env (sig_res (Cminor.fn_sig f)) s2) (s0 : Cminor.stmt) (n : nat) (e1 e1' : Cminor.env) (A : step tge (State f' s' k' sp e' m') E0 (State f' Sskip k' sp e1' m')) (B : eventually n (Cminor.State f s0 k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e1 m))) (C : env_lessdef e1 e1') : match_states (Cminor.State f Cminor.Sskip k sp e1 m)\n  (State f' Sskip k' sp e1' m').","conclusion":"match_states (Cminor.State f Cminor.Sskip k sp e1 m)\n  (State f' Sskip k' sp e1' m')","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = Some s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (WT_ENV : wt_env env e) (WT_CONT : wt_cont env (sig_res (Cminor.fn_sig f)) k) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (Cminor.fn_sig f)) (Cminor.fn_body f)) (H2 : map env (Cminor.fn_params f) = proj_sig_args (Cminor.fn_sig f)) (H1 : type_function f = OK env) (H7 : wt_expr env a Tint) (H8 : wt_stmt env (sig_res (Cminor.fn_sig f)) s1) (H9 : wt_stmt env (sig_res (Cminor.fn_sig f)) s2) (s0 : Cminor.stmt) (n : nat) (e1 e1' : Cminor.env) (A : step tge (State f' s' k' sp e' m') E0 (State f' Sskip k' sp e1' m')) (B : eventually n (Cminor.State f s0 k sp e m)\n  (eq (Cminor.State f Cminor.Sskip k sp e1 m))) (C : env_lessdef e1 e1')","proofString":"eauto using match_states_skip."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = None) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) env s2 kont = OK x0) : (exists T2 : state,\n   plus step tge\n     (State f' (Sifthenelse (condexpr_of_expr (sel_expr a)) x x0) k' sp e' m')\n     E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' (Sifthenelse (condexpr_of_expr (sel_expr a)) x x0) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sifthenelse (condexpr_of_expr (sel_expr a)) x x0) k' sp e' m')\n     E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Sifthenelse (condexpr_of_expr (sel_expr a)) x x0) k' sp e' m')\n     E0 T2 /\\\n   match_states (Cminor.State f (if b then s1 else s2) k sp e m) T2) \\/\n(measure (Cminor.State f (if b then s1 else s2) k sp e m) <\n measure (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (if b then s1 else s2) k sp e m)\n  (State f' (Sifthenelse (condexpr_of_expr (sel_expr a)) x x0) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sifthenelse (condexpr_of_expr (sel_expr a)) x x0) k' sp e' m')\n     E0 T2 /\\\n   eventually n (Cminor.State f (if b then s1 else s2) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (s1 s2 : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : Cminor.eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (WTS : wt_state (Cminor.State f (Cminor.Sifthenelse a s1 s2) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (IFC : if_conversion (known_id f) env a s1 s2 kont = None) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s1 kont = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) env s2 kont = OK x0)","proofString":"exploit sel_expr_correct; eauto.\nintros [v' [A B]].\nassert (Val.bool_of_val v' b).\ninv B.\nauto.\ninv H0.\nleft; exists (State f' (if b then x else x0) k' sp e' m'); split.\napply plus_one; econstructor; eauto.\neapply eval_condexpr_of_expr; eauto.\neconstructor; eauto.\ndestruct b; eauto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sloop s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s Sskip = OK x) : (exists T2 : state,\n   plus step tge (State f' (Sloop x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m) T2) \\/\n(measure (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m) <\n measure (Cminor.State f (Cminor.Sloop s) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m)\n  (State f' (Sloop x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sloop x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sloop x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m) T2) \\/\n(measure (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m) <\n measure (Cminor.State f (Cminor.Sloop s) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m)\n  (State f' (Sloop x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sloop x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s (Cminor.Kseq (Cminor.Sloop s) k) sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sloop s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s Sskip = OK x)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neconstructor; eauto.\napply match_cont_seq with Sskip; auto.\nsimpl; rewrite EQ; auto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sloop s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s Sskip = OK x) : match_cont cunit hf (known_id f) env (Cminor.Kseq (Cminor.Sloop s) k)\n  (Kseq (Sloop x) k').","conclusion":"match_cont cunit hf (known_id f) env (Cminor.Kseq (Cminor.Sloop s) k)\n  (Kseq (Sloop x) k')","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sloop s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s Sskip = OK x)","proofString":"apply match_cont_seq with Sskip; auto.\nsimpl; rewrite EQ; auto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sloop s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s Sskip = OK x) : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.Sloop s) Sskip =\nOK (Sloop x).","conclusion":"sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.Sloop s) Sskip =\nOK (Sloop x)","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sloop s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s Sskip = OK x)","proofString":"simpl; rewrite EQ; auto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sblock s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s kont = OK x) : (exists T2 : state,\n   plus step tge (State f' (Sblock x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s (Cminor.Kblock k) sp e m) T2) \\/\n(measure (Cminor.State f s (Cminor.Kblock k) sp e m) <\n measure (Cminor.State f (Cminor.Sblock s) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s (Cminor.Kblock k) sp e m)\n  (State f' (Sblock x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sblock x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s (Cminor.Kblock k) sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sblock x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s (Cminor.Kblock k) sp e m) T2) \\/\n(measure (Cminor.State f s (Cminor.Kblock k) sp e m) <\n measure (Cminor.State f (Cminor.Sblock s) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s (Cminor.Kblock k) sp e m)\n  (State f' (Sblock x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sblock x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s (Cminor.Kblock k) sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sblock s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s kont = OK x)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sblock s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s kont = OK x) : match_cont cunit hf (known_id f) env (Cminor.Kblock k) (Kblock k').","conclusion":"match_cont cunit hf (known_id f) env (Cminor.Kblock k) (Kblock k')","hypotheses":"(f : Cminor.function) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sblock s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s kont = OK x)","proofString":"constructor; auto."},{"statement":"(f : Cminor.function) (n : nat) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kseq s k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit n) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit n) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (n : nat) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kseq s k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv MC.\nleft; econstructor; split.\napply plus_one; constructor.\neapply match_state with (kont := Sskip); eauto.\ninv H."},{"statement":"(f : Cminor.function) (n : nat) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (kont0 s' : stmt) (k'0 : cont) (H5 : sel_stmt (prog_defmap cunit) (known_id f) env s kont0 = OK s') (H7 : match_cont cunit hf (known_id f) env k k'0) : (exists T2 : state,\n   plus step tge (State f' (Sexit n) (Kseq s' k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit n) (Kseq s' k'0) sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit n) (Kseq s' k'0) sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit n) (Kseq s' k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit n) (Kseq s' k'0) sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit n) (Kseq s' k'0) sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (n : nat) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (kont0 s' : stmt) (k'0 : cont) (H5 : sel_stmt (prog_defmap cunit) (known_id f) env s kont0 = OK s') (H7 : match_cont cunit hf (known_id f) env k k'0)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (n : nat) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kseq s k) k') : (exists T2 : state,\n   plus step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit n) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit n) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit n) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (n : nat) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit n) (Cminor.Kseq s k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kseq s k) k')","proofString":"inv H."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kblock k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' (Sexit 0) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' (Sexit 0) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kblock k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv MC.\nleft; econstructor; split.\napply plus_one; constructor.\neauto using match_states_skip.\ninv H."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (k'0 : cont) (H4 : match_cont cunit hf (known_id f) env k k'0) : (exists T2 : state,\n   plus step tge (State f' (Sexit 0) (Kblock k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' (Sexit 0) (Kblock k'0) sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sexit 0) (Kblock k'0) sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit 0) (Kblock k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' (Sexit 0) (Kblock k'0) sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sexit 0) (Kblock k'0) sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (k'0 : cont) (H4 : match_cont cunit hf (known_id f) env k k'0)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neauto using match_states_skip."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kblock k) k') : (exists T2 : state,\n   plus step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' (Sexit 0) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp e m) T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp e m) <\n measure (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp e m)\n  (State f' (Sexit 0) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sexit 0) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit 0) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kblock k) k')","proofString":"inv H."},{"statement":"(f : Cminor.function) (n : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kblock k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit (S n)) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit (S n)) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (n : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env (Cminor.Kblock k) k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv MC.\nleft; econstructor; split.\napply plus_one; constructor.\neapply match_state with (kont := Sskip); eauto.\ninv H."},{"statement":"(f : Cminor.function) (n : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (k'0 : cont) (H4 : match_cont cunit hf (known_id f) env k k'0) : (exists T2 : state,\n   plus step tge (State f' (Sexit (S n)) (Kblock k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit (S n)) (Kblock k'0) sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit (S n)) (Kblock k'0) sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit (S n)) (Kblock k'0) sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit (S n)) (Kblock k'0) sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit (S n)) (Kblock k'0) sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (n : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (k'0 : cont) (H4 : match_cont cunit hf (known_id f) env k k'0)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (n : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kblock k) k') : (exists T2 : state,\n   plus step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit (S n)) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f (Cminor.Sexit n) k sp e m) T2) \\/\n(measure (Cminor.State f (Cminor.Sexit n) k sp e m) <\n measure (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f (Cminor.Sexit n) k sp e m)\n  (State f' (Sexit (S n)) k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' (Sexit (S n)) k' sp e' m') E0 T2 /\\\n   eventually n0 (Cminor.State f (Cminor.Sexit n) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (n : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Sexit (S n)) (Cminor.Kblock k) sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H : match_call_cont (Cminor.Kblock k) k')","proofString":"inv H."},{"statement":"(f : Cminor.function) (islong : bool) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (n : Z) (H : Cminor.eval_expr ge sp e m a v) (H0 : switch_argument islong v n) (WTS : wt_state (Cminor.State f (Cminor.Sswitch islong a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : sel_stmt (prog_defmap cunit) (known_id f) env\n  (Cminor.Sswitch islong a cases default) kont = OK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m)\n     T2) \\/\n(measure\n   (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch islong a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n0\n     (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m)\n     T2) \\/\n(measure\n   (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch islong a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n0 : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n0\n     (Cminor.State f (Cminor.Sexit (switch_target n default cases)) k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (islong : bool) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (n : Z) (H : Cminor.eval_expr ge sp e m a v) (H0 : switch_argument islong v n) (WTS : wt_state (Cminor.State f (Cminor.Sswitch islong a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : sel_stmt (prog_defmap cunit) (known_id f) env\n  (Cminor.Sswitch islong a cases default) kont = OK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"inv H0; simpl in TS.\nset (ct := compile_switch Int.modulus default cases) in *.\ndestruct (validate_switch Int.modulus default cases ct) eqn:VALID; inv TS.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_int_correct; eauto.\neapply match_state with (kont := Sskip); eauto.\nset (ct := compile_switch Int64.modulus default cases) in *.\ndestruct (validate_switch Int64.modulus default cases ct) eqn:VALID; inv TS.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_long_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int) (H : Cminor.eval_expr ge sp e m a (Vint i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : (if\n  validate_switch Int.modulus default cases\n    (compile_switch Int.modulus default cases)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr a)\n          (sel_switch_int 0 (compile_switch Int.modulus default cases))))\n else Error (msg \"Selection: bad switch (int)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int) (H : Cminor.eval_expr ge sp e m a (Vint i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : (if\n  validate_switch Int.modulus default cases\n    (compile_switch Int.modulus default cases)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr a)\n          (sel_switch_int 0 (compile_switch Int.modulus default cases))))\n else Error (msg \"Selection: bad switch (int)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"set (ct := compile_switch Int.modulus default cases) in *.\ndestruct (validate_switch Int.modulus default cases ct) eqn:VALID; inv TS.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_int_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int) (H : Cminor.eval_expr ge sp e m a (Vint i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (TS : (if validate_switch Int.modulus default cases ct\n then OK (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct)))\n else Error (msg \"Selection: bad switch (int)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int) (H : Cminor.eval_expr ge sp e m a (Vint i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (TS : (if validate_switch Int.modulus default cases ct\n then OK (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct)))\n else Error (msg \"Selection: bad switch (int)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"destruct (validate_switch Int.modulus default cases ct) eqn:VALID; inv TS.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_int_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int) (H : Cminor.eval_expr ge sp e m a (Vint i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (VALID : validate_switch Int.modulus default cases ct = true) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m)\n  (State f' (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct))) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m) <\n measure (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e m)\n  (State f' (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct))) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_int 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int.unsigned i) default cases)) k sp e\n        m) (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int) (H : Cminor.eval_expr ge sp e m a (Vint i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch false a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (VALID : validate_switch Int.modulus default cases ct = true) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"exploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_int_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int64) (H : Cminor.eval_expr ge sp e m a (Vlong i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : (if\n  validate_switch Int64.modulus default cases\n    (compile_switch Int64.modulus default cases)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr a)\n          (sel_switch_long 0 (compile_switch Int64.modulus default cases))))\n else Error (msg \"Selection: bad switch (long)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e\n      m) <\n measure (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e\n      m) <\n measure (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int64) (H : Cminor.eval_expr ge sp e m a (Vlong i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (TS : (if\n  validate_switch Int64.modulus default cases\n    (compile_switch Int64.modulus default cases)\n then\n  OK\n    (Sswitch\n       (XElet (sel_expr a)\n          (sel_switch_long 0 (compile_switch Int64.modulus default cases))))\n else Error (msg \"Selection: bad switch (long)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"set (ct := compile_switch Int64.modulus default cases) in *.\ndestruct (validate_switch Int64.modulus default cases ct) eqn:VALID; inv TS.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_long_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int64) (H : Cminor.eval_expr ge sp e m a (Vlong i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (TS : (if validate_switch Int64.modulus default cases ct\n then OK (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct)))\n else Error (msg \"Selection: bad switch (long)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e\n      m) <\n measure (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' s' k' sp e' m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e\n      m) <\n measure (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e m)\n  (State f' s' k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' s' k' sp e' m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int64) (H : Cminor.eval_expr ge sp e m a (Vlong i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont s' : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (TS : (if validate_switch Int64.modulus default cases ct\n then OK (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct)))\n else Error (msg \"Selection: bad switch (long)\")) = \nOK s') (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"destruct (validate_switch Int64.modulus default cases ct) eqn:VALID; inv TS.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_long_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int64) (H : Cminor.eval_expr ge sp e m a (Vlong i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (VALID : validate_switch Int64.modulus default cases ct = true) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e\n      m) <\n measure (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e m)\n  (State f' (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct))) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   match_states\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) T2) \\/\n(measure\n   (Cminor.State f\n      (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e\n      m) <\n measure (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f\n     (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp e m)\n  (State f' (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct))) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sswitch (XElet (sel_expr a) (sel_switch_long 0 ct))) k' sp e'\n        m') E0 T2 /\\\n   eventually n\n     (Cminor.State f\n        (Cminor.Sexit (switch_target (Int64.unsigned i) default cases)) k sp\n        e m) (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (cases : list (Z * nat)) (default : nat) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (i : int64) (H : Cminor.eval_expr ge sp e m a (Vlong i)) (WTS : wt_state (Cminor.State f (Cminor.Sswitch true a cases default) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (ct : comptree) (VALID : validate_switch Int64.modulus default cases ct = true) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"exploit sel_expr_correct; eauto.\nintros [v' [A B]].\ninv B.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply sel_switch_long_correct; eauto.\neapply match_state with (kont := Sskip); eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m2' [P Q]].\nerewrite <- stackspace_function_translated in P by eauto.\nleft; econstructor; split.\napply plus_one; econstructor.\nsimpl; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"intros [m2' [P Q]].\nerewrite <- stackspace_function_translated in P by eauto.\nleft; econstructor; split.\napply plus_one; econstructor.\nsimpl; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (P : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (Q : Mem.extends m' m2') : (exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (P : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (Q : Mem.extends m' m2')","proofString":"erewrite <- stackspace_function_translated in P by eauto.\nleft; econstructor; split.\napply plus_one; econstructor.\nsimpl; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') : (exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0\n     T2 /\\\n   match_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate Vundef (Cminor.call_cont k) m') <\n measure (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n  (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sreturn None) k' (Vptr sp Ptrofs.zero) e' m'0) E0 T2 /\\\n   eventually n (Cminor.Returnstate Vundef (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2')","proofString":"left; econstructor; split.\napply plus_one; econstructor.\nsimpl; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') : match_call_cont (Cminor.call_cont k) (call_cont k').","conclusion":"match_call_cont (Cminor.call_cont k) (call_cont k')","hypotheses":"(f : Cminor.function) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state (Cminor.State f (Cminor.Sreturn None) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2')","proofString":"eapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m2' [P Q]].\nerewrite <- stackspace_function_translated in P by eauto.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists m2' : mem,\n   Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2' /\\\n   Mem.extends m' m2') ->\n(exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"intros [m2' [P Q]].\nerewrite <- stackspace_function_translated in P by eauto.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (P : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (Q : Mem.extends m' m2') : (exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (P : Mem.free m'0 sp 0 (Cminor.fn_stackspace f) = Some m2') (Q : Mem.extends m' m2')","proofString":"erewrite <- stackspace_function_translated in P by eauto.\nexploit sel_expr_correct; eauto.\nintros [v' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') : (exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\ match_states (Cminor.Returnstate v (Cminor.call_cont k) m') T2) \\/\n(measure (Cminor.Returnstate v (Cminor.call_cont k) m') <\n measure\n   (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.Returnstate v (Cminor.call_cont k) m')\n  (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (State f' (Sreturn (Some (sel_expr a))) k' (Vptr sp Ptrofs.zero) e' m'0)\n     E0 T2 /\\\n   eventually n (Cminor.Returnstate v (Cminor.call_cont k) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2')","proofString":"exploit sel_expr_correct; eauto.\nintros [v' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto.\neapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (v' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) v') (B : Val.lessdef v v') : match_call_cont (Cminor.call_cont k) (call_cont k').","conclusion":"match_call_cont (Cminor.call_cont k) (call_cont k')","hypotheses":"(f : Cminor.function) (a : Cminor.expr) (k : Cminor.cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : Cminor.eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (Cminor.fn_stackspace f) = Some m') (WTS : wt_state\n  (Cminor.State f (Cminor.Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m'0) (m2' : mem) (Q : Mem.extends m' m2') (P : Mem.free m'0 sp 0 (fn_stackspace f') = Some m2') (v' : val) (A : eval_expr tge (Vptr sp Ptrofs.zero) e' m'0 nil (sel_expr a) v') (B : Val.lessdef v v')","proofString":"eapply call_cont_commut; eauto."},{"statement":"(f : Cminor.function) (lbl : label) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Slabel lbl s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s kont = OK x) : (exists T2 : state,\n   plus step tge (State f' (Slabel lbl x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f (Cminor.Slabel lbl s) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m)\n  (State f' (Slabel lbl x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Slabel lbl x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Slabel lbl x) k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s k sp e m) T2) \\/\n(measure (Cminor.State f s k sp e m) <\n measure (Cminor.State f (Cminor.Slabel lbl s) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s k sp e m)\n  (State f' (Slabel lbl x) k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Slabel lbl x) k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s k sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (lbl : label) (s : Cminor.stmt) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (WTS : wt_state (Cminor.State f (Cminor.Slabel lbl s) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k' : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : stmt) (EQ : sel_stmt (prog_defmap cunit) (known_id f) env s kont = OK x)","proofString":"left; econstructor; split.\napply plus_one; constructor.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"assert (sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip = OK (fn_body f')).\nmonadInv TF; simpl.\ncongruence.\nexploit (find_label_commut cunit hf (known_id f) env lbl (Cminor.fn_body f) Sskip (Cminor.call_cont k)).\napply match_cont_other.\neapply call_cont_commut; eauto.\neauto.\nrewrite H.\ndestruct (find_label lbl (fn_body f') (call_cont k'0))  as [[s'' k'']|] eqn:?; intros; try contradiction.\ndestruct H1 as (cont1 & P & Q).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f').","conclusion":"sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m')","proofString":"monadInv TF; simpl.\ncongruence."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : typenv) (EQ : type_function f = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) x (Cminor.fn_body f) Sskip = OK x0) : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK x0.","conclusion":"sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK x0","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (x : typenv) (EQ : type_function f = OK x) (x0 : stmt) (EQ1 : sel_stmt (prog_defmap cunit) (known_id f) x (Cminor.fn_body f) Sskip = OK x0)","proofString":"congruence."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')) : (exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f'))","proofString":"exploit (find_label_commut cunit hf (known_id f) env lbl (Cminor.fn_body f) Sskip (Cminor.call_cont k)).\napply match_cont_other.\neapply call_cont_commut; eauto.\neauto.\nrewrite H.\ndestruct (find_label lbl (fn_body f') (call_cont k'0))  as [[s'' k'']|] eqn:?; intros; try contradiction.\ndestruct H1 as (cont1 & P & Q).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')) : match find_label lbl (fn_body f') (call_cont k'0) with\n| Some (s1', k1') =>\n    exists kont1 : stmt,\n      sel_stmt (prog_defmap cunit) (known_id f) env s' kont1 = OK s1' /\\\n      match_cont cunit hf (known_id f) env k' k1'\n| None => False\nend ->\n(exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"match find_label lbl (fn_body f') (call_cont k'0) with\n| Some (s1', k1') =>\n    exists kont1 : stmt,\n      sel_stmt (prog_defmap cunit) (known_id f) env s' kont1 = OK s1' /\\\n      match_cont cunit hf (known_id f) env k' k1'\n| None => False\nend ->\n(exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f'))","proofString":"destruct (find_label lbl (fn_body f') (call_cont k'0))  as [[s'' k'']|] eqn:?; intros; try contradiction.\ndestruct H1 as (cont1 & P & Q).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')) (s'' : stmt) (k'' : cont) (Heqo : find_label lbl (fn_body f') (call_cont k'0) = Some (s'', k'')) (H1 : exists kont1 : stmt,\n  sel_stmt (prog_defmap cunit) (known_id f) env s' kont1 = OK s'' /\\\n  match_cont cunit hf (known_id f) env k' k'') : (exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')) (s'' : stmt) (k'' : cont) (Heqo : find_label lbl (fn_body f') (call_cont k'0) = Some (s'', k'')) (H1 : exists kont1 : stmt,\n  sel_stmt (prog_defmap cunit) (known_id f) env s' kont1 = OK s'' /\\\n  match_cont cunit hf (known_id f) env k' k'')","proofString":"destruct H1 as (cont1 & P & Q).\nleft; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')) (s'' : stmt) (k'' : cont) (Heqo : find_label lbl (fn_body f') (call_cont k'0) = Some (s'', k'')) (cont1 : stmt) (P : sel_stmt (prog_defmap cunit) (known_id f) env s' cont1 = OK s'') (Q : match_cont cunit hf (known_id f) env k' k'') : (exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   match_states (Cminor.State f s' k' sp e m) T2) \\/\n(measure (Cminor.State f s' k' sp e m) <\n measure (Cminor.State f (Cminor.Sgoto lbl) k sp e m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f s' k' sp e m)\n  (State f' (Sgoto lbl) k'0 sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (Sgoto lbl) k'0 sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f s' k' sp e m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (lbl : label) (k : Cminor.cont) (sp : val) (e : Cminor.env) (m : mem) (s' : Cminor.stmt) (k' : Cminor.cont) (H : Cminor.find_label lbl (Cminor.fn_body f) (Cminor.call_cont k) = Some (s', k')) (WTS : wt_state (Cminor.State f (Cminor.Sgoto lbl) k sp e m)) (cunit : Cminor.program) (hf : helper_functions) (f' : function) (kont : stmt) (k'0 : cont) (e' : Cminor.env) (m' : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k'0) (LD : env_lessdef e e') (ME0 : Mem.extends m m') (H0 : sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) Sskip =\nOK (fn_body f')) (s'' : stmt) (k'' : cont) (Heqo : find_label lbl (fn_body f') (call_cont k'0) = Some (s'', k'')) (cont1 : stmt) (P : sel_stmt (prog_defmap cunit) (known_id f) env s' cont1 = OK s'') (Q : match_cont cunit hf (known_id f) env k' k'')","proofString":"left; econstructor; split.\napply plus_one; econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (TF : match_fundef cunit (Internal f) f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (TF : match_fundef cunit (Internal f) f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0)","proofString":"destruct TF as (hf & HF & TF).\nmonadInv TF.\ngeneralize EQ; intros TF; monadInv TF.\nexploit Mem.alloc_extends.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m2' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; simpl; eauto using Val.has_argtype_list_lessdef.\neconstructor; simpl; eauto.\napply match_cont_other; auto.\napply set_locals_lessdef.\napply set_params_lessdef; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (TF : sel_fundef (prog_defmap cunit) hf (Internal f) = OK f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (TF : sel_fundef (prog_defmap cunit) hf (Internal f) = OK f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0)","proofString":"monadInv TF.\ngeneralize EQ; intros TF; monadInv TF.\nexploit Mem.alloc_extends.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m2' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; simpl; eauto using Val.has_argtype_list_lessdef.\neconstructor; simpl; eauto.\napply match_cont_other; auto.\napply set_locals_lessdef.\napply set_params_lessdef; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x : function) (EQ : sel_function (prog_defmap cunit) hf f = OK x) : (exists T2 : state,\n   plus step tge (Callstate (Internal x) args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m') (Callstate (Internal x) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (Internal x) args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate (Internal x) args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m') (Callstate (Internal x) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (Internal x) args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x : function) (EQ : sel_function (prog_defmap cunit) hf f = OK x)","proofString":"generalize EQ; intros TF; monadInv TF.\nexploit Mem.alloc_extends.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m2' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; simpl; eauto using Val.has_argtype_list_lessdef.\neconstructor; simpl; eauto.\napply match_cont_other; auto.\napply set_locals_lessdef.\napply set_params_lessdef; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) : (exists T2 : state,\n   plus step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m')\n  (Callstate\n     (Internal\n        {|\n          fn_sig := Cminor.fn_sig f;\n          fn_params := Cminor.fn_params f;\n          fn_vars := Cminor.fn_vars f;\n          fn_stackspace := Cminor.fn_stackspace f;\n          fn_body := x1\n        |}) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m')\n  (Callstate\n     (Internal\n        {|\n          fn_sig := Cminor.fn_sig f;\n          fn_params := Cminor.fn_params f;\n          fn_vars := Cminor.fn_vars f;\n          fn_stackspace := Cminor.fn_stackspace f;\n          fn_body := x1\n        |}) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1)","proofString":"exploit Mem.alloc_extends.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m2' [A B]].\nleft; econstructor; split.\napply plus_one; econstructor; simpl; eauto using Val.has_argtype_list_lessdef.\neconstructor; simpl; eauto.\napply match_cont_other; auto.\napply set_locals_lessdef.\napply set_params_lessdef; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2') : (exists T2 : state,\n   plus step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m')\n  (Callstate\n     (Internal\n        {|\n          fn_sig := Cminor.fn_sig f;\n          fn_params := Cminor.fn_params f;\n          fn_vars := Cminor.fn_vars f;\n          fn_stackspace := Cminor.fn_stackspace f;\n          fn_body := x1\n        |}) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   match_states\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m') T2) \\/\n(measure\n   (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n      (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n      m') < measure (Cminor.Callstate (Internal f) vargs k m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n     m')\n  (Callstate\n     (Internal\n        {|\n          fn_sig := Cminor.fn_sig f;\n          fn_params := Cminor.fn_params f;\n          fn_vars := Cminor.fn_vars f;\n          fn_stackspace := Cminor.fn_stackspace f;\n          fn_body := x1\n        |}) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge\n     (Callstate\n        (Internal\n           {|\n             fn_sig := Cminor.fn_sig f;\n             fn_params := Cminor.fn_params f;\n             fn_vars := Cminor.fn_vars f;\n             fn_stackspace := Cminor.fn_stackspace f;\n             fn_body := x1\n           |}) args' k' m'0) E0 T2 /\\\n   eventually n\n     (Cminor.State f (Cminor.fn_body f) k (Vptr sp Ptrofs.zero)\n        (set_locals (Cminor.fn_vars f)\n           (set_params vargs (Cminor.fn_params f))) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2')","proofString":"left; econstructor; split.\napply plus_one; econstructor; simpl; eauto using Val.has_argtype_list_lessdef.\neconstructor; simpl; eauto.\napply match_cont_other; auto.\napply set_locals_lessdef.\napply set_params_lessdef; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2') : match_cont cunit hf (known_id f) x0 k k'.","conclusion":"match_cont cunit hf (known_id f) x0 k k'","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2')","proofString":"apply match_cont_other; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2') : env_lessdef\n  (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n  (set_locals (Cminor.fn_vars f) (set_params args' (Cminor.fn_params f))).","conclusion":"env_lessdef\n  (set_locals (Cminor.fn_vars f) (set_params vargs (Cminor.fn_params f)))\n  (set_locals (Cminor.fn_vars f) (set_params args' (Cminor.fn_params f)))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2')","proofString":"apply set_locals_lessdef.\napply set_params_lessdef; auto."},{"statement":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2') : env_lessdef (set_params vargs (Cminor.fn_params f))\n  (set_params args' (Cminor.fn_params f)).","conclusion":"env_lessdef (set_params vargs (Cminor.fn_params f))\n  (set_params args' (Cminor.fn_params f))","hypotheses":"(f : Cminor.function) (vargs : list val) (k : Cminor.cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (Cminor.fn_sig f))) (H0 : Mem.alloc m 0 (Cminor.fn_stackspace f) = (m', sp)) (WTS : wt_state (Cminor.Callstate (Internal f) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (x1 : stmt) (EQ : sel_function (prog_defmap cunit) hf f =\nOK\n  {|\n    fn_sig := Cminor.fn_sig f;\n    fn_params := Cminor.fn_params f;\n    fn_vars := Cminor.fn_vars f;\n    fn_stackspace := Cminor.fn_stackspace f;\n    fn_body := x1\n  |}) (x0 : typenv) (EQ0 : type_function f = OK x0) (EQ2 : sel_stmt (prog_defmap cunit) (known_id f) x0 (Cminor.fn_body f) Sskip = OK x1) (m2' : Mem.mem') (A : Mem.alloc m'0 0 (Cminor.fn_stackspace f) = (m2', sp)) (B : Mem.extends m' m2')","proofString":"apply set_params_lessdef; auto."},{"statement":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (TF : match_fundef cunit (External ef) f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (TF : match_fundef cunit (External ef) f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0)","proofString":"destruct TF as (hf & HF & TF).\nmonadInv TF.\nexploit external_call_mem_extends; eauto.\nintros [vres' [m2 [A [B [C D]]]]].\nleft; econstructor; split.\napply plus_one; econstructor.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (TF : sel_fundef (prog_defmap cunit) hf (External ef) = OK f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate f' args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m') (Callstate f' args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate f' args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (f' : fundef) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (TF : sel_fundef (prog_defmap cunit) hf (External ef) = OK f') (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0)","proofString":"monadInv TF.\nexploit external_call_mem_extends; eauto.\nintros [vres' [m2 [A [B [C D]]]]].\nleft; econstructor; split.\napply plus_one; econstructor.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m')\n  (Callstate (External ef) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m')\n  (Callstate (External ef) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0)","proofString":"exploit external_call_mem_extends; eauto.\nintros [vres' [m2 [A [B [C D]]]]].\nleft; econstructor; split.\napply plus_one; econstructor.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) : (exists (vres' : val) (m2' : mem),\n   external_call ef ge args' m'0 t vres' m2' /\\\n   Val.lessdef vres vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) m'0 m2') ->\n(exists T2 : state,\n   plus step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m')\n  (Callstate (External ef) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists (vres' : val) (m2' : mem),\n   external_call ef ge args' m'0 t vres' m2' /\\\n   Val.lessdef vres vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) m'0 m2') ->\n(exists T2 : state,\n   plus step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m')\n  (Callstate (External ef) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0)","proofString":"intros [vres' [m2 [A [B [C D]]]]].\nleft; econstructor; split.\napply plus_one; econstructor.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (vres' : val) (m2 : mem) (A : external_call ef ge args' m'0 t vres' m2) (B : Val.lessdef vres vres') (C : Mem.extends m' m2) (D : Mem.unchanged_on (loc_out_of_bounds m) m'0 m2) : (exists T2 : state,\n   plus step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m')\n  (Callstate (External ef) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres k m') T2) \\/\n(measure (Cminor.Returnstate vres k m') <\n measure (Cminor.Callstate (External ef) vargs k m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres k m')\n  (Callstate (External ef) args' k' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (Callstate (External ef) args' k' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres k m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (vres' : val) (m2 : mem) (A : external_call ef ge args' m'0 t vres' m2) (B : Val.lessdef vres vres') (C : Mem.extends m' m2) (D : Mem.unchanged_on (loc_out_of_bounds m) m'0 m2)","proofString":"left; econstructor; split.\napply plus_one; econstructor.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (vres' : val) (m2 : mem) (A : external_call ef ge args' m'0 t vres' m2) (B : Val.lessdef vres vres') (C : Mem.extends m' m2) (D : Mem.unchanged_on (loc_out_of_bounds m) m'0 m2) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(ef : external_function) (vargs : list val) (k : Cminor.cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WTS : wt_state (Cminor.Callstate (External ef) vargs k m)) (cunit : Cminor.program) (args' : list val) (k' : cont) (m'0 : mem) (LINK : linkorder cunit prog) (hf : helper_functions) (HF : helper_functions_declared cunit hf) (MC : match_call_cont k k') (LD : Val.lessdef_list vargs args') (ME0 : Mem.extends m m'0) (vres' : val) (m2 : mem) (A : external_call ef ge args' m'0 t vres' m2) (B : Val.lessdef vres vres') (C : Mem.extends m' m2) (D : Mem.unchanged_on (loc_out_of_bounds m) m'0 m2)","proofString":"apply senv_preserved."},{"statement":"(ef : external_function) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k0 : Cminor.cont) (WTS : wt_state\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k0) m)) (cunit : Cminor.program) (hf : helper_functions) (al : list Cminor.expr) (f' : function) (e' : Cminor.env) (k' : cont) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k0 k') (EA : Cminor.eval_exprlist ge sp e m al vargs) (LDE : env_lessdef e e') (ME0 : Mem.extends m m'0) : (exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef al) k' sp e' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m')\n     T2) \\/\n(measure (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m') <\n measure\n   (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k0) m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m')\n  (State f' (sel_builtin optid ef al) k' sp e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef al) k' sp e' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m')\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' (sel_builtin optid ef al) k' sp e' m'0) t T2 /\\\n   match_states (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m')\n     T2) \\/\n(measure (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m') <\n measure\n   (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k0) m))%nat /\\\nt = E0 /\\\nmatch_states (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m')\n  (State f' (sel_builtin optid ef al) k' sp e' m'0) \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' (sel_builtin optid ef al) k' sp e' m'0) t T2 /\\\n   eventually n (Cminor.Returnstate vres (Cminor.Kcall optid f sp e k0) m')\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(ef : external_function) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k0 : Cminor.cont) (WTS : wt_state\n  (Cminor.Callstate (External ef) vargs (Cminor.Kcall optid f sp e k0) m)) (cunit : Cminor.program) (hf : helper_functions) (al : list Cminor.expr) (f' : function) (e' : Cminor.env) (k' : cont) (m'0 : mem) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k0 k') (EA : Cminor.eval_exprlist ge sp e m al vargs) (LDE : env_lessdef e e') (ME0 : Mem.extends m m'0)","proofString":"exploit sel_builtin_correct; eauto.\nintros (e2' & m2' & P & Q & R).\nleft; econstructor; split.\neexact P.\neconstructor; eauto."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (v' : val) (k' : cont) (m' : mem) (MC : match_call_cont (Cminor.Kcall optid f sp e k) k') (LD : Val.lessdef v v') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (Returnstate v' k' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (Returnstate v' k' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (Returnstate v' k' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Returnstate v' k' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (Returnstate v' k' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (Returnstate v' k' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (v' : val) (k' : cont) (m' : mem) (MC : match_call_cont (Cminor.Kcall optid f sp e k) k') (LD : Val.lessdef v v') (ME0 : Mem.extends m m')","proofString":"inv MC.\nleft; econstructor; split.\napply plus_one; econstructor.\neapply match_states_skip; eauto.\ndestruct optid; simpl; auto.\napply set_var_lessdef; auto."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (v' : val) (m' : mem) (LD : Val.lessdef v v') (ME0 : Mem.extends m m') (cunit : Cminor.program) (hf : helper_functions) (env : typenv) (f' : function) (e' : Cminor.env) (k'0 : cont) (H4 : linkorder cunit prog) (H5 : helper_functions_declared cunit hf) (H7 : sel_function (prog_defmap cunit) hf f = OK f') (H8 : type_function f = OK env) (H9 : match_cont cunit hf (known_id f) env k k'0) (H10 : env_lessdef e e') : (exists T2 : state,\n   plus step tge (Returnstate v' (Kcall optid f' sp e' k'0) m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (Returnstate v' (Kcall optid f' sp e' k'0) m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (Returnstate v' (Kcall optid f' sp e' k'0) m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (Returnstate v' (Kcall optid f' sp e' k'0) m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (Returnstate v' (Kcall optid f' sp e' k'0) m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (Returnstate v' (Kcall optid f' sp e' k'0) m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (v' : val) (m' : mem) (LD : Val.lessdef v v') (ME0 : Mem.extends m m') (cunit : Cminor.program) (hf : helper_functions) (env : typenv) (f' : function) (e' : Cminor.env) (k'0 : cont) (H4 : linkorder cunit prog) (H5 : helper_functions_declared cunit hf) (H7 : sel_function (prog_defmap cunit) hf f = OK f') (H8 : type_function f = OK env) (H9 : match_cont cunit hf (known_id f) env k k'0) (H10 : env_lessdef e e')","proofString":"left; econstructor; split.\napply plus_one; econstructor.\neapply match_states_skip; eauto.\ndestruct optid; simpl; auto.\napply set_var_lessdef; auto."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (v' : val) (m' : mem) (LD : Val.lessdef v v') (ME0 : Mem.extends m m') (cunit : Cminor.program) (hf : helper_functions) (env : typenv) (f' : function) (e' : Cminor.env) (k'0 : cont) (H4 : linkorder cunit prog) (H5 : helper_functions_declared cunit hf) (H7 : sel_function (prog_defmap cunit) hf f = OK f') (H8 : type_function f = OK env) (H9 : match_cont cunit hf (known_id f) env k k'0) (H10 : env_lessdef e e') : env_lessdef (set_optvar optid v e) (set_optvar optid v' e').","conclusion":"env_lessdef (set_optvar optid v e) (set_optvar optid v' e')","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (v' : val) (m' : mem) (LD : Val.lessdef v v') (ME0 : Mem.extends m m') (cunit : Cminor.program) (hf : helper_functions) (env : typenv) (f' : function) (e' : Cminor.env) (k'0 : cont) (H4 : linkorder cunit prog) (H5 : helper_functions_declared cunit hf) (H7 : sel_function (prog_defmap cunit) hf f = OK f') (H8 : type_function f = OK env) (H9 : match_cont cunit hf (known_id f) env k k'0) (H10 : env_lessdef e e')","proofString":"destruct optid; simpl; auto.\napply set_var_lessdef; auto."},{"statement":"(v : val) (i : ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall (Some i) f sp e k) m)) (v' : val) (m' : mem) (LD : Val.lessdef v v') (ME0 : Mem.extends m m') (cunit : Cminor.program) (hf : helper_functions) (env : typenv) (f' : function) (e' : Cminor.env) (k'0 : cont) (H4 : linkorder cunit prog) (H5 : helper_functions_declared cunit hf) (H7 : sel_function (prog_defmap cunit) hf f = OK f') (H8 : type_function f = OK env) (H9 : match_cont cunit hf (known_id f) env k k'0) (H10 : env_lessdef e e') : env_lessdef (PTree.set i v e) (PTree.set i v' e').","conclusion":"env_lessdef (PTree.set i v e) (PTree.set i v' e')","hypotheses":"(v : val) (i : ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall (Some i) f sp e k) m)) (v' : val) (m' : mem) (LD : Val.lessdef v v') (ME0 : Mem.extends m m') (cunit : Cminor.program) (hf : helper_functions) (env : typenv) (f' : function) (e' : Cminor.env) (k'0 : cont) (H4 : linkorder cunit prog) (H5 : helper_functions_declared cunit hf) (H7 : sel_function (prog_defmap cunit) hf f = OK f') (H8 : type_function f = OK env) (H9 : match_cont cunit hf (known_id f) env k k'0) (H10 : env_lessdef e e')","proofString":"apply set_var_lessdef; auto."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m') : (exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2)).","conclusion":"(exists T2 : state,\n   plus step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     T2) \\/\n(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (State f' Sskip k' sp e' m') \\/\n(exists (T2 : state) (n : nat),\n   step tge (State f' Sskip k' sp e' m') E0 T2 /\\\n   eventually n (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n     (fun S3 : Cminor.state => match_states S3 T2))","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m')","proofString":"right; left; split.\nsimpl; lia.\nsplit.\nauto.\neauto using match_states_skip."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m') : (measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat.","conclusion":"(measure (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m) <\n measure (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m))%nat","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m')","proofString":"simpl; lia."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m') : E0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (State f' Sskip k' sp e' m').","conclusion":"E0 = E0 /\\\nmatch_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (State f' Sskip k' sp e' m')","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m')","proofString":"split.\nauto.\neauto using match_states_skip."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m') : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m')","proofString":"auto."},{"statement":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m') : match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (State f' Sskip k' sp e' m').","conclusion":"match_states (Cminor.State f Cminor.Sskip k sp (set_optvar optid v e) m)\n  (State f' Sskip k' sp e' m')","hypotheses":"(v : val) (optid : option ident) (f : Cminor.function) (sp : val) (e : Cminor.env) (k : Cminor.cont) (m : mem) (WTS : wt_state (Cminor.Returnstate v (Cminor.Kcall optid f sp e k) m)) (cunit : Cminor.program) (hf : helper_functions) (v' : val) (f' : function) (e' : Cminor.env) (m' : mem) (k' : cont) (env : typenv) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LDV : Val.lessdef v v') (LDE : env_lessdef (set_optvar optid v e) e') (ME0 : Mem.extends m m')","proofString":"eauto using match_states_skip."},{"statement":"(b : block) (f : Cminor.fundef) (m0 : mem) (ge0 : Genv.t Cminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Cminor.funsig f = signature_main) (cu : Cminor.program) (f' : fundef) (A : Genv.find_funct_ptr tge b = Some f') (B : match_fundef cu f f') (C : linkorder cu prog) : funsig f' = Cminor.funsig f.","conclusion":"funsig f' = Cminor.funsig f","hypotheses":"(b : block) (f : Cminor.fundef) (m0 : mem) (ge0 : Genv.t Cminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Cminor.funsig f = signature_main) (cu : Cminor.program) (f' : fundef) (A : Genv.find_funct_ptr tge b = Some f') (B : match_fundef cu f f') (C : linkorder cu prog)","proofString":"eapply sig_function_translated; eauto."},{"statement":"(b : block) (f : Cminor.fundef) (m0 : mem) (ge0 : Genv.t Cminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Cminor.funsig f = signature_main) (cu : Cminor.program) (f' : fundef) (A : Genv.find_funct_ptr tge b = Some f') (B : match_fundef cu f f') (C : linkorder cu prog) : match_call_cont Cminor.Kstop Kstop.","conclusion":"match_call_cont Cminor.Kstop Kstop","hypotheses":"(b : block) (f : Cminor.fundef) (m0 : mem) (ge0 : Genv.t Cminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Cminor.funsig f = signature_main) (cu : Cminor.program) (f' : fundef) (A : Genv.find_funct_ptr tge b = Some f') (B : match_fundef cu f f') (C : linkorder cu prog)","proofString":"constructor."},{"statement":"(b : block) (f : Cminor.fundef) (m0 : mem) (ge0 : Genv.t Cminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Cminor.funsig f = signature_main) (cu : Cminor.program) (f' : fundef) (A : Genv.find_funct_ptr tge b = Some f') (B : match_fundef cu f f') (C : linkorder cu prog) : Mem.extends m0 m0.","conclusion":"Mem.extends m0 m0","hypotheses":"(b : block) (f : Cminor.fundef) (m0 : mem) (ge0 : Genv.t Cminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Cminor.funsig f = signature_main) (cu : Cminor.program) (f' : fundef) (A : Genv.find_funct_ptr tge b = Some f') (B : match_fundef cu f f') (C : linkorder cu prog)","proofString":"apply Mem.extends_refl."},{"statement":"(S : Cminor.state) (R : state) (r : int) (H : match_states S R) (H0 : Cminor.final_state S r) : final_state R r.","conclusion":"final_state R r","hypotheses":"(S : Cminor.state) (R : state) (r : int) (H : match_states S R) (H0 : Cminor.final_state S r)","proofString":"inv H0.\ninv H.\ninv MC.\ninv LD.\nconstructor."},{"statement":"(R : state) (r : int) (m : mem) (H : match_states (Cminor.Returnstate (Vint r) Cminor.Kstop m) R) : final_state R r.","conclusion":"final_state R r","hypotheses":"(R : state) (r : int) (m : mem) (H : match_states (Cminor.Returnstate (Vint r) Cminor.Kstop m) R)","proofString":"inv H.\ninv MC.\ninv LD.\nconstructor."},{"statement":"(r : int) (m : mem) (v' : val) (k' : cont) (m' : mem) (MC : match_call_cont Cminor.Kstop k') (LD : Val.lessdef (Vint r) v') (ME : Mem.extends m m') : final_state (Returnstate v' k' m') r.","conclusion":"final_state (Returnstate v' k' m') r","hypotheses":"(r : int) (m : mem) (v' : val) (k' : cont) (m' : mem) (MC : match_call_cont Cminor.Kstop k') (LD : Val.lessdef (Vint r) v') (ME : Mem.extends m m')","proofString":"inv MC.\ninv LD.\nconstructor."},{"statement":"(r : int) (m : mem) (v' : val) (m' : mem) (LD : Val.lessdef (Vint r) v') (ME : Mem.extends m m') : final_state (Returnstate v' Kstop m') r.","conclusion":"final_state (Returnstate v' Kstop m') r","hypotheses":"(r : int) (m : mem) (v' : val) (m' : mem) (LD : Val.lessdef (Vint r) v') (ME : Mem.extends m m')","proofString":"inv LD.\nconstructor."},{"statement":"(r : int) (m m' : mem) (ME : Mem.extends m m') : final_state (Returnstate (Vint r) Kstop m') r.","conclusion":"final_state (Returnstate (Vint r) Kstop m') r","hypotheses":"(r : int) (m m' : mem) (ME : Mem.extends m m')","proofString":"constructor."},{"statement":"(MS : Cminor.state -> state -> Prop) : forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Cminor.semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Cminor.semantics prog)) id","hypotheses":"(MS : Cminor.state -> state -> Prop)","proofString":"apply senv_preserved."},{"statement":"(MS : Cminor.state -> state -> Prop) : forall s1 : Smallstep.state (Cminor.semantics prog),\nSmallstep.initial_state (Cminor.semantics prog) s1 ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ wt_state s1.","conclusion":"forall s1 : Smallstep.state (Cminor.semantics prog),\nSmallstep.initial_state (Cminor.semantics prog) s1 ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states s1 s2 /\\ wt_state s1","hypotheses":"(MS : Cminor.state -> state -> Prop)","proofString":"intros S INIT.\nexploit sel_initial_states; eauto.\nintros (T & P & Q).\nassert (W: wt_state S).\neapply wt_initial_state.\neexact wt_prog.\nauto.\neauto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) : exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S.","conclusion":"exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S","hypotheses":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S)","proofString":"exploit sel_initial_states; eauto.\nintros (T & P & Q).\nassert (W: wt_state S).\neapply wt_initial_state.\neexact wt_prog.\nauto.\neauto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) : (exists R : state, initial_state tprog R /\\ match_states S R) ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S.","conclusion":"(exists R : state, initial_state tprog R /\\ match_states S R) ->\nexists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S","hypotheses":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S)","proofString":"intros (T & P & Q).\nassert (W: wt_state S).\neapply wt_initial_state.\neexact wt_prog.\nauto.\neauto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) (T : state) (P : initial_state tprog T) (Q : match_states S T) : exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S.","conclusion":"exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S","hypotheses":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) (T : state) (P : initial_state tprog T) (Q : match_states S T)","proofString":"assert (W: wt_state S).\neapply wt_initial_state.\neexact wt_prog.\nauto.\neauto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) (T : state) (P : initial_state tprog T) (Q : match_states S T) : wt_state S.","conclusion":"wt_state S","hypotheses":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) (T : state) (P : initial_state tprog T) (Q : match_states S T)","proofString":"eapply wt_initial_state.\neexact wt_prog.\nauto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) (T : state) (P : initial_state tprog T) (Q : match_states S T) (W : wt_state S) : exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S.","conclusion":"exists s2 : Smallstep.state (semantics tprog),\n  Smallstep.initial_state (semantics tprog) s2 /\\\n  match_states S s2 /\\ wt_state S","hypotheses":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (INIT : Smallstep.initial_state (Cminor.semantics prog) S) (T : state) (P : initial_state tprog T) (Q : match_states S T) (W : wt_state S)","proofString":"eauto."},{"statement":"(MS : Cminor.state -> state -> Prop) : forall (s1 : Smallstep.state (Cminor.semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : int),\nmatch_states s1 s2 /\\ wt_state s1 ->\nSmallstep.final_state (Cminor.semantics prog) s1 r ->\nSmallstep.final_state (semantics tprog) s2 r.","conclusion":"forall (s1 : Smallstep.state (Cminor.semantics prog))\n  (s2 : Smallstep.state (semantics tprog)) (r : int),\nmatch_states s1 s2 /\\ wt_state s1 ->\nSmallstep.final_state (Cminor.semantics prog) s1 r ->\nSmallstep.final_state (semantics tprog) s2 r","hypotheses":"(MS : Cminor.state -> state -> Prop)","proofString":"intros S T r (M & W) FIN.\neapply sel_final_states; eauto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (T : Smallstep.state (semantics tprog)) (r : int) (M : match_states S T) (W : wt_state S) (FIN : Smallstep.final_state (Cminor.semantics prog) S r) : Smallstep.final_state (semantics tprog) T r.","conclusion":"Smallstep.final_state (semantics tprog) T r","hypotheses":"(MS : Cminor.state -> state -> Prop) (S : Smallstep.state (Cminor.semantics prog)) (T : Smallstep.state (semantics tprog)) (r : int) (M : match_states S T) (W : wt_state S) (FIN : Smallstep.final_state (Cminor.semantics prog) S r)","proofString":"eapply sel_final_states; eauto."},{"statement":"(MS : Cminor.state -> state -> Prop) : forall (s1 : Smallstep.state (Cminor.semantics prog)) \n  (t : trace) (s1' : Smallstep.state (Cminor.semantics prog)),\nStep (Cminor.semantics prog) s1 t s1' ->\nforall s2 : Smallstep.state (semantics tprog),\nmatch_states s1 s2 /\\ wt_state s1 ->\n(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) s2 t s2' \\/\n    Star (semantics tprog) s2 t s2' /\\ (measure s1' < measure s1)%nat) /\\\n   match_states s1' s2' /\\ wt_state s1') \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) s2 t s2' /\\\n   Eventually (Cminor.semantics prog) n s1'\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"forall (s1 : Smallstep.state (Cminor.semantics prog)) \n  (t : trace) (s1' : Smallstep.state (Cminor.semantics prog)),\nStep (Cminor.semantics prog) s1 t s1' ->\nforall s2 : Smallstep.state (semantics tprog),\nmatch_states s1 s2 /\\ wt_state s1 ->\n(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) s2 t s2' \\/\n    Star (semantics tprog) s2 t s2' /\\ (measure s1' < measure s1)%nat) /\\\n   match_states s1' s2' /\\ wt_state s1') \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) s2 t s2' /\\\n   Eventually (Cminor.semantics prog) n s1'\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop)","proofString":"intros S1 t S2 A T1 (M & W1).\nassert (W2: wt_state S2) by (eapply subject_reduction; eauto using wt_prog).\nexploit sel_step_correct; eauto.\nintros [(T2 & D & E) | [(D & E & F) | (T2 & n & D & E)]].\nleft; exists T2; auto.\nsubst t.\nleft; exists T1; auto using star_refl.\nright; exists n, T2; split.\napply plus_one; auto.\napply eventually_and_invariant; eauto using subject_reduction, wt_prog."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) : (exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1)","proofString":"assert (W2: wt_state S2) by (eapply subject_reduction; eauto using wt_prog).\nexploit sel_step_correct; eauto.\nintros [(T2 & D & E) | [(D & E & F) | (T2 & n & D & E)]].\nleft; exists T2; auto.\nsubst t.\nleft; exists T1; auto using star_refl.\nright; exists n, T2; split.\napply plus_one; auto.\napply eventually_and_invariant; eauto using subject_reduction, wt_prog."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) : (exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2)","proofString":"exploit sel_step_correct; eauto.\nintros [(T2 & D & E) | [(D & E & F) | (T2 & n & D & E)]].\nleft; exists T2; auto.\nsubst t.\nleft; exists T1; auto using star_refl.\nright; exists n, T2; split.\napply plus_one; auto.\napply eventually_and_invariant; eauto using subject_reduction, wt_prog."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) : (exists T2 : state, plus step tge T1 t T2 /\\ match_states S2 T2) \\/\n(measure S2 < measure S1)%nat /\\ t = E0 /\\ match_states S2 T1 \\/\n(exists (T2 : state) (n : nat),\n   step tge T1 t T2 /\\\n   eventually n S2 (fun S3 : Cminor.state => match_states S3 T2)) ->\n(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists T2 : state, plus step tge T1 t T2 /\\ match_states S2 T2) \\/\n(measure S2 < measure S1)%nat /\\ t = E0 /\\ match_states S2 T1 \\/\n(exists (T2 : state) (n : nat),\n   step tge T1 t T2 /\\\n   eventually n S2 (fun S3 : Cminor.state => match_states S3 T2)) ->\n(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2)","proofString":"intros [(T2 & D & E) | [(D & E & F) | (T2 & n & D & E)]].\nleft; exists T2; auto.\nsubst t.\nleft; exists T1; auto using star_refl.\nright; exists n, T2; split.\napply plus_one; auto.\napply eventually_and_invariant; eauto using subject_reduction, wt_prog."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (D : plus step tge T1 t T2) (E : match_states S2 T2) : (exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (D : plus step tge T1 t T2) (E : match_states S2 T2)","proofString":"left; exists T2; auto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (D : (measure S2 < measure S1)%nat) (E : t = E0) (F : match_states S2 T1) : (exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (D : (measure S2 < measure S1)%nat) (E : t = E0) (F : match_states S2 T1)","proofString":"subst t.\nleft; exists T1; auto using star_refl."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 E0 S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (D : (measure S2 < measure S1)%nat) (F : match_states S2 T1) : (exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 E0 s2' \\/\n    Star (semantics tprog) T1 E0 s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 E0 s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 E0 s2' \\/\n    Star (semantics tprog) T1 E0 s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 E0 s2' /\\\n   Eventually (Cminor.semantics prog) n S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 E0 S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (D : (measure S2 < measure S1)%nat) (F : match_states S2 T1)","proofString":"left; exists T1; auto using star_refl."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (n : nat) (D : step tge T1 t T2) (E : eventually n S2 (fun S3 : Cminor.state => match_states S3 T2)) : (exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n0 : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n0 S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1'')).","conclusion":"(exists s2' : Smallstep.state (semantics tprog),\n   (Plus (semantics tprog) T1 t s2' \\/\n    Star (semantics tprog) T1 t s2' /\\ (measure S2 < measure S1)%nat) /\\\n   match_states S2 s2' /\\ wt_state S2) \\/\n(exists (n0 : nat) (s2' : Smallstep.state (semantics tprog)),\n   Plus (semantics tprog) T1 t s2' /\\\n   Eventually (Cminor.semantics prog) n0 S2\n     (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n      match_states s1'' s2' /\\ wt_state s1''))","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (n : nat) (D : step tge T1 t T2) (E : eventually n S2 (fun S3 : Cminor.state => match_states S3 T2))","proofString":"right; exists n, T2; split.\napply plus_one; auto.\napply eventually_and_invariant; eauto using subject_reduction, wt_prog."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (n : nat) (D : step tge T1 t T2) (E : eventually n S2 (fun S3 : Cminor.state => match_states S3 T2)) : Plus (semantics tprog) T1 t T2.","conclusion":"Plus (semantics tprog) T1 t T2","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (n : nat) (D : step tge T1 t T2) (E : eventually n S2 (fun S3 : Cminor.state => match_states S3 T2))","proofString":"apply plus_one; auto."},{"statement":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (n : nat) (D : step tge T1 t T2) (E : eventually n S2 (fun S3 : Cminor.state => match_states S3 T2)) : Eventually (Cminor.semantics prog) n S2\n  (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n   match_states s1'' T2 /\\ wt_state s1'').","conclusion":"Eventually (Cminor.semantics prog) n S2\n  (fun s1'' : Smallstep.state (Cminor.semantics prog) =>\n   match_states s1'' T2 /\\ wt_state s1'')","hypotheses":"(MS : Cminor.state -> state -> Prop) (S1 : Smallstep.state (Cminor.semantics prog)) (t : trace) (S2 : Smallstep.state (Cminor.semantics prog)) (A : Step (Cminor.semantics prog) S1 t S2) (T1 : Smallstep.state (semantics tprog)) (M : match_states S1 T1) (W1 : wt_state S1) (W2 : wt_state S2) (T2 : state) (n : nat) (D : step tge T1 t T2) (E : eventually n S2 (fun S3 : Cminor.state => match_states S3 T2))","proofString":"apply eventually_and_invariant; eauto using subject_reduction, wt_prog."}]}