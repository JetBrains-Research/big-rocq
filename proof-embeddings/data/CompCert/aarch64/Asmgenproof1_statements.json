{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/Asmgenproof1.v","fileSamples":[{"statement":"(r : mreg) (x : ireg) (H : match preg_of r with\n| IR mr => OK mr\n| _ => Error (msg \"Asmgen.ireg_of\")\nend = OK x) : x <> X16.","proofString":"destruct (preg_of r) eqn:E; inv H.\nred; intros; subst x.\nelim (preg_of_not_X16 r); auto."},{"statement":"(r : mreg) (x : ireg) (E : preg_of r = x) : x <> X16.","proofString":"red; intros; subst x.\nelim (preg_of_not_X16 r); auto."},{"statement":"(r : mreg) (E : preg_of r = X16) : False.","proofString":"elim (preg_of_not_X16 r); auto."},{"statement":"(r : mreg) (x : ireg) (H : ireg_of r = OK x) : x <> X16.","proofString":"apply ireg_of_not_X16 in H.\ncongruence."},{"statement":"(r : mreg) (x : ireg) (H : x <> X16) : x <> X16.","proofString":"congruence."},{"statement":"(n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.of_nat 0 * 16) : Z.testbit (recompose_int accu (decompose_int 0 n p)) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"simpl.\nrewrite zlt_true; auto.\nextlia."},{"statement":"(n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.of_nat 0 * 16) : Z.testbit accu i = (if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite zlt_true; auto.\nextlia."},{"statement":"(n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.of_nat 0 * 16) : i < p.","proofString":"extlia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.of_nat (Datatypes.S N) * 16) : Z.testbit (recompose_int accu (decompose_int (Datatypes.S N) n p)) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite inj_S in RANGE.\nsimpl.\nset (frag := Zzero_ext 16 (Z.shiftr n p)).\nassert (FRAG: forall i, p <= i < p + 16 -> Z.testbit n i = Z.testbit frag (i - p)).\nunfold frag; intros.\nrewrite Zzero_ext_spec by lia.\nrewrite zlt_true by lia.\nrewrite Z.shiftr_spec by lia.\nf_equal; lia.\ndestruct (Z.eqb_spec frag 0).\nrewrite IHN.\ndestruct (zlt i p).\nrewrite zlt_true by lia.\nauto.\ndestruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto.\nlia.\nintros; apply ABOVE; lia.\nextlia.\nsimpl.\nrewrite IHN.\ndestruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r.\nlia.\nintros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia.\nextlia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) : Z.testbit (recompose_int accu (decompose_int (Datatypes.S N) n p)) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"simpl.\nset (frag := Zzero_ext 16 (Z.shiftr n p)).\nassert (FRAG: forall i, p <= i < p + 16 -> Z.testbit n i = Z.testbit frag (i - p)).\nunfold frag; intros.\nrewrite Zzero_ext_spec by lia.\nrewrite zlt_true by lia.\nrewrite Z.shiftr_spec by lia.\nf_equal; lia.\ndestruct (Z.eqb_spec frag 0).\nrewrite IHN.\ndestruct (zlt i p).\nrewrite zlt_true by lia.\nauto.\ndestruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto.\nlia.\nintros; apply ABOVE; lia.\nextlia.\nsimpl.\nrewrite IHN.\ndestruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r.\nlia.\nintros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia.\nextlia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) : Z.testbit\n  (recompose_int accu\n     (if Zzero_ext 16 (Z.shiftr n p) =? 0\n      then decompose_int N n (p + 16)\n      else\n       (Zzero_ext 16 (Z.shiftr n p), p)\n       :: decompose_int N (Z.ldiff n (Z.shiftl 65535 p)) (p + 16))) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"set (frag := Zzero_ext 16 (Z.shiftr n p)).\nassert (FRAG: forall i, p <= i < p + 16 -> Z.testbit n i = Z.testbit frag (i - p)).\nunfold frag; intros.\nrewrite Zzero_ext_spec by lia.\nrewrite zlt_true by lia.\nrewrite Z.shiftr_spec by lia.\nf_equal; lia.\ndestruct (Z.eqb_spec frag 0).\nrewrite IHN.\ndestruct (zlt i p).\nrewrite zlt_true by lia.\nauto.\ndestruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto.\nlia.\nintros; apply ABOVE; lia.\nextlia.\nsimpl.\nrewrite IHN.\ndestruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r.\nlia.\nintros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia.\nextlia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n0 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (i0 : Z) (H : p <= i0 < p + 16) : Z.testbit n i0 = Z.testbit (Zzero_ext 16 (Z.shiftr n p)) (i0 - p).","proofString":"rewrite Zzero_ext_spec by lia.\nrewrite zlt_true by lia.\nrewrite Z.shiftr_spec by lia.\nf_equal; lia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n0 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (i0 : Z) (H : p <= i0 < p + 16) : Z.testbit n i0 =\n(if zlt (i0 - p) 16 then Z.testbit (Z.shiftr n p) (i0 - p) else false).","proofString":"rewrite zlt_true by lia.\nrewrite Z.shiftr_spec by lia.\nf_equal; lia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n0 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (i0 : Z) (H : p <= i0 < p + 16) : Z.testbit n i0 = Z.testbit (Z.shiftr n p) (i0 - p).","proofString":"rewrite Z.shiftr_spec by lia.\nf_equal; lia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n0 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (i0 : Z) (H : p <= i0 < p + 16) : Z.testbit n i0 = Z.testbit n (i0 - p + p).","proofString":"f_equal; lia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) : Z.testbit\n  (recompose_int accu\n     (if frag =? 0\n      then decompose_int N n (p + 16)\n      else\n       (frag, p) :: decompose_int N (Z.ldiff n (Z.shiftl 65535 p)) (p + 16)))\n  i = (if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"destruct (Z.eqb_spec frag 0).\nrewrite IHN.\ndestruct (zlt i p).\nrewrite zlt_true by lia.\nauto.\ndestruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto.\nlia.\nintros; apply ABOVE; lia.\nextlia.\nsimpl.\nrewrite IHN.\ndestruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r.\nlia.\nintros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia.\nextlia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) : Z.testbit (recompose_int accu (decompose_int N n (p + 16))) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite IHN.\ndestruct (zlt i p).\nrewrite zlt_true by lia.\nauto.\ndestruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto.\nlia.\nintros; apply ABOVE; lia.\nextlia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) : (if zlt i (p + 16) then Z.testbit accu i else Z.testbit n i) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"destruct (zlt i p).\nrewrite zlt_true by lia.\nauto.\ndestruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (l : i < p) : (if zlt i (p + 16) then Z.testbit accu i else Z.testbit n i) =\nZ.testbit accu i.","proofString":"rewrite zlt_true by lia.\nauto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (l : i < p) : Z.testbit accu i = Z.testbit accu i.","proofString":"auto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (g : i >= p) : (if zlt i (p + 16) then Z.testbit accu i else Z.testbit n i) = Z.testbit n i.","proofString":"destruct (zlt i (p + 16)); auto.\nrewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (g : i >= p) (l : i < p + 16) : Z.testbit accu i = Z.testbit n i.","proofString":"rewrite ABOVE by lia.\nrewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (g : i >= p) (l : i < p + 16) : false = Z.testbit n i.","proofString":"rewrite FRAG by lia.\nrewrite e, Z.testbit_0_l.\nauto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (g : i >= p) (l : i < p + 16) : false = Z.testbit frag (i - p).","proofString":"rewrite e, Z.testbit_0_l.\nauto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) (g : i >= p) (l : i < p + 16) : false = false.","proofString":"auto."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) : 0 <= p + 16.","proofString":"lia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) : forall i0 : Z, p + 16 <= i0 -> Z.testbit accu i0 = false.","proofString":"intros; apply ABOVE; lia."},{"statement":"(N : nat) (IHN : forall n0 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n0 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n0 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (e : frag = 0) : 0 <= i < p + 16 + Z.of_nat N * 16.","proofString":"extlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) : Z.testbit\n  (recompose_int accu\n     ((frag, p) :: decompose_int N (Z.ldiff n (Z.shiftl 65535 p)) (p + 16)))\n  i = (if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"simpl.\nrewrite IHN.\ndestruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r.\nlia.\nintros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia.\nextlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) : Z.testbit\n  (recompose_int (Zinsert accu frag p 16)\n     (decompose_int N (Z.ldiff n (Z.shiftl 65535 p)) (p + 16))) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite IHN.\ndestruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r.\nlia.\nintros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia.\nextlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) : (if zlt i (p + 16)\n then Z.testbit (Zinsert accu frag p 16) i\n else Z.testbit (Z.ldiff n (Z.shiftl 65535 p)) i) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"destruct (zlt i (p + 16)).\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia.\nrewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) : Z.testbit (Zinsert accu frag p 16) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) : (if zle p i && zlt i (p + 16)\n then Z.testbit frag (i - p)\n else Z.testbit accu i) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"unfold proj_sumbool.\nrewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) : (if\n  (if zle p i then true else false) &&\n  (if zlt i (p + 16) then true else false)\n then Z.testbit frag (i - p)\n else Z.testbit accu i) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite zlt_true by lia.\ndestruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) : (if (if zle p i then true else false) && true\n then Z.testbit frag (i - p)\n else Z.testbit accu i) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"destruct (zlt i p).\nrewrite zle_false by lia.\nauto.\nrewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) (l0 : i < p) : (if (if zle p i then true else false) && true\n then Z.testbit frag (i - p)\n else Z.testbit accu i) = Z.testbit accu i.","proofString":"rewrite zle_false by lia.\nauto."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) (l0 : i < p) : (if false && true then Z.testbit frag (i - p) else Z.testbit accu i) =\nZ.testbit accu i.","proofString":"auto."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) (g : i >= p) : (if (if zle p i then true else false) && true\n then Z.testbit frag (i - p)\n else Z.testbit accu i) = Z.testbit n i.","proofString":"rewrite zle_true by lia.\nsimpl.\nsymmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) (g : i >= p) : (if true && true then Z.testbit frag (i - p) else Z.testbit accu i) =\nZ.testbit n i.","proofString":"simpl.\nsymmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (l : i < p + 16) (g : i >= p) : Z.testbit frag (i - p) = Z.testbit n i.","proofString":"symmetry; apply FRAG; lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (g : i >= p + 16) : Z.testbit (Z.ldiff n (Z.shiftl 65535 p)) i =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite Z.ldiff_spec, Z.shiftl_spec by lia.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (g : i >= p + 16) : Z.testbit n i && negb (Z.testbit 65535 (i - p)) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"change 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (g : i >= p + 16) : Z.testbit n i && negb (Z.testbit (two_p 16 - 1) (i - p)) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (g : i >= p + 16) : Z.testbit n i && negb (if zlt (i - p) 16 then true else false) =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite zlt_false by lia.\nrewrite zlt_false by lia.\napply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (g : i >= p + 16) : Z.testbit n i && negb false =\n(if zlt i p then Z.testbit accu i else Z.testbit n i).","proofString":"rewrite zlt_false by lia.\napply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) (g : i >= p + 16) : Z.testbit n i && negb false = Z.testbit n i.","proofString":"apply andb_true_r."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) : 0 <= p + 16.","proofString":"lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) : forall i0 : Z, p + 16 <= i0 -> Z.testbit (Zinsert accu frag p 16) i0 = false.","proofString":"intros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : Z.testbit (Zinsert accu frag p 16) i0 = false.","proofString":"rewrite Zinsert_spec by lia.\nunfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : (if zle p i0 && zlt i0 (p + 16)\n then Z.testbit frag (i0 - p)\n else Z.testbit accu i0) = false.","proofString":"unfold proj_sumbool.\nrewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : (if\n  (if zle p i0 then true else false) &&\n  (if zlt i0 (p + 16) then true else false)\n then Z.testbit frag (i0 - p)\n else Z.testbit accu i0) = false.","proofString":"rewrite zle_true by lia.\nrewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : (if true && (if zlt i0 (p + 16) then true else false)\n then Z.testbit frag (i0 - p)\n else Z.testbit accu i0) = false.","proofString":"rewrite zlt_false by lia.\nsimpl.\napply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : (if true && false then Z.testbit frag (i0 - p) else Z.testbit accu i0) =\nfalse.","proofString":"simpl.\napply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : Z.testbit accu i0 = false.","proofString":"apply ABOVE.\nlia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i1 : Z, p0 <= i1 -> Z.testbit accu0 i1 = false) ->\nforall i1 : Z,\n0 <= i1 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i1 =\n(if zlt i1 p0 then Z.testbit accu0 i1 else Z.testbit n1 i1)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i1 : Z, p <= i1 -> Z.testbit accu i1 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i1 : Z, p <= i1 < p + 16 -> Z.testbit n i1 = Z.testbit frag (i1 - p)) (n0 : frag <> 0) (i0 : Z) (H : p + 16 <= i0) : p <= i0.","proofString":"lia."},{"statement":"(N : nat) (IHN : forall n1 p0 accu0 : Z,\n0 <= p0 ->\n(forall i0 : Z, p0 <= i0 -> Z.testbit accu0 i0 = false) ->\nforall i0 : Z,\n0 <= i0 < p0 + Z.of_nat N * 16 ->\nZ.testbit (recompose_int accu0 (decompose_int N n1 p0)) i0 =\n(if zlt i0 p0 then Z.testbit accu0 i0 else Z.testbit n1 i0)) (n p accu : Z) (PPOS : 0 <= p) (ABOVE : forall i0 : Z, p <= i0 -> Z.testbit accu i0 = false) (i : Z) (RANGE : 0 <= i < p + Z.succ (Z.of_nat N) * 16) (frag : Z) (FRAG : forall i0 : Z, p <= i0 < p + 16 -> Z.testbit n i0 = Z.testbit frag (i0 - p)) (n0 : frag <> 0) : 0 <= i < p + 16 + Z.of_nat N * 16.","proofString":"extlia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : Z.testbit (recompose_int 0 (decompose_int N n 0)) i = Z.testbit n i.","proofString":"rewrite decompose_int_correct.\napply zlt_false; lia.\nlia.\nintros; apply Z.testbit_0_l.\nextlia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : (if zlt i 0 then Z.testbit 0 i else Z.testbit n i) = Z.testbit n i.","proofString":"apply zlt_false; lia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : 0 <= 0.","proofString":"lia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : forall i0 : Z, 0 <= i0 -> Z.testbit 0 i0 = false.","proofString":"intros; apply Z.testbit_0_l."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : 0 <= i < 0 + Z.of_nat N * 16.","proofString":"extlia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : Z.testbit (Z.lnot (recompose_int 0 (decompose_int N (Z.lnot n) 0))) i =\nZ.testbit n i.","proofString":"rewrite Z.lnot_spec, decompose_int_correct.\nrewrite zlt_false by lia.\nrewrite Z.lnot_spec by lia.\napply negb_involutive.\nlia.\nintros; apply Z.testbit_0_l.\nextlia.\nlia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : negb (if zlt i 0 then Z.testbit 0 i else Z.testbit (Z.lnot n) i) =\nZ.testbit n i.","proofString":"rewrite zlt_false by lia.\nrewrite Z.lnot_spec by lia.\napply negb_involutive."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : negb (Z.testbit (Z.lnot n) i) = Z.testbit n i.","proofString":"rewrite Z.lnot_spec by lia.\napply negb_involutive."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : negb (negb (Z.testbit n i)) = Z.testbit n i.","proofString":"apply negb_involutive."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : 0 <= 0.","proofString":"lia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : forall i0 : Z, 0 <= i0 -> Z.testbit 0 i0 = false.","proofString":"intros; apply Z.testbit_0_l."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : 0 <= i < 0 + Z.of_nat N * 16.","proofString":"extlia."},{"statement":"(N : nat) (n i : Z) (H : 0 <= i < Z.of_nat (N * 16)) : 0 <= i.","proofString":"lia."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) : Z.lxor n 65535 = Zzero_ext 16 (Z.lnot m).","proofString":"apply equal_same_bits; intros.\nrewrite H.\nchange 65535 with (two_p 16 - 1).\nrewrite Z.lxor_spec, !Zzero_ext_spec, Z.lnot_spec, Ztestbit_two_p_m1 by lia.\ndestruct (zlt i 16).\napply xorb_true_r.\nauto."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) (i : Z) (H2 : 0 <= i) : Z.testbit (Z.lxor n 65535) i = Z.testbit (Zzero_ext 16 (Z.lnot m)) i.","proofString":"rewrite H.\nchange 65535 with (two_p 16 - 1).\nrewrite Z.lxor_spec, !Zzero_ext_spec, Z.lnot_spec, Ztestbit_two_p_m1 by lia.\ndestruct (zlt i 16).\napply xorb_true_r.\nauto."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) (i : Z) (H2 : 0 <= i) : Z.testbit (Z.lxor (Zzero_ext 16 m) 65535) i =\nZ.testbit (Zzero_ext 16 (Z.lnot m)) i.","proofString":"change 65535 with (two_p 16 - 1).\nrewrite Z.lxor_spec, !Zzero_ext_spec, Z.lnot_spec, Ztestbit_two_p_m1 by lia.\ndestruct (zlt i 16).\napply xorb_true_r.\nauto."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) (i : Z) (H2 : 0 <= i) : Z.testbit (Z.lxor (Zzero_ext 16 m) (two_p 16 - 1)) i =\nZ.testbit (Zzero_ext 16 (Z.lnot m)) i.","proofString":"rewrite Z.lxor_spec, !Zzero_ext_spec, Z.lnot_spec, Ztestbit_two_p_m1 by lia.\ndestruct (zlt i 16).\napply xorb_true_r.\nauto."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) (i : Z) (H2 : 0 <= i) : xorb (if zlt i 16 then Z.testbit m i else false)\n  (if zlt i 16 then true else false) =\n(if zlt i 16 then negb (Z.testbit m i) else false).","proofString":"destruct (zlt i 16).\napply xorb_true_r.\nauto."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) (i : Z) (H2 : 0 <= i) (l0 : i < 16) : xorb (Z.testbit m i) true = negb (Z.testbit m i).","proofString":"apply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : wf_decomposition (negate_decomposition l)) (i : Z) (H2 : 0 <= i) (g : i >= 16) : xorb false false = false.","proofString":"auto."},{"statement":"(n : nat) (x1 x2 y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (H1 : eqmod (two_power_nat n) x1 x2) : eqmod (two_power_nat n) (Zinsert x1 y p l) (Zinsert x2 y p l).","proofString":"apply eqmod_same_bits; intros.\nrewrite ! Zinsert_spec by lia.\ndestruct (zle p i && zlt i (p + l)); auto.\napply same_bits_eqmod with n; auto."},{"statement":"(n : nat) (x1 x2 y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (H1 : eqmod (two_power_nat n) x1 x2) (i : Z) (H2 : 0 <= i < Z.of_nat n) : Z.testbit (Zinsert x1 y p l) i = Z.testbit (Zinsert x2 y p l) i.","proofString":"rewrite ! Zinsert_spec by lia.\ndestruct (zle p i && zlt i (p + l)); auto.\napply same_bits_eqmod with n; auto."},{"statement":"(n : nat) (x1 x2 y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (H1 : eqmod (two_power_nat n) x1 x2) (i : Z) (H2 : 0 <= i < Z.of_nat n) : (if zle p i && zlt i (p + l) then Z.testbit y (i - p) else Z.testbit x1 i) =\n(if zle p i && zlt i (p + l) then Z.testbit y (i - p) else Z.testbit x2 i).","proofString":"destruct (zle p i && zlt i (p + l)); auto.\napply same_bits_eqmod with n; auto."},{"statement":"(n : nat) (x1 x2 y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (H1 : eqmod (two_power_nat n) x1 x2) (i : Z) (H2 : 0 <= i < Z.of_nat n) : Z.testbit x1 i = Z.testbit x2 i.","proofString":"apply same_bits_eqmod with n; auto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) : Z.shiftl (Zzero_ext l y) p = Zinsert 0 (Zzero_ext l y) p l.","proofString":"apply equal_same_bits; intros.\nrewrite Zinsert_spec by lia.\nunfold proj_sumbool.\ndestruct (zlt i p); [rewrite zle_false by lia|rewrite zle_true by lia]; simpl.\nrewrite Z.testbit_0_l, Z.shiftl_spec_low by auto.\nauto.\nrewrite Z.shiftl_spec by lia.\ndestruct (zlt i (p + l)); auto.\nrewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) : Z.testbit (Z.shiftl (Zzero_ext l y) p) i =\nZ.testbit (Zinsert 0 (Zzero_ext l y) p l) i.","proofString":"rewrite Zinsert_spec by lia.\nunfold proj_sumbool.\ndestruct (zlt i p); [rewrite zle_false by lia|rewrite zle_true by lia]; simpl.\nrewrite Z.testbit_0_l, Z.shiftl_spec_low by auto.\nauto.\nrewrite Z.shiftl_spec by lia.\ndestruct (zlt i (p + l)); auto.\nrewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) : Z.testbit (Z.shiftl (Zzero_ext l y) p) i =\n(if zle p i && zlt i (p + l)\n then Z.testbit (Zzero_ext l y) (i - p)\n else Z.testbit 0 i).","proofString":"unfold proj_sumbool.\ndestruct (zlt i p); [rewrite zle_false by lia|rewrite zle_true by lia]; simpl.\nrewrite Z.testbit_0_l, Z.shiftl_spec_low by auto.\nauto.\nrewrite Z.shiftl_spec by lia.\ndestruct (zlt i (p + l)); auto.\nrewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) : Z.testbit (Z.shiftl (Zzero_ext l y) p) i =\n(if\n  (if zle p i then true else false) &&\n  (if zlt i (p + l) then true else false)\n then Z.testbit (Zzero_ext l y) (i - p)\n else Z.testbit 0 i).","proofString":"destruct (zlt i p); [rewrite zle_false by lia|rewrite zle_true by lia]; simpl.\nrewrite Z.testbit_0_l, Z.shiftl_spec_low by auto.\nauto.\nrewrite Z.shiftl_spec by lia.\ndestruct (zlt i (p + l)); auto.\nrewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) (l0 : i < p) : Z.testbit (Z.shiftl (Zzero_ext l y) p) i = Z.testbit 0 i.","proofString":"rewrite Z.testbit_0_l, Z.shiftl_spec_low by auto.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) (l0 : i < p) : false = false.","proofString":"auto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) (g : i >= p) : Z.testbit (Z.shiftl (Zzero_ext l y) p) i =\n(if if zlt i (p + l) then true else false\n then Z.testbit (Zzero_ext l y) (i - p)\n else Z.testbit 0 i).","proofString":"rewrite Z.shiftl_spec by lia.\ndestruct (zlt i (p + l)); auto.\nrewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) (g : i >= p) : Z.testbit (Zzero_ext l y) (i - p) =\n(if if zlt i (p + l) then true else false\n then Z.testbit (Zzero_ext l y) (i - p)\n else Z.testbit 0 i).","proofString":"destruct (zlt i (p + l)); auto.\nrewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) (g : i >= p) (g0 : i >= p + l) : Z.testbit (Zzero_ext l y) (i - p) = Z.testbit 0 i.","proofString":"rewrite Zzero_ext_spec, zlt_false, Z.testbit_0_l by lia.\nauto."},{"statement":"(y p l : Z) (H : 0 <= p) (H0 : 0 <= l) (i : Z) (H1 : 0 <= i) (g : i >= p) (g0 : i >= p + l) : false = false.","proofString":"auto."},{"statement":"(accu : Z) : Z.lnot accu = Z.lnot accu.","proofString":"auto."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu : Z) : recompose_int (Zinsert (Z.lnot accu) (Z.lxor n 65535) p 16)\n  (negate_decomposition l) = Z.lnot (recompose_int (Zinsert accu n p 16) l).","proofString":"rewrite <- IHwf_decomposition.\nf_equal.\napply equal_same_bits; intros.\nrewrite Z.lnot_spec, ! Zinsert_spec, Z.lxor_spec, Z.lnot_spec by lia.\nunfold proj_sumbool.\ndestruct (zle p i); simpl; auto.\ndestruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu : Z) : recompose_int (Zinsert (Z.lnot accu) (Z.lxor n 65535) p 16)\n  (negate_decomposition l) =\nrecompose_int (Z.lnot (Zinsert accu n p 16)) (negate_decomposition l).","proofString":"f_equal.\napply equal_same_bits; intros.\nrewrite Z.lnot_spec, ! Zinsert_spec, Z.lxor_spec, Z.lnot_spec by lia.\nunfold proj_sumbool.\ndestruct (zle p i); simpl; auto.\ndestruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu : Z) : Zinsert (Z.lnot accu) (Z.lxor n 65535) p 16 = Z.lnot (Zinsert accu n p 16).","proofString":"apply equal_same_bits; intros.\nrewrite Z.lnot_spec, ! Zinsert_spec, Z.lxor_spec, Z.lnot_spec by lia.\nunfold proj_sumbool.\ndestruct (zle p i); simpl; auto.\ndestruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) : Z.testbit (Zinsert (Z.lnot accu) (Z.lxor n 65535) p 16) i =\nZ.testbit (Z.lnot (Zinsert accu n p 16)) i.","proofString":"rewrite Z.lnot_spec, ! Zinsert_spec, Z.lxor_spec, Z.lnot_spec by lia.\nunfold proj_sumbool.\ndestruct (zle p i); simpl; auto.\ndestruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) : (if zle p i && zlt i (p + 16)\n then xorb (Z.testbit n (i - p)) (Z.testbit 65535 (i - p))\n else negb (Z.testbit accu i)) =\nnegb\n  (if zle p i && zlt i (p + 16)\n   then Z.testbit n (i - p)\n   else Z.testbit accu i).","proofString":"unfold proj_sumbool.\ndestruct (zle p i); simpl; auto.\ndestruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) : (if\n  (if zle p i then true else false) &&\n  (if zlt i (p + 16) then true else false)\n then xorb (Z.testbit n (i - p)) (Z.testbit 65535 (i - p))\n else negb (Z.testbit accu i)) =\nnegb\n  (if\n    (if zle p i then true else false) &&\n    (if zlt i (p + 16) then true else false)\n   then Z.testbit n (i - p)\n   else Z.testbit accu i).","proofString":"destruct (zle p i); simpl; auto.\ndestruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) (l0 : p <= i) : (if if zlt i (p + 16) then true else false\n then xorb (Z.testbit n (i - p)) (Z.testbit 65535 (i - p))\n else negb (Z.testbit accu i)) =\nnegb\n  (if if zlt i (p + 16) then true else false\n   then Z.testbit n (i - p)\n   else Z.testbit accu i).","proofString":"destruct (zlt i (p + 16)); simpl; auto.\nchange 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) (l0 : p <= i) (l1 : i < p + 16) : xorb (Z.testbit n (i - p)) (Z.testbit 65535 (i - p)) =\nnegb (Z.testbit n (i - p)).","proofString":"change 65535 with (two_p 16 - 1).\nrewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) (l0 : p <= i) (l1 : i < p + 16) : xorb (Z.testbit n (i - p)) (Z.testbit (two_p 16 - 1) (i - p)) =\nnegb (Z.testbit n (i - p)).","proofString":"rewrite Ztestbit_two_p_m1 by lia.\nrewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) (l0 : p <= i) (l1 : i < p + 16) : xorb (Z.testbit n (i - p)) (if zlt (i - p) 16 then true else false) =\nnegb (Z.testbit n (i - p)).","proofString":"rewrite zlt_true by lia.\napply xorb_true_r."},{"statement":"(m n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall accu0 : Z,\nrecompose_int (Z.lnot accu0) (negate_decomposition l) =\nZ.lnot (recompose_int accu0 l)) (accu i : Z) (H2 : 0 <= i) (l0 : p <= i) (l1 : i < p + 16) : xorb (Z.testbit n (i - p)) true = negb (Z.testbit n (i - p)).","proofString":"apply xorb_true_r."},{"statement":"(rd : ireg) (k : code) (m : mem) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : exists rs' : regset,\n  exec_straight_opt ge fn k rs m k rs' m /\\\n  rs' rd = Vint (Int.repr accu) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"exists rs; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(rd : ireg) (k : code) (m : mem) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : exec_straight_opt ge fn k rs m k rs m.","proofString":"apply exec_straight_opt_refl."},{"statement":"(rd : ireg) (k : code) (m : mem) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : rs rd = Vint (Int.repr accu) /\\\n(forall r : preg, r <> PC -> r <> rd -> rs r = rs r).","proofString":"auto."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : exists rs' : regset,\n  exec_straight_opt ge fn (Pmovk W rd n p :: loadimm_k W rd l k) rs m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"destruct (IHwf_decomposition                (nextinstr (rs#rd <- (insert_in_int rs#rd n p 16)))                (Zinsert accu n p 16))  as (rs' & P & Q & R).\nSimpl.\nrewrite ACCU.\nsimpl.\nf_equal.\napply Int.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr.\nexists rs'; split.\neapply exec_straight_opt_step_opt.\nsimpl; eauto.\nauto.\nexact P.\nsplit.\nexact Q.\nintros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) rd =\nVint (Int.repr (Zinsert accu n p 16)).","proofString":"Simpl.\nrewrite ACCU.\nsimpl.\nf_equal.\napply Int.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : insert_in_int (rs rd) n p 16 = Vint (Int.repr (Zinsert accu n p 16)).","proofString":"rewrite ACCU.\nsimpl.\nf_equal.\napply Int.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : insert_in_int (Vint (Int.repr accu)) n p 16 =\nVint (Int.repr (Zinsert accu n p 16)).","proofString":"simpl.\nf_equal.\napply Int.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : Vint (Int.repr (Zinsert (Int.unsigned (Int.repr accu)) n p 16)) =\nVint (Int.repr (Zinsert accu n p 16)).","proofString":"f_equal.\napply Int.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : Int.repr (Zinsert (Int.unsigned (Int.repr accu)) n p 16) =\nInt.repr (Zinsert accu n p 16).","proofString":"apply Int.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : Int.eqm (Zinsert (Int.unsigned (Int.repr accu)) n p 16) (Zinsert accu n p 16).","proofString":"apply Zinsert_eqmod.\nauto.\nlia.\napply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : 0 <= p.","proofString":"auto."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : 0 <= 16.","proofString":"lia."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) : eqmod (two_power_nat Int.wordsize) (Int.unsigned (Int.repr accu)) accu.","proofString":"apply Int.eqm_sym; apply Int.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r) : exists rs'0 : regset,\n  exec_straight_opt ge fn (Pmovk W rd n p :: loadimm_k W rd l k) rs m k rs'0\n    m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs r).","proofString":"exists rs'; split.\neapply exec_straight_opt_step_opt.\nsimpl; eauto.\nauto.\nexact P.\nsplit.\nexact Q.\nintros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r) : exec_straight_opt ge fn (Pmovk W rd n p :: loadimm_k W rd l k) rs m k rs' m.","proofString":"eapply exec_straight_opt_step_opt.\nsimpl; eauto.\nauto.\nexact P."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r) : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l)) /\\\n(forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"split.\nexact Q.\nintros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r) : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l)).","proofString":"exact Q."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r) : forall r : preg, r <> PC -> r <> rd -> rs' r = rs r.","proofString":"intros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r0 : preg, r0 <> PC -> r0 <> rd -> rs'0 r0 = rs0 r0)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r0 : preg,\nr0 <> PC ->\nr0 <> rd -> rs' r0 = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r0) (r : preg) (H2 : r <> PC) (H3 : r <> rd) : rs' r = rs r.","proofString":"rewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vint (Int.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k W rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vint (Int.repr (recompose_int accu0 l)) /\\\n  (forall r0 : preg, r0 <> PC -> r0 <> rd -> rs'0 r0 = rs0 r0)) (rs : regset) (accu : Z) (ACCU : rs rd = Vint (Int.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k)\n  (nextinstr rs # rd <- (insert_in_int (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vint (Int.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r0 : preg,\nr0 <> PC ->\nr0 <> rd -> rs' r0 = nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r0) (r : preg) (H2 : r <> PC) (H3 : r <> rd) : nextinstr rs # rd <- (insert_in_int (rs rd) n p 16) r = rs r.","proofString":"Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (Pmovz W rd 0 0 :: k) rs m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int 0 nil)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : nextinstr rs # rd <- (Vint (Int.repr 0)) rd =\nVint (Int.repr (recompose_int 0 nil)).","proofString":"Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : forall r : preg,\nr <> PC -> r <> rd -> nextinstr rs # rd <- (Vint (Int.repr 0)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) : exists rs' : regset,\n  exec_straight ge fn (Pmovz W rd n p :: loadimm_k W rd l k) rs m k rs' m /\\\n  rs' rd = Vint (Int.repr (recompose_int 0 ((n, p) :: l))) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"set (accu0 := Zinsert 0 n p 16).\nset (rs1 := nextinstr (rs#rd <- (Vint (Int.repr accu0)))).\ndestruct (exec_loadimm_k_w rd k m l H1 rs1 accu0) as (rs2 & P & Q & R); auto.\nunfold rs1; Simpl.\nexists rs2; split.\neapply exec_straight_opt_step; eauto.\nsimpl.\nunfold rs1.\ndo 5 f_equal.\nunfold accu0.\nrewrite H.\napply Zinsert_0_l; lia.\nreflexivity.\nsplit.\nexact Q.\nintros.\nrewrite R by auto.\nunfold rs1; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k) rs1 m k rs2 m) (Q : rs2 rd = Vint (Int.repr (recompose_int accu0 l))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl n p = Zinsert 0 n p 16.","proofString":"rewrite H.\napply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k W rd l k) rs1 m k rs2 m) (Q : rs2 rd = Vint (Int.repr (recompose_int accu0 l))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl (Zzero_ext 16 m0) p = Zinsert 0 (Zzero_ext 16 m0) p 16.","proofString":"apply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (Pmovn W rd 0 0 :: k) rs m k rs' m /\\\n  rs' rd = Vint (Int.repr (Z.lnot (recompose_int 0 nil))) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : nextinstr rs # rd <- (Vint (Int.repr (Z.lnot 0))) rd =\nVint (Int.repr (Z.lnot (recompose_int 0 nil))).","proofString":"Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : forall r : preg,\nr <> PC ->\nr <> rd -> nextinstr rs # rd <- (Vint (Int.repr (Z.lnot 0))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) : exists rs' : regset,\n  exec_straight ge fn\n    (Pmovn W rd n p :: loadimm_k W rd (negate_decomposition l) k) rs m k rs'\n    m /\\\n  rs' rd = Vint (Int.repr (Z.lnot (recompose_int 0 ((n, p) :: l)))) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"set (accu0 := Z.lnot (Zinsert 0 n p 16)).\nset (rs1 := nextinstr (rs#rd <- (Vint (Int.repr accu0)))).\ndestruct (exec_loadimm_k_w rd k m (negate_decomposition l)                                     (negate_decomposition_wf l H1)                                    rs1 accu0) as (rs2 & P & Q & R).\nunfold rs1; Simpl.\nexists rs2; split.\neapply exec_straight_opt_step; eauto.\nsimpl.\nunfold rs1.\ndo 5 f_equal.\nunfold accu0.\nf_equal.\nrewrite H.\napply Zinsert_0_l; lia.\nreflexivity.\nsplit.\nunfold accu0 in Q; rewrite recompose_int_negated in Q by auto.\nexact Q.\nintros.\nrewrite R by auto.\nunfold rs1; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k W rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vint (Int.repr (recompose_int accu0 (negate_decomposition l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.lnot (Z.shiftl n p) = Z.lnot (Zinsert 0 n p 16).","proofString":"f_equal.\nrewrite H.\napply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k W rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vint (Int.repr (recompose_int accu0 (negate_decomposition l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl n p = Zinsert 0 n p 16.","proofString":"rewrite H.\napply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k W rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vint (Int.repr (recompose_int accu0 (negate_decomposition l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl (Zzero_ext 16 m0) p = Zinsert 0 (Zzero_ext 16 m0) p 16.","proofString":"apply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k W rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vint (Int.repr (Z.lnot (recompose_int (Zinsert 0 n p 16) l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : rs2 rd = Vint (Int.repr (Z.lnot (recompose_int 0 ((n, p) :: l)))).","proofString":"exact Q."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm32 n\n     then Porrimm W rd XZR (Int.unsigned n) :: k\n     else\n      if\n       (Datatypes.length (decompose_int 2 (Int.unsigned n) 0) <=?\n        Datatypes.length (decompose_int 2 (Z.lnot (Int.unsigned n)) 0))%nat\n      then loadimm_z W rd (decompose_int 2 (Int.unsigned n) 0) k\n      else loadimm_n W rd (decompose_int 2 (Z.lnot (Int.unsigned n)) 0) k) rs\n    m k rs' m /\\\n  rs' rd = Vint n /\\ (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"destruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite Int.repr_unsigned, Int.or_zero_l; auto.\nintros; Simpl.\nset (dz := decompose_int 2%nat (Int.unsigned n) 0).\nset (dn := decompose_int 2%nat (Z.lnot (Int.unsigned n)) 0).\nassert (A: Int.repr (recompose_int 0 dz) = n).\ntransitivity (Int.repr (Int.unsigned n)).\napply Int.eqm_samerepr.\napply decompose_int_eqmod.\napply Int.repr_unsigned.\nassert (B: Int.repr (Z.lnot (recompose_int 0 dn)) = n).\ntransitivity (Int.repr (Int.unsigned n)).\napply Int.eqm_samerepr.\napply decompose_notint_eqmod.\napply Int.repr_unsigned.\ndestruct Nat.leb.\nrewrite <- A.\napply exec_loadimm_z_w.\napply decompose_int_wf; lia.\nrewrite <- B.\napply exec_loadimm_n_w.\napply decompose_int_wf; lia."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (Porrimm W rd XZR (Int.unsigned n) :: k) rs m k rs' m /\\\n  rs' rd = Vint n /\\ (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite Int.repr_unsigned, Int.or_zero_l; auto.\nintros; Simpl."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) : nextinstr rs # rd <- (Vint (Int.or Int.zero (Int.repr (Int.unsigned n)))) rd =\nVint n.","proofString":"Simpl.\nrewrite Int.repr_unsigned, Int.or_zero_l; auto."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) : Vint (Int.or Int.zero (Int.repr (Int.unsigned n))) = Vint n.","proofString":"rewrite Int.repr_unsigned, Int.or_zero_l; auto."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) : forall r : preg,\nr <> PC ->\nr <> rd ->\nnextinstr rs # rd <- (Vint (Int.or Int.zero (Int.repr (Int.unsigned n)))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn\n    (if\n      (Datatypes.length (decompose_int 2 (Int.unsigned n) 0) <=?\n       Datatypes.length (decompose_int 2 (Z.lnot (Int.unsigned n)) 0))%nat\n     then loadimm_z W rd (decompose_int 2 (Int.unsigned n) 0) k\n     else loadimm_n W rd (decompose_int 2 (Z.lnot (Int.unsigned n)) 0) k) rs\n    m k rs' m /\\\n  rs' rd = Vint n /\\ (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"set (dz := decompose_int 2%nat (Int.unsigned n) 0).\nset (dn := decompose_int 2%nat (Z.lnot (Int.unsigned n)) 0).\nassert (A: Int.repr (recompose_int 0 dz) = n).\ntransitivity (Int.repr (Int.unsigned n)).\napply Int.eqm_samerepr.\napply decompose_int_eqmod.\napply Int.repr_unsigned.\nassert (B: Int.repr (Z.lnot (recompose_int 0 dn)) = n).\ntransitivity (Int.repr (Int.unsigned n)).\napply Int.eqm_samerepr.\napply decompose_notint_eqmod.\napply Int.repr_unsigned.\ndestruct Nat.leb.\nrewrite <- A.\napply exec_loadimm_z_w.\napply decompose_int_wf; lia.\nrewrite <- B.\napply exec_loadimm_n_w.\napply decompose_int_wf; lia."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) (dz : list (Z * Z)) (dn : list (Z * Z)) : Int.repr (Int.unsigned n) = n.","proofString":"apply Int.repr_unsigned."},{"statement":"(rd : ireg) (n : int) (k : code) (rs : regset) (m : mem) (dz : list (Z * Z)) (dn : list (Z * Z)) (A : Int.repr (recompose_int 0 dz) = n) : Int.repr (Int.unsigned n) = n.","proofString":"apply Int.repr_unsigned."},{"statement":"(rd : ireg) (k : code) (m : mem) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : exists rs' : regset,\n  exec_straight_opt ge fn k rs m k rs' m /\\\n  rs' rd = Vlong (Int64.repr accu) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"exists rs; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(rd : ireg) (k : code) (m : mem) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : exec_straight_opt ge fn k rs m k rs m.","proofString":"apply exec_straight_opt_refl."},{"statement":"(rd : ireg) (k : code) (m : mem) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : rs rd = Vlong (Int64.repr accu) /\\\n(forall r : preg, r <> PC -> r <> rd -> rs r = rs r).","proofString":"auto."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : exists rs' : regset,\n  exec_straight_opt ge fn (Pmovk X rd n p :: loadimm_k X rd l k) rs m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"destruct (IHwf_decomposition                (nextinstr (rs#rd <- (insert_in_long rs#rd n p 16)))                (Zinsert accu n p 16))  as (rs' & P & Q & R).\nSimpl.\nrewrite ACCU.\nsimpl.\nf_equal.\napply Int64.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr.\nexists rs'; split.\neapply exec_straight_opt_step_opt.\nsimpl; eauto.\nauto.\nexact P.\nsplit.\nexact Q.\nintros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) rd =\nVlong (Int64.repr (Zinsert accu n p 16)).","proofString":"Simpl.\nrewrite ACCU.\nsimpl.\nf_equal.\napply Int64.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : insert_in_long (rs rd) n p 16 = Vlong (Int64.repr (Zinsert accu n p 16)).","proofString":"rewrite ACCU.\nsimpl.\nf_equal.\napply Int64.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : insert_in_long (Vlong (Int64.repr accu)) n p 16 =\nVlong (Int64.repr (Zinsert accu n p 16)).","proofString":"simpl.\nf_equal.\napply Int64.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : Vlong (Int64.repr (Zinsert (Int64.unsigned (Int64.repr accu)) n p 16)) =\nVlong (Int64.repr (Zinsert accu n p 16)).","proofString":"f_equal.\napply Int64.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : Int64.repr (Zinsert (Int64.unsigned (Int64.repr accu)) n p 16) =\nInt64.repr (Zinsert accu n p 16).","proofString":"apply Int64.eqm_samerepr.\napply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : Int64.eqm (Zinsert (Int64.unsigned (Int64.repr accu)) n p 16)\n  (Zinsert accu n p 16).","proofString":"apply Zinsert_eqmod.\nauto.\nlia.\napply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : 0 <= p.","proofString":"auto."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : 0 <= 16.","proofString":"lia."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs' : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) : eqmod (two_power_nat Int64.wordsize) (Int64.unsigned (Int64.repr accu)) accu.","proofString":"apply Int64.eqm_sym; apply Int64.eqm_unsigned_repr."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r) : exists rs'0 : regset,\n  exec_straight_opt ge fn (Pmovk X rd n p :: loadimm_k X rd l k) rs m k rs'0\n    m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs r).","proofString":"exists rs'; split.\neapply exec_straight_opt_step_opt.\nsimpl; eauto.\nauto.\nexact P.\nsplit.\nexact Q.\nintros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r) : exec_straight_opt ge fn (Pmovk X rd n p :: loadimm_k X rd l k) rs m k rs' m.","proofString":"eapply exec_straight_opt_step_opt.\nsimpl; eauto.\nauto.\nexact P."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r) : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l)) /\\\n(forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"split.\nexact Q.\nintros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r) : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l)).","proofString":"exact Q."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs'0 r = rs0 r)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r : preg,\nr <> PC ->\nr <> rd -> rs' r = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r) : forall r : preg, r <> PC -> r <> rd -> rs' r = rs r.","proofString":"intros; Simpl.\nrewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r0 : preg, r0 <> PC -> r0 <> rd -> rs'0 r0 = rs0 r0)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r0 : preg,\nr0 <> PC ->\nr0 <> rd -> rs' r0 = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r0) (r : preg) (H2 : r <> PC) (H3 : r <> rd) : rs' r = rs r.","proofString":"rewrite R by auto.\nSimpl."},{"statement":"(rd : ireg) (k : code) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (IHwf_decomposition : forall (rs0 : regset) (accu0 : Z),\nrs0 rd = Vlong (Int64.repr accu0) ->\nexists rs'0 : regset,\n  exec_straight_opt ge fn (loadimm_k X rd l k) rs0 m k rs'0 m /\\\n  rs'0 rd = Vlong (Int64.repr (recompose_int accu0 l)) /\\\n  (forall r0 : preg, r0 <> PC -> r0 <> rd -> rs'0 r0 = rs0 r0)) (rs : regset) (accu : Z) (ACCU : rs rd = Vlong (Int64.repr accu)) (rs' : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k)\n  (nextinstr rs # rd <- (insert_in_long (rs rd) n p 16)) m k rs' m) (Q : rs' rd = Vlong (Int64.repr (recompose_int (Zinsert accu n p 16) l))) (R : forall r0 : preg,\nr0 <> PC ->\nr0 <> rd -> rs' r0 = nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r0) (r : preg) (H2 : r <> PC) (H3 : r <> rd) : nextinstr rs # rd <- (insert_in_long (rs rd) n p 16) r = rs r.","proofString":"Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (Pmovz X rd 0 0 :: k) rs m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int 0 nil)) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : nextinstr rs # rd <- (Vlong (Int64.repr 0)) rd =\nVlong (Int64.repr (recompose_int 0 nil)).","proofString":"Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : forall r : preg,\nr <> PC -> r <> rd -> nextinstr rs # rd <- (Vlong (Int64.repr 0)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) : exists rs' : regset,\n  exec_straight ge fn (Pmovz X rd n p :: loadimm_k X rd l k) rs m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (recompose_int 0 ((n, p) :: l))) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"set (accu0 := Zinsert 0 n p 16).\nset (rs1 := nextinstr (rs#rd <- (Vlong (Int64.repr accu0)))).\ndestruct (exec_loadimm_k_x rd k m l H1 rs1 accu0) as (rs2 & P & Q & R); auto.\nunfold rs1; Simpl.\nexists rs2; split.\neapply exec_straight_opt_step; eauto.\nsimpl.\nunfold rs1.\ndo 5 f_equal.\nunfold accu0.\nrewrite H.\napply Zinsert_0_l; lia.\nreflexivity.\nsplit.\nexact Q.\nintros.\nrewrite R by auto.\nunfold rs1; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k) rs1 m k rs2 m) (Q : rs2 rd = Vlong (Int64.repr (recompose_int accu0 l))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl n p = Zinsert 0 n p 16.","proofString":"rewrite H.\napply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k X rd l k) rs1 m k rs2 m) (Q : rs2 rd = Vlong (Int64.repr (recompose_int accu0 l))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl (Zzero_ext 16 m0) p = Zinsert 0 (Zzero_ext 16 m0) p 16.","proofString":"apply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (Pmovn X rd 0 0 :: k) rs m k rs' m /\\\n  rs' rd = Vlong (Int64.repr (Z.lnot (recompose_int 0 nil))) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : nextinstr rs # rd <- (Vlong (Int64.repr (Z.lnot 0))) rd =\nVlong (Int64.repr (Z.lnot (recompose_int 0 nil))).","proofString":"Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) : forall r : preg,\nr <> PC ->\nr <> rd -> nextinstr rs # rd <- (Vlong (Int64.repr (Z.lnot 0))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) : exists rs' : regset,\n  exec_straight ge fn\n    (Pmovn X rd n p :: loadimm_k X rd (negate_decomposition l) k) rs m k rs'\n    m /\\\n  rs' rd = Vlong (Int64.repr (Z.lnot (recompose_int 0 ((n, p) :: l)))) /\\\n  (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"set (accu0 := Z.lnot (Zinsert 0 n p 16)).\nset (rs1 := nextinstr (rs#rd <- (Vlong (Int64.repr accu0)))).\ndestruct (exec_loadimm_k_x rd k m (negate_decomposition l)                                     (negate_decomposition_wf l H1)                                    rs1 accu0) as (rs2 & P & Q & R).\nunfold rs1; Simpl.\nexists rs2; split.\neapply exec_straight_opt_step; eauto.\nsimpl.\nunfold rs1.\ndo 5 f_equal.\nunfold accu0.\nf_equal.\nrewrite H.\napply Zinsert_0_l; lia.\nreflexivity.\nsplit.\nunfold accu0 in Q; rewrite recompose_int_negated in Q by auto.\nexact Q.\nintros.\nrewrite R by auto.\nunfold rs1; Simpl."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k X rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vlong (Int64.repr (recompose_int accu0 (negate_decomposition l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.lnot (Z.shiftl n p) = Z.lnot (Zinsert 0 n p 16).","proofString":"f_equal.\nrewrite H.\napply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k X rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vlong (Int64.repr (recompose_int accu0 (negate_decomposition l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl n p = Zinsert 0 n p 16.","proofString":"rewrite H.\napply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k X rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vlong (Int64.repr (recompose_int accu0 (negate_decomposition l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : Z.shiftl (Zzero_ext 16 m0) p = Zinsert 0 (Zzero_ext 16 m0) p 16.","proofString":"apply Zinsert_0_l; lia."},{"statement":"(rd : ireg) (k : code) (rs : regset) (m : mem) (m0 n p : Z) (l : list (Z * Z)) (H : n = Zzero_ext 16 m0) (H0 : 0 <= p) (H1 : wf_decomposition l) (accu0 : Z) (rs1 : PregEq.t -> val) (rs2 : regset) (P : exec_straight_opt ge fn (loadimm_k X rd (negate_decomposition l) k) rs1 m k\n  rs2 m) (Q : rs2 rd = Vlong (Int64.repr (Z.lnot (recompose_int (Zinsert 0 n p 16) l)))) (R : forall r : preg, r <> PC -> r <> rd -> rs2 r = rs1 r) : rs2 rd = Vlong (Int64.repr (Z.lnot (recompose_int 0 ((n, p) :: l)))).","proofString":"exact Q."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm64 n\n     then Porrimm X rd XZR (Int64.unsigned n) :: k\n     else\n      if\n       (Datatypes.length (decompose_int 4 (Int64.unsigned n) 0) <=?\n        Datatypes.length (decompose_int 4 (Z.lnot (Int64.unsigned n)) 0))%nat\n      then loadimm_z X rd (decompose_int 4 (Int64.unsigned n) 0) k\n      else loadimm_n X rd (decompose_int 4 (Z.lnot (Int64.unsigned n)) 0) k)\n    rs m k rs' m /\\\n  rs' rd = Vlong n /\\ (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"destruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite Int64.repr_unsigned, Int64.or_zero_l; auto.\nintros; Simpl.\nset (dz := decompose_int 4%nat (Int64.unsigned n) 0).\nset (dn := decompose_int 4%nat (Z.lnot (Int64.unsigned n)) 0).\nassert (A: Int64.repr (recompose_int 0 dz) = n).\ntransitivity (Int64.repr (Int64.unsigned n)).\napply Int64.eqm_samerepr.\napply decompose_int_eqmod.\napply Int64.repr_unsigned.\nassert (B: Int64.repr (Z.lnot (recompose_int 0 dn)) = n).\ntransitivity (Int64.repr (Int64.unsigned n)).\napply Int64.eqm_samerepr.\napply decompose_notint_eqmod.\napply Int64.repr_unsigned.\ndestruct Nat.leb.\nrewrite <- A.\napply exec_loadimm_z_x.\napply decompose_int_wf; lia.\nrewrite <- B.\napply exec_loadimm_n_x.\napply decompose_int_wf; lia."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (Porrimm X rd XZR (Int64.unsigned n) :: k) rs m k rs' m /\\\n  rs' rd = Vlong n /\\ (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite Int64.repr_unsigned, Int64.or_zero_l; auto.\nintros; Simpl."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) : nextinstr\n  rs # rd <- (Vlong (Int64.or Int64.zero (Int64.repr (Int64.unsigned n)))) rd =\nVlong n.","proofString":"Simpl.\nrewrite Int64.repr_unsigned, Int64.or_zero_l; auto."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) : Vlong (Int64.or Int64.zero (Int64.repr (Int64.unsigned n))) = Vlong n.","proofString":"rewrite Int64.repr_unsigned, Int64.or_zero_l; auto."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) : forall r : preg,\nr <> PC ->\nr <> rd ->\nnextinstr\n  rs # rd <- (Vlong (Int64.or Int64.zero (Int64.repr (Int64.unsigned n)))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn\n    (if\n      (Datatypes.length (decompose_int 4 (Int64.unsigned n) 0) <=?\n       Datatypes.length (decompose_int 4 (Z.lnot (Int64.unsigned n)) 0))%nat\n     then loadimm_z X rd (decompose_int 4 (Int64.unsigned n) 0) k\n     else loadimm_n X rd (decompose_int 4 (Z.lnot (Int64.unsigned n)) 0) k)\n    rs m k rs' m /\\\n  rs' rd = Vlong n /\\ (forall r : preg, r <> PC -> r <> rd -> rs' r = rs r).","proofString":"set (dz := decompose_int 4%nat (Int64.unsigned n) 0).\nset (dn := decompose_int 4%nat (Z.lnot (Int64.unsigned n)) 0).\nassert (A: Int64.repr (recompose_int 0 dz) = n).\ntransitivity (Int64.repr (Int64.unsigned n)).\napply Int64.eqm_samerepr.\napply decompose_int_eqmod.\napply Int64.repr_unsigned.\nassert (B: Int64.repr (Z.lnot (recompose_int 0 dn)) = n).\ntransitivity (Int64.repr (Int64.unsigned n)).\napply Int64.eqm_samerepr.\napply decompose_notint_eqmod.\napply Int64.repr_unsigned.\ndestruct Nat.leb.\nrewrite <- A.\napply exec_loadimm_z_x.\napply decompose_int_wf; lia.\nrewrite <- B.\napply exec_loadimm_n_x.\napply decompose_int_wf; lia."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (dz : list (Z * Z)) (dn : list (Z * Z)) : Int64.repr (Int64.unsigned n) = n.","proofString":"apply Int64.repr_unsigned."},{"statement":"(rd : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (dz : list (Z * Z)) (dn : list (Z * Z)) (A : Int64.repr (recompose_int 0 dz) = n) : Int64.repr (Int64.unsigned n) = n.","proofString":"apply Int64.repr_unsigned."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (addimm_aux insn rd r1 (Int.unsigned n) k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"unfold addimm_aux.\nset (nlo := Zzero_ext 12 (Int.unsigned n)).\nset (nhi := Int.unsigned n - nlo).\nassert (E: Int.unsigned n = nhi + nlo) by (unfold nhi; lia).\nrewrite <- (Int.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.unsigned n - Zzero_ext 12 (Int.unsigned n) =? 0\n     then insn rd r1 (Zzero_ext 12 (Int.unsigned n)) :: k\n     else\n      if Zzero_ext 12 (Int.unsigned n) =? 0\n      then insn rd r1 (Int.unsigned n - Zzero_ext 12 (Int.unsigned n)) :: k\n      else\n       insn rd r1 (Int.unsigned n - Zzero_ext 12 (Int.unsigned n))\n       :: insn rd rd (Zzero_ext 12 (Int.unsigned n)) :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"set (nlo := Zzero_ext 12 (Int.unsigned n)).\nset (nhi := Int.unsigned n - nlo).\nassert (E: Int.unsigned n = nhi + nlo) by (unfold nhi; lia).\nrewrite <- (Int.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.unsigned n - nlo =? 0\n     then insn rd r1 nlo :: k\n     else\n      if nlo =? 0\n      then insn rd r1 (Int.unsigned n - nlo) :: k\n      else insn rd r1 (Int.unsigned n - nlo) :: insn rd rd nlo :: k) rs m k\n    rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"set (nhi := Int.unsigned n - nlo).\nassert (E: Int.unsigned n = nhi + nlo) by (unfold nhi; lia).\nrewrite <- (Int.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) : exists rs' : regset,\n  exec_straight ge fn\n    (if nhi =? 0\n     then insn rd r1 nlo :: k\n     else\n      if nlo =? 0\n      then insn rd r1 nhi :: k\n      else insn rd r1 nhi :: insn rd rd nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"rewrite <- (Int.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) : exists rs' : regset,\n  exec_straight ge fn\n    (if nhi =? 0\n     then insn rd r1 nlo :: k\n     else\n      if nlo =? 0\n      then insn rd r1 nhi :: k\n      else insn rd r1 nhi :: insn rd rd nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint (Int.repr (Int.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (e : nhi = 0) : exists rs' : regset,\n  exec_straight ge fn (insn rd r1 nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint (Int.repr (Int.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (e : nhi = 0) : nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nlo))) rd =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"Simpl.\ndo 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (e : nhi = 0) : sem (rs r1) (Vint (Int.repr nlo)) =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"do 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (e : nhi = 0) : forall r : preg,\ndata_preg r = true ->\nr <> rd -> nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nlo))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : exists rs' : regset,\n  exec_straight ge fn (insn rd r1 nhi :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint (Int.repr (Int.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nhi))) rd =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"Simpl.\ndo 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : sem (rs r1) (Vint (Int.repr nhi)) =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"do 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int),\nsem (sem v (Vint n1)) (Vint n2) = sem v (Vint (Int.add n1 n2))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : forall r : preg,\ndata_preg r = true ->\nr <> rd -> nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nhi))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : exists rs' : regset,\n  exec_straight ge fn (insn rd r1 nhi :: insn rd rd nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint (Int.repr (Int.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : nextinstr\n  (nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nhi)))) # rd <-\n  (sem (nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nhi))) rd)\n     (Vint (Int.repr nlo))) rd =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"Simpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : sem (sem (rs r1) (Vint (Int.repr nhi))) (Vint (Int.repr nlo)) =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"rewrite ASSOC.\ndo 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : sem (rs r1) (Vint (Int.add (Int.repr nhi) (Int.repr nlo))) =\nsem (rs r1) (Vint (Int.repr (Int.unsigned n))).","proofString":"do 2 f_equal.\napply Int.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : Int.add (Int.repr nhi) (Int.repr nlo) = Int.repr (Int.unsigned n).","proofString":"apply Int.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : Int.eqm (Int.unsigned (Int.repr nhi) + Int.unsigned (Int.repr nlo))\n  (Int.unsigned n).","proofString":"rewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : Int.eqm (Int.unsigned (Int.repr nhi) + Int.unsigned (Int.repr nlo))\n  (nhi + nlo).","proofString":"auto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vint (Int.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int),\nsem (sem v (Vint n2)) (Vint n3) = sem v (Vint (Int.add n2 n3))) (rd r1 : iregsp) (n : int) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  (nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nhi)))) # rd <-\n  (sem (nextinstr rs # rd <- (sem (rs r1) (Vint (Int.repr nhi))) rd)\n     (Vint (Int.repr nlo))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (addimm32 rd r1 n k) rs m k rs' m /\\\n  rs' rd = Val.add (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"unfold addimm32.\nset (nn := Int.neg n).\ndestruct (Int.eq n (Int.zero_ext 24 n)); [| destruct (Int.eq nn (Int.zero_ext 24 nn))].\napply exec_addimm_aux_32 with (sem := Val.add).\nauto.\nintros; apply Val.add_assoc.\nrewrite <- Val.sub_opp_add.\napply exec_addimm_aux_32 with (sem := Val.sub).\nauto.\nintros.\nrewrite ! Val.sub_add_opp, Val.add_assoc.\nrewrite Int.neg_add_distr.\nauto.\ndestruct (Int.lt n Int.zero).\nrewrite <- Val.sub_opp_add; fold nn.\nedestruct (exec_loadimm32 X16 nn) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\neapply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite B, C; eauto with asmgen.\nintros; Simpl.\nedestruct (exec_loadimm32 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\neapply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite B, C; eauto with asmgen.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.eq n (Int.zero_ext 24 n)\n     then addimm_aux (Paddimm W) rd r1 (Int.unsigned n) k\n     else\n      if Int.eq (Int.neg n) (Int.zero_ext 24 (Int.neg n))\n      then addimm_aux (Psubimm W) rd r1 (Int.unsigned (Int.neg n)) k\n      else\n       if Int.lt n Int.zero\n       then loadimm32 X16 (Int.neg n) (Psub W rd r1 X16 SOnone :: k)\n       else loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)) rs m k rs' m /\\\n  rs' rd = Val.add (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"set (nn := Int.neg n).\ndestruct (Int.eq n (Int.zero_ext 24 n)); [| destruct (Int.eq nn (Int.zero_ext 24 nn))].\napply exec_addimm_aux_32 with (sem := Val.add).\nauto.\nintros; apply Val.add_assoc.\nrewrite <- Val.sub_opp_add.\napply exec_addimm_aux_32 with (sem := Val.sub).\nauto.\nintros.\nrewrite ! Val.sub_add_opp, Val.add_assoc.\nrewrite Int.neg_add_distr.\nauto.\ndestruct (Int.lt n Int.zero).\nrewrite <- Val.sub_opp_add; fold nn.\nedestruct (exec_loadimm32 X16 nn) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\neapply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite B, C; eauto with asmgen.\nintros; Simpl.\nedestruct (exec_loadimm32 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\neapply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite B, C; eauto with asmgen.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : exists rs' : regset,\n  exec_straight ge fn (addimm_aux (Paddimm W) rd r1 (Int.unsigned n) k) rs m\n    k rs' m /\\\n  rs' rd = Val.add (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"apply exec_addimm_aux_32 with (sem := Val.add).\nauto.\nintros; apply Val.add_assoc."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (Paddimm W rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (Val.add (rs0 r0) (Vint (Int.repr n0)))) m0.","proofString":"auto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : forall (v : val) (n1 n2 : int),\nVal.add (Val.add v (Vint n1)) (Vint n2) = Val.add v (Vint (Int.add n1 n2)).","proofString":"intros; apply Val.add_assoc."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (Psubimm W rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (Val.sub (rs0 r0) (Vint (Int.repr n0)))) m0.","proofString":"auto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : forall (v : val) (n1 n2 : int),\nVal.sub (Val.sub v (Vint n1)) (Vint n2) = Val.sub v (Vint (Int.add n1 n2)).","proofString":"intros.\nrewrite ! Val.sub_add_opp, Val.add_assoc.\nrewrite Int.neg_add_distr.\nauto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (v : val) (n1 n2 : int) : Val.sub (Val.sub v (Vint n1)) (Vint n2) = Val.sub v (Vint (Int.add n1 n2)).","proofString":"rewrite ! Val.sub_add_opp, Val.add_assoc.\nrewrite Int.neg_add_distr.\nauto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (v : val) (n1 n2 : int) : Val.add v (Val.add (Vint (Int.neg n1)) (Vint (Int.neg n2))) =\nVal.add v (Vint (Int.neg (Int.add n1 n2))).","proofString":"rewrite Int.neg_add_distr.\nauto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (v : val) (n1 n2 : int) : Val.add v (Val.add (Vint (Int.neg n1)) (Vint (Int.neg n2))) =\nVal.add v (Vint (Int.add (Int.neg n1) (Int.neg n2))).","proofString":"auto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 nn (Psub W rd r1 X16 SOnone :: k)) rs m\n    k rs' m /\\\n  rs' rd = Val.sub (rs r1) (Vint nn) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"edestruct (exec_loadimm32 X16 nn) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\neapply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite B, C; eauto with asmgen.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 nn (Psub W rd r1 X16 SOnone :: k)) rs m\n  (Psub W rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : nextinstr rs1 # rd <- (Val.sub (rs1 r1) (rs1 X16)) rd =\nVal.sub (rs r1) (Vint nn).","proofString":"Simpl.\nrewrite B, C; eauto with asmgen."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 nn (Psub W rd r1 X16 SOnone :: k)) rs m\n  (Psub W rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.sub (rs1 r1) (rs1 X16) = Val.sub (rs r1) (Vint nn).","proofString":"rewrite B, C; eauto with asmgen."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 nn (Psub W rd r1 X16 SOnone :: k)) rs m\n  (Psub W rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd -> nextinstr rs1 # rd <- (Val.sub (rs1 r1) (rs1 X16)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)) rs m k\n    rs' m /\\\n  rs' rd = Val.add (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"edestruct (exec_loadimm32 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\neapply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nSimpl.\nrewrite B, C; eauto with asmgen.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)) rs m\n  (Padd W rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : nextinstr rs1 # rd <- (Val.add (rs1 r1) (rs1 X16)) rd =\nVal.add (rs r1) (Vint n).","proofString":"Simpl.\nrewrite B, C; eauto with asmgen."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)) rs m\n  (Padd W rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.add (rs1 r1) (rs1 X16) = Val.add (rs r1) (Vint n).","proofString":"rewrite B, C; eauto with asmgen."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)) rs m\n  (Padd W rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd -> nextinstr rs1 # rd <- (Val.add (rs1 r1) (rs1 X16)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn (addimm_aux insn rd r1 (Int64.unsigned n) k) rs m k rs'\n    m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"unfold addimm_aux.\nset (nlo := Zzero_ext 12 (Int64.unsigned n)).\nset (nhi := Int64.unsigned n - nlo).\nassert (E: Int64.unsigned n = nhi + nlo) by (unfold nhi; lia).\nrewrite <- (Int64.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int64.unsigned n - Zzero_ext 12 (Int64.unsigned n) =? 0\n     then insn rd r1 (Zzero_ext 12 (Int64.unsigned n)) :: k\n     else\n      if Zzero_ext 12 (Int64.unsigned n) =? 0\n      then\n       insn rd r1 (Int64.unsigned n - Zzero_ext 12 (Int64.unsigned n)) :: k\n      else\n       insn rd r1 (Int64.unsigned n - Zzero_ext 12 (Int64.unsigned n))\n       :: insn rd rd (Zzero_ext 12 (Int64.unsigned n)) :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"set (nlo := Zzero_ext 12 (Int64.unsigned n)).\nset (nhi := Int64.unsigned n - nlo).\nassert (E: Int64.unsigned n = nhi + nlo) by (unfold nhi; lia).\nrewrite <- (Int64.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int64.unsigned n - nlo =? 0\n     then insn rd r1 nlo :: k\n     else\n      if nlo =? 0\n      then insn rd r1 (Int64.unsigned n - nlo) :: k\n      else insn rd r1 (Int64.unsigned n - nlo) :: insn rd rd nlo :: k) rs m k\n    rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"set (nhi := Int64.unsigned n - nlo).\nassert (E: Int64.unsigned n = nhi + nlo) by (unfold nhi; lia).\nrewrite <- (Int64.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) : exists rs' : regset,\n  exec_straight ge fn\n    (if nhi =? 0\n     then insn rd r1 nlo :: k\n     else\n      if nlo =? 0\n      then insn rd r1 nhi :: k\n      else insn rd r1 nhi :: insn rd rd nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"rewrite <- (Int64.repr_unsigned n).\ndestruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) : exists rs' : regset,\n  exec_straight ge fn\n    (if nhi =? 0\n     then insn rd r1 nlo :: k\n     else\n      if nlo =? 0\n      then insn rd r1 nhi :: k\n      else insn rd r1 nhi :: insn rd rd nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (Z.eqb_spec nhi 0); [|destruct (Z.eqb_spec nlo 0)].\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (e : nhi = 0) : exists rs' : regset,\n  exec_straight ge fn (insn rd r1 nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (e : nhi = 0) : nextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nlo))) rd =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"Simpl.\ndo 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (e : nhi = 0) : sem (rs r1) (Vlong (Int64.repr nlo)) =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"do 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n0)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (e : nhi = 0) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nlo))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : exists rs' : regset,\n  exec_straight ge fn (insn rd r1 nhi :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\napply SEM.\nSimpl.\nsplit.\nSimpl.\ndo 3 f_equal; lia.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : nextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nhi))) rd =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"Simpl.\ndo 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : sem (rs r1) (Vlong (Int64.repr nhi)) =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"do 3 f_equal; lia."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n1 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n1) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n1)))) m0) (ASSOC : forall (v : val) (n1 n2 : int64),\nsem (sem v (Vlong n1)) (Vlong n2) = sem v (Vlong (Int64.add n1 n2))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (e : nlo = 0) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nhi))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : exists rs' : regset,\n  exec_straight ge fn (insn rd r1 nhi :: insn rd rd nlo :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\neapply exec_straight_two.\napply SEM.\napply SEM.\nSimpl.\nSimpl.\nsplit.\nSimpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints.\nintros; Simpl."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : nextinstr\n  (nextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nhi)))) # rd <-\n  (sem (nextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nhi))) rd)\n     (Vlong (Int64.repr nlo))) rd =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"Simpl.\nrewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : sem (sem (rs r1) (Vlong (Int64.repr nhi))) (Vlong (Int64.repr nlo)) =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"rewrite ASSOC.\ndo 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : sem (rs r1) (Vlong (Int64.add (Int64.repr nhi) (Int64.repr nlo))) =\nsem (rs r1) (Vlong (Int64.repr (Int64.unsigned n))).","proofString":"do 2 f_equal.\napply Int64.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : Int64.add (Int64.repr nhi) (Int64.repr nlo) = Int64.repr (Int64.unsigned n).","proofString":"apply Int64.eqm_samerepr.\nrewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : Int64.eqm (Int64.unsigned (Int64.repr nhi) + Int64.unsigned (Int64.repr nlo))\n  (Int64.unsigned n).","proofString":"rewrite E.\nauto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : Int64.eqm (Int64.unsigned (Int64.repr nhi) + Int64.unsigned (Int64.repr nlo))\n  (nhi + nlo).","proofString":"auto with ints."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (sem : val -> val -> val) (SEM : forall (rd0 r0 : iregsp) (n2 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn rd0 r0 n2) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (Vlong (Int64.repr n2)))) m0) (ASSOC : forall (v : val) (n2 n3 : int64),\nsem (sem v (Vlong n2)) (Vlong n3) = sem v (Vlong (Int64.add n2 n3))) (rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (nlo : Z) (nhi : Z) (E : Int64.unsigned n = nhi + nlo) (n0 : nhi <> 0) (n1 : nlo <> 0) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  (nextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nhi)))) # rd <-\n  (sem (nextinstr rs # rd <- (sem (rs r1) (Vlong (Int64.repr nhi))) rd)\n     (Vlong (Int64.repr nlo))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) : exists rs' : regset,\n  exec_straight ge fn (addimm_aux (Paddimm X) rd r1 (Int64.unsigned n) k) rs\n    m k rs' m /\\\n  rs' rd = Val.addl (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"apply exec_addimm_aux_64 with (sem := Val.addl).\nauto.\nintros; apply Val.addl_assoc."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (Paddimm X rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (Val.addl (rs0 r0) (Vlong (Int64.repr n0)))) m0.","proofString":"auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) : forall (v : val) (n1 n2 : int64),\nVal.addl (Val.addl v (Vlong n1)) (Vlong n2) =\nVal.addl v (Vlong (Int64.add n1 n2)).","proofString":"intros; apply Val.addl_assoc."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) : forall (rd0 r0 : iregsp) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (Psubimm X rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (Val.subl (rs0 r0) (Vlong (Int64.repr n0)))) m0.","proofString":"auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) : forall (v : val) (n1 n2 : int64),\nVal.subl (Val.subl v (Vlong n1)) (Vlong n2) =\nVal.subl v (Vlong (Int64.add n1 n2)).","proofString":"intros.\nrewrite ! Val.subl_addl_opp, Val.addl_assoc.\nrewrite Int64.neg_add_distr.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (v : val) (n1 n2 : int64) : Val.subl (Val.subl v (Vlong n1)) (Vlong n2) =\nVal.subl v (Vlong (Int64.add n1 n2)).","proofString":"rewrite ! Val.subl_addl_opp, Val.addl_assoc.\nrewrite Int64.neg_add_distr.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (v : val) (n1 n2 : int64) : Val.addl v (Val.addl (Vlong (Int64.neg n1)) (Vlong (Int64.neg n2))) =\nVal.addl v (Vlong (Int64.neg (Int64.add n1 n2))).","proofString":"rewrite Int64.neg_add_distr.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (v : val) (n1 n2 : int64) : Val.addl v (Val.addl (Vlong (Int64.neg n1)) (Vlong (Int64.neg n2))) =\nVal.addl v (Vlong (Int64.add (Int64.neg n1) (Int64.neg n2))).","proofString":"auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 nn (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Psubext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.subl (rs r1) (Val.shll (Vlong nn) (Vint Int.zero)) =\nVal.subl (rs r1) (Vlong nn).","proofString":"simpl.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 nn (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Psubext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.subl (rs r1)\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' nn Int.zero)\n   else Vundef) = Val.subl (rs r1) (Vlong nn).","proofString":"rewrite Int64.shl'_zero.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 nn (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Psubext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.subl (rs r1)\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong nn else Vundef) =\nVal.subl (rs r1) (Vlong nn).","proofString":"auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 nn (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Psubext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong nn) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs1 # rd <- (Val.subl (rs1 r1) (Val.shll (rs1 X16) (Vint Int.zero))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Paddext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.addl (rs r1) (Val.shll (Vlong n) (Vint Int.zero)) =\nVal.addl (rs r1) (Vlong n).","proofString":"simpl.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Paddext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.addl (rs r1)\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' n Int.zero)\n   else Vundef) = Val.addl (rs r1) (Vlong n).","proofString":"rewrite Int64.shl'_zero.\nauto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Paddext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : Val.addl (rs r1)\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong n else Vundef) =\nVal.addl (rs r1) (Vlong n).","proofString":"auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (nn : int64) (rs1 : regset) (A : exec_straight ge fn\n  (loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)) rs m\n  (Paddext rd r1 X16 (EOuxtx Int.zero) :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs1 # rd <- (Val.addl (rs1 r1) (Val.shll (rs1 X16) (Vint Int.zero))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (logicalimm32 insn1 insn2 rd r1 n k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"unfold logicalimm32.\ndestruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\napply SEM1.\nreflexivity.\nsplit.\nSimpl.\nrewrite Int.repr_unsigned; auto.\nintros; Simpl.\nedestruct (exec_loadimm32 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\napply SEM2.\nreflexivity.\nsplit.\nSimpl.\nf_equal; auto.\napply C; auto with asmgen.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm32 n\n     then insn1 rd r1 (Int.unsigned n) :: k\n     else loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\napply SEM1.\nreflexivity.\nsplit.\nSimpl.\nrewrite Int.repr_unsigned; auto.\nintros; Simpl.\nedestruct (exec_loadimm32 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\napply SEM2.\nreflexivity.\nsplit.\nSimpl.\nf_equal; auto.\napply C; auto with asmgen.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (insn1 rd r1 (Int.unsigned n) :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\napply SEM1.\nreflexivity.\nsplit.\nSimpl.\nrewrite Int.repr_unsigned; auto.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : nextinstr rs # rd <- (sem (ir0w rs r1) (Vint (Int.repr (Int.unsigned n)))) rd =\nsem (rs r1) (Vint n).","proofString":"Simpl.\nrewrite Int.repr_unsigned; auto."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : sem (ir0w rs r1) (Vint (Int.repr (Int.unsigned n))) = sem (rs r1) (Vint n).","proofString":"rewrite Int.repr_unsigned; auto."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr rs # rd <- (sem (ir0w rs r1) (Vint (Int.repr (Int.unsigned n)))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m k\n    rs' m /\\\n  rs' rd = sem (rs r1) (Vint n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"edestruct (exec_loadimm32 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\napply SEM2.\nreflexivity.\nsplit.\nSimpl.\nf_equal; auto.\napply C; auto with asmgen.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : nextinstr\n  rs1 # rd <- (sem (ir0w rs1 r1) (eval_shift_op_int (rs1 X16) SOnone)) rd =\nsem (rs r1) (Vint n).","proofString":"Simpl.\nf_equal; auto.\napply C; auto with asmgen."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : sem (ir0w rs1 r1) (eval_shift_op_int (rs1 X16) SOnone) = sem (rs r1) (Vint n).","proofString":"f_equal; auto.\napply C; auto with asmgen."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : ir0w rs1 r1 = rs r1.","proofString":"apply C; auto with asmgen."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (Vint (Int.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0w rs0 r0) (eval_shift_op_int (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs1 # rd <- (sem (ir0w rs1 r1) (eval_shift_op_int (rs1 X16) SOnone)) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (logicalimm64 insn1 insn2 rd r1 n k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"unfold logicalimm64.\ndestruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\napply SEM1.\nreflexivity.\nsplit.\nSimpl.\nrewrite Int64.repr_unsigned.\nauto.\nintros; Simpl.\nedestruct (exec_loadimm64 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\napply SEM2.\nreflexivity.\nsplit.\nSimpl.\nf_equal; auto.\napply C; auto with asmgen.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm64 n\n     then insn1 rd r1 (Int64.unsigned n) :: k\n     else loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\napply SEM1.\nreflexivity.\nsplit.\nSimpl.\nrewrite Int64.repr_unsigned.\nauto.\nintros; Simpl.\nedestruct (exec_loadimm64 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\napply SEM2.\nreflexivity.\nsplit.\nSimpl.\nf_equal; auto.\napply C; auto with asmgen.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (insn1 rd r1 (Int64.unsigned n) :: k) rs m k rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\napply SEM1.\nreflexivity.\nsplit.\nSimpl.\nrewrite Int64.repr_unsigned.\nauto.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : nextinstr\n  rs # rd <- (sem (ir0x rs r1) (Vlong (Int64.repr (Int64.unsigned n)))) rd =\nsem (rs r1) (Vlong n).","proofString":"Simpl.\nrewrite Int64.repr_unsigned.\nauto."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : sem (ir0x rs r1) (Vlong (Int64.repr (Int64.unsigned n))) =\nsem (rs r1) (Vlong n).","proofString":"rewrite Int64.repr_unsigned.\nauto."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : sem (ir0x rs r1) (Vlong n) = sem (rs r1) (Vlong n).","proofString":"auto."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs # rd <- (sem (ir0x rs r1) (Vlong (Int64.repr (Int64.unsigned n)))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m k\n    rs' m /\\\n  rs' rd = sem (rs r1) (Vlong n) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"edestruct (exec_loadimm64 X16 n) as (rs1 & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\napply SEM2.\nreflexivity.\nsplit.\nSimpl.\nf_equal; auto.\napply C; auto with asmgen.\nintros; Simpl."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : nextinstr\n  rs1 # rd <- (sem (ir0x rs1 r1) (eval_shift_op_long (rs1 X16) SOnone)) rd =\nsem (rs r1) (Vlong n).","proofString":"Simpl.\nf_equal; auto.\napply C; auto with asmgen."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : sem (ir0x rs1 r1) (eval_shift_op_long (rs1 X16) SOnone) =\nsem (rs r1) (Vlong n).","proofString":"f_equal; auto.\napply C; auto with asmgen."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : ir0x rs1 r1 = rs r1.","proofString":"apply C; auto with asmgen."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (sem : val -> val -> val) (SEM1 : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z) (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn1 rd0 r0 n0) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (Vlong (Int64.repr n0)))) m0) (SEM2 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insn2 rd0 r0 r2 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r2) s)))\n  m0) (rd r1 : ireg) (n : int64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs1 : regset) (A : exec_straight ge fn (loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)) rs m\n  (insn2 rd r1 X16 SOnone :: k) rs1 m) (B : rs1 X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs1 r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs1 # rd <- (sem (ir0x rs1 r1) (eval_shift_op_long (rs1 X16) SOnone)) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ SelectOp.symbol_is_relocatable s = false) : exists rs' : regset,\n  exec_straight ge fn\n    (if SelectOp.symbol_is_relocatable s\n     then\n      if Ptrofs.eq ofs Ptrofs.zero\n      then Ploadsymbol rd s :: k\n      else Ploadsymbol rd s :: addimm64 rd rd (Ptrofs.to_int64 ofs) k\n     else Padrp rd s ofs :: Paddadr rd rd s ofs :: k) rs m k rs' m /\\\n  rs' rd = Genv.symbol_address ge s ofs /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (SelectOp.symbol_is_relocatable s).\npredSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero.\nsubst ofs.\neconstructor; split.\napply exec_straight_one; [simpl; eauto | reflexivity].\nsplit.\nSimpl.\nintros; Simpl.\nexploit exec_addimm64.\ninstantiate (1 := rd).\nsimpl.\ndestruct H; congruence.\nintros (rs1 & A & B & C).\neconstructor; split.\neconstructor.\nsimpl; eauto.\nauto.\neexact A.\nsplit.\nsimpl in B; rewrite B.\nSimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto.\nintros.\nrewrite C by auto.\nSimpl.\neconstructor; split.\neapply exec_straight_two.\nsimpl; eauto.\nsimpl; eauto.\nauto.\nauto.\nsplit.\nSimpl.\nrewrite symbol_high_low; auto.\nintros; Simpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) : exists rs' : regset,\n  exec_straight ge fn\n    (if Ptrofs.eq ofs Ptrofs.zero\n     then Ploadsymbol rd s :: k\n     else Ploadsymbol rd s :: addimm64 rd rd (Ptrofs.to_int64 ofs) k) rs m k\n    rs' m /\\\n  rs' rd = Genv.symbol_address ge s ofs /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"predSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero.\nsubst ofs.\neconstructor; split.\napply exec_straight_one; [simpl; eauto | reflexivity].\nsplit.\nSimpl.\nintros; Simpl.\nexploit exec_addimm64.\ninstantiate (1 := rd).\nsimpl.\ndestruct H; congruence.\nintros (rs1 & A & B & C).\neconstructor; split.\neconstructor.\nsimpl; eauto.\nauto.\neexact A.\nsplit.\nsimpl in B; rewrite B.\nSimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto.\nintros.\nrewrite C by auto.\nSimpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs = Ptrofs.zero) : exists rs' : regset,\n  exec_straight ge fn (Ploadsymbol rd s :: k) rs m k rs' m /\\\n  rs' rd = Genv.symbol_address ge s ofs /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"subst ofs.\neconstructor; split.\napply exec_straight_one; [simpl; eauto | reflexivity].\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(rd : ireg) (s : ident) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) : exists rs' : regset,\n  exec_straight ge fn (Ploadsymbol rd s :: k) rs m k rs' m /\\\n  rs' rd = Genv.symbol_address ge s Ptrofs.zero /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one; [simpl; eauto | reflexivity].\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(rd : ireg) (s : ident) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) : nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd =\nGenv.symbol_address ge s Ptrofs.zero.","proofString":"Simpl."},{"statement":"(rd : ireg) (s : ident) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) : exists rs' : regset,\n  exec_straight ge fn\n    (Ploadsymbol rd s :: addimm64 rd rd (Ptrofs.to_int64 ofs) k) rs m k rs' m /\\\n  rs' rd = Genv.symbol_address ge s ofs /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"exploit exec_addimm64.\ninstantiate (1 := rd).\nsimpl.\ndestruct H; congruence.\nintros (rs1 & A & B & C).\neconstructor; split.\neconstructor.\nsimpl; eauto.\nauto.\neexact A.\nsplit.\nsimpl in B; rewrite B.\nSimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto.\nintros.\nrewrite C by auto.\nSimpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) : rd <> X16.","proofString":"simpl.\ndestruct H; congruence."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) : rd <> X16.","proofString":"destruct H; congruence."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nrs1 r = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r) : rs1 rd = Genv.symbol_address ge s ofs.","proofString":"simpl in B; rewrite B.\nSimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nrs1 r = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r) : Val.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs)) = Genv.symbol_address ge s ofs.","proofString":"Simpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nrs1 r = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r) : Val.addl (Genv.symbol_address ge s Ptrofs.zero) (Vlong (Ptrofs.to_int64 ofs)) =\nGenv.symbol_address ge s ofs.","proofString":"rewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nrs1 r = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r) : Genv.symbol_address ge s\n  (Ptrofs.add Ptrofs.zero (Ptrofs.of_int64 (Ptrofs.to_int64 ofs))) =\nGenv.symbol_address ge s ofs.","proofString":"rewrite Ptrofs.add_zero_l, Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nrs1 r = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r) : Genv.symbol_address ge s ofs = Genv.symbol_address ge s ofs.","proofString":"auto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nrs1 r = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r) : forall r : preg, data_preg r = true -> r <> rd -> rs1 r = rs r.","proofString":"intros.\nrewrite C by auto.\nSimpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r0 : preg,\ndata_preg r0 = true ->\nr0 <> rd ->\nrs1 r0 = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r0) (r : preg) (H1 : data_preg r = true) (H2 : r <> rd) : rs1 r = rs r.","proofString":"rewrite C by auto.\nSimpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ true = false) (H0 : ofs <> Ptrofs.zero) (rs1 : regset) (A : exec_straight ge fn (addimm64 rd rd (Ptrofs.to_int64 ofs) k)\n  (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero)) m k rs1 m) (B : rs1 rd =\nVal.addl (nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) rd)\n  (Vlong (Ptrofs.to_int64 ofs))) (C : forall r0 : preg,\ndata_preg r0 = true ->\nr0 <> rd ->\nrs1 r0 = nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r0) (r : preg) (H1 : data_preg r = true) (H2 : r <> rd) : nextinstr rs # rd <- (Genv.symbol_address ge s Ptrofs.zero) r = rs r.","proofString":"Simpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ false = false) : exists rs' : regset,\n  exec_straight ge fn (Padrp rd s ofs :: Paddadr rd rd s ofs :: k) rs m k rs'\n    m /\\\n  rs' rd = Genv.symbol_address ge s ofs /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\neapply exec_straight_two.\nsimpl; eauto.\nsimpl; eauto.\nauto.\nauto.\nsplit.\nSimpl.\nrewrite symbol_high_low; auto.\nintros; Simpl."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ false = false) : nextinstr\n  (nextinstr rs # rd <- (symbol_high ge s ofs)) # rd <-\n  (Val.addl (nextinstr rs # rd <- (symbol_high ge s ofs) rd)\n     (symbol_low ge s ofs)) rd = Genv.symbol_address ge s ofs.","proofString":"Simpl.\nrewrite symbol_high_low; auto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ false = false) : Val.addl (symbol_high ge s ofs) (symbol_low ge s ofs) =\nGenv.symbol_address ge s ofs.","proofString":"rewrite symbol_high_low; auto."},{"statement":"(rd : ireg) (s : ident) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (H : rd <> X16 \\/ false = false) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  (nextinstr rs # rd <- (symbol_high ge s ofs)) # rd <-\n  (Val.addl (nextinstr rs # rd <- (symbol_high ge s ofs) rd)\n     (symbol_low ge s ofs)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(s : shift) (v : val) (a : amount32) : eval_shift_op_int v (transl_shift s a) = eval_shift s v a.","proofString":"destruct s; simpl; auto."},{"statement":"(s : shift) (v : val) (a : amount32) : Val.or (Vint Int.zero) (eval_shift_op_int v (transl_shift s a)) =\neval_shift s v a.","proofString":"rewrite or_zero_eval_shift_op_int by (apply transl_shift_not_none).\napply transl_eval_shift."},{"statement":"(s : shift) (v : val) (a : amount32) : eval_shift_op_int v (transl_shift s a) = eval_shift s v a.","proofString":"apply transl_eval_shift."},{"statement":"(s : shift) (v : val) (a : amount64) : eval_shift_op_long v (transl_shift s a) = eval_shiftl s v a.","proofString":"destruct s; simpl; auto."},{"statement":"(s : shift) (v : val) (a : amount64) : Val.orl (Vlong Int64.zero) (eval_shift_op_long v (transl_shift s a)) =\neval_shiftl s v a.","proofString":"rewrite or_zero_eval_shift_op_long by (apply transl_shift_not_none).\napply transl_eval_shiftl."},{"statement":"(s : shift) (v : val) (a : amount64) : eval_shift_op_long v (transl_shift s a) = eval_shiftl s v a.","proofString":"apply transl_eval_shiftl."},{"statement":"(s : shift) (v : val) (a : amount64) : Val.addl (Vlong Int64.zero) (eval_shift_op_long v (transl_shift s a)) =\neval_shiftl s v a.","proofString":"rewrite add_zero_eval_shift_op_long by (apply transl_shift_not_none).\napply transl_eval_shiftl."},{"statement":"(s : shift) (v : val) (a : amount64) : eval_shift_op_long v (transl_shift s a) = eval_shiftl s v a.","proofString":"apply transl_eval_shiftl."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (arith_extended insnX insnS rd r1 r2 ex a k) rs m k rs'\n    m /\\\n  rs' rd = sem (rs r1) (Op.eval_extend ex (rs r2) a) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"unfold arith_extended.\ndestruct (Int.ltu a (Int.repr 5)).\neconstructor; split.\napply exec_straight_one.\nrewrite EX; eauto.\nauto.\nsplit.\nSimpl.\nf_equal.\ndestruct ex; auto.\nintros; Simpl.\nexploit (exec_move_extended_base X16 r2 ex).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nrewrite ES.\neauto.\nauto.\nsplit.\nSimpl.\nunfold ir0x.\nrewrite C by eauto with asmgen.\nf_equal.\nrewrite B.\ndestruct ex; auto.\nintros; Simpl."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.ltu a (Int.repr 5)\n     then insnX rd r1 r2 (transl_extension ex a) :: k\n     else move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n    k rs' m /\\\n  rs' rd = sem (rs r1) (Op.eval_extend ex (rs r2) a) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (Int.ltu a (Int.repr 5)).\neconstructor; split.\napply exec_straight_one.\nrewrite EX; eauto.\nauto.\nsplit.\nSimpl.\nf_equal.\ndestruct ex; auto.\nintros; Simpl.\nexploit (exec_move_extended_base X16 r2 ex).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nrewrite ES.\neauto.\nauto.\nsplit.\nSimpl.\nunfold ir0x.\nrewrite C by eauto with asmgen.\nf_equal.\nrewrite B.\ndestruct ex; auto.\nintros; Simpl."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (insnX rd r1 r2 (transl_extension ex a) :: k) rs m k\n    rs' m /\\\n  rs' rd = sem (rs r1) (Op.eval_extend ex (rs r2) a) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nrewrite EX; eauto.\nauto.\nsplit.\nSimpl.\nf_equal.\ndestruct ex; auto.\nintros; Simpl."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : nextinstr\n  rs # rd <- (sem (rs r1) (eval_extend (rs r2) (transl_extension ex a))) rd =\nsem (rs r1) (Op.eval_extend ex (rs r2) a).","proofString":"Simpl.\nf_equal.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : sem (rs r1) (eval_extend (rs r2) (transl_extension ex a)) =\nsem (rs r1) (Op.eval_extend ex (rs r2) a).","proofString":"f_equal.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : eval_extend (rs r2) (transl_extension ex a) = Op.eval_extend ex (rs r2) a.","proofString":"destruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs # rd <- (sem (rs r1) (eval_extend (rs r2) (transl_extension ex a))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m k\n    rs' m /\\\n  rs' rd = sem (rs r1) (Op.eval_extend ex (rs r2) a) /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"exploit (exec_move_extended_base X16 r2 ex).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nrewrite ES.\neauto.\nauto.\nsplit.\nSimpl.\nunfold ir0x.\nrewrite C by eauto with asmgen.\nf_equal.\nrewrite B.\ndestruct ex; auto.\nintros; Simpl."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : nextinstr\n  rs' # rd <- (sem (ir0x rs' r1) (eval_shift_op_long (rs' X16) (SOlsl a))) rd =\nsem (rs r1) (Op.eval_extend ex (rs r2) a).","proofString":"Simpl.\nunfold ir0x.\nrewrite C by eauto with asmgen.\nf_equal.\nrewrite B.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : sem (ir0x rs' r1) (eval_shift_op_long (rs' X16) (SOlsl a)) =\nsem (rs r1) (Op.eval_extend ex (rs r2) a).","proofString":"unfold ir0x.\nrewrite C by eauto with asmgen.\nf_equal.\nrewrite B.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : sem (rs' r1) (eval_shift_op_long (rs' X16) (SOlsl a)) =\nsem (rs r1) (Op.eval_extend ex (rs r2) a).","proofString":"rewrite C by eauto with asmgen.\nf_equal.\nrewrite B.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : sem (rs r1) (eval_shift_op_long (rs' X16) (SOlsl a)) =\nsem (rs r1) (Op.eval_extend ex (rs r2) a).","proofString":"f_equal.\nrewrite B.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : eval_shift_op_long (rs' X16) (SOlsl a) = Op.eval_extend ex (rs r2) a.","proofString":"rewrite B.\ndestruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : eval_shift_op_long\n  match ex with\n  | Xsgn32 => Val.longofint (rs r2)\n  | Xuns32 => Val.longofintu (rs r2)\n  end (SOlsl a) = Op.eval_extend ex (rs r2) a.","proofString":"destruct ex; auto."},{"statement":"(sem : val -> val -> val) (insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (EX : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnX rd0 r0 r3 x) rs0 m0 =\nNext (nextinstr rs0 # rd0 <- (sem (rs0 r0) (eval_extend (rs0 r3) x))) m0) (ES : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op) \n  (rs0 : regset) (m0 : mem),\nexec_instr ge fn (insnS rd0 r0 r3 s) rs0 m0 =\nNext\n  (nextinstr rs0 # rd0 <- (sem (ir0x rs0 r0) (eval_shift_op_long (rs0 r3) s)))\n  m0) (rd r1 r2 : ireg) (ex : extension) (a : amount64) (k : code) (rs : regset) (m : mem) (H : r1 <> X16) (rs' : regset) (A : exec_straight ge fn\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)) rs m\n  (insnS rd r1 X16 (SOlsl a) :: k) rs' m) (B : rs' X16 =\nmatch ex with\n| Xsgn32 => Val.longofint (rs r2)\n| Xuns32 => Val.longofintu (rs r2)\nend) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  rs' # rd <- (sem (ir0x rs' r1) (eval_shift_op_long (rs' X16) (SOlsl a))) r =\nrs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (H : Val.shrx (rs r1) (Vint n) = Some v) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.eq n Int.zero\n     then Pmov rd r1 :: k\n     else\n      Porr W X16 XZR r1 (SOasr (Int.repr 31))\n      :: Padd W X16 r1 X16 (SOlsr (Int.sub Int.iwordsize n))\n         :: Porr W rd XZR X16 (SOasr n) :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"apply Val.shrx_shr_2 in H.\ndestruct (Int.eq n Int.zero) eqn:E.\neconstructor; split.\napply exec_straight_one; [simpl;eauto|auto].\nsplit.\nSimpl.\nsubst v; auto.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_three.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_int by congruence.\neauto.\nsimpl; eauto.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_int by congruence.\neauto.\nauto.\nauto.\nauto.\nsplit.\nsubst v; Simpl.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (H : v =\n(if Int.eq n Int.zero\n then rs r1\n else\n  Val.shr\n    (Val.add (rs r1)\n       (Val.shru (Val.shr (rs r1) (Vint (Int.repr 31)))\n          (Vint (Int.sub (Int.repr 32) n)))) (Vint n))) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.eq n Int.zero\n     then Pmov rd r1 :: k\n     else\n      Porr W X16 XZR r1 (SOasr (Int.repr 31))\n      :: Padd W X16 r1 X16 (SOlsr (Int.sub Int.iwordsize n))\n         :: Porr W rd XZR X16 (SOasr n) :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (Int.eq n Int.zero) eqn:E.\neconstructor; split.\napply exec_straight_one; [simpl;eauto|auto].\nsplit.\nSimpl.\nsubst v; auto.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_three.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_int by congruence.\neauto.\nsimpl; eauto.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_int by congruence.\neauto.\nauto.\nauto.\nauto.\nsplit.\nsubst v; Simpl.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H : v = rs r1) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (Pmov rd r1 :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one; [simpl;eauto|auto].\nsplit.\nSimpl.\nsubst v; auto.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H : v = rs r1) (H0 : r1 <> X16) : nextinstr rs # rd <- (rs r1) rd = v.","proofString":"Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H : v = rs r1) (H0 : r1 <> X16) : forall r : preg,\ndata_preg r = true -> r <> rd -> nextinstr rs # rd <- (rs r1) r = rs r.","proofString":"subst v; auto.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H0 : r1 <> X16) : forall r : preg,\ndata_preg r = true -> r <> rd -> nextinstr rs # rd <- (rs r1) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = false) (H : v =\nVal.shr\n  (Val.add (rs r1)\n     (Val.shru (Val.shr (rs r1) (Vint (Int.repr 31)))\n        (Vint (Int.sub (Int.repr 32) n)))) (Vint n)) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (Porr W X16 XZR r1 (SOasr (Int.repr 31))\n     :: Padd W X16 r1 X16 (SOlsr (Int.sub Int.iwordsize n))\n        :: Porr W rd XZR X16 (SOasr n) :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\neapply exec_straight_three.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_int by congruence.\neauto.\nsimpl; eauto.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_int by congruence.\neauto.\nauto.\nauto.\nauto.\nsplit.\nsubst v; Simpl.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = false) (H : v =\nVal.shr\n  (Val.add (rs r1)\n     (Val.shru (Val.shr (rs r1) (Vint (Int.repr 31)))\n        (Vint (Int.sub (Int.repr 32) n)))) (Vint n)) (H0 : r1 <> X16) : nextinstr\n  (nextinstr\n     (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31)))) # X16 <-\n     (Val.add\n        (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))) r1)\n        (Val.shru\n           (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))) X16)\n           (Vint (Int.sub Int.iwordsize n))))) # rd <-\n  (eval_shift_op_int\n     (nextinstr\n        (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))))\n        # X16 <-\n        (Val.add\n           (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))) r1)\n           (Val.shru\n              (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31)))\n                 X16) (Vint (Int.sub Int.iwordsize n)))) X16) \n     (SOasr n)) rd = v.","proofString":"subst v; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = false) (H : v =\nVal.shr\n  (Val.add (rs r1)\n     (Val.shru (Val.shr (rs r1) (Vint (Int.repr 31)))\n        (Vint (Int.sub (Int.repr 32) n)))) (Vint n)) (H0 : r1 <> X16) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  (nextinstr\n     (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31)))) # X16 <-\n     (Val.add\n        (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))) r1)\n        (Val.shru\n           (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))) X16)\n           (Vint (Int.sub Int.iwordsize n))))) # rd <-\n  (eval_shift_op_int\n     (nextinstr\n        (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))))\n        # X16 <-\n        (Val.add\n           (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31))) r1)\n           (Val.shru\n              (nextinstr rs # X16 <- (Val.shr (rs r1) (Vint (Int.repr 31)))\n                 X16) (Vint (Int.sub Int.iwordsize n)))) X16) \n     (SOasr n)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (H : Val.shrxl (rs r1) (Vint n) = Some v) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.eq n Int.zero\n     then Pmov rd r1 :: k\n     else\n      Porr X X16 XZR r1 (SOasr (Int.repr 63))\n      :: Padd X X16 r1 X16 (SOlsr (Int.sub Int64.iwordsize' n))\n         :: Porr X rd XZR X16 (SOasr n) :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"apply Val.shrxl_shrl_2 in H.\ndestruct (Int.eq n Int.zero) eqn:E.\neconstructor; split.\napply exec_straight_one; [simpl;eauto|auto].\nsplit.\nSimpl.\nsubst v; auto.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_three.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_long by congruence.\neauto.\nsimpl; eauto.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_long by congruence.\neauto.\nauto.\nauto.\nauto.\nsplit.\nsubst v; Simpl.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (H : v =\n(if Int.eq n Int.zero\n then rs r1\n else\n  Val.shrl\n    (Val.addl (rs r1)\n       (Val.shrlu (Val.shrl (rs r1) (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n))) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (if Int.eq n Int.zero\n     then Pmov rd r1 :: k\n     else\n      Porr X X16 XZR r1 (SOasr (Int.repr 63))\n      :: Padd X X16 r1 X16 (SOlsr (Int.sub Int64.iwordsize' n))\n         :: Porr X rd XZR X16 (SOasr n) :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"destruct (Int.eq n Int.zero) eqn:E.\neconstructor; split.\napply exec_straight_one; [simpl;eauto|auto].\nsplit.\nSimpl.\nsubst v; auto.\nintros; Simpl.\neconstructor; split.\neapply exec_straight_three.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_long by congruence.\neauto.\nsimpl; eauto.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_long by congruence.\neauto.\nauto.\nauto.\nauto.\nsplit.\nsubst v; Simpl.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H : v = rs r1) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn (Pmov rd r1 :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one; [simpl;eauto|auto].\nsplit.\nSimpl.\nsubst v; auto.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H : v = rs r1) (H0 : r1 <> X16) : nextinstr rs # rd <- (rs r1) rd = v.","proofString":"Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H : v = rs r1) (H0 : r1 <> X16) : forall r : preg,\ndata_preg r = true -> r <> rd -> nextinstr rs # rd <- (rs r1) r = rs r.","proofString":"subst v; auto.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (rs : regset) (m : mem) (E : Int.eq n Int.zero = true) (H0 : r1 <> X16) : forall r : preg,\ndata_preg r = true -> r <> rd -> nextinstr rs # rd <- (rs r1) r = rs r.","proofString":"intros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = false) (H : v =\nVal.shrl\n  (Val.addl (rs r1)\n     (Val.shrlu (Val.shrl (rs r1) (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (H0 : r1 <> X16) : exists rs' : regset,\n  exec_straight ge fn\n    (Porr X X16 XZR r1 (SOasr (Int.repr 63))\n     :: Padd X X16 r1 X16 (SOlsr (Int.sub Int64.iwordsize' n))\n        :: Porr X rd XZR X16 (SOasr n) :: k) rs m k rs' m /\\\n  rs' rd = v /\\\n  (forall r : preg, data_preg r = true -> r <> rd -> rs' r = rs r).","proofString":"econstructor; split.\neapply exec_straight_three.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_long by congruence.\neauto.\nsimpl; eauto.\nunfold exec_instr.\nrewrite or_zero_eval_shift_op_long by congruence.\neauto.\nauto.\nauto.\nauto.\nsplit.\nsubst v; Simpl.\nintros; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = false) (H : v =\nVal.shrl\n  (Val.addl (rs r1)\n     (Val.shrlu (Val.shrl (rs r1) (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (H0 : r1 <> X16) : nextinstr\n  (nextinstr\n     (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63)))) # X16 <-\n     (Val.addl\n        (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))) r1)\n        (Val.shrlu\n           (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))) X16)\n           (Vint (Int.sub Int64.iwordsize' n))))) # rd <-\n  (eval_shift_op_long\n     (nextinstr\n        (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))))\n        # X16 <-\n        (Val.addl\n           (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))) r1)\n           (Val.shrlu\n              (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63)))\n                 X16) (Vint (Int.sub Int64.iwordsize' n)))) X16) \n     (SOasr n)) rd = v.","proofString":"subst v; Simpl."},{"statement":"(rd r1 : ireg) (n : int) (k : code) (v : val) (rs : regset) (m : mem) (E : Int.eq n Int.zero = false) (H : v =\nVal.shrl\n  (Val.addl (rs r1)\n     (Val.shrlu (Val.shrl (rs r1) (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (H0 : r1 <> X16) : forall r : preg,\ndata_preg r = true ->\nr <> rd ->\nnextinstr\n  (nextinstr\n     (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63)))) # X16 <-\n     (Val.addl\n        (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))) r1)\n        (Val.shrlu\n           (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))) X16)\n           (Vint (Int.sub Int64.iwordsize' n))))) # rd <-\n  (eval_shift_op_long\n     (nextinstr\n        (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))))\n        # X16 <-\n        (Val.addl\n           (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63))) r1)\n           (Val.shrlu\n              (nextinstr rs # X16 <- (Val.shrl (rs r1) (Vint (Int.repr 63)))\n                 X16) (Vint (Int.sub Int64.iwordsize' n)))) X16) \n     (SOasr n)) r = rs r.","proofString":"intros; Simpl."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_bool c v1 v2 = Some b) : eval_testcond (cond_for_signed_cmp c) (compare_int rs v1 v2 m) = Some b.","proofString":"generalize (compare_int_spec rs v1 v2 m).\nset (rs' := compare_int rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_bool c v1 v2 = Some b) : (let rs' := compare_int rs v1 v2 m in\n rs' CN = Val.negative (Val.sub v1 v2) /\\\n rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs' CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) (compare_int rs v1 v2 m) = Some b.","proofString":"set (rs' := compare_int rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) : (let rs'0 := rs' in\n rs'0 CN = Val.negative (Val.sub v1 v2) /\\\n rs'0 CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs'0 CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs'0 CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) rs' = Some b.","proofString":"intros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub v1 v2)) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2) (E : rs' CV = Val.sub_overflow v1 v2) : eval_testcond (cond_for_signed_cmp c) rs' = Some b.","proofString":"unfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub v1 v2)) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2) (E : rs' CV = Val.sub_overflow v1 v2) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub v1 v2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub v1 v2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"destruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (i i0 : int) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_bool c (Vint i) (Vint i0) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"simpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","proofString":"unfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint c0 =>\n        match (if Int.eq i i0 then Vtrue else Vfalse) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint c0 =>\n        match (if Int.eq i i0 then Vtrue else Vfalse) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one)\n| TCgt =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.zero && \n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.one || \n           Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmp c i i0).","proofString":"destruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto.\nrewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Int.eq i i0).","proofString":"destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Int.eq i i0)).","proofString":"destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : Some\n  (Int.eq\n     (Int.xor (Int.sub_overflow i i0 Int.zero) (Int.negative (Int.sub i i0)))\n     Int.one) = Some (Int.lt i i0).","proofString":"rewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one) =\nSome (Int.lt i i0).","proofString":"destruct (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one || \n       Int.eq z Int.one)\n| _ => None\nend = Some (negb (Int.lt i0 i)).","proofString":"rewrite Int.lt_sub_overflow, Int.not_lt.\ndestruct (Int.eq i i0), (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.one\n       || Int.eq z Int.one)\n| _ => None\nend = Some (Int.lt i i0 || Int.eq i i0).","proofString":"destruct (Int.eq i i0), (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero && \n       Int.eq z Int.zero)\n| _ => None\nend = Some (Int.lt i0 i).","proofString":"rewrite Int.lt_sub_overflow, (Int.lt_not i).\ndestruct (Int.eq i i0), (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint z =>\n    Some\n      (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero &&\n       Int.eq z Int.zero)\n| _ => None\nend = Some (negb (Int.lt i i0) && negb (Int.eq i i0)).","proofString":"destruct (Int.eq i i0), (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : Some\n  (Int.eq\n     (Int.xor (Int.sub_overflow i i0 Int.zero) (Int.negative (Int.sub i i0)))\n     Int.zero) = Some (negb (Int.lt i i0)).","proofString":"rewrite Int.lt_sub_overflow.\ndestruct (Int.lt i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : Some (Int.eq (if Int.lt i i0 then Int.one else Int.zero) Int.zero) =\nSome (negb (Int.lt i i0)).","proofString":"destruct (Int.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : eval_testcond (cond_for_unsigned_cmp c) (compare_int rs v1 v2 m) = Some b.","proofString":"generalize (compare_int_spec rs v1 v2 m).\nset (rs' := compare_int rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : (let rs' := compare_int rs v1 v2 m in\n rs' CN = Val.negative (Val.sub v1 v2) /\\\n rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs' CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_unsigned_cmp c) (compare_int rs v1 v2 m) = Some b.","proofString":"set (rs' := compare_int rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (rs' : PregEq.t -> val) : (let rs'0 := rs' in\n rs'0 CN = Val.negative (Val.sub v1 v2) /\\\n rs'0 CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 /\\\n rs'0 CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2 /\\\n rs'0 CV = Val.sub_overflow v1 v2) ->\neval_testcond (cond_for_unsigned_cmp c) rs' = Some b.","proofString":"intros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub v1 v2)) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2) (E : rs' CV = Val.sub_overflow v1 v2) : eval_testcond (cond_for_unsigned_cmp c) rs' = Some b.","proofString":"unfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub v1 v2)) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq v1 v2) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge v1 v2) (E : rs' CV = Val.sub_overflow v1 v2) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub v1 v2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub v1 v2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge v1 v2 with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow v1 v2 with\n    | Vint o =>\n        match Val.negative (Val.sub v1 v2) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq v1 v2 with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"destruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (i i0 : int) (b : bool) (rs : regset) (m : mem) (H : Val.cmpu_bool (Mem.valid_pointer m) c (Vint i) (Vint i0) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"simpl in H; inv H.\nunfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negative (Val.sub (Vint i) (Vint i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0) with\n    | Vint c0 =>\n        match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.sub_overflow (Vint i) (Vint i0) with\n    | Vint o =>\n        match Val.negative (Val.sub (Vint i) (Vint i0)) with\n        | Vint s =>\n            match Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0) with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int.cmpu c i i0).","proofString":"unfold Val.cmpu; simpl.\ndestruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(c : comparison) (i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi => Some (Int.eq (Int.negative (Int.sub i i0)) Int.one)\n| TCpl => Some (Int.eq (Int.negative (Int.sub i i0)) Int.zero)\n| TChi =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint c0 =>\n        match (if Int.eq i i0 then Vtrue else Vfalse) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n    | Vint c0 =>\n        match (if Int.eq i i0 then Vtrue else Vfalse) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor (Int.sub_overflow i i0 Int.zero)\n            (Int.negative (Int.sub i i0))) Int.one)\n| TCgt =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.zero && \n           Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor (Int.sub_overflow i i0 Int.zero)\n                (Int.negative (Int.sub i i0))) Int.one || \n           Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int.cmpu c i i0).","proofString":"destruct c; simpl.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.eq i i0); auto.\ndestruct (Int.ltu i i0); auto.\nrewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\nrewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto.\ndestruct (Int.ltu i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Int.eq i i0).","proofString":"destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if Int.eq i i0 then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Int.eq i i0)).","proofString":"destruct (Int.eq i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (Int.ltu i i0).","proofString":"destruct (Int.ltu i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n| Vint c =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Int.ltu i0 i)).","proofString":"rewrite (Int.not_ltu i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n| Vint c =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Int.ltu i i0 || Int.eq i i0).","proofString":"destruct (Int.eq i i0), (Int.ltu i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n| Vint c =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Int.ltu i0 i).","proofString":"rewrite (Int.ltu_not i).\ndestruct (Int.eq i i0), (Int.ltu i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n| Vint c =>\n    match (if Int.eq i i0 then Vtrue else Vfalse) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Int.ltu i i0) && negb (Int.eq i i0)).","proofString":"destruct (Int.eq i i0), (Int.ltu i i0); auto."},{"statement":"(i i0 : int) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negative (Val.sub (Vint i) (Vint i0))) (C : rs' CZ = Val.cmpu (Mem.valid_pointer m) Ceq (Vint i) (Vint i0)) (D : rs' CC = Val.cmpu (Mem.valid_pointer m) Cge (Vint i) (Vint i0)) (E : rs' CV = Val.sub_overflow (Vint i) (Vint i0)) : match (if negb (Int.ltu i i0) then Vtrue else Vfalse) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (Int.ltu i i0)).","proofString":"destruct (Int.ltu i i0); auto."},{"statement":"(x y : int64) : Int.xor (Int.repr (Int64.unsigned (Int64.sub_overflow x y Int64.zero)))\n  (Int.repr (Int64.unsigned (Int64.negative (Int64.sub x y)))) =\n(if Int64.lt x y then Int.one else Int.zero).","proofString":"transitivity (Int.repr (Int64.unsigned (if Int64.lt x y then Int64.one else Int64.zero))).\nrewrite <- (Int64.lt_sub_overflow x y).\nunfold Int64.sub_overflow, Int64.negative.\nset (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto.\ndestruct (Int64.lt x y); auto."},{"statement":"(x y : int64) : Int.xor (Int.repr (Int64.unsigned (Int64.sub_overflow x y Int64.zero)))\n  (Int.repr (Int64.unsigned (Int64.negative (Int64.sub x y)))) =\nInt.repr (Int64.unsigned (if Int64.lt x y then Int64.one else Int64.zero)).","proofString":"rewrite <- (Int64.lt_sub_overflow x y).\nunfold Int64.sub_overflow, Int64.negative.\nset (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) : Int.xor (Int.repr (Int64.unsigned (Int64.sub_overflow x y Int64.zero)))\n  (Int.repr (Int64.unsigned (Int64.negative (Int64.sub x y)))) =\nInt.repr\n  (Int64.unsigned\n     (Int64.xor (Int64.sub_overflow x y Int64.zero)\n        (Int64.negative (Int64.sub x y)))).","proofString":"unfold Int64.sub_overflow, Int64.negative.\nset (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) : Int.xor\n  (Int.repr\n     (Int64.unsigned\n        (if\n          zle Int64.min_signed\n            (Int64.signed x - Int64.signed y - Int64.signed Int64.zero) &&\n          zle (Int64.signed x - Int64.signed y - Int64.signed Int64.zero)\n            Int64.max_signed\n         then Int64.zero\n         else Int64.one)))\n  (Int.repr\n     (Int64.unsigned\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))) =\nInt.repr\n  (Int64.unsigned\n     (Int64.xor\n        (if\n          zle Int64.min_signed\n            (Int64.signed x - Int64.signed y - Int64.signed Int64.zero) &&\n          zle (Int64.signed x - Int64.signed y - Int64.signed Int64.zero)\n            Int64.max_signed\n         then Int64.zero\n         else Int64.one)\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))).","proofString":"set (s := Int64.signed x - Int64.signed y - Int64.signed Int64.zero).\ndestruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) (s : Z) : Int.xor\n  (Int.repr\n     (Int64.unsigned\n        (if zle Int64.min_signed s && zle s Int64.max_signed\n         then Int64.zero\n         else Int64.one)))\n  (Int.repr\n     (Int64.unsigned\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))) =\nInt.repr\n  (Int64.unsigned\n     (Int64.xor\n        (if zle Int64.min_signed s && zle s Int64.max_signed\n         then Int64.zero\n         else Int64.one)\n        (if Int64.lt (Int64.sub x y) Int64.zero\n         then Int64.one\n         else Int64.zero))).","proofString":"destruct (zle Int64.min_signed s && zle s Int64.max_signed);  destruct (Int64.lt (Int64.sub x y) Int64.zero);  auto."},{"statement":"(x y : int64) : Int.repr (Int64.unsigned (if Int64.lt x y then Int64.one else Int64.zero)) =\n(if Int64.lt x y then Int.one else Int.zero).","proofString":"destruct (Int64.lt x y); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpl_bool c v1 v2 = Some b) : eval_testcond (cond_for_signed_cmp c) (compare_long rs v1 v2 m) = Some b.","proofString":"generalize (compare_long_spec rs v1 v2 m).\nset (rs' := compare_long rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpl_bool c v1 v2 = Some b) : (let rs' := compare_long rs v1 v2 m in\n rs' CN = Val.negativel (Val.subl v1 v2) /\\\n rs' CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) /\\\n rs' CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) /\\\n rs' CV = Val.subl_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) (compare_long rs v1 v2 m) = Some b.","proofString":"set (rs' := compare_long rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpl_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) : (let rs'0 := rs' in\n rs'0 CN = Val.negativel (Val.subl v1 v2) /\\\n rs'0 CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) /\\\n rs'0 CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) /\\\n rs'0 CV = Val.subl_overflow v1 v2) ->\neval_testcond (cond_for_signed_cmp c) rs' = Some b.","proofString":"intros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpl_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl v1 v2)) (C : rs' CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)) (D : rs' CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2)) (E : rs' CV = Val.subl_overflow v1 v2) : eval_testcond (cond_for_signed_cmp c) rs' = Some b.","proofString":"unfold eval_testcond; rewrite B, C, D, E.\ndestruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmpl_bool c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl v1 v2)) (C : rs' CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)) (D : rs' CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2)) (E : rs' CV = Val.subl_overflow v1 v2) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl v1 v2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl v1 v2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) with\n    | Vint c0 =>\n        match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) with\n    | Vint c0 =>\n        match Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s =>\n            match\n              Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s =>\n            match\n              Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"destruct v1; try discriminate; destruct v2; try discriminate.\nsimpl in H; inv H.\nunfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (i i0 : int64) (b : bool) (rs : regset) (m : mem) (H : Val.cmpl_bool c (Vlong i) (Vlong i0) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"simpl in H; inv H.\nunfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int64.cmp c i i0).","proofString":"unfold Val.cmplu; simpl.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match cond_for_signed_cmp c with\n| TCeq =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.of_bool (negb (Int64.ltu i i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.of_bool (negb (Int64.ltu i i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    Some\n      (Int.eq (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0))))\n         Int.one)\n| TCpl =>\n    Some\n      (Int.eq (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0))))\n         Int.zero)\n| TChi =>\n    match Val.of_bool (negb (Int64.ltu i i0)) with\n    | Vint c0 =>\n        match Val.of_bool (Int64.eq i i0) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.of_bool (negb (Int64.ltu i i0)) with\n    | Vint c0 =>\n        match Val.of_bool (Int64.eq i i0) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    Some\n      (Int.eq\n         (Int.xor\n            (Int.repr (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n            (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n         Int.zero)\n| TClt =>\n    Some\n      (Int.eq\n         (Int.xor\n            (Int.repr (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n            (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n         Int.one)\n| TCgt =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor\n                (Int.repr\n                   (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n                (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n             Int.zero && Int.eq z Int.zero)\n    | _ => None\n    end\n| TCle =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint z =>\n        Some\n          (Int.eq\n             (Int.xor\n                (Int.repr\n                   (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n                (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n             Int.one || Int.eq z Int.one)\n    | _ => None\n    end\nend = Some (Int64.cmp c i i0).","proofString":"destruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto.\nrewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Int64.eq i i0).","proofString":"destruct (Int64.eq i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Int64.eq i i0)).","proofString":"destruct (Int64.eq i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : Some\n  (Int.eq\n     (Int.xor\n        (Int.repr (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n        (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n     Int.one) = Some (Int64.lt i i0).","proofString":"rewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : Some (Int.eq (if Int64.lt i i0 then Int.one else Int.zero) Int.one) =\nSome (Int64.lt i i0).","proofString":"destruct (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint z =>\n    Some\n      (Int.eq\n         (Int.xor\n            (Int.repr (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n            (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n         Int.one || Int.eq z Int.one)\n| _ => None\nend = Some (negb (Int64.lt i0 i)).","proofString":"rewrite int64_sub_overflow, Int64.not_lt.\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint z =>\n    Some\n      (Int.eq (if Int64.lt i i0 then Int.one else Int.zero) Int.one\n       || Int.eq z Int.one)\n| _ => None\nend = Some (Int64.lt i i0 || Int64.eq i i0).","proofString":"destruct (Int64.eq i i0), (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint z =>\n    Some\n      (Int.eq\n         (Int.xor\n            (Int.repr (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n            (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n         Int.zero && Int.eq z Int.zero)\n| _ => None\nend = Some (Int64.lt i0 i).","proofString":"rewrite int64_sub_overflow, (Int64.lt_not i).\ndestruct (Int64.eq i i0), (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint z =>\n    Some\n      (Int.eq (if Int64.lt i i0 then Int.one else Int.zero) Int.zero &&\n       Int.eq z Int.zero)\n| _ => None\nend = Some (negb (Int64.lt i i0) && negb (Int64.eq i i0)).","proofString":"destruct (Int64.eq i i0), (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : Some\n  (Int.eq\n     (Int.xor\n        (Int.repr (Int64.unsigned (Int64.sub_overflow i i0 Int64.zero)))\n        (Int.repr (Int64.unsigned (Int64.negative (Int64.sub i i0)))))\n     Int.zero) = Some (negb (Int64.lt i i0)).","proofString":"rewrite int64_sub_overflow.\ndestruct (Int64.lt i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : Some (Int.eq (if Int64.lt i i0 then Int.one else Int.zero) Int.zero) =\nSome (negb (Int64.lt i i0)).","proofString":"destruct (Int64.lt i i0); auto."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : eval_testcond (cond_for_unsigned_cmp c) (compare_long rs v1 v2 m) = Some b.","proofString":"generalize (compare_long_spec rs v1 v2 m).\nset (rs' := compare_long rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E; unfold Val.cmplu.\ndestruct v1; try discriminate; destruct v2; try discriminate; simpl in H.\ninv H.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nsimpl.\ndestruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : (let rs' := compare_long rs v1 v2 m in\n rs' CN = Val.negativel (Val.subl v1 v2) /\\\n rs' CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) /\\\n rs' CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) /\\\n rs' CV = Val.subl_overflow v1 v2) ->\neval_testcond (cond_for_unsigned_cmp c) (compare_long rs v1 v2 m) = Some b.","proofString":"set (rs' := compare_long rs v1 v2 m).\nintros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E; unfold Val.cmplu.\ndestruct v1; try discriminate; destruct v2; try discriminate; simpl in H.\ninv H.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nsimpl.\ndestruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (rs' : PregEq.t -> val) : (let rs'0 := rs' in\n rs'0 CN = Val.negativel (Val.subl v1 v2) /\\\n rs'0 CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2) /\\\n rs'0 CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2) /\\\n rs'0 CV = Val.subl_overflow v1 v2) ->\neval_testcond (cond_for_unsigned_cmp c) rs' = Some b.","proofString":"intros (B & C & D & E).\nunfold eval_testcond; rewrite B, C, D, E; unfold Val.cmplu.\ndestruct v1; try discriminate; destruct v2; try discriminate; simpl in H.\ninv H.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nsimpl.\ndestruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl v1 v2)) (C : rs' CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)) (D : rs' CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2)) (E : rs' CV = Val.subl_overflow v1 v2) : eval_testcond (cond_for_unsigned_cmp c) rs' = Some b.","proofString":"unfold eval_testcond; rewrite B, C, D, E; unfold Val.cmplu.\ndestruct v1; try discriminate; destruct v2; try discriminate; simpl in H.\ninv H.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nsimpl.\ndestruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (v1 v2 : val) (b : bool) (rs : regset) (m : mem) (H : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl v1 v2)) (C : rs' CZ = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)) (D : rs' CC = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Cge v1 v2)) (E : rs' CV = Val.subl_overflow v1 v2) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge v1 v2))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge v1 v2))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl v1 v2) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl v1 v2) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge v1 v2))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge v1 v2))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow v1 v2 with\n    | Vint o =>\n        match Val.negativel (Val.subl v1 v2) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"destruct v1; try discriminate; destruct v2; try discriminate; simpl in H.\ninv H.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nsimpl.\ndestruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity.\nsimpl.\ndestruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (i i0 : int64) (b : bool) (rs : regset) (m : mem) (H : Some (Int64.cmpu c i i0) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vlong i) (Vlong i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vlong i) (Vlong i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"inv H.\ndestruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto."},{"statement":"(c : comparison) (i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vlong i) (Vlong i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vlong i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vlong i) (Vlong i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some (Int64.cmpu c i i0).","proofString":"destruct c; simpl.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.eq i i0); auto.\ndestruct (Int64.ltu i i0); auto.\nrewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\nrewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto.\ndestruct (Int64.ltu i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Int64.eq i i0).","proofString":"destruct (Int64.eq i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (Int64.eq i i0) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Int64.eq i i0)).","proofString":"destruct (Int64.eq i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (negb (Int64.ltu i i0)) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (Int64.ltu i i0).","proofString":"destruct (Int64.ltu i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (negb (Int64.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Int64.ltu i0 i)).","proofString":"rewrite (Int64.not_ltu i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (negb (Int64.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Int64.ltu i i0 || Int64.eq i i0).","proofString":"destruct (Int64.eq i i0), (Int64.ltu i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (negb (Int64.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Int64.ltu i0 i).","proofString":"rewrite (Int64.ltu_not i).\ndestruct (Int64.eq i i0), (Int64.ltu i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (negb (Int64.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Int64.eq i i0) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Int64.ltu i i0) && negb (Int64.eq i i0)).","proofString":"destruct (Int64.eq i i0), (Int64.ltu i i0); auto."},{"statement":"(i i0 : int64) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vlong i0)) : match Val.of_bool (negb (Int64.ltu i i0)) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (Int64.ltu i i0)).","proofString":"destruct (Int64.ltu i i0); auto."},{"statement":"(c : comparison) (i : int64) (b0 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (H : (if\n  Int64.eq i Int64.zero &&\n  (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n   || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n then Val.cmp_different_blocks c\n else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vptr b0 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vptr b0 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vptr b0 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vptr b0 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vlong i) (Vptr b0 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vlong i) (Vptr b0 i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vlong i) (Vptr b0 i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                  (Vlong i) (Vptr b0 i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                  (Vlong i) (Vptr b0 i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vlong i) (Vptr b0 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vptr b0 i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vlong i) (Vptr b0 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vptr b0 i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vlong i) (Vptr b0 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vptr b0 i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vlong i) (Vptr b0 i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vlong i) (Vptr b0 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vlong i) (Vptr b0 i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vlong i) (Vptr b0 i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"simpl.\ndestruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (i : int64) (b0 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (H : (if\n  Int64.eq i Int64.zero &&\n  (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n   || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n then Val.cmp_different_blocks c\n else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vptr b0 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vptr b0 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vptr b0 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n            then Some false\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n            then Some false\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n            then None\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n            then None\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n            then None\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 Int64.eq i Int64.zero &&\n                 (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n                  || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n                then Some false\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n            then None\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 Int64.eq i Int64.zero &&\n                 (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)\n                  || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))\n                then Some false\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct (Int64.eq i Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i0)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (i : int64) (b0 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_different_blocks c = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vlong i) (Vptr b0 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vlong i) (Vptr b0 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vlong i) (Vptr b0 i0))) (E : rs' CV = Val.subl_overflow (Vlong i) (Vptr b0 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.maketotal (option_map Val.of_bool (Some false)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.maketotal (option_map Val.of_bool (Some false)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint c0 =>\n        match Val.maketotal (option_map Val.of_bool (Some false)) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint c0 =>\n        match Val.maketotal (option_map Val.of_bool (Some false)) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (i0 : int64) (b : bool) (rs : regset) (m : mem) (H : (if\n  Int64.eq i0 Int64.zero &&\n  (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n then Val.cmp_different_blocks c\n else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vlong i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vptr b0 i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vptr b0 i) (Vlong i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                  (Vptr b0 i) (Vlong i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                  (Vptr b0 i) (Vlong i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vptr b0 i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vptr b0 i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vlong i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vptr b0 i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vptr b0 i) (Vlong i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vptr b0 i) (Vlong i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vlong i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vptr b0 i) (Vlong i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"simpl.\ndestruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (i0 : int64) (b : bool) (rs : regset) (m : mem) (H : (if\n  Int64.eq i0 Int64.zero &&\n  (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n then Val.cmp_different_blocks c\n else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vlong i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i0 Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n            then Some false\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i0 Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n            then Some false\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i0 Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n            then None\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i0 Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n            then None\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i0 Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n            then None\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 Int64.eq i0 Int64.zero &&\n                 (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n                  || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n                then Some false\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Int64.eq i0 Int64.zero &&\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n            then None\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 Int64.eq i0 Int64.zero &&\n                 (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n                  || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))\n                then Some false\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct (Int64.eq i0 Int64.zero &&            (Mem.valid_pointer m b0 (Ptrofs.unsigned i)              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (i0 : int64) (b : bool) (rs : regset) (m : mem) (H : Val.cmp_different_blocks c = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vlong i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vlong i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vlong i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vlong i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.maketotal (option_map Val.of_bool (Some false)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.maketotal (option_map Val.of_bool (Some false)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint c0 =>\n        match Val.maketotal (option_map Val.of_bool (Some false)) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint c0 =>\n        match Val.maketotal (option_map Val.of_bool (Some false)) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (H : (if eq_block b0 b1\n then\n  if\n   (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n    || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n   (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n    || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None\n else\n  if\n   Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n   Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n  then Val.cmp_different_blocks c\n  else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vptr b1 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0)))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0)) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0)) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                  (Vptr b0 i) (Vptr b1 i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (Val.cmplu_bool (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0)))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                  (Vptr b0 i) (Vptr b1 i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCge =>\n    match Val.subl_overflow (Vptr b0 i) (Vptr b1 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TClt =>\n    match Val.subl_overflow (Vptr b0 i) (Vptr b1 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0)) with\n        | Vint s => Some (Int.eq (Int.xor o s) Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCgt =>\n    match Val.subl_overflow (Vptr b0 i) (Vptr b1 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vptr b0 i) (Vptr b1 i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\n| TCle =>\n    match Val.subl_overflow (Vptr b0 i) (Vptr b1 i0) with\n    | Vint o =>\n        match Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0)) with\n        | Vint s =>\n            match\n              Val.maketotal\n                (option_map Val.of_bool\n                   (Val.cmplu_bool (Mem.valid_pointer m) Ceq \n                      (Vptr b0 i) (Vptr b1 i0)))\n            with\n            | Vint z =>\n                Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one)\n            | _ => None\n            end\n        | _ => None\n        end\n    | _ => None\n    end\nend = Some b.","proofString":"simpl.\ndestruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (H : (if eq_block b0 b1\n then\n  if\n   (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n    || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n   (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n    || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n  then Some (Ptrofs.cmpu c i i0)\n  else None\n else\n  if\n   Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n   Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n  then Val.cmp_different_blocks c\n  else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vptr b1 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if eq_block b0 b1\n            then\n             if\n              (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n               || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n              (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n               || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n             then Some (Ptrofs.eq i i0)\n             else None\n            else\n             if\n              Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n              Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n             then Some false\n             else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if eq_block b0 b1\n            then\n             if\n              (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n               || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n              (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n               || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n             then Some (Ptrofs.eq i i0)\n             else None\n            else\n             if\n              Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n              Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n             then Some false\n             else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if eq_block b0 b1\n            then\n             if\n              (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n               || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n              (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n               || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n             then Some (negb (Ptrofs.ltu i i0))\n             else None\n            else\n             if\n              Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n              Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n             then None\n             else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if eq_block b0 b1\n            then\n             if\n              (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n               || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n              (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n               || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n             then Some (negb (Ptrofs.ltu i i0))\n             else None\n            else\n             if\n              Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n              Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n             then None\n             else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match\n      Val.negativel\n        (if eq_block b0 b1\n         then Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))\n         else Vundef)\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match\n      Val.negativel\n        (if eq_block b0 b1\n         then Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))\n         else Vundef)\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if eq_block b0 b1\n            then\n             if\n              (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n               || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n              (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n               || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n             then Some (negb (Ptrofs.ltu i i0))\n             else None\n            else\n             if\n              Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n              Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n             then None\n             else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if eq_block b0 b1\n                then\n                 if\n                  (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n                   || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n                  (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                   || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n                 then Some (Ptrofs.eq i i0)\n                 else None\n                else\n                 if\n                  Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n                  Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                 then Some false\n                 else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if eq_block b0 b1\n            then\n             if\n              (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n               || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n              (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n               || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n             then Some (negb (Ptrofs.ltu i i0))\n             else None\n            else\n             if\n              Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n              Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n             then None\n             else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if eq_block b0 b1\n                then\n                 if\n                  (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n                   || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n                  (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                   || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n                 then Some (Ptrofs.eq i i0)\n                 else None\n                else\n                 if\n                  Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n                  Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                 then Some false\n                 else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct (eq_block b0 b1).\ndestruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\ndestruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (e : b0 = b1) (H : (if\n  (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n   || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n  (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n   || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n then Some (Ptrofs.cmpu c i i0)\n else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vptr b1 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n            then Some (Ptrofs.eq i i0)\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n            then Some (Ptrofs.eq i i0)\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n            then Some (negb (Ptrofs.ltu i i0))\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n            then Some (negb (Ptrofs.ltu i i0))\n            else None))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n            then Some (negb (Ptrofs.ltu i i0))\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n                  || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n                 (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                  || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n                then Some (Ptrofs.eq i i0)\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n              || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n            then Some (negb (Ptrofs.ltu i i0))\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 (Mem.valid_pointer m b0 (Ptrofs.unsigned i)\n                  || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&\n                 (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                  || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1))\n                then Some (Ptrofs.eq i i0)\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i)             || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1)) &&            (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)             || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)));  inv H.\ndestruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto."},{"statement":"(c : comparison) (i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.maketotal (option_map Val.of_bool (Some (Ptrofs.eq i i0))) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.maketotal (option_map Val.of_bool (Some (Ptrofs.eq i i0))) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal (option_map Val.of_bool (Some (negb (Ptrofs.ltu i i0))))\n    with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal (option_map Val.of_bool (Some (negb (Ptrofs.ltu i i0))))\n    with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel (Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))) with\n    | Vint n => Some (Int.eq n Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel (Vlong (Ptrofs.to_int64 (Ptrofs.sub i i0))) with\n    | Vint n => Some (Int.eq n Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal (option_map Val.of_bool (Some (negb (Ptrofs.ltu i i0))))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal (option_map Val.of_bool (Some (Ptrofs.eq i i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal (option_map Val.of_bool (Some (negb (Ptrofs.ltu i i0))))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal (option_map Val.of_bool (Some (Ptrofs.eq i i0)))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some (Ptrofs.cmpu c i i0).","proofString":"destruct c; simpl.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.eq i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\nrewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto.\ndestruct (Ptrofs.ltu i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (Ptrofs.eq i i0) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (Ptrofs.eq i i0).","proofString":"destruct (Ptrofs.eq i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (Ptrofs.eq i i0) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (negb (Ptrofs.eq i i0)).","proofString":"destruct (Ptrofs.eq i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (negb (Ptrofs.ltu i i0)) with\n| Vint n => Some (Int.eq n Int.zero)\n| _ => None\nend = Some (Ptrofs.ltu i i0).","proofString":"destruct (Ptrofs.ltu i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (negb (Ptrofs.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Ptrofs.eq i i0) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Ptrofs.ltu i0 i)).","proofString":"rewrite (Ptrofs.not_ltu i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (negb (Ptrofs.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Ptrofs.eq i i0) with\n    | Vint z => Some (Int.eq c Int.zero || Int.eq z Int.one)\n    | _ => None\n    end\n| _ => None\nend = Some (Ptrofs.ltu i i0 || Ptrofs.eq i i0).","proofString":"destruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (negb (Ptrofs.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Ptrofs.eq i i0) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (Ptrofs.ltu i0 i).","proofString":"rewrite (Ptrofs.ltu_not i).\ndestruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (negb (Ptrofs.ltu i i0)) with\n| Vint c =>\n    match Val.of_bool (Ptrofs.eq i i0) with\n    | Vint z => Some (Int.eq c Int.one && Int.eq z Int.zero)\n    | _ => None\n    end\n| _ => None\nend = Some (negb (Ptrofs.ltu i i0) && negb (Ptrofs.eq i i0)).","proofString":"destruct (Ptrofs.eq i i0), (Ptrofs.ltu i i0); auto."},{"statement":"(i : ptrofs) (b1 : block) (i0 : ptrofs) (rs : regset) (m : mem) (rs' : PregEq.t -> val) (E : rs' CV = Val.subl_overflow (Vptr b1 i) (Vptr b1 i0)) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b1 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b1 i) (Vptr b1 i0))) (B : rs' CN = Val.negativel (Val.subl (Vptr b1 i) (Vptr b1 i0))) : match Val.of_bool (negb (Ptrofs.ltu i i0)) with\n| Vint n => Some (Int.eq n Int.one)\n| _ => None\nend = Some (negb (Ptrofs.ltu i i0)).","proofString":"destruct (Ptrofs.ltu i i0); auto."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (n : b0 <> b1) (H : (if\n  Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n  Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n then Val.cmp_different_blocks c\n else None) = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vptr b1 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n             Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n            then Some false\n            else None))\n    with\n    | Vint n0 => Some (Int.eq n0 Int.one)\n    | _ => None\n    end\n| TCne =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n             Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n            then Some false\n            else None))\n    with\n    | Vint n0 => Some (Int.eq n0 Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n             Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n            then None\n            else None))\n    with\n    | Vint n0 => Some (Int.eq n0 Int.one)\n    | _ => None\n    end\n| TClo =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n             Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n            then None\n            else None))\n    with\n    | Vint n0 => Some (Int.eq n0 Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel Vundef with\n    | Vint n0 => Some (Int.eq n0 Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel Vundef with\n    | Vint n0 => Some (Int.eq n0 Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n             Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n            then None\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n                 Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                then Some false\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match\n      Val.maketotal\n        (option_map Val.of_bool\n           (if\n             Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n             Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n            then None\n            else None))\n    with\n    | Vint c0 =>\n        match\n          Val.maketotal\n            (option_map Val.of_bool\n               (if\n                 Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&\n                 Mem.valid_pointer m b1 (Ptrofs.unsigned i0)\n                then Some false\n                else None))\n        with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) &&            Mem.valid_pointer m b1 (Ptrofs.unsigned i0)); try discriminate.\ndestruct c; simpl in H; inv H; reflexivity."},{"statement":"(c : comparison) (b0 : block) (i : ptrofs) (b1 : block) (i0 : ptrofs) (b : bool) (rs : regset) (m : mem) (n : b0 <> b1) (H : Val.cmp_different_blocks c = Some b) (rs' : PregEq.t -> val) (B : rs' CN = Val.negativel (Val.subl (Vptr b0 i) (Vptr b1 i0))) (C : rs' CZ =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq (Vptr b0 i) (Vptr b1 i0))) (D : rs' CC =\nVal.maketotal (Val.cmplu (Mem.valid_pointer m) Cge (Vptr b0 i) (Vptr b1 i0))) (E : rs' CV = Val.subl_overflow (Vptr b0 i) (Vptr b1 i0)) : match cond_for_unsigned_cmp c with\n| TCeq =>\n    match Val.maketotal (option_map Val.of_bool (Some false)) with\n    | Vint n0 => Some (Int.eq n0 Int.one)\n    | _ => None\n    end\n| TCne =>\n    match Val.maketotal (option_map Val.of_bool (Some false)) with\n    | Vint n0 => Some (Int.eq n0 Int.zero)\n    | _ => None\n    end\n| TChs =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint n0 => Some (Int.eq n0 Int.one)\n    | _ => None\n    end\n| TClo =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint n0 => Some (Int.eq n0 Int.zero)\n    | _ => None\n    end\n| TCmi =>\n    match Val.negativel Vundef with\n    | Vint n0 => Some (Int.eq n0 Int.one)\n    | _ => None\n    end\n| TCpl =>\n    match Val.negativel Vundef with\n    | Vint n0 => Some (Int.eq n0 Int.zero)\n    | _ => None\n    end\n| TChi =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint c0 =>\n        match Val.maketotal (option_map Val.of_bool (Some false)) with\n        | Vint z => Some (Int.eq c0 Int.one && Int.eq z Int.zero)\n        | _ => None\n        end\n    | _ => None\n    end\n| TCls =>\n    match Val.maketotal (option_map Val.of_bool None) with\n    | Vint c0 =>\n        match Val.maketotal (option_map Val.of_bool (Some false)) with\n        | Vint z => Some (Int.eq c0 Int.zero || Int.eq z Int.one)\n        | _ => None\n        end\n    | _ => None\n    end\n| _ => None\nend = Some b.","proofString":"destruct c; simpl in H; inv H; reflexivity."},{"statement":"(rs : regset) (v1 v2 : val) (r : preg) (H : match r with\n| CR _ => False\n| _ => True\nend) : nextinstr\n  match v1 with\n  | Vfloat f1 =>\n      match v2 with\n      | Vfloat f2 =>\n          (((rs # CN <- (Val.of_bool (Float.cmp Clt f1 f2))) # CZ <-\n            (Val.of_bool (Float.cmp Ceq f1 f2))) # CC <-\n           (Val.of_bool (negb (Float.cmp Clt f1 f2)))) # CV <-\n          (Val.of_bool (negb (Float.ordered f1 f2)))\n      | _ =>\n          (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <-\n          Vundef\n      end\n  | _ => (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <- Vundef\n  end r = nextinstr rs r.","proofString":"destruct r; try contradiction; destruct v1; auto; destruct v2; auto."},{"statement":"(rs : regset) (v1 v2 : val) (r : preg) (H : match r with\n| CR _ => False\n| _ => True\nend) : nextinstr\n  match v1 with\n  | Vsingle f1 =>\n      match v2 with\n      | Vsingle f2 =>\n          (((rs # CN <- (Val.of_bool (Float32.cmp Clt f1 f2))) # CZ <-\n            (Val.of_bool (Float32.cmp Ceq f1 f2))) # CC <-\n           (Val.of_bool (negb (Float32.cmp Clt f1 f2)))) # CV <-\n          (Val.of_bool (negb (Float32.ordered f1 f2)))\n      | _ =>\n          (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <-\n          Vundef\n      end\n  | _ => (((rs # CN <- Vundef) # CZ <- Vundef) # CC <- Vundef) # CV <- Vundef\n  end r = nextinstr rs r.","proofString":"destruct r; try contradiction; destruct v1; auto; destruct v2; auto."},{"statement":"(cond : condition) (args : list mreg) (k : code) (c : list instruction) (rs : regset) (m : mem) (TR : transl_cond cond args k = OK c) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m /\\\n  (forall b : bool,\n   eval_condition cond (map rs (map preg_of args)) m = Some b ->\n   eval_testcond (cond_for_cond cond) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct cond; simpl in TR; ArgsInv.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate.\ndestruct (is_arith_imm32 n); [|destruct (is_arith_imm32 (Int.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int.repr_unsigned, Int.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\ndestruct (is_arith_imm32 n); [|destruct (is_arith_imm32 (Int.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int.repr_unsigned, Int.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shift.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shift.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate.\ndestruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Ceq); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_sint Ceq); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\ndestruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Cne); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_sint Cne); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate.\ndestruct (is_arith_imm64 n); [|destruct (is_arith_imm64 (Int64.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int64.repr_unsigned, Int64.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\ndestruct (is_arith_imm64 n); [|destruct (is_arith_imm64 (Int64.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int64.repr_unsigned, Int64.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shiftl.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shiftl.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate.\ndestruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Ceq); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_slong Ceq); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\ndestruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Cne); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_slong Cne); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto.\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp W x x0 SOnone :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool c0 (rs x) (rs x0) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmp_bool c0 (rs x) (rs x0) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_int rs (rs x) (rs x0) m)) = \nSome b.","proofString":"apply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs (rs x) (rs x0) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp W x x0 SOnone :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (rs x0) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (rs x0) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_int rs (rs x) (rs x0) m)) = \nSome b.","proofString":"apply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs (rs x) (rs x0) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_arith_imm32 n\n     then Pcmpimm W x (Int.unsigned n) :: k\n     else\n      if is_arith_imm32 (Int.neg n)\n      then Pcmnimm W x (Int.unsigned (Int.neg n)) :: k\n      else loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_arith_imm32 n); [|destruct (is_arith_imm32 (Int.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int.repr_unsigned, Int.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmpimm W x (Int.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_int rs (rs x) (Vint (Int.repr (Int.unsigned n))) m)) =\nSome b.","proofString":"rewrite Int.repr_unsigned.\napply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_int rs (rs x) (Vint n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs (rs x) (Vint (Int.repr (Int.unsigned n))) m) r =\nrs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmnimm W x (Int.unsigned (Int.neg n)) :: k) rs m k\n    rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int.repr_unsigned, Int.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_int rs (rs x) (Vint n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs (rs x) (Vint n) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmp_bool c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_sint; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmp_bool c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_int rs' (rs x) (Vint n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (rs x) (Vint n) m) r = rs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (rs x) (Vint n) m) r = rs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_arith_imm32 n\n     then Pcmpimm W x (Int.unsigned n) :: k\n     else\n      if is_arith_imm32 (Int.neg n)\n      then Pcmnimm W x (Int.unsigned (Int.neg n)) :: k\n      else loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_arith_imm32 n); [|destruct (is_arith_imm32 (Int.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int.repr_unsigned, Int.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmpimm W x (Int.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_int rs (rs x) (Vint (Int.repr (Int.unsigned n))) m)) =\nSome b.","proofString":"rewrite Int.repr_unsigned.\napply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_int rs (rs x) (Vint n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs (rs x) (Vint (Int.repr (Int.unsigned n))) m) r =\nrs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmnimm W x (Int.unsigned (Int.neg n)) :: k) rs m k\n    rs' m /\\\n  (forall b : bool,\n   Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int.repr_unsigned, Int.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_int rs (rs x) (Vint n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs (rs x) (Vint n) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_uint; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_int rs' (rs x) (Vint n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (rs x) (Vint n) m) r = rs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (rs x) (Vint n) m) r = rs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)) rs m\n  (Pcmp W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp W x x0 (transl_shift s a) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool c0 (rs x) (eval_shift s (rs x0) a) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shift.\napply eval_testcond_compare_sint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmp_bool c0 (rs x) (eval_shift s (rs x0) a) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr\n     (compare_int rs (rs x) (eval_shift_op_int (rs x0) (transl_shift s a)) m)) =\nSome b.","proofString":"rewrite transl_eval_shift.\napply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmp_bool c0 (rs x) (eval_shift s (rs x0) a) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_int rs (rs x) (eval_shift s (rs x0) a) m)) = \nSome b.","proofString":"apply eval_testcond_compare_sint; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_int rs (rs x) (eval_shift_op_int (rs x0) (transl_shift s a)) m) r =\nrs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp W x x0 (transl_shift s a) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (eval_shift s (rs x0) a) =\n   Some b -> eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shift.\napply eval_testcond_compare_uint; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (eval_shift s (rs x0) a) =\nSome b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr\n     (compare_int rs (rs x) (eval_shift_op_int (rs x0) (transl_shift s a)) m)) =\nSome b.","proofString":"rewrite transl_eval_shift.\napply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (eval_shift s (rs x0) a) =\nSome b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_int rs (rs x) (eval_shift s (rs x0) a) m)) = \nSome b.","proofString":"apply eval_testcond_compare_uint; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount32) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_int rs (rs x) (eval_shift_op_int (rs x0) (transl_shift s a)) m) r =\nrs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm32 n\n     then Ptstimm W x (Int.unsigned n) :: k\n     else loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool Ceq (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.one)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Ceq); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_sint Ceq); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Ptstimm W x (Int.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool Ceq (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.one)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Ceq); auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool Ceq (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b) : match\n  nextinstr\n    (compare_int rs (Val.and (rs x) (Vint (Int.repr (Int.unsigned n))))\n       (Vint Int.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.one)\n| _ => None\nend = Some b.","proofString":"rewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Ceq); auto."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool Ceq (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b) : match\n  nextinstr (compare_int rs (Val.and (rs x) (Vint n)) (Vint Int.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.one)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_sint Ceq); auto."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_int rs (Val.and (rs x) (Vint (Int.repr (Int.unsigned n))))\n     (Vint Int.zero) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmp_bool Ceq (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.one)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_sint Ceq); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmp_bool Ceq (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b) : match\n  nextinstr (compare_int rs' (Val.and (rs x) (Vint n)) (Vint Int.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.one)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_sint Ceq); auto."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (Val.and (rs x) (Vint n)) (Vint Int.zero) m) r =\nrs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (Val.and (rs x) (Vint n)) (Vint Int.zero) m) r =\nrs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm32 n\n     then Ptstimm W x (Int.unsigned n) :: k\n     else loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool Cne (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.zero)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_logical_imm32 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Cne); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_sint Cne); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Ptstimm W x (Int.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmp_bool Cne (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.zero)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Cne); auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool Cne (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b) : match\n  nextinstr\n    (compare_int rs (Val.and (rs x) (Vint (Int.repr (Int.unsigned n))))\n       (Vint Int.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.zero)\n| _ => None\nend = Some b.","proofString":"rewrite Int.repr_unsigned.\napply (eval_testcond_compare_sint Cne); auto."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmp_bool Cne (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b) : match\n  nextinstr (compare_int rs (Val.and (rs x) (Vint n)) (Vint Int.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.zero)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_sint Cne); auto."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_int rs (Val.and (rs x) (Vint (Int.repr (Int.unsigned n))))\n     (Vint Int.zero) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmp_bool Cne (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.zero)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm32 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_sint Cne); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmp_bool Cne (Val.and (rs x) (Vint n)) (Vint Int.zero) = Some b) : match\n  nextinstr (compare_int rs' (Val.and (rs x) (Vint n)) (Vint Int.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.zero)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_sint Cne); auto."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (Val.and (rs x) (Vint n)) (Vint Int.zero) m) r =\nrs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_int rs' (Val.and (rs x) (Vint n)) (Vint Int.zero) m) r =\nrs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm32 X16 n (Ptst W x X16 SOnone :: k)) rs m\n  (Ptst W x X16 SOnone :: k) rs' m) (B : rs' X16 = Vint n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp X x x0 SOnone :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool c0 (rs x) (rs x0) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmpl_bool c0 (rs x) (rs x0) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_long rs (rs x) (rs x0) m)) = \nSome b.","proofString":"apply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs (rs x) (rs x0) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp X x x0 SOnone :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (rs x0) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (rs x0) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_long rs (rs x) (rs x0) m)) = \nSome b.","proofString":"apply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs (rs x) (rs x0) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_arith_imm64 n\n     then Pcmpimm X x (Int64.unsigned n) :: k\n     else\n      if is_arith_imm64 (Int64.neg n)\n      then Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k\n      else loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_arith_imm64 n); [|destruct (is_arith_imm64 (Int64.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int64.repr_unsigned, Int64.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmpimm X x (Int64.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr\n     (compare_long rs (rs x) (Vlong (Int64.repr (Int64.unsigned n))) m)) =\nSome b.","proofString":"rewrite Int64.repr_unsigned.\napply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_long rs (rs x) (Vlong n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs (rs x) (Vlong (Int64.repr (Int64.unsigned n))) m)\n  r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k) rs m\n    k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int64.repr_unsigned, Int64.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_long rs (rs x) (Vlong n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs (rs x) (Vlong n) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmpl_bool c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_slong; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmpl_bool c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_long rs' (rs x) (Vlong n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (rs x) (Vlong n) m) r = rs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (rs x) (Vlong n) m) r = rs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_arith_imm64 n\n     then Pcmpimm X x (Int64.unsigned n) :: k\n     else\n      if is_arith_imm64 (Int64.neg n)\n      then Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k\n      else loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_arith_imm64 n); [|destruct (is_arith_imm64 (Int64.neg n))].\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate.\neconstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int64.repr_unsigned, Int64.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmpimm X x (Int64.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr\n     (compare_long rs (rs x) (Vlong (Int64.repr (Int64.unsigned n))) m)) =\nSome b.","proofString":"rewrite Int64.repr_unsigned.\napply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_long rs (rs x) (Vlong n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs (rs x) (Vlong (Int64.repr (Int64.unsigned n))) m)\n  r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k) rs m\n    k rs' m /\\\n  (forall b : bool,\n   Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl.\nrewrite Int64.repr_unsigned, Int64.neg_involutive.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_long rs (rs x) (Vlong n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs (rs x) (Vlong n) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b ->\n   eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply eval_testcond_compare_ulong; auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n) = Some b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_long rs' (rs x) (Vlong n) m)) = \nSome b.","proofString":"apply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (rs x) (Vlong n) m) r = rs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (rs x) (Vlong n) m) r = rs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)) rs m\n  (Pcmp X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp X x x0 (transl_shift s a) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool c0 (rs x) (eval_shiftl s (rs x0) a) = Some b ->\n   eval_testcond (cond_for_signed_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shiftl.\napply eval_testcond_compare_slong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmpl_bool c0 (rs x) (eval_shiftl s (rs x0) a) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr\n     (compare_long rs (rs x) (eval_shift_op_long (rs x0) (transl_shift s a))\n        m)) = Some b.","proofString":"rewrite transl_eval_shiftl.\napply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmpl_bool c0 (rs x) (eval_shiftl s (rs x0) a) = Some b) : eval_testcond (cond_for_signed_cmp c0)\n  (nextinstr (compare_long rs (rs x) (eval_shiftl s (rs x0) a) m)) = \nSome b.","proofString":"apply eval_testcond_compare_slong; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_long rs (rs x) (eval_shift_op_long (rs x0) (transl_shift s a)) m)\n  r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pcmp X x x0 (transl_shift s a) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (eval_shiftl s (rs x0) a) =\n   Some b -> eval_testcond (cond_for_unsigned_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite transl_eval_shiftl.\napply eval_testcond_compare_ulong; auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (eval_shiftl s (rs x0) a) =\nSome b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr\n     (compare_long rs (rs x) (eval_shift_op_long (rs x0) (transl_shift s a))\n        m)) = Some b.","proofString":"rewrite transl_eval_shiftl.\napply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (b : bool) (H : Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (eval_shiftl s (rs x0) a) =\nSome b) : eval_testcond (cond_for_unsigned_cmp c0)\n  (nextinstr (compare_long rs (rs x) (eval_shiftl s (rs x0) a) m)) = \nSome b.","proofString":"apply eval_testcond_compare_ulong; auto."},{"statement":"(c0 : comparison) (s : shift) (a : amount64) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (x0 : ireg) (EQ1 : ireg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_long rs (rs x) (eval_shift_op_long (rs x0) (transl_shift s a)) m)\n  r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm64 n\n     then Ptstimm X x (Int64.unsigned n) :: k\n     else loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool Ceq (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.one)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Ceq); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_slong Ceq); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Ptstimm X x (Int64.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool Ceq (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.one)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Ceq); auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool Ceq (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b) : match\n  nextinstr\n    (compare_long rs\n       (Val.andl (rs x) (Vlong (Int64.repr (Int64.unsigned n))))\n       (Vlong Int64.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.one)\n| _ => None\nend = Some b.","proofString":"rewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Ceq); auto."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool Ceq (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b) : match\n  nextinstr\n    (compare_long rs (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.one)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_slong Ceq); auto."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_long rs (Val.andl (rs x) (Vlong (Int64.repr (Int64.unsigned n))))\n     (Vlong Int64.zero) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmpl_bool Ceq (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.one)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_slong Ceq); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmpl_bool Ceq (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b) : match\n  nextinstr\n    (compare_long rs' (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.one)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_slong Ceq); auto."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m)\n  r = rs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m)\n  r = rs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn\n    (if is_logical_imm64 n\n     then Ptstimm X x (Int64.unsigned n) :: k\n     else loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool Cne (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.zero)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (is_logical_imm64 n).\neconstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Cne); auto.\ndestruct r; reflexivity || discriminate.\nexploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_slong Cne); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Ptstimm X x (Int64.unsigned n) :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpl_bool Cne (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.zero)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit; intros.\nrewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Cne); auto.\ndestruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool Cne (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b) : match\n  nextinstr\n    (compare_long rs\n       (Val.andl (rs x) (Vlong (Int64.repr (Int64.unsigned n))))\n       (Vlong Int64.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.zero)\n| _ => None\nend = Some b.","proofString":"rewrite Int64.repr_unsigned.\napply (eval_testcond_compare_slong Cne); auto."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (b : bool) (H : Val.cmpl_bool Cne (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b) : match\n  nextinstr\n    (compare_long rs (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.zero)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_slong Cne); auto."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr\n  (compare_long rs (Val.andl (rs x) (Vlong (Int64.repr (Int64.unsigned n))))\n     (Vlong Int64.zero) m) r = rs r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m k rs'\n    m /\\\n  (forall b : bool,\n   Val.cmpl_bool Cne (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b ->\n   match rs' CZ with\n   | Vint n0 => Some (Int.eq n0 Int.zero)\n   | _ => None\n   end = Some b) /\\ (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm64 X16 n).\nintros (rs' & A & B & C).\neconstructor; split.\neapply exec_straight_trans.\neexact A.\napply exec_straight_one.\nsimpl.\nrewrite B, C by eauto with asmgen.\neauto.\nauto.\nsplit; intros.\napply (eval_testcond_compare_slong Cne); auto.\ntransitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) (b : bool) (H : Val.cmpl_bool Cne (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) = Some b) : match\n  nextinstr\n    (compare_long rs' (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m) CZ\nwith\n| Vint n0 => Some (Int.eq n0 Int.zero)\n| _ => None\nend = Some b.","proofString":"apply (eval_testcond_compare_slong Cne); auto."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m)\n  r = rs r.","proofString":"transitivity (rs' r).\ndestruct r; reflexivity || discriminate.\nauto with asmgen."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : nextinstr (compare_long rs' (Val.andl (rs x) (Vlong n)) (Vlong Int64.zero) m)\n  r = rs' r.","proofString":"destruct r; reflexivity || discriminate."},{"statement":"(n : int64) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : ireg) (EQ : ireg_of m0 = OK x) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 n (Ptst X x X16 SOnone :: k)) rs m\n  (Ptst X x X16 SOnone :: k) rs' m) (B : rs' X16 = Vlong n) (C : forall r0 : preg, r0 <> PC -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp D x x0 :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpf_bool c0 (rs x) (rs x0) = Some b ->\n   eval_testcond (cond_for_float_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (b : bool) (H : Val.cmpf_bool c0 (rs x) (rs x0) = Some b) : eval_testcond (cond_for_float_cmp c0)\n  (nextinstr (compare_float rs (rs x) (rs x0))) = \nSome b.","proofString":"apply eval_testcond_compare_float; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_float rs (rs x) (rs x0)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp D x x0 :: k) rs m k rs' m /\\\n  (forall b : bool,\n   option_map negb (Val.cmpf_bool c0 (rs x) (rs x0)) = Some b ->\n   eval_testcond (cond_for_float_not_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (b : bool) (H : option_map negb (Val.cmpf_bool c0 (rs x) (rs x0)) = Some b) : eval_testcond (cond_for_float_not_cmp c0)\n  (nextinstr (compare_float rs (rs x) (rs x0))) = \nSome b.","proofString":"apply eval_testcond_compare_not_float; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_float rs (rs x) (rs x0)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp0 D x :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpf_bool c0 (rs x) (Vfloat Float.zero) = Some b ->\n   eval_testcond (cond_for_float_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (b : bool) (H : Val.cmpf_bool c0 (rs x) (Vfloat Float.zero) = Some b) : eval_testcond (cond_for_float_cmp c0)\n  (nextinstr (compare_float rs (rs x) (Vfloat Float.zero))) = \nSome b.","proofString":"apply eval_testcond_compare_float; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_float rs (rs x) (Vfloat Float.zero)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp0 D x :: k) rs m k rs' m /\\\n  (forall b : bool,\n   option_map negb (Val.cmpf_bool c0 (rs x) (Vfloat Float.zero)) = Some b ->\n   eval_testcond (cond_for_float_not_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_float_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_float; auto.\ndestruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (b : bool) (H : option_map negb (Val.cmpf_bool c0 (rs x) (Vfloat Float.zero)) = Some b) : eval_testcond (cond_for_float_not_cmp c0)\n  (nextinstr (compare_float rs (rs x) (Vfloat Float.zero))) = \nSome b.","proofString":"apply eval_testcond_compare_not_float; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_float rs (rs x) (Vfloat Float.zero)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_float_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp S x x0 :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpfs_bool c0 (rs x) (rs x0) = Some b ->\n   eval_testcond (cond_for_float_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (b : bool) (H : Val.cmpfs_bool c0 (rs x) (rs x0) = Some b) : eval_testcond (cond_for_float_cmp c0)\n  (nextinstr (compare_single rs (rs x) (rs x0))) = \nSome b.","proofString":"apply eval_testcond_compare_single; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_single rs (rs x) (rs x0)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp S x x0 :: k) rs m k rs' m /\\\n  (forall b : bool,\n   option_map negb (Val.cmpfs_bool c0 (rs x) (rs x0)) = Some b ->\n   eval_testcond (cond_for_float_not_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (b : bool) (H : option_map negb (Val.cmpfs_bool c0 (rs x) (rs x0)) = Some b) : eval_testcond (cond_for_float_not_cmp c0)\n  (nextinstr (compare_single rs (rs x) (rs x0))) = \nSome b.","proofString":"apply eval_testcond_compare_not_single; auto."},{"statement":"(c0 : comparison) (m0 m1 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (x0 : freg) (EQ1 : freg_of m1 = OK x0) (r : preg) (H : data_preg r = true) : nextinstr (compare_single rs (rs x) (rs x0)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp0 S x :: k) rs m k rs' m /\\\n  (forall b : bool,\n   Val.cmpfs_bool c0 (rs x) (Vsingle Float32.zero) = Some b ->\n   eval_testcond (cond_for_float_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (b : bool) (H : Val.cmpfs_bool c0 (rs x) (Vsingle Float32.zero) = Some b) : eval_testcond (cond_for_float_cmp c0)\n  (nextinstr (compare_single rs (rs x) (Vsingle Float32.zero))) = \nSome b.","proofString":"apply eval_testcond_compare_single; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_single rs (rs x) (Vsingle Float32.zero)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) : exists rs' : regset,\n  exec_straight ge fn (Pfcmp0 S x :: k) rs m k rs' m /\\\n  (forall b : bool,\n   option_map negb (Val.cmpfs_bool c0 (rs x) (Vsingle Float32.zero)) = Some b ->\n   eval_testcond (cond_for_float_not_cmp c0) rs' = Some b) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; split.\napply exec_straight_one.\nsimpl; eauto.\nrewrite compare_single_inv; auto.\nsplit; intros.\napply eval_testcond_compare_not_single; auto.\ndestruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (b : bool) (H : option_map negb (Val.cmpfs_bool c0 (rs x) (Vsingle Float32.zero)) = Some b) : eval_testcond (cond_for_float_not_cmp c0)\n  (nextinstr (compare_single rs (rs x) (Vsingle Float32.zero))) = \nSome b.","proofString":"apply eval_testcond_compare_not_single; auto."},{"statement":"(c0 : comparison) (m0 : mreg) (k : code) (rs : regset) (m : mem) (x : freg) (EQ : freg_of m0 = OK x) (r : preg) (H : data_preg r = true) : nextinstr (compare_single rs (rs x) (Vsingle Float32.zero)) r = rs r.","proofString":"destruct r; discriminate || rewrite compare_single_inv; auto."},{"statement":"(sz : Z) (addr : Op.addressing) (args : list mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (TR : transl_addressing sz addr args insn k = OK c) (EV : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b o)) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"unfold transl_addressing in TR; destruct addr; ArgsInv; SimplEval EV.\ndestruct (offset_representable sz ofs); inv EQ0.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\nexploit (exec_loadimm64 X16 ofs).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro; eexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\neauto with asmgen.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\ndestruct (Int.eq a Int.zero) eqn:E; [|destruct (Int.eq (Int.shl Int.one a) (Int.repr sz))]; inv EQ2.\napply Int.same_if_eq in E.\nrewrite E.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nsplit; auto.\nsimpl.\nrewrite Val.addl_commut in H0.\ndestruct (rs x0); try discriminate.\nunfold Val.shll.\nrewrite Int64.shl'_zero.\nauto.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\neconstructor; econstructor; split.\napply exec_straight_opt_intro.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nsimpl.\nSimpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero.\nauto.\nintros; Simpl.\ndestruct (Int.eq a Int.zero || Int.eq (Int.shl Int.one a) (Int.repr sz)); inv EQ2.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nsplit; auto.\ndestruct x; auto.\nexploit (exec_arith_extended Val.addl Paddext (Padd X)); auto.\ninstantiate (1 := x0).\neauto with asmgen.\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B.\nrewrite Val.addl_assoc.\nf_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto.\nintros.\napply C; eauto with asmgen.\ndestruct (Ptrofs.eq (Ptrofs.modu ofs (Ptrofs.repr sz)) Ptrofs.zero && symbol_is_aligned id sz); inv TR.\neconstructor; econstructor; split.\napply exec_straight_opt_intro.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nsimpl.\nSimpl.\nrewrite symbol_high_low.\nsimpl in EV.\ncongruence.\nintros; Simpl.\nexploit (exec_loadsymbol X16 id ofs).\nauto.\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B.\nrewrite <- Genv.shift_symbol_address_64, Ptrofs.add_zero by auto.\nsimpl in EV.\ncongruence.\nauto with asmgen.\nassert (E: Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o).\nsimpl in EV.\ninv EV.\ndestruct (rs SP); simpl in H1; inv H1.\nsimpl.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto.\ndestruct (offset_representable sz (Ptrofs.to_int64 ofs)); inv TR.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\nexploit (exec_loadimm64 X16 (Ptrofs.to_int64 ofs)).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\nauto with asmgen."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (EQ0 : (if offset_representable sz ofs\n then OK (insn (ADimm x ofs) :: k)\n else OK (loadimm64 X16 ofs (insn (ADreg x X16) :: k))) = \nOK c) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Vlong ofs) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (offset_representable sz ofs); inv EQ0.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\nexploit (exec_loadimm64 X16 ofs).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro; eexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\neauto with asmgen."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (insn (ADimm x ofs) :: k) rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Vlong ofs) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (loadimm64 X16 ofs (insn (ADreg x X16) :: k)) rs m\n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Vlong ofs) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm64 X16 ofs).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro; eexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\neauto with asmgen."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 ofs (insn (ADreg x X16) :: k)) rs m\n  (insn (ADreg x X16) :: k) rs' m) (B : rs' X16 = Vlong ofs) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : eval_addressing ge (ADreg x X16) rs' = Val.addl (rs x) (Vlong ofs).","proofString":"simpl.\nrewrite B, C by eauto with asmgen.\nauto."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 ofs (insn (ADreg x X16) :: k)) rs m\n  (insn (ADreg x X16) :: k) rs' m) (B : rs' X16 = Vlong ofs) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : Val.addl (rs' x) (rs' X16) = Val.addl (rs x) (Vlong ofs).","proofString":"rewrite B, C by eauto with asmgen.\nauto."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 ofs (insn (ADreg x X16) :: k)) rs m\n  (insn (ADreg x X16) :: k) rs' m) (B : rs' X16 = Vlong ofs) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : Val.addl (rs x) (Vlong ofs) = Val.addl (rs x) (Vlong ofs).","proofString":"auto."},{"statement":"(sz : Z) (ofs : int64) (m0 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x : ireg) (EQ : ireg_of m0 = OK x) (H0 : Val.addl (rs x) (Vlong ofs) = Vptr b o) (rs' : regset) (A : exec_straight ge fn (loadimm64 X16 ofs (insn (ADreg x X16) :: k)) rs m\n  (insn (ADreg x X16) :: k) rs' m) (B : rs' X16 = Vlong ofs) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : forall r : preg, data_preg r = true -> rs' r = rs r.","proofString":"eauto with asmgen."},{"statement":"(sz : Z) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (H0 : Val.addl (rs x) (rs x0) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (insn (ADreg x x0) :: k) rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (rs x0) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (EQ2 : (if Int.eq a Int.zero\n then OK (insn (ADreg x x0) :: k)\n else\n  if Int.eq (Int.shl Int.one a) (Int.repr sz)\n  then OK (insn (ADlsl x x0 a) :: k)\n  else OK (Padd X X16 x x0 (SOlsl a) :: insn (ADimm X16 Int64.zero) :: k)) =\nOK c) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Val.shll (rs x0) (Vint a)) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (Int.eq a Int.zero) eqn:E; [|destruct (Int.eq (Int.shl Int.one a) (Int.repr sz))]; inv EQ2.\napply Int.same_if_eq in E.\nrewrite E.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nsplit; auto.\nsimpl.\nrewrite Val.addl_commut in H0.\ndestruct (rs x0); try discriminate.\nunfold Val.shll.\nrewrite Int64.shl'_zero.\nauto.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\neconstructor; econstructor; split.\napply exec_straight_opt_intro.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nsimpl.\nSimpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero.\nauto.\nintros; Simpl."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = true) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (insn (ADreg x x0) :: k) rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Val.shll (rs x0) (Vint a)) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"apply Int.same_if_eq in E.\nrewrite E.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nsplit; auto.\nsimpl.\nrewrite Val.addl_commut in H0.\ndestruct (rs x0); try discriminate.\nunfold Val.shll.\nrewrite Int64.shl'_zero.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (insn (ADlsl x x0 a) :: k) rs m \n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Val.shll (rs x0) (Vint a)) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn\n    (Padd X X16 x x0 (SOlsl a) :: insn (ADimm X16 Int64.zero) :: k) rs m\n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x) (Val.shll (rs x0) (Vint a)) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_intro.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nsimpl.\nSimpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero.\nauto.\nintros; Simpl."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : eval_addressing ge (ADimm X16 Int64.zero)\n  (nextinstr rs # X16 <- (Val.addl (rs x) (Val.shll (rs x0) (Vint a)))) =\nVal.addl (rs x) (Val.shll (rs x0) (Vint a)).","proofString":"simpl.\nSimpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : Val.addl\n  (nextinstr rs # X16 <- (Val.addl (rs x) (Val.shll (rs x0) (Vint a))) X16)\n  (Vlong Int64.zero) = Val.addl (rs x) (Val.shll (rs x0) (Vint a)).","proofString":"Simpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : Val.addl (Val.addl (rs x) (Val.shll (rs x0) (Vint a))) (Vlong Int64.zero) =\nVal.addl (rs x) (Val.shll (rs x0) (Vint a)).","proofString":"rewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : Val.addl (Vptr b o) (Vlong Int64.zero) = Vptr b o.","proofString":"simpl.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : Vptr b (Ptrofs.add o (Ptrofs.of_int64 Int64.zero)) = Vptr b o.","proofString":"rewrite Ptrofs.add_zero.\nauto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : Vptr b o = Vptr b o.","proofString":"auto."},{"statement":"(sz : Z) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x0 x : ireg) (EQ : ireg_of m0 = OK x) (EQ1 : ireg_of m1 = OK x0) (E : Int.eq a Int.zero = false) (H0 : Val.addl (rs x) (Val.shll (rs x0) (Vint a)) = Vptr b o) : forall r : preg,\ndata_preg r = true ->\nnextinstr rs # X16 <- (Val.addl (rs x) (Val.shll (rs x0) (Vint a))) r = rs r.","proofString":"intros; Simpl."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (EQ2 : (if Int.eq a Int.zero || Int.eq (Int.shl Int.one a) (Int.repr sz)\n then\n  OK\n    (insn\n       match x with\n       | Xsgn32 => ADsxt x0 x1 a\n       | Xuns32 => ADuxt x0 x1 a\n       end :: k)\n else\n  OK\n    (arith_extended Paddext (Padd X) X16 x0 x1 x a\n       (insn (ADimm X16 Int64.zero) :: k))) = OK c) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x0) (Op.eval_extend x (rs x1) a) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (Int.eq a Int.zero || Int.eq (Int.shl Int.one a) (Int.repr sz)); inv EQ2.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nsplit; auto.\ndestruct x; auto.\nexploit (exec_arith_extended Val.addl Paddext (Padd X)); auto.\ninstantiate (1 := x0).\neauto with asmgen.\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B.\nrewrite Val.addl_assoc.\nf_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto.\nintros.\napply C; eauto with asmgen."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn\n    (insn\n       match x with\n       | Xsgn32 => ADsxt x0 x1 a\n       | Xuns32 => ADuxt x0 x1 a\n       end :: k) rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x0) (Op.eval_extend x (rs x1) a) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_refl.\nsplit; auto.\ndestruct x; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) : eval_addressing ge\n  match x with\n  | Xsgn32 => ADsxt x0 x1 a\n  | Xuns32 => ADuxt x0 x1 a\n  end rs = Val.addl (rs x0) (Op.eval_extend x (rs x1) a).","proofString":"destruct x; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn\n    (arith_extended Paddext (Padd X) X16 x0 x1 x a\n       (insn (ADimm X16 Int64.zero) :: k)) rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Val.addl (rs x0) (Op.eval_extend x (rs x1) a) /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_arith_extended Val.addl Paddext (Padd X)); auto.\ninstantiate (1 := x0).\neauto with asmgen.\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B.\nrewrite Val.addl_assoc.\nf_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto.\nintros.\napply C; eauto with asmgen."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) : x0 <> X16.","proofString":"eauto with asmgen."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : eval_addressing ge (ADimm X16 Int64.zero) rs' =\nVal.addl (rs x0) (Op.eval_extend x (rs x1) a).","proofString":"simpl.\nrewrite B.\nrewrite Val.addl_assoc.\nf_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Val.addl (rs' X16) (Vlong Int64.zero) =\nVal.addl (rs x0) (Op.eval_extend x (rs x1) a).","proofString":"rewrite B.\nrewrite Val.addl_assoc.\nf_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Val.addl (Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (Vlong Int64.zero) =\nVal.addl (rs x0) (Op.eval_extend x (rs x1) a).","proofString":"rewrite Val.addl_assoc.\nf_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Val.addl (rs x0) (Val.addl (Op.eval_extend x (rs x1) a) (Vlong Int64.zero)) =\nVal.addl (rs x0) (Op.eval_extend x (rs x1) a).","proofString":"f_equal.\nunfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Val.addl (Op.eval_extend x (rs x1) a) (Vlong Int64.zero) =\nOp.eval_extend x (rs x1) a.","proofString":"unfold Op.eval_extend; destruct x, (rs x1); simpl; auto; rewrite ! a64_range;  simpl; rewrite Int64.add_zero; auto."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : forall r : preg, data_preg r = true -> rs' r = rs r.","proofString":"intros.\napply C; eauto with asmgen."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m0 m1 : mreg) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (x1 x0 : ireg) (EQ : ireg_of m0 = OK x0) (EQ1 : ireg_of m1 = OK x1) (H0 : Val.addl (rs x0) (Op.eval_extend x (rs x1) a) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Val.addl (rs x0) (Op.eval_extend x (rs x1) a)) (C : forall r0 : preg, data_preg r0 = true -> r0 <> X16 -> rs' r0 = rs r0) (r : preg) (H : data_preg r = true) : rs' r = rs r.","proofString":"apply C; eauto with asmgen."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (TR : (if\n  Ptrofs.eq (Ptrofs.modu ofs (Ptrofs.repr sz)) Ptrofs.zero &&\n  symbol_is_aligned id sz\n then OK (Padrp X16 id ofs :: insn (ADadr X16 id ofs) :: k)\n else OK (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k))) = \nOK c) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (Ptrofs.eq (Ptrofs.modu ofs (Ptrofs.repr sz)) Ptrofs.zero && symbol_is_aligned id sz); inv TR.\neconstructor; econstructor; split.\napply exec_straight_opt_intro.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nsimpl.\nSimpl.\nrewrite symbol_high_low.\nsimpl in EV.\ncongruence.\nintros; Simpl.\nexploit (exec_loadsymbol X16 id ofs).\nauto.\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B.\nrewrite <- Genv.shift_symbol_address_64, Ptrofs.add_zero by auto.\nsimpl in EV.\ncongruence.\nauto with asmgen."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (Padrp X16 id ofs :: insn (ADadr X16 id ofs) :: k)\n    rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_intro.\napply exec_straight_one.\nsimpl; eauto.\nauto.\nsplit.\nsimpl.\nSimpl.\nrewrite symbol_high_low.\nsimpl in EV.\ncongruence.\nintros; Simpl."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : eval_addressing ge (ADadr X16 id ofs)\n  (nextinstr rs # X16 <- (symbol_high ge id ofs)) = \nVptr b o.","proofString":"simpl.\nSimpl.\nrewrite symbol_high_low.\nsimpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : Val.addl (nextinstr rs # X16 <- (symbol_high ge id ofs) X16)\n  (symbol_low ge id ofs) = Vptr b o.","proofString":"Simpl.\nrewrite symbol_high_low.\nsimpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : Val.addl (symbol_high ge id ofs) (symbol_low ge id ofs) = Vptr b o.","proofString":"rewrite symbol_high_low.\nsimpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : Genv.symbol_address ge id ofs = Vptr b o.","proofString":"simpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Some (Genv.symbol_address ge id ofs) = Some (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : Genv.symbol_address ge id ofs = Vptr b o.","proofString":"congruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : forall r : preg,\ndata_preg r = true -> nextinstr rs # X16 <- (symbol_high ge id ofs) r = rs r.","proofString":"intros; Simpl."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn\n    (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadsymbol X16 id ofs).\nauto.\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B.\nrewrite <- Genv.shift_symbol_address_64, Ptrofs.add_zero by auto.\nsimpl in EV.\ncongruence.\nauto with asmgen."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) : X16 <> X16 \\/ SelectOp.symbol_is_relocatable id = false.","proofString":"auto."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Genv.symbol_address ge id ofs) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : eval_addressing ge (ADimm X16 Int64.zero) rs' = Vptr b o.","proofString":"simpl.\nrewrite B.\nrewrite <- Genv.shift_symbol_address_64, Ptrofs.add_zero by auto.\nsimpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Genv.symbol_address ge id ofs) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Val.addl (rs' X16) (Vlong Int64.zero) = Vptr b o.","proofString":"rewrite B.\nrewrite <- Genv.shift_symbol_address_64, Ptrofs.add_zero by auto.\nsimpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Genv.symbol_address ge id ofs) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Val.addl (Genv.symbol_address ge id ofs) (Vlong Int64.zero) = Vptr b o.","proofString":"rewrite <- Genv.shift_symbol_address_64, Ptrofs.add_zero by auto.\nsimpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Genv.symbol_address ge id ofs) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Genv.symbol_address ge id ofs = Vptr b o.","proofString":"simpl in EV.\ncongruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Some (Genv.symbol_address ge id ofs) = Some (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Genv.symbol_address ge id ofs) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : Genv.symbol_address ge id ofs = Vptr b o.","proofString":"congruence."},{"statement":"(sz : Z) (id : ident) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (Heqb0 : SelectOp.symbol_is_relocatable id = false) (Heqb1 : true = true) (EV : Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Aglobal id ofs) (map rs (map preg_of nil))) =\nVptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadsymbol X16 id ofs (insn (ADimm X16 Int64.zero) :: k)) rs m\n  (insn (ADimm X16 Int64.zero) :: k) rs' m) (B : rs' X16 = Genv.symbol_address ge id ofs) (C : forall r : preg, data_preg r = true -> r <> X16 -> rs' r = rs r) : forall r : preg, data_preg r = true -> rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"assert (E: Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o).\nsimpl in EV.\ninv EV.\ndestruct (rs SP); simpl in H1; inv H1.\nsimpl.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto.\ndestruct (offset_representable sz (Ptrofs.to_int64 ofs)); inv TR.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\nexploit (exec_loadimm64 X16 (Ptrofs.to_int64 ofs)).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\nauto with asmgen."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o.","proofString":"simpl in EV.\ninv EV.\ndestruct (rs SP); simpl in H1; inv H1.\nsimpl.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (EV : Some (Val.offset_ptr (rs SP) ofs) = Some (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o.","proofString":"inv EV.\ndestruct (rs SP); simpl in H1; inv H1.\nsimpl.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (H1 : Val.offset_ptr (rs SP) ofs = Vptr b o) : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Val.offset_ptr (rs SP) ofs.","proofString":"destruct (rs SP); simpl in H1; inv H1.\nsimpl.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (i : ptrofs) (H : Val.maketotal\n  (Op.eval_addressing ge (Vptr b i) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b (Ptrofs.add i ofs)) : Val.addl (Vptr b i) (Vlong (Ptrofs.to_int64 ofs)) =\nVal.offset_ptr (Vptr b i) ofs.","proofString":"simpl.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (i : ptrofs) (H : Val.maketotal\n  (Op.eval_addressing ge (Vptr b i) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b (Ptrofs.add i ofs)) : Vptr b (Ptrofs.add i (Ptrofs.of_int64 (Ptrofs.to_int64 ofs))) =\nVptr b (Ptrofs.add i ofs).","proofString":"rewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (i : ptrofs) (H : Val.maketotal\n  (Op.eval_addressing ge (Vptr b i) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b (Ptrofs.add i ofs)) : Vptr b (Ptrofs.add i ofs) = Vptr b (Ptrofs.add i ofs).","proofString":"auto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (c : code) (b : block) (o : ptrofs) (TR : (if offset_representable sz (Ptrofs.to_int64 ofs)\n then OK (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k)\n else OK (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k))) =\nOK c) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn c rs m (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct (offset_representable sz (Ptrofs.to_int64 ofs)); inv TR.\neconstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto.\nexploit (exec_loadimm64 X16 (Ptrofs.to_int64 ofs)).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\nauto with asmgen."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (insn (ADimm XSP (Ptrofs.to_int64 ofs)) :: k) rs m\n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn\n    (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k)) rs m\n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b o /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit (exec_loadimm64 X16 (Ptrofs.to_int64 ofs)).\nintros (rs' & A & B & C).\neconstructor; exists rs'; split.\napply exec_straight_opt_intro.\neexact A.\nsplit.\nsimpl.\nrewrite B, C by eauto with asmgen.\nauto.\nauto with asmgen."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k)) rs m\n  (insn (ADreg XSP X16) :: k) rs' m) (B : rs' X16 = Vlong (Ptrofs.to_int64 ofs)) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : eval_addressing ge (ADreg XSP X16) rs' = Vptr b o.","proofString":"simpl.\nrewrite B, C by eauto with asmgen.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k)) rs m\n  (insn (ADreg XSP X16) :: k) rs' m) (B : rs' X16 = Vlong (Ptrofs.to_int64 ofs)) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : Val.addl (rs' SP) (rs' X16) = Vptr b o.","proofString":"rewrite B, C by eauto with asmgen.\nauto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k)) rs m\n  (insn (ADreg XSP X16) :: k) rs' m) (B : rs' X16 = Vlong (Ptrofs.to_int64 ofs)) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o.","proofString":"auto."},{"statement":"(sz : Z) (ofs : ptrofs) (insn : addressing -> instruction) (k : code) (rs : regset) (m : mem) (b : block) (o : ptrofs) (EV : Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil)) =\nSome (Vptr b o)) (H : Val.maketotal\n  (Op.eval_addressing ge (rs SP) (Ainstack ofs) (map rs (map preg_of nil))) =\nVptr b o) (E : Val.addl (rs SP) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b o) (rs' : regset) (A : exec_straight ge fn\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg XSP X16) :: k)) rs m\n  (insn (ADreg XSP X16) :: k) rs' m) (B : rs' X16 = Vlong (Ptrofs.to_int64 ofs)) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : forall r : preg, data_preg r = true -> rs' r = rs r.","proofString":"auto with asmgen."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (vaddr v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) = Some vaddr) (H1 : Mem.loadv chunk m vaddr = Some v) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m /\\\n  rs' (preg_of dst) = v /\\\n  (forall r : preg, data_preg r = true -> r <> preg_of dst -> rs' r = rs r).","proofString":"destruct vaddr; try discriminate.\nassert (A: exists sz insn,                transl_addressing sz addr args insn k = OK c             /\\ (forall ad rs', exec_instr ge fn (insn ad) rs' m =                              exec_load ge chunk (fun v => v) ad (preg_of dst) rs' m)).\ndestruct chunk; monadInv H;    try rewrite (ireg_of_eq _ _ EQ); try rewrite (freg_of_eq _ _ EQ);    do 2 econstructor; (split; [eassumption|auto]).\ndestruct A as (sz & insn & B & C).\nexploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (X: exec_load ge chunk (fun v => v) ad (preg_of dst) rs' m =             Next (nextinstr (rs'#(preg_of dst) <- v)) m).\nunfold exec_load.\nrewrite Q, H1.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, X; eauto.\nSimpl.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m /\\\n  rs' (preg_of dst) = v /\\\n  (forall r : preg, data_preg r = true -> r <> preg_of dst -> rs' r = rs r).","proofString":"assert (A: exists sz insn,                transl_addressing sz addr args insn k = OK c             /\\ (forall ad rs', exec_instr ge fn (insn ad) rs' m =                              exec_load ge chunk (fun v => v) ad (preg_of dst) rs' m)).\ndestruct chunk; monadInv H;    try rewrite (ireg_of_eq _ _ EQ); try rewrite (freg_of_eq _ _ EQ);    do 2 econstructor; (split; [eassumption|auto]).\ndestruct A as (sz & insn & B & C).\nexploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (X: exec_load ge chunk (fun v => v) ad (preg_of dst) rs' m =             Next (nextinstr (rs'#(preg_of dst) <- v)) m).\nunfold exec_load.\nrewrite Q, H1.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, X; eauto.\nSimpl.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) : exists (sz : Z) (insn : addressing -> instruction),\n  transl_addressing sz addr args insn k = OK c /\\\n  (forall (ad : addressing) (rs' : regset),\n   exec_instr ge fn (insn ad) rs' m =\n   exec_load ge chunk (fun v0 : val => v0) ad (preg_of dst) rs' m).","proofString":"destruct chunk; monadInv H;    try rewrite (ireg_of_eq _ _ EQ); try rewrite (freg_of_eq _ _ EQ);    do 2 econstructor; (split; [eassumption|auto])."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (A : exists (sz : Z) (insn : addressing -> instruction),\n  transl_addressing sz addr args insn k = OK c /\\\n  (forall (ad : addressing) (rs' : regset),\n   exec_instr ge fn (insn ad) rs' m =\n   exec_load ge chunk (fun v0 : val => v0) ad (preg_of dst) rs' m)) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m /\\\n  rs' (preg_of dst) = v /\\\n  (forall r : preg, data_preg r = true -> r <> preg_of dst -> rs' r = rs r).","proofString":"destruct A as (sz & insn & B & C).\nexploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (X: exec_load ge chunk (fun v => v) ad (preg_of dst) rs' m =             Next (nextinstr (rs'#(preg_of dst) <- v)) m).\nunfold exec_load.\nrewrite Q, H1.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, X; eauto.\nSimpl.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (sz : Z) (insn : addressing -> instruction) (B : transl_addressing sz addr args insn k = OK c) (C : forall (ad : addressing) (rs' : regset),\nexec_instr ge fn (insn ad) rs' m =\nexec_load ge chunk (fun v0 : val => v0) ad (preg_of dst) rs' m) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m /\\\n  rs' (preg_of dst) = v /\\\n  (forall r : preg, data_preg r = true -> r <> preg_of dst -> rs' r = rs r).","proofString":"exploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (X: exec_load ge chunk (fun v => v) ad (preg_of dst) rs' m =             Next (nextinstr (rs'#(preg_of dst) <- v)) m).\nunfold exec_load.\nrewrite Q, H1.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, X; eauto.\nSimpl.\nsplit.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (sz : Z) (insn : addressing -> instruction) (B : transl_addressing sz addr args insn k = OK c) (C : forall (ad0 : addressing) (rs'0 : regset),\nexec_instr ge fn (insn ad0) rs'0 m =\nexec_load ge chunk (fun v0 : val => v0) ad0 (preg_of dst) rs'0 m) (ad : addressing) (rs' : regset) (P : exec_straight_opt ge fn c rs m (insn ad :: k) rs' m) (Q : eval_addressing ge ad rs' = Vptr b i) (R : forall r : preg, data_preg r = true -> rs' r = rs r) (X : exec_load ge chunk (fun v0 : val => v0) ad (preg_of dst) rs' m =\nNext (nextinstr rs' # (preg_of dst) <- v) m) : nextinstr rs' # (preg_of dst) <- v (preg_of dst) = v.","proofString":"Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (dst : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (v : val) (H : transl_load chunk addr args dst k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.loadv chunk m (Vptr b i) = Some v) (sz : Z) (insn : addressing -> instruction) (B : transl_addressing sz addr args insn k = OK c) (C : forall (ad0 : addressing) (rs'0 : regset),\nexec_instr ge fn (insn ad0) rs'0 m =\nexec_load ge chunk (fun v0 : val => v0) ad0 (preg_of dst) rs'0 m) (ad : addressing) (rs' : regset) (P : exec_straight_opt ge fn c rs m (insn ad :: k) rs' m) (Q : eval_addressing ge ad rs' = Vptr b i) (R : forall r : preg, data_preg r = true -> rs' r = rs r) (X : exec_load ge chunk (fun v0 : val => v0) ad (preg_of dst) rs' m =\nNext (nextinstr rs' # (preg_of dst) <- v) m) : forall r : preg,\ndata_preg r = true ->\nr <> preg_of dst -> nextinstr rs' # (preg_of dst) <- v r = rs r.","proofString":"intros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (src : mreg) (k c : code) (rs : regset) (m : mem) (vaddr : val) (m' : mem) (H : transl_store chunk addr args src k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) = Some vaddr) (H1 : Mem.storev chunk m vaddr (rs (preg_of src)) = Some m') : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m' /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct vaddr; try discriminate.\nassert (A: exists sz insn,                transl_addressing sz addr args insn k = OK c             /\\ (forall ad rs', exec_instr ge fn (insn ad) rs' m =                              exec_store ge chunk ad rs'#(preg_of src) rs' m)).\ndestruct chunk; monadInv H;    try rewrite (ireg_of_eq _ _ EQ); try rewrite (freg_of_eq _ _ EQ);    do 2 econstructor; (split; [eassumption|auto]).\ndestruct A as (sz & insn & B & C).\nexploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (Y: exec_store ge chunk ad rs'#(preg_of src) rs' m =             Next (nextinstr rs') m').\nunfold exec_store.\nrewrite Q, R, H1 by auto with asmgen.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, Y; eauto.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (src : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (m' : mem) (H : transl_store chunk addr args src k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) (rs (preg_of src)) = Some m') : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m' /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"assert (A: exists sz insn,                transl_addressing sz addr args insn k = OK c             /\\ (forall ad rs', exec_instr ge fn (insn ad) rs' m =                              exec_store ge chunk ad rs'#(preg_of src) rs' m)).\ndestruct chunk; monadInv H;    try rewrite (ireg_of_eq _ _ EQ); try rewrite (freg_of_eq _ _ EQ);    do 2 econstructor; (split; [eassumption|auto]).\ndestruct A as (sz & insn & B & C).\nexploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (Y: exec_store ge chunk ad rs'#(preg_of src) rs' m =             Next (nextinstr rs') m').\nunfold exec_store.\nrewrite Q, R, H1 by auto with asmgen.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, Y; eauto.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (src : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (m' : mem) (H : transl_store chunk addr args src k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) (rs (preg_of src)) = Some m') : exists (sz : Z) (insn : addressing -> instruction),\n  transl_addressing sz addr args insn k = OK c /\\\n  (forall (ad : addressing) (rs' : regset),\n   exec_instr ge fn (insn ad) rs' m =\n   exec_store ge chunk ad (rs' (preg_of src)) rs' m).","proofString":"destruct chunk; monadInv H;    try rewrite (ireg_of_eq _ _ EQ); try rewrite (freg_of_eq _ _ EQ);    do 2 econstructor; (split; [eassumption|auto])."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (src : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (m' : mem) (H : transl_store chunk addr args src k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) (rs (preg_of src)) = Some m') (A : exists (sz : Z) (insn : addressing -> instruction),\n  transl_addressing sz addr args insn k = OK c /\\\n  (forall (ad : addressing) (rs' : regset),\n   exec_instr ge fn (insn ad) rs' m =\n   exec_store ge chunk ad (rs' (preg_of src)) rs' m)) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m' /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"destruct A as (sz & insn & B & C).\nexploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (Y: exec_store ge chunk ad rs'#(preg_of src) rs' m =             Next (nextinstr rs') m').\nunfold exec_store.\nrewrite Q, R, H1 by auto with asmgen.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, Y; eauto.\nSimpl.\nintros; Simpl."},{"statement":"(chunk : memory_chunk) (addr : Op.addressing) (args : list mreg) (src : mreg) (k c : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (m' : mem) (H : transl_store chunk addr args src k = OK c) (H0 : Op.eval_addressing ge (rs SP) addr (map rs (map preg_of args)) =\nSome (Vptr b i)) (H1 : Mem.storev chunk m (Vptr b i) (rs (preg_of src)) = Some m') (sz : Z) (insn : addressing -> instruction) (B : transl_addressing sz addr args insn k = OK c) (C : forall (ad : addressing) (rs' : regset),\nexec_instr ge fn (insn ad) rs' m =\nexec_store ge chunk ad (rs' (preg_of src)) rs' m) : exists rs' : regset,\n  exec_straight ge fn c rs m k rs' m' /\\\n  (forall r : preg, data_preg r = true -> rs' r = rs r).","proofString":"exploit transl_addressing_correct.\neexact B.\neexact H0.\nintros (ad & rs' & P & Q & R).\nassert (Y: exec_store ge chunk ad rs'#(preg_of src) rs' m =             Next (nextinstr rs') m').\nunfold exec_store.\nrewrite Q, R, H1 by auto with asmgen.\nauto.\neconstructor; split.\neapply exec_straight_opt_right.\neexact P.\napply exec_straight_one.\nrewrite C, Y; eauto.\nSimpl.\nintros; Simpl."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (H0 : Val.offset_ptr (rs base) ofs = Vptr b i) : Val.addl (rs base) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b i.","proofString":"destruct (rs base); try discriminate.\nsimpl in *.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (b0 : block) (i0 : ptrofs) (H0 : Val.offset_ptr (Vptr b0 i0) ofs = Vptr b i) : Val.addl (Vptr b0 i0) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b i.","proofString":"simpl in *.\nrewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (b0 : block) (i0 : ptrofs) (H0 : Vptr b0 (Ptrofs.add i0 ofs) = Vptr b i) : Vptr b0 (Ptrofs.add i0 (Ptrofs.of_int64 (Ptrofs.to_int64 ofs))) = Vptr b i.","proofString":"rewrite Ptrofs.of_int64_to_int64 by auto.\nauto."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (b0 : block) (i0 : ptrofs) (H0 : Vptr b0 (Ptrofs.add i0 ofs) = Vptr b i) : Vptr b0 (Ptrofs.add i0 ofs) = Vptr b i.","proofString":"auto."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (H0 : Val.offset_ptr (rs base) ofs = Vptr b i) (H1 : Val.addl (rs base) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b i) : exists (ad : addressing) (rs' : regset),\n  exec_straight_opt ge fn (insn (ADimm base (Ptrofs.to_int64 ofs)) :: k) rs m\n    (insn ad :: k) rs' m /\\\n  eval_addressing ge ad rs' = Vptr b i /\\\n  (forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r).","proofString":"econstructor; econstructor; split.\napply exec_straight_opt_refl.\nauto."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (H0 : Val.offset_ptr (rs base) ofs = Vptr b i) (H1 : Val.addl (rs base) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b i) (rs' : regset) (A : exec_straight ge fn\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg base X16) :: k)) rs m\n  (insn (ADreg base X16) :: k) rs' m) (B : rs' X16 = Vlong (Ptrofs.to_int64 ofs)) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : Val.addl (rs base) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b i.","proofString":"auto."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (rs : regset) (m : mem) (b : block) (i : ptrofs) (H : base <> X16) (H0 : Val.offset_ptr (rs base) ofs = Vptr b i) (H1 : Val.addl (rs base) (Vlong (Ptrofs.to_int64 ofs)) = Vptr b i) (rs' : regset) (A : exec_straight ge fn\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg base X16) :: k)) rs m\n  (insn (ADreg base X16) :: k) rs' m) (B : rs' X16 = Vlong (Ptrofs.to_int64 ofs)) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r.","proofString":"auto."},{"statement":"(base : iregsp) (ofs : ptrofs) (dst : ireg) (k : code) (m : mem) (v : val) (rs : regset) (b : block) (i : ptrofs) (V : Val.offset_ptr (rs base) ofs = Vptr b i) (H : Mem.loadv Mint64 m (Vptr b i) = Some v) (H0 : base <> X16) (ad : addressing) (rs' : regset) (A : exec_straight_opt ge fn (indexed_memory_access (Pldrx dst) 8 base ofs k) rs m\n  (Pldrx dst ad :: k) rs' m) (B : eval_addressing ge ad rs' = Vptr b i) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : nextinstr rs' # dst <- v dst = v.","proofString":"Simpl."},{"statement":"(base : iregsp) (ofs : ptrofs) (dst : ireg) (k : code) (m : mem) (v : val) (rs : regset) (b : block) (i : ptrofs) (V : Val.offset_ptr (rs base) ofs = Vptr b i) (H : Mem.loadv Mint64 m (Vptr b i) = Some v) (H0 : base <> X16) (ad : addressing) (rs' : regset) (A : exec_straight_opt ge fn (indexed_memory_access (Pldrx dst) 8 base ofs k) rs m\n  (Pldrx dst ad :: k) rs' m) (B : eval_addressing ge ad rs' = Vptr b i) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : forall r : preg,\nr <> PC -> r <> X16 -> r <> dst -> nextinstr rs' # dst <- v r = rs r.","proofString":"intros; Simpl."},{"statement":"(base : iregsp) (ofs : ptrofs) (ty : typ) (dst : mreg) (k : code) (c : list instruction) (rs : regset) (m : mem) (v : val) (H : loadind base ofs ty dst k = OK c) (b : block) (i : ptrofs) (V : Val.offset_ptr (rs base) ofs = Vptr b i) (H0 : Mem.loadv (chunk_of_type ty) m (Vptr b i) = Some v) (H1 : base <> X16) : exists (sz : Z) (insn : addressing -> instruction),\n  c = indexed_memory_access insn sz base ofs k /\\\n  (forall (ad : addressing) (rs' : regset),\n   exec_instr ge fn (insn ad) rs' m =\n   exec_load ge (chunk_of_type ty) (fun v0 : val => v0) ad \n     (preg_of dst) rs' m).","proofString":"unfold loadind in H; destruct ty; destruct (preg_of dst); inv H; do 2 econstructor; eauto."},{"statement":"(base : iregsp) (ofs : ptrofs) (ty : typ) (dst : mreg) (k : code) (rs : regset) (m : mem) (v : val) (sz : Z) (insn : addressing -> instruction) (H : loadind base ofs ty dst k = OK (indexed_memory_access insn sz base ofs k)) (b : block) (i : ptrofs) (V : Val.offset_ptr (rs base) ofs = Vptr b i) (H0 : Mem.loadv (chunk_of_type ty) m (Vptr b i) = Some v) (H1 : base <> X16) (SEM : forall (ad0 : addressing) (rs'0 : regset),\nexec_instr ge fn (insn ad0) rs'0 m =\nexec_load ge (chunk_of_type ty) (fun v0 : val => v0) ad0 (preg_of dst) rs'0 m) (ad : addressing) (rs' : regset) (A : exec_straight_opt ge fn (indexed_memory_access insn sz base ofs k) rs m\n  (insn ad :: k) rs' m) (B : eval_addressing ge ad rs' = Vptr b i) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : nextinstr rs' # (preg_of dst) <- v (preg_of dst) = v.","proofString":"Simpl."},{"statement":"(base : iregsp) (ofs : ptrofs) (ty : typ) (dst : mreg) (k : code) (rs : regset) (m : mem) (v : val) (sz : Z) (insn : addressing -> instruction) (H : loadind base ofs ty dst k = OK (indexed_memory_access insn sz base ofs k)) (b : block) (i : ptrofs) (V : Val.offset_ptr (rs base) ofs = Vptr b i) (H0 : Mem.loadv (chunk_of_type ty) m (Vptr b i) = Some v) (H1 : base <> X16) (SEM : forall (ad0 : addressing) (rs'0 : regset),\nexec_instr ge fn (insn ad0) rs'0 m =\nexec_load ge (chunk_of_type ty) (fun v0 : val => v0) ad0 (preg_of dst) rs'0 m) (ad : addressing) (rs' : regset) (A : exec_straight_opt ge fn (indexed_memory_access insn sz base ofs k) rs m\n  (insn ad :: k) rs' m) (B : eval_addressing ge ad rs' = Vptr b i) (C : forall r : preg, r <> PC -> r <> X16 -> rs' r = rs r) : forall r : preg,\ndata_preg r = true ->\nr <> preg_of dst -> nextinstr rs' # (preg_of dst) <- v r = rs r.","proofString":"intros; Simpl."},{"statement":"(base : iregsp) (ofs : ptrofs) (ty : typ) (src : mreg) (k : code) (c : list instruction) (rs : regset) (m m' : mem) (H : storeind src base ofs ty k = OK c) (b : block) (i : ptrofs) (V : Val.offset_ptr (rs base) ofs = Vptr b i) (H0 : Mem.storev (chunk_of_type ty) m (Vptr b i) (rs (preg_of src)) = Some m') (H1 : base <> X16) : exists (sz : Z) (insn : addressing -> instruction),\n  c = indexed_memory_access insn sz base ofs k /\\\n  (forall (ad : addressing) (rs' : regset),\n   exec_instr ge fn (insn ad) rs' m =\n   exec_store ge (chunk_of_type ty) ad (rs' (preg_of src)) rs' m).","proofString":"unfold storeind in H; destruct ty; destruct (preg_of src); inv H; do 2 econstructor; eauto."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) : exists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"exploit Mem.loadv_extends.\neauto.\neexact LP.\nauto.\nsimpl.\nintros (parent' & LP' & LDP').\nexploit Mem.loadv_extends.\neauto.\neexact LRA.\nauto.\nsimpl.\nintros (ra' & LRA' & LDRA').\nexploit lessdef_parent_sp; eauto.\nintros EQ; subst parent'; clear LDP'.\nexploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) : (exists v2 : val,\n   Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\n   Some v2 /\\ Val.lessdef (parent_sp cs) v2) ->\nexists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"intros (parent' & LP' & LDP').\nexploit Mem.loadv_extends.\neauto.\neexact LRA.\nauto.\nsimpl.\nintros (ra' & LRA' & LDRA').\nexploit lessdef_parent_sp; eauto.\nintros EQ; subst parent'; clear LDP'.\nexploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (parent' : val) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome parent') (LDP' : Val.lessdef (parent_sp cs) parent') : exists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"exploit Mem.loadv_extends.\neauto.\neexact LRA.\nauto.\nsimpl.\nintros (ra' & LRA' & LDRA').\nexploit lessdef_parent_sp; eauto.\nintros EQ; subst parent'; clear LDP'.\nexploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (parent' : val) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome parent') (LDP' : Val.lessdef (parent_sp cs) parent') : (exists v2 : val,\n   Mem.load Mint64 tm stk\n     (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) = \n   Some v2 /\\ Val.lessdef (parent_ra cs) v2) ->\nexists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"intros (ra' & LRA' & LDRA').\nexploit lessdef_parent_sp; eauto.\nintros EQ; subst parent'; clear LDP'.\nexploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (parent' : val) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome parent') (LDP' : Val.lessdef (parent_sp cs) parent') (ra' : val) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome ra') (LDRA' : Val.lessdef (parent_ra cs) ra') : exists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"exploit lessdef_parent_sp; eauto.\nintros EQ; subst parent'; clear LDP'.\nexploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (parent' : val) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome parent') (LDP' : Val.lessdef (parent_sp cs) parent') (ra' : val) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome ra') (LDRA' : Val.lessdef (parent_ra cs) ra') : parent' = parent_sp cs ->\nexists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"intros EQ; subst parent'; clear LDP'.\nexploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (ra' : val) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome ra') (LDRA' : Val.lessdef (parent_ra cs) ra') : exists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"exploit lessdef_parent_ra; eauto.\nintros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (ra' : val) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome ra') (LDRA' : Val.lessdef (parent_ra cs) ra') : ra' = parent_ra cs ->\nexists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"intros EQ; subst ra'; clear LDRA'.\nexploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) : exists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) : (exists m2' : mem,\n   Mem.free tm stk 0 (fn_stacksize f) = Some m2' /\\ Mem.extends m' m2') ->\nexists (rs' : regset) (tm' : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm' /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm' /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"intros (tm' & FREE' & MEXT').\nunfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') : exists (rs' : regset) (tm'0 : mem),\n  exec_straight ge fn (make_epilogue f k) rs tm k rs' tm'0 /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm'0 /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"unfold make_epilogue.\nexploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') : exists (rs' : regset) (tm'0 : mem),\n  exec_straight ge fn\n    (loadptr XSP (fn_retaddr_ofs f) X30\n       (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm k rs' tm'0 /\\\n  agree ms (parent_sp cs) rs' /\\\n  Mem.extends m' tm'0 /\\\n  rs' X30 = parent_ra cs /\\\n  rs' SP = parent_sp cs /\\\n  (forall r : preg,\n   r <> PC -> r <> SP -> r <> X30 -> r <> X16 -> rs' r = rs r).","proofString":"exploit (loadptr_correct XSP (fn_retaddr_ofs f)).\ninstantiate (2 := rs).\nsimpl.\nrewrite <- (sp_val _ _ _ AG).\nsimpl.\neexact LRA'.\nsimpl; congruence.\nintros (rs1 & A1 & B1 & C1).\neconstructor; econstructor; split.\neapply exec_straight_trans.\neexact A1.\napply exec_straight_one.\nsimpl.\nsimpl; rewrite (C1 SP) by auto with asmgen.\nrewrite <- (sp_val _ _ _ AG).\nsimpl; rewrite LP'.\nrewrite FREE'.\neauto.\nauto.\nsplit.\napply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto.\nsplit.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') : XSP <> X16.","proofString":"simpl; congruence."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : agree ms (parent_sp cs)\n  (nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef).","proofString":"apply agree_nextinstr.\napply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : agree ms (parent_sp cs) (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef.","proofString":"apply agree_set_other; auto.\napply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : agree ms (parent_sp cs) rs1 # SP <- (parent_sp cs).","proofString":"apply agree_change_sp with (Vptr stk soff).\napply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen.\neapply parent_sp_def; eauto."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : agree ms (Vptr stk soff) rs1.","proofString":"apply agree_exten with rs; auto.\nintros; apply C1; auto with asmgen."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : forall r : preg, data_preg r = true -> rs1 r = rs r.","proofString":"intros; apply C1; auto with asmgen."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : parent_sp cs <> Vundef.","proofString":"eapply parent_sp_def; eauto."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : Mem.extends m' tm' /\\\nnextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef X30 = parent_ra cs /\\\nnextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef SP = parent_sp cs /\\\n(forall r : preg,\n r <> PC ->\n r <> SP ->\n r <> X30 ->\n r <> X16 -> nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef r = rs r).","proofString":"split.\nauto.\nsplit.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : Mem.extends m' tm'.","proofString":"auto."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef X30 = parent_ra cs /\\\nnextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef SP = parent_sp cs /\\\n(forall r : preg,\n r <> PC ->\n r <> SP ->\n r <> X30 ->\n r <> X16 -> nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef r = rs r).","proofString":"split.\nSimpl.\nsplit.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef X30 = parent_ra cs.","proofString":"Simpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef SP = parent_sp cs /\\\n(forall r : preg,\n r <> PC ->\n r <> SP ->\n r <> X30 ->\n r <> X16 -> nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef r = rs r).","proofString":"split.\nSimpl.\nintros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef SP = parent_sp cs.","proofString":"Simpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r : preg, r <> PC -> r <> X16 -> r <> X30 -> rs1 r = rs r) : forall r : preg,\nr <> PC ->\nr <> SP ->\nr <> X30 ->\nr <> X16 -> nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef r = rs r.","proofString":"intros.\nSimpl."},{"statement":"(ge0 : Mach.genv) (f : Mach.function) (m : mem) (stk : block) (soff : ptrofs) (cs : list stackframe) (m' : mem) (ms : Mach.regset) (rs : regset) (k : code) (tm : mem) (LP : load_stack m (Vptr stk soff) Tptr (fn_link_ofs f) = Some (parent_sp cs)) (LRA : load_stack m (Vptr stk soff) Tptr (fn_retaddr_ofs f) = Some (parent_ra cs)) (FREE : Mem.free m stk 0 (fn_stacksize f) = Some m') (AG : agree ms (Vptr stk soff) rs) (MEXT : Mem.extends m tm) (MCS : match_stack ge0 cs) (LP' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_link_ofs f))) =\nSome (parent_sp cs)) (LRA' : Mem.load Mint64 tm stk (Ptrofs.unsigned (Ptrofs.add soff (fn_retaddr_ofs f))) =\nSome (parent_ra cs)) (tm' : mem) (FREE' : Mem.free tm stk 0 (fn_stacksize f) = Some tm') (MEXT' : Mem.extends m' tm') (rs1 : regset) (A1 : exec_straight ge fn\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)) rs tm\n  (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k) rs1 tm) (B1 : rs1 X30 = parent_ra cs) (C1 : forall r0 : preg, r0 <> PC -> r0 <> X16 -> r0 <> X30 -> rs1 r0 = rs r0) (r : preg) (H : r <> PC) (H0 : r <> SP) (H1 : r <> X30) (H2 : r <> X16) : nextinstr (rs1 # SP <- (parent_sp cs)) # X16 <- Vundef r = rs r.","proofString":"Simpl."}]}