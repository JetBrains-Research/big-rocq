[{"statement":"Lemma msg_rel_co_irr l :\n  irreflexive (msg_rel G sc l ⨾ co).","proof":"unfold msg_rel.\nintros x AA.\ndestruct AA as [y [[z [AA BB]] CC]].\neapply release_co_urr_irr; eauto.\n1-4: by apply IMMCON.\neexists; split; [|eexists]; eauto.\n"},{"statement":"Lemma s_tm_cov_sc_fence\n      f ordf thread\n      (TID: tid f = thread)\n      (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T)\n      (NEXT : next G (covered T) f)\n      (FPARAMS : lab f = Afence ordf)\n      (SC : Sc f) :\n  forall l,\n    S_tm G l (covered T ∪₁ eq f) ≡₁\n    S_tm G l (covered T) ∪₁ t_acq G sc thread l (covered T).","proof":"cdes IMMCON.\nintro l; split.\n- unfold S_tm, t_acq.\nrewrite s_tmr_union; relsf; unionL; splits; [basic_solver|].\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\nunfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42.\n- unionL; [by unfold S_tm; rewrite s_tmr_union; basic_solver|].\nunfold t_acq, S_tm.\nrewrite s_tmr_union.\nrelsf.\nunfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\n{\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\n{\nrewrite <- TID; rewrite next_helper'; eauto.\nbasic_solver.\n}\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\n}\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\n{\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\n}\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\n{\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\n}\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\narewrite (sc ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ sc).\n{\nnow eapply sc_covered; eauto.\n}\nunfold S_tmr; basic_solver 21.\n"},{"statement":"Lemma msg_rel_alt\n      (Wf_sc : wf_sc G sc)\n      w (WW : W w) (NCOV : ~ covered T w) (ISS : issuable G sc T w)\n      locw (LOC : loc lab w = Some locw) l:\n  dom_rel (msg_rel G sc l ⨾ ⦗ eq w ⦘) ≡₁\n  (if is_rel lab w\n   then t_cur G sc (tid w) l (covered T ∪₁ eq w)\n   else t_rel G sc (tid w) l locw (covered T)) ∪₁\n  dom_rel (msg_rel G sc l ⨾ (rf ⨾ rmw) ⨾ ⦗ eq w ⦘).","proof":"assert (E w) as EW.\n{\napply ISS.\n}\nassert (~ is_init w) as WNIT.\n{\nintros H.\napply NCOV.\neapply init_covered; vauto.\n}\nassert (Rel w -> dom_rel (sb ⨾ ⦗eq w⦘) ≡₁ (Tid_ (tid w) ∪₁ Init) ∩₁ covered T) as TT.\n{\nintros REL.\nsplit.\n{\nintros x [y H].\napply seq_eqv_r in H; desf.\nsplit.\n{\nby destruct (sb_tid_init H); [left|right].\n}\neapply fwbob_issuable_in_C; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\napply sb_to_w_rel_in_fwbob.\napply seq_eqv_r.\nsplit; vauto.\n}\nintros x [TIDIN COV].\nexists w.\napply seq_eqv_r; split; auto.\nassert (E x) as EX by (eapply coveredE; eauto).\ndestruct TIDIN as [TID|INIT].\n2: by eapply init_ninit_sb; eauto.\nedestruct same_thread as [H|H].\n3: by apply WNIT.\n{\napply ISS.\n}\n{\napply EX.\n}\n1,3: done.\nexfalso.\ndestruct H as [|H]; [by desf|].\napply NCOV.\neapply dom_sb_covered; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\n}\nassert (Rel w -> dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ covered T) as TT'.\n{\nintros H.\nrewrite (TT H).\nbasic_solver.\n}\nassert (~ Rel w ->          ⦗Rel⦘ ⨾ fwbob G ⨾ ⦗eq w⦘ ⊆          ⦗Rel⦘ ⨾ ⦗W_ locw ∪₁ F⦘ ⨾ ⦗Tid_ (tid w) ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq w⦘) as QQ.\n{\nintros HH.\narewrite (fwbob G ⨾ ⦗eq w⦘ ⊆ ⦗covered T⦘ ⨾ fwbob G ⨾ ⦗eq w⦘).\n{\nintros x y H.\napply seq_eqv_l; split; [|done].\napply seq_eqv_r in H.\ndesc.\nsubst.\neapply fwbob_issuable_in_C; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\n}\nunfold fwbob; rewrite !seq_union_l.\nrewrite !seqA.\narewrite (⦗W ∩₁ Rel⦘ ⨾ ⦗eq w⦘ ⊆ ∅₂) by basic_solver.\narewrite (⦗F ∩₁ (fun a : actid => is_ra lab a)⦘ ⨾ ⦗eq w⦘ ⊆ ∅₂) by type_solver.\nrelsf; unionL.\n- unfold same_loc; unfolder; ins; desf; splits; eauto.\nby left; splits; congruence.\nby apply (@sb_tid_init G).\n- generalize (@sb_tid_init G).\nbasic_solver 21.\n}\nunfold msg_rel at 1.\nunfold imm_s_hb.release.\nunfold imm_s_hb.rs.\nrewrite rtE.\nrewrite !seq_union_r.\nrewrite seq_union_l.\nrewrite dom_union.\napply set_equiv_union.\n2: {\napply dom_rel_more.\nunfold msg_rel at 1.\nunfold imm_s_hb.release.\nunfold imm_s_hb.rs.\nrewrite ct_end.\nbasic_solver.\n}\nrewrite seq_id_r.\nunfold t_cur, t_rel.\nsplit.\n{\nrewrite !seqA.\narewrite (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc lab)^? ⨾ ⦗W⦘ ⨾ ⦗eq w⦘ ⊆              ⦗Rel⦘ ⨾ fwbob G ⨾ ⦗eq w⦘ ∪ ⦗Rel ∩₁ eq w⦘).\n{\ncase_refl _; case_refl _.\n{\nbasic_solver.\n}\nall: unfold fwbob.\n{\nbasic_solver 42.\n}\nall: arewrite (⦗Rel⦘ ⨾ ⦗F⦘ ⊆ ⦗Rel⦘ ⨾ ⦗F ∩₁ (fun a => is_ra lab a)⦘) by mode_solver.\n2: arewrite (sb ⨾ ⦗W⦘ ⨾ sb ∩ same_loc lab ⊆ sb) by          (generalize (@sb_trans G); basic_solver).\nall: basic_solver 42.\n}\nrewrite seq_union_r.\ndesf.\n{\narewrite (Rel ∩₁ eq w ≡₁ eq w); [basic_solver|].\narewrite (urr G sc l ⨾ ⦗Rel⦘ ⨾ fwbob G ⨾ ⦗eq w⦘ ∪ urr G sc l ⨾ ⦗eq w⦘ ⊆                urr G sc l ⨾ ⦗eq w⦘).\n{\nrewrite union_absorb_l; [done|].\nhahn_frame.\netransitivity.\n2: by apply urr_hb.\nhahn_frame.\nrewrite fwbob_in_bob.\nrewrite bob_in_sb.\nrewrite sb_in_hb.\nbasic_solver.\n}\nrewrite urr_w_alt_union_eqv; auto.\napply dom_rel_mori.\narewrite (⦗eq w⦘ ⊆ ⦗W⦘ ⨾ ⦗eq w⦘) at 1 by basic_solver.\nseq_rewrite (urr_w WF); relsf; unionL; [unionR left| basic_solver 12].\ngeneralize (TT' Heq); basic_solver 21.\n}\narewrite (Rel ∩₁ eq w ≡₁ ∅) by basic_solver.\nrewrite <- dom_rel_ext with        (r := c_rel G sc (tid w) l locw (covered T))        (r' := (sb ⨾ ⦗ eq w ⦘) ).\napply dom_rel_mori.\nunfold c_rel.\nrewrite crE.\nrewrite !seq_union_r.\nunionR right.\nrewrite !seqA; rewrite QQ; [basic_solver 12| by rewrite Heq].\n}\ndesf.\n{\nrewrite urr_w_alt_union_eqv; auto.\nrelsf; unionL; splits; [|unfold urr; basic_solver 42].\nrewrite crE at 1; relsf; unionL; splits.\n- rewrite seq_eqvC; rewrite <- id_inter.\nrewrite <- (TT Heq).\nrewrite dom_rel_eqv_dom_rel.\napply dom_rel_mori.\nrewrite !crE; relsf.\nunionR left -> left.\nrewrite !seqA.\narewrite (⦗eq w⦘ ⊆ ⦗Rel⦘ ⨾ ⦗eq w⦘) at 1 by basic_solver.\narewrite (⦗eq w⦘ ⊆ ⦗W⦘ ⨾ ⦗eq w⦘) at 1 by basic_solver.\nhahn_frame.\netransitivity;[|by apply urr_hb].\nrewrite sb_in_hb.\nbasic_solver.\n- rewrite sb_in_hb at 1.\narewrite (hb ⊆ hb^?) at 1 .\narewrite_id ⦗covered T⦘; rels.\nsin_rewrite (@urr_hb G sc l).\nbasic_solver 21.\n}\nunfold c_rel.\nrewrite <- !id_inter.\nintros x [y [z [HH [H'' JJ]]]]; subst.\nexists w.\napply seq_eqv_r; split; auto.\nexists y; split; auto.\ndestruct JJ as [JJ1 [JJ2 [JJ3 JJ4]]].\nassert (E y) as EY by (eapply coveredE; eauto).\nassert (sb y w) as SBYW.\n{\ndestruct JJ3 as [TID|INIT].\n2: by eapply init_ninit_sb; eauto.\nedestruct same_thread as [H|H].\n3: by apply WNIT.\n{\napply ISS.\n}\n{\napply EY.\n}\n1,3: done.\nexfalso.\ndestruct H as [|H]; [by desf|].\napply NCOV.\neapply dom_sb_covered; eauto.\neexists.\napply seq_eqv_r.\nsplit; eauto.\n}\napply seq_eqv_l; split; auto.\ndestruct JJ2.\n{\nexists y; split; [by left|].\napply seq_eqv_l; split; [apply H|].\napply seq_eqv_r; split; auto.\nright; split; auto.\nred.\nrewrite LOC; apply H.\n}\nbasic_solver 12.\n"},{"statement":"Lemma msg_rel_alt2\n      (Wf_sc : wf_sc G sc)\n      w (WW : W w) (NCOV : ~ covered T w) (ISS : issuable G sc T w)\n      locw (LOC : loc lab w = Some locw) l:\n  dom_rel (msg_rel G sc l ⨾ ⦗ eq w ⦘) ≡₁\n  (if is_rel lab w\n   then t_cur G sc (tid w) l (covered T)\n   else t_rel G sc (tid w) l locw (covered T)) ∪₁\n  dom_rel (msg_rel G sc l ⨾ (rf ⨾ rmw) ⨾ ⦗ eq w ⦘) ∪₁\n  Rel ∩₁ Loc_ l ∩₁ eq w.","proof":"rewrite msg_rel_alt; eauto.\ndesf.\n2: by arewrite (Rel ∩₁ Loc_ l ∩₁ eq w ≡₁ ∅); basic_solver 10.\nrewrite t_cur_urr_union_eqv_w; auto.\n{\narewrite (Rel ∩₁ Loc_ l ∩₁ eq w ≡₁ Loc_ l ∩₁ eq w).\n2: by unfold t_cur, c_cur; basic_solver 10.\nbasic_solver 10.\n}\netransitivity; [| apply fwbob_issuable_in_C]; eauto.\ngeneralize (@sb_to_w_rel_in_fwbob G) Heq.\nbasic_solver 10.\n"},{"statement":"Lemma msg_rel_rfrmw_helper\n      w (WW : W w) (NCOV : ~ covered T w) (ISS : issuable G sc T w)\n      locw (LOC : loc lab w = Some locw) l:\n  dom_rel ((urr G sc l ⨾ release) ⨾ (rf ⨾ rmw) ⨾ ⦗eq w⦘) ⊆₁\n  dom_rel (urr G sc l ⨾ ⦗Rel⦘ ⨾ ⦗W_ locw ∪₁ F⦘ ⨾ ⦗Tid_ (tid w) ∪₁ Init⦘ ⨾ ⦗covered T⦘)\n  ∪₁ dom_rel ((urr G sc l ⨾ release) ⨾ (⦗W_ex⦘ ⨾ rfi ∪ rfe) ⨾ rmw ⨾ ⦗eq w⦘).","proof":"rewrite rfi_union_rfe; relsf; unionL; splits.\n2: basic_solver 12.\nunfold imm_s_hb.release.\nunfold imm_s_hb.rs.\nrewrite rtE; relsf.\nunionL; splits; cycle 1.\nrewrite rmw_W_ex at 1.\nrewrite <- !seqA.\nrewrite inclusion_ct_seq_eqv_r.\nunionR right -> left -> right; basic_solver 21.\nunionR left.\nrewrite !seqA.\narewrite ((sb ∩ same_loc lab)^? ⨾ ⦗W⦘ ⨾ rfi ⨾ rmw ⊆ sb ∩ same_loc lab).\n{\narewrite_id ⦗W⦘; rewrite (rfi_in_sbloc' WF), (rmw_in_sb_loc WF).\ngeneralize (@sb_same_loc_trans G); ins; relsf.\n}\narewrite (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ sb ∩ same_loc lab ⨾ ⦗eq w⦘   ⊆ ⦗Rel⦘ ⨾ ⦗W_ locw ∪₁ F⦘ ⨾ ⦗Tid_ (tid w) ∪₁ Init⦘ ⨾ fwbob G ⨾ ⦗eq w⦘).\n{\nrewrite crE at 1; relsf; unionL.\n- unfold fwbob.\nrewrite sb_tid_init' at 1.\nrewrite (init_pln WF) at 1.\nunfold same_tid.\nrelsf.\nunionR left -> left -> right.\nunfolder; ins; desf; splits; eauto 20.\nunfold same_loc in *; desf; eauto; left; splits; congruence.\nunfold same_loc in *; desf; eauto; left; splits; congruence.\nmode_solver 42.\n- rewrite !seqA.\narewrite (sb ⨾ ⦗W⦘ ⨾ sb ∩ same_loc lab ⊆ sb).\nby generalize (@sb_trans G); basic_solver.\narewrite (⦗Rel⦘ ⨾ ⦗F⦘ ⨾ sb ⨾ ⦗eq w⦘ ⊆ ⦗Rel⦘ ⨾ ⦗F⦘ ⨾ ⦗Tid_ (tid w)⦘ ⨾ fwbob G ⨾ ⦗eq w⦘).\n{\nunfold fwbob.\nrewrite sb_tid_init' at 1.\nrewrite (init_w WF).\nunfold same_tid.\nmode_solver 21.\n}\nbasic_solver.\n}\narewrite (⦗eq w⦘ ⊆ ⦗dom_cond (fwbob G) (covered T)⦘).\n{\napply eqv_rel_mori.\napply set_subset_eq.\neapply dom_rel_to_cond; eauto.\napply fwbob_issuable_in_C; auto.\n}\nrewrite dom_cond_elim.\nbasic_solver 12.\n"},{"statement":"Lemma t_rel_msg_rel_rfrmw\n      w (WW : W w) (NCOV : ~ covered T w) (ISS : issuable G sc T w)\n      locw (LOC : loc lab w = Some locw) l:\n  t_rel G sc (tid w) l locw (covered T) ∪₁ dom_rel (msg_rel G sc l ⨾ (rf ⨾ rmw) ⨾ ⦗eq w⦘) ≡₁\n  t_rel G sc (tid w) l locw (covered T) ∪₁\n  dom_rel (msg_rel G sc l ⨾ (⦗ W_ex ⦘ ⨾ rfi ∪ rfe) ⨾ rmw ⨾ ⦗eq w⦘).","proof":"ins; split; unionL; desf.\n1,3: basic_solver.\n2: rewrite rfi_union_rfe; basic_solver 12.\nunfold t_rel, c_rel, msg_rel.\nby apply msg_rel_rfrmw_helper.\n"},{"statement":"Lemma t_cur_msg_rel_rfrmw\n      w (WW : W w) (NCOV : ~ covered T w) (ISS : issuable G sc T w) l:\n  t_cur G sc (tid w) l (covered T) ∪₁ dom_rel (msg_rel G sc l ⨾ (rf ⨾ rmw) ⨾ ⦗eq w⦘) ≡₁\n  t_cur G sc (tid w) l (covered T) ∪₁\n  dom_rel (msg_rel G sc l ⨾ (⦗ W_ex ⦘ ⨾ rfi ∪ rfe) ⨾ rmw ⨾ ⦗eq w⦘).","proof":"ins; split; unionL; desf.\n1,3: basic_solver.\n2: rewrite rfi_union_rfe; basic_solver 12.\nunfold t_cur, c_cur, msg_rel.\nassert (exists locw, loc lab w = Some locw).\nby unfold loc, is_w in *; destruct (lab w); eauto.\ndesc.\nrewrite msg_rel_rfrmw_helper; try edone.\nbasic_solver 21.\n"},{"statement":"Lemma t_cur_n_sc_fence_step\n      (Wf_sc : wf_sc G sc)\n      f (FENCE : F f) (NSC : ~ Sc f) (NEXT : next G (covered T) f)\n      (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T):\n  forall l,\n    t_cur G sc (tid f) l (covered T ∪₁ eq f) ≡₁\n    if is_acq lab f\n    then t_acq G sc (tid f) l (covered T)\n    else t_cur G sc (tid f) l (covered T).","proof":"ins; split; rewrite t_cur_union; unionL; desf.\nby apply t_cur_in_t_acq.\n4: basic_solver.\nall: unfold t_cur, t_acq, c_cur, c_acq.\n- arewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘) by basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗ F ∩₁ set_compl Sc ⦘ ⨾ ⦗eq f⦘) by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nrewrite next_helper'; basic_solver 21.\n- arewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘) by basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Acq ⦘ ⨾ ⦗eq f⦘) by basic_solver.\nsin_rewrite (urr_f_non_acq WF); auto.\nrewrite next_helper'; basic_solver 21.\n- rewrite crE at 1; relsf; unionL; splits; [basic_solver 12|].\nunionR right.\nrewrite next_helper'; eauto.\nrewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Acq ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nunfold imm_s_hb.sw; basic_solver 16.\narewrite (sw ⊆ hb^?).\nsin_rewrite urr_hb.\nbasic_solver 21.\n"},{"statement":"Lemma t_acq_n_sc_fence_step\n      (Wf_sc : wf_sc G sc)\n      f (FENCE : F f) (NSC : ~ Sc f) (NEXT : next G (covered T) f):\n  forall l,\n    t_acq G sc (tid f) l (covered T ∪₁ eq f) ≡₁\n    t_acq G sc (tid f) l (covered T).","proof":"ins; split; rewrite t_acq_union; unionL; splits; desf; [|basic_solver].\nunfold t_acq, c_acq.\narewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘) by basic_solver.\nrewrite next_helper'; eauto.\nrewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21.\n"},{"statement":"Lemma t_rel_n_sc_fence_step\n      (Wf_sc : wf_sc G sc)\n      f (FENCE : F f) (NSC : ~ Sc f) (NEXT : next G (covered T) f):\n  forall l l',\n    t_rel G sc (tid f) l l' (covered T ∪₁ eq f) ∪₁\n    (if LocSet.Facts.eq_dec l l'\n     then W ∩₁ Loc_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T ∪₁ eq f)\n     else ∅) ≡₁\n    if is_acqrel lab f\n    then t_acq G sc (tid f) l (covered T)\n    else\n      if is_rel lab f\n      then t_cur G sc (tid f) l (covered T)\n      else\n        t_rel G sc (tid f) l l' (covered T) ∪₁\n        (if LocSet.Facts.eq_dec l l'\n         then W ∩₁ Loc_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T)\n         else ∅).","proof":"ins; split; try rewrite t_rel_union; unionL; desf.\nby apply t_rel_in_t_acq.\nby apply t_rel_in_t_cur.\nall: try rewrite set_inter_union_r.\nall: unionL.\nall: try  basic_solver 8.\nall: try type_solver.\n5: unfold t_acq, c_acq, urr; basic_solver 42.\n5: unfold t_cur, c_cur, urr; basic_solver 42.\nall: try rewrite set_union_empty_r.\nall: unfold t_rel, c_rel, t_acq, c_acq, t_cur, c_cur.\nall: rewrite next_helper'; eauto.\nall: rewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\n- arewrite ( ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F∩₁set_compl Sc⦘ ⨾ ⦗eq f⦘).\ntype_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21.\n- arewrite ( ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F∩₁set_compl Acq⦘ ⨾ ⦗eq f⦘).\nmode_solver.\nsin_rewrite (urr_f_non_acq WF); auto.\nbasic_solver 21.\n- arewrite ( ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F∩₁set_compl Acq⦘ ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗eq f⦘).\nmode_solver.\nsin_rewrite (urr_f_non_acq WF); auto.\nbasic_solver 21.\n- arewrite ( ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F∩₁set_compl Acq⦘ ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗eq f⦘).\nmode_solver.\nsin_rewrite (urr_f_non_acq WF); auto.\nbasic_solver 21.\n- arewrite ((release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘ ⊆ hb^? ⨾ ⦗eq f⦘) at 1.\n{\nrewrite crE at 1; relsf; unionL.\narewrite (sb ⊆ hb^?) at 1; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Acq ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nunfold imm_s_hb.sw; basic_solver 16.\narewrite (sw ⊆ hb^?); basic_solver.\n}\nsin_rewrite urr_hb.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Rel ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\nbasic_solver 21.\n- arewrite ((release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘ ⊆ hb^? ⨾ ⦗eq f⦘) at 1.\n{\nrewrite crE at 1; relsf; unionL.\narewrite (sb ⊆ hb^?) at 1; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Acq ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nunfold imm_s_hb.sw; basic_solver 16.\narewrite (sw ⊆ hb^?); basic_solver.\n}\nsin_rewrite urr_hb.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Rel ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\nbasic_solver 21.\n- arewrite (sb ⊆ hb^?) at 1.\nsin_rewrite urr_hb.\nbasic_solver 21.\n- arewrite (sb ⊆ hb^?) at 1.\nsin_rewrite urr_hb.\nbasic_solver 21.\n"},{"statement":"Lemma sc_helper' (Wf_sc : wf_sc G sc)\n f (FENCE : F f) (SC : Sc f) (COV : coverable G sc T f) (NCOV : ~ covered T f) :\n ⦗F ∩₁ Sc⦘ ⨾ ⦗covered T⦘ ≡ ⦗dom_rel (sc ⨾ ⦗eq f⦘)⦘.","proof":"split.\n- unfold coverable, dom_cond in *.\nunfolder in *; desf; try type_solver.\nins; desf; splits; eauto.\neexists; splits; eauto.\neapply tot_ex.\n* apply Wf_sc.\n* basic_solver.\n* generalize coveredE; basic_solver.\n* intro; apply NCOV.\neapply dom_sc_covered; vauto.\n* intro; subst; eauto.\n- rewrite <- !id_inter.\napply eqv_rel_mori.\napply set_subset_inter_r.\nsplit.\n{\nrewrite (wf_scD Wf_sc).\nbasic_solver.\n}\nrewrite <- dom_sc_coverable; eauto.\nbasic_solver.\n"},{"statement":"Lemma coverable_next_covered e\n      (COV: coverable G sc T e)\n      (NCOV : ~ covered T e):\n  next G (covered T) e.","proof":"red.\nsplit; auto.\nsplit; [apply COV| ].\nred.\nerewrite <- dom_sb_coverable; eauto.\nbasic_solver.\n"},{"statement":"Lemma t_cur_sc_fence_step \n      (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T)\n      f (FENCE : F f) (SC: Sc f) \n      (COV : coverable G sc T f) (NCOV : ~ covered T f) :\n  forall l,\n    t_cur G sc (tid f) l (covered T ∪₁ eq f) ≡₁\n    S_tm G l (covered T) ∪₁ t_acq G sc (tid f) l (covered T).","proof":"cdes IMMCON.\nins; split; try rewrite t_cur_union; unionL; desf.\nby rewrite t_cur_in_t_acq; basic_solver.\nall: unfold t_cur, c_cur, S_tm, S_tmr, t_acq, c_acq, t_rel, c_rel.\n- arewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾  ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘).\nbasic_solver.\nsin_rewrite (urr_f_sc WF); auto.\nrewrite !seqA.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗eq f⦘ ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc^? ⨾ ⦗eq f⦘).\n{\nrewrite (dom_r (wf_rfD WF)) at 1.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾  ⦗eq f⦘) at 1 by basic_solver.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nhahn_frame_r; unfolder; ins; desf; eauto 20; type_solver.\n}\nrewrite (crE sc); relsf.\nrewrite <- !dom_eqv1.\nunionL; splits.\n* arewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ S_tmr G l (eq f)).\nrewrite (s_tmr_helper l (eq f) WF).\nrewrite next_helper'; eauto using coverable_next_covered.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nunfold urr.\nunionR right; basic_solver 42.\n* unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nbasic_solver 21.\n- unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nunionR right; basic_solver 21.\n- rewrite crE at 1; relsf; unionL; splits; [basic_solver 12|].\nunionR right.\nrewrite next_helper'; eauto using coverable_next_covered.\nrewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Acq ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nunfold imm_s_hb.sw; basic_solver 16.\narewrite (sw ⊆ hb^?).\nsin_rewrite urr_hb.\nbasic_solver 21.\n"},{"statement":"Lemma t_acq_sc_fence_step\n      f (FENCE : F f) (SC: Sc f) (COV : coverable G sc T f) (NCOV : ~ covered T f):\n  forall l,\n    t_acq G sc (tid f) l (covered T ∪₁ eq f) ≡₁\n    t_acq G sc (tid f) l (covered T) ∪₁\n    S_tm G l (covered T).","proof":"cdes IMMCON.\nins; split; try rewrite t_acq_union; unionL; desf.\n1,3: basic_solver.\nall: unfold t_cur, c_cur, S_tm, S_tmr, t_acq, c_acq, t_rel, c_rel.\n- arewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾  ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘).\nrewrite (dom_r (wf_rfD WF)) at 1; type_solver.\nsin_rewrite (urr_f_sc WF); auto.\nrewrite !seqA.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗eq f⦘ ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc^? ⨾ ⦗eq f⦘).\n{\nrewrite (dom_r (wf_rfD WF)) at 1.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾  ⦗eq f⦘) at 1 by basic_solver.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nhahn_frame_r; unfolder; ins; desf; eauto 20; type_solver.\n}\nrewrite (crE sc); relsf; rewrite <- !dom_eqv1; unionL; splits.\n* arewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ S_tmr G l (eq f)).\nrewrite (s_tmr_helper l (eq f) WF).\nrewrite next_helper'; eauto using coverable_next_covered.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nunfold urr.\nunionR left; basic_solver 42.\n* unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nbasic_solver 21.\n- unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nunionR right; basic_solver 42.\n"},{"statement":"Lemma t_rel_sc_fence_step\n      f (FENCE : F f) (SC: Sc f) (COV : coverable G sc T f) (NCOV : ~ covered T f) :\n  forall l l',\n    t_rel G sc (tid f) l l' (covered T ∪₁ eq f) ∪₁\n    (if LocSet.Facts.eq_dec l l'\n     then W ∩₁ Loc_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T ∪₁ eq f)\n     else ∅) ≡₁\n     S_tm G l (covered T) ∪₁ t_acq G sc (tid f) l (covered T).","proof":"cdes IMMCON.\nins; split; try rewrite t_rel_union; unionL; desf.\nby rewrite t_rel_in_t_acq; basic_solver.\nall: unfold t_cur, c_cur, S_tm, S_tmr, t_acq, c_acq, t_rel, c_rel.\n2: by unfold urr; type_solver 42.\n- arewrite (⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾  ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘).\nbasic_solver.\nsin_rewrite (urr_f_sc WF); auto.\nrewrite !seqA.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗eq f⦘ ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc^? ⨾ ⦗eq f⦘).\n{\nrewrite (dom_r (wf_rfD WF)) at 1.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾  ⦗eq f⦘) at 1 by basic_solver.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nhahn_frame_r; unfolder; ins; desf; eauto 20; type_solver.\n}\nrewrite (crE sc); relsf; rewrite <- !dom_eqv1; unionL; splits.\n* arewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ S_tmr G l (eq f)).\nrewrite (s_tmr_helper l (eq f) WF).\nrewrite next_helper'; eauto using coverable_next_covered.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nunfold urr.\nunionR right; basic_solver 42.\n* unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nbasic_solver 21.\n- unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nassert (Rel f) by mode_solver.\nunionR left -> right; basic_solver 42.\n- unfold urr.\nrewrite (sc_helper' Wf_sc FENCE); auto.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\nrewrite (dom_l (wf_scD Wf_sc)) at 1.\nassert (Rel f) by mode_solver.\nunionR left -> right; basic_solver 42.\n- rewrite next_helper'; eauto using coverable_next_covered.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\narewrite ((release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘ ⊆ hb^? ⨾ ⦗eq f⦘) at 1.\n{\nrewrite crE at 1; relsf; unionL.\narewrite (sb ⊆ hb^?) at 1; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Acq ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nunfold imm_s_hb.sw; basic_solver 16.\narewrite (sw ⊆ hb^?); basic_solver.\n}\nsin_rewrite urr_hb.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Rel ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\nbasic_solver 21.\n- rewrite next_helper'; eauto using coverable_next_covered.\nrewrite <- !seqA, dom_rel_eqv_dom_rel, !seqA.\narewrite ((release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘ ⊆ hb^? ⨾ ⦗eq f⦘) at 1.\n{\nrewrite crE at 1; relsf; unionL.\narewrite (sb ⊆ hb^?) at 1; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Acq ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nunfold imm_s_hb.sw; basic_solver 16.\narewrite (sw ⊆ hb^?); basic_solver.\n}\nsin_rewrite urr_hb.\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁ Rel ⦘ ⨾ ⦗eq f⦘) at 1 by mode_solver.\nbasic_solver 21.\n"},{"statement":"Lemma t_cur_fence_step\n      (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T)\n      f (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f):\n  forall l,\n    t_cur G sc (tid f) l (covered T ∪₁ eq f) ≡₁\n    if is_sc lab f\n    then S_tm G l (covered T) ∪₁ t_acq G sc (tid f) l (covered T)\n    else\n      if is_acq lab f\n      then t_acq G sc (tid f) l (covered T)\n      else t_cur G sc (tid f) l (covered T).","proof":"destruct (is_sc lab f) eqn: H.\napply t_cur_sc_fence_step; auto.\napply t_cur_n_sc_fence_step; auto.\nby apply IMMCON.\nby ins; desf.\napply coverable_next_covered; auto.\n"},{"statement":"Lemma t_acq_fence_step\n      f (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f):\n  forall l,\n    t_acq G sc (tid f) l (covered T ∪₁ eq f) ≡₁\n    t_acq G sc (tid f) l (covered T) ∪₁\n    if is_sc lab f\n    then S_tm G l (covered T)\n    else ∅.","proof":"destruct (is_sc lab f) eqn: H.\napply t_acq_sc_fence_step; auto.\nins; rewrite set_union_empty_r; apply t_acq_n_sc_fence_step; auto.\nby apply IMMCON.\nby ins; desf.\napply coverable_next_covered; auto.\n"},{"statement":"Lemma t_rel_fence_step\n      f (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) :\n  forall l l',\n    t_rel G sc (tid f) l l' (covered T ∪₁ eq f) ∪₁\n    (if LocSet.Facts.eq_dec l l'\n     then W ∩₁ Loc_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T ∪₁ eq f)\n     else ∅) ≡₁\n    if is_sc lab f\n    then S_tm G l (covered T) ∪₁ t_acq G sc (tid f) l (covered T)\n    else \n      if is_acqrel lab f\n      then t_acq G sc (tid f) l (covered T)\n      else\n        if is_rel lab f\n        then t_cur G sc (tid f) l (covered T)\n        else\n          (t_rel G sc (tid f) l l' (covered T) ∪₁\n           (if LocSet.Facts.eq_dec l l'\n            then W ∩₁ Loc_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T)\n            else ∅)).","proof":"destruct (is_sc lab f) eqn: H.\napply t_rel_sc_fence_step; auto.\napply t_rel_n_sc_fence_step; auto.\nby apply IMMCON.\nby ins; desf.\napply coverable_next_covered; auto.\n"}]