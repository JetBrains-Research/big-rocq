[{"statement":"Lemma sw_js_in_sw : sw_js ⊆ sw.","proof":"unfold imm_s_hb.sw, JSMM.sw.\narewrite (Sc ⊆₁ Rel) at 1 by mode_solver.\narewrite (Sc ⊆₁ Acq) by mode_solver.\nunfold imm_s_hb.release, imm_s_hb.rs.\nrewrite !seqA.\nassert (⦗fun _ => True⦘ ⊆ (rf ⨾ rmw)＊) as HH      by basic_solver.\nrewrite <- HH.\nrewrite <- !inclusion_id_cr.\nrewrite !seq_id_l.\nrewrite (dom_l (wf_rfD WF)) at 1.\nbasic_solver 10.\n"},{"statement":"Lemma hb_js_in_hb : hb_js ⊆ hb.","proof":"unfold imm_s_hb.hb, JSMM.hb.\nby rewrite sw_js_in_sw.\n"},{"statement":"Lemma hb_jsE : hb_js ≡ ⦗E⦘ ⨾ hb_js ⨾ ⦗E⦘.","proof":"apply dom_helper_3.\nrewrite hb_js_in_hb.\napply dom_helper_3.\nby apply wf_hbE.\n"},{"statement":"Lemma sw_js_sc : sw_js ≡ ⦗Sc⦘ ⨾ sw_js ⨾ ⦗Sc⦘.","proof":"apply dom_helper_3.\nunfold JSMM.sw.\nbasic_solver.\n"},{"statement":"Lemma sc_hb_js_sc_in_sc_ct :\n  ⦗Sc⦘ ⨾ hb_js ⨾ ⦗Sc⦘ ⊆\n  (⦗Sc⦘ ⨾ sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺.","proof":"unfold JSMM.hb, JSMM.sw.\nrewrite path_tur with (adom:=Sc) (bdom:=Sc).\n3,4: basic_solver.\n2: by apply sb_trans.\nrewrite !seq_union_l, !seq_union_r.\nunionL.\n{\nrewrite <- ct_step.\nby unionR left.\n}\nrewrite !seqA.\narewrite ((⦗Sc⦘ ⨾ sb)^? ⨾ ⦗Sc⦘ ⊆ ⦗Sc⦘ ⨾ (⦗Sc⦘ ⨾ sb)^? ⨾ ⦗Sc⦘).\n{\nbasic_solver 10.\n}\narewrite (⦗Sc⦘ ⨾ (sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺ ⨾ ⦗Sc⦘ ⊆            (⦗Sc⦘ ⨾ sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺).\n2: {\nrewrite crE.\nrewrite !seq_union_l, !seq_union_r, seq_id_l, !seqA.\nunionL.\n{\nbasic_solver.\n}\narewrite        (⦗Sc⦘ ⨾ sb ⨾ ⦗Sc⦘ ⊆             (⦗Sc⦘ ⨾ sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺) at 2.\napply ct_ct.\n}\narewrite (⦗Sc⦘ ⨾ (sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺ ⨾ ⦗Sc⦘ ⊆            ⦗Sc⦘ ⨾ (sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺).\nred.\nintros x y HH.\napply seq_eqv_l in HH.\ndestruct HH as [SCX HH].\ninduction HH.\n{\napply ct_step.\ngeneralize SCX H.\nbasic_solver 10.\n}\napply ct_ct.\nexists y.\nsplit; auto.\napply IHHH2.\nclear -HH1.\nassert (((sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺ ⨾ ⦗Sc⦘) x y) as AA.\n2: {\napply seq_eqv_r in AA.\ndesf.\n}\nassert ((sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺ ⊆          (sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘)⁺ ⨾ ⦗Sc⦘ ) as BB.\n2: by apply BB.\narewrite (sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆            (sb ⨾ ⦗Sc⦘ ∪ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘) ⨾ ⦗Sc⦘).\n{\nbasic_solver.\n}\napply inclusion_ct_seq_eqv_r.\n"},{"statement":"Lemma hb_js_co_fr_ac sc (IPC : imm_s.imm_psc_consistent G sc) :\n  acyclic (hb_js ∪ ⦗ Sc ⦘ ⨾ (fr ∪ co) ⨾ ⦗ Sc ⦘).","proof":"cdes IPC.\ncdes IC.\nassert (acyclic hb_js) as HBJSAC.\n{\nrewrite hb_js_in_hb.\nred.\nunfold imm_s_hb.hb.\nrewrite ct_of_ct.\napply hb_irr; auto.\n}\napply acyclic_ud with (adom:=Sc) (bdom:=Sc); auto.\n1,2: basic_solver.\narewrite (hb_js⁺ ⊆ hb_js).\nrewrite sc_hb_js_sc_in_sc_ct.\narewrite (⦗Sc⦘ ⨾ sb ⨾ ⦗Sc⦘ ⊆ psc_base G).\n{\nunfold psc_base, scb.\nbasic_solver 40.\n}\narewrite (⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ psc_base G).\n{\nunfold psc_base, scb.\narewrite (⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆                   ⦗Sc⦘ ⨾ (⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘) ⨾ ⦗Sc⦘).\n{\nbasic_solver.\n}\nhahn_frame.\narewrite (⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ hb ∩ same_loc).\n2: basic_solver 20.\napply inclusion_inter_r.\n2: rewrite wf_rfl; auto; basic_solver.\nrewrite <- hb_js_in_hb.\nunfold JSMM.hb.\nrewrite <- ct_step.\nby right.\n}\narewrite (⦗Sc⦘ ⨾ (fr ∪ co) ⨾ ⦗Sc⦘ ⊆ psc_base G).\n{\nunfold psc_base, scb.\nbasic_solver 40.\n}\nrewrite unionK.\narewrite ((psc_base G)⁺ ∪ psc_base G ⊆ (psc_base G)⁺).\nred.\nrewrite ct_of_ct.\neapply inclusion_acyclic.\n2: by apply Cpsc.\ndone.\n"},{"statement":"Theorem s_imm_consistent_implies_jsmm_consistent sc\n      (IPC : imm_s.imm_psc_consistent G sc) :\n  exists tot, jsmm_consistent G tot.","proof":"cdes IPC.\ncdes IC.\ncdes FINDOM.\nexists (⦗E⦘ ⨾            tot_ext findom             (hb_js ∪ ⦗ Sc ⦘ ⨾ (fr ∪ co) ⨾ ⦗ Sc ⦘) ⨾          ⦗E⦘).\nred.\nsplits.\n{\nred.\nsplit; [split|].\n{\nrewrite <- restr_relE.\napply irreflexive_restr.\napply tot_ext_irr.\neapply hb_js_co_fr_ac; eauto.\n}\n{\nrewrite <- restr_relE.\napply transitive_restr.\napply tot_ext_trans.\n}\nred.\nins.\nedestruct tot_ext_total.\n3: by eauto.\nall: eauto.\n{\nleft.\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r.\nsplit; eauto.\n}\nright.\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r.\nsplit; eauto.\n}\n{\nrewrite <- tot_ext_extends.\nrewrite hb_jsE at 1.\nhahn_frame.\neauto with hahn.\n}\n{\nrewrite hb_js_in_hb, rf_in_eco.\narewrite (eco ⊆ eco^?).\napply IPC.\n}\n{\nunfolder.\nintros w' [r [HBWR HH]].\ndestruct HH as [w [RF [[HBJS AA] WW']]].\nassert (hb w w') as HB by (by apply hb_js_in_hb).\napply (wf_hbE WF) in HB.\napply seq_eqv_l in HB.\ndestruct HB as [EW HB].\napply seq_eqv_r in HB.\ndestruct HB as [HB EW'].\napply (dom_l (wf_rfD WF)) in RF.\napply seq_eqv_l in RF.\ndestruct RF as [WW RF].\nedestruct is_w_loc as [l LL].\n{\napply WW.\n}\nassert (w <> w') as NEQ.\n{\nintros HH.\nsubst.\neapply hb_irr; eauto.\n}\nedestruct (wf_co_total WF).\n3: by eauto.\n1,2: by unfolder; splits.\n{\neapply Cint.\nexists r.\nsplit.\n{\napply hb_js_in_hb.\neauto.\n}\nright.\napply fr_in_eco.\neexists.\neauto.\n}\neapply Cint.\nexists w'.\nsplit; eauto.\nright.\nby apply co_in_eco.\n}\n{\nintros w' HH.\napply seq_eqv_l in HH.\ndestruct HH as [[WW' SCW'] HH].\ndestruct HH as [r [TOT HH]].\napply seq_eqv_l in HH.\ndestruct HH as [[RR SCR] HH].\ndestruct HH as [w [RF HH]].\napply seq_eqv_l in HH.\ndestruct HH as [[WW SCW] [TOTJS SL]].\napply seq_eqv_l in TOTJS.\ndestruct TOTJS as [EW' TOTJS].\napply seq_eqv_r in TOTJS.\ndestruct TOTJS as [TOTJS EW].\nedestruct is_w_loc as [l LL].\n{\napply WW.\n}\nassert (w <> w') as NEQ.\n{\nintros HH.\nsubst.\neapply tot_ext_irr; [|by eauto].\neapply hb_js_co_fr_ac; eauto.\n}\nedestruct (wf_co_total WF).\n3: by eauto.\n1,2: by unfolder; splits.\nall: eapply tot_ext_irr;         [by eapply hb_js_co_fr_ac; eauto|].\n{\neapply tot_ext_trans.\n{\ngeneralize TOT.\nbasic_solver.\n}\napply tot_ext_extends.\nright.\napply seq_eqv_l.\nsplit; [by apply SCR|].\napply seq_eqv_r.\nsplit; [|by apply SCW'].\nleft.\neexists.\neauto.\n}\neapply tot_ext_trans; eauto.\napply tot_ext_extends.\nright.\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r.\nsplit; auto.\nby right.\n}\n{\nintros w' HH.\napply seq_eqv_l in HH.\ndestruct HH as [[WW' SCW'] HH].\ndestruct HH as [r [HBWR' HH]].\ndestruct HH as [w [[HBWR RF] HH]].\napply seq_eqv_l in HH.\ndestruct HH as [[WW SCW] [TOTJS SL]].\napply seq_eqv_l in TOTJS.\ndestruct TOTJS as [EW' TOTJS].\napply seq_eqv_r in TOTJS.\ndestruct TOTJS as [TOTJS EW].\nedestruct is_w_loc as [l LL].\n{\napply WW.\n}\nassert (w <> w') as NEQ.\n{\nintros HH.\nsubst.\neapply tot_ext_irr; [|by eauto].\neapply hb_js_co_fr_ac; eauto.\n}\nedestruct (wf_co_total WF).\n3: by eauto.\n1,2: by unfolder; splits.\n{\neapply Cint.\neexists.\nsplit.\n{\napply hb_js_in_hb.\napply HBWR'.\n}\nright.\napply fr_in_eco.\neexists.\neauto.\n}\neapply tot_ext_irr; [by eapply hb_js_co_fr_ac; eauto|].\neapply tot_ext_trans; eauto.\napply tot_ext_extends.\nright.\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r.\nsplit; auto.\nby right.\n}\nintros w' HH.\napply seq_eqv_l in HH.\ndestruct HH as [[WW' SCW'] HH].\ndestruct HH as [r [TOT HH]].\napply seq_eqv_l in TOT.\ndestruct TOT as [EW' TOT].\napply seq_eqv_r in TOT.\ndestruct TOT as [TOT ER].\napply seq_eqv_l in HH.\ndestruct HH as [[RR SCR] HH].\ndestruct HH as [w [[HBWR RF] [HBJS SL]]].\napply (dom_l (wf_rfD WF)) in RF.\napply seq_eqv_l in RF.\ndestruct RF as [WW RF].\napply (dom_l (wf_rfE WF)) in RF.\napply seq_eqv_l in RF.\ndestruct RF as [EW RF].\nedestruct is_w_loc as [l LL].\n{\napply WW.\n}\nassert (w <> w') as NEQ.\n{\nintros HH.\nsubst.\neapply hb_irr; eauto.\napply hb_js_in_hb.\neauto.\n}\nedestruct (wf_co_total WF).\n3: by eauto.\n1,2: by unfolder; splits.\n{\neapply tot_ext_irr; [by eapply hb_js_co_fr_ac; eauto|].\neapply tot_ext_trans.\n{\ngeneralize TOT.\nbasic_solver.\n}\napply tot_ext_extends.\nright.\napply seq_eqv_l.\nsplit; [by apply SCR|].\napply seq_eqv_r.\nsplit; [|by apply SCW'].\nleft.\neexists.\neauto.\n}\neapply Cint.\neexists.\nsplit.\n{\napply hb_js_in_hb.\napply HBJS.\n}\nright.\nby apply co_in_eco.\n"}]