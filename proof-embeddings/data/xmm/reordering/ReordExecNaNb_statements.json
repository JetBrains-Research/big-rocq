{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/reordering/ReordExecNaNb.v","fileSamples":[{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : E_t' ≡₁ E_t ∪₁ eq e.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : tid e <> tid_init.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ~ is_init e.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ~ E_t e.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : lab_t' = upd lab_t e l.","proofString":"apply ADD'."},{"statement":"(EXTSB : ext_sb e a_t) (H : is_init e) : tid e = tid a_t.","proofString":"enough (HH : ~ is_init e) by desf.\napply rsr_e_ninit."},{"statement":"(EXTSB : ext_sb e a_t) (H : is_init e) : ~ is_init e.","proofString":"apply rsr_e_ninit."},{"statement":"eq a_t ∩₁ E_t' ≡₁ eq a_t ∩₁ E_t.","proofString":"rewrite rsr_step_acts.\nbasic_solver."},{"statement":"eq a_t ∩₁ (E_t ∪₁ eq e) ≡₁ eq a_t ∩₁ E_t.","proofString":"basic_solver."},{"statement":"eq b_t ∩₁ E_t' ≡₁ eq b_t ∩₁ E_t.","proofString":"rewrite rsr_step_acts.\nbasic_solver."},{"statement":"eq b_t ∩₁ (E_t ∪₁ eq e) ≡₁ eq b_t ∩₁ E_t.","proofString":"basic_solver."},{"statement":"(APR : E_t' a_t <-> E_t a_t) : A_s ≡₁ A_s'.","proofString":"set (BPR := rsr_b_preserved).\nunfold extra_a; desf; tauto."},{"statement":"(APR : E_t' a_t <-> E_t a_t) (BPR : E_t' b_t <-> E_t b_t) : A_s ≡₁ A_s'.","proofString":"unfold extra_a; desf; tauto."},{"statement":"(EXTSB : ext_sb a_t e) (H : is_init a_t) : tid e = tid a_t.","proofString":"enough (HH : ~ is_init a_t) by desf.\napply (rsr_at_ninit INV)."},{"statement":"(EXTSB : ext_sb a_t e) (H : is_init a_t) : ~ is_init a_t.","proofString":"apply (rsr_at_ninit INV)."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) : False.","proofString":"apply (rsr_bt_max INV' INB' NINA') with b_t e.\nassert (INB : E_t b_t) by now apply rsr_b_preserved.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nhahn_rewrite (WCore.add_event_sb ADD').\nexists b_t.\nsplit; [basic_solver |].\nright.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) : (⦗eq b_t ∩₁ E_t'⦘ ⨾ sb_t') b_t e.","proofString":"assert (INB : E_t b_t) by now apply rsr_b_preserved.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nhahn_rewrite (WCore.add_event_sb ADD').\nexists b_t.\nsplit; [basic_solver |].\nright.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) (INB : E_t b_t) : (⦗eq b_t ∩₁ E_t'⦘ ⨾ sb_t') b_t e.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nhahn_rewrite (WCore.add_event_sb ADD').\nexists b_t.\nsplit; [basic_solver |].\nright.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) (INB : E_t b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : (⦗eq b_t ∩₁ E_t'⦘ ⨾ sb_t') b_t e.","proofString":"hahn_rewrite (WCore.add_event_sb ADD').\nexists b_t.\nsplit; [basic_solver |].\nright.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) (INB : E_t b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : (⦗eq b_t ∩₁ E_t'⦘ ⨾ (sb_t ∪ WCore.sb_delta e E_t)) b_t e.","proofString":"exists b_t.\nsplit; [basic_solver |].\nright.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) (INB : E_t b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗eq b_t ∩₁ E_t'⦘ b_t b_t /\\ (sb_t ∪ WCore.sb_delta e E_t) b_t e.","proofString":"split; [basic_solver |].\nright.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) (INB : E_t b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : (sb_t ∪ WCore.sb_delta e E_t) b_t e.","proofString":"right.\nbasic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t' b_t) (NINA' : ~ E_t' a_t) (INB : E_t b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : WCore.sb_delta e E_t b_t e.","proofString":"basic_solver."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t b_t) (NINA' : ~ E_t a_t) : False.","proofString":"apply rsr_Et_restr'; auto.\nset (APR := rsr_a_preserved).\nset (BPR := rsr_b_preserved).\ntauto."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t b_t) (NINA' : ~ E_t a_t) : E_t' b_t /\\ ~ E_t' a_t.","proofString":"set (APR := rsr_a_preserved).\nset (BPR := rsr_b_preserved).\ntauto."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t b_t) (NINA' : ~ E_t a_t) (APR : E_t' a_t <-> E_t a_t) : E_t' b_t /\\ ~ E_t' a_t.","proofString":"set (BPR := rsr_b_preserved).\ntauto."},{"statement":"(ETID : tid e = tid b_t) (INB' : E_t b_t) (NINA' : ~ E_t a_t) (APR : E_t' a_t <-> E_t a_t) (BPR : E_t' b_t <-> E_t b_t) : E_t' b_t /\\ ~ E_t' a_t.","proofString":"tauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ WCore.sb_delta e E_s.","proofString":"rewrite (rsr_actsE INV SIMREL).\narewrite (WCore.sb_delta e (E_t ∪₁ B_s) ≡    WCore.sb_delta e E_t ∪ (B_s ∩₁ same_tid e) × eq e  ).\nunfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA.\nrewrite id_union, !seq_union_l.\napply union_more; [apply (sb_deltaEE ADD') |].\nunfold extra_a.\ndesf; [| basic_solver].\nunfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗E_t ∪₁ B_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ WCore.sb_delta e (E_t ∪₁ B_s).","proofString":"arewrite (WCore.sb_delta e (E_t ∪₁ B_s) ≡    WCore.sb_delta e E_t ∪ (B_s ∩₁ same_tid e) × eq e  ).\nunfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA.\nrewrite id_union, !seq_union_l.\napply union_more; [apply (sb_deltaEE ADD') |].\nunfold extra_a.\ndesf; [| basic_solver].\nunfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : WCore.sb_delta e (E_t ∪₁ B_s)\n≡ WCore.sb_delta e E_t ∪ (B_s ∩₁ same_tid e) × eq e.","proofString":"unfold WCore.sb_delta.\nrewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : (is_init ∪₁ (E_t ∪₁ B_s) ∩₁ same_tid e) × eq e\n≡ (is_init ∪₁ E_t ∩₁ same_tid e) × eq e ∪ (B_s ∩₁ same_tid e) × eq e.","proofString":"rewrite set_inter_union_l, !cross_union_l.\nnow rewrite <- unionA."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : is_init × eq e ∪ ((E_t ∩₁ same_tid e) × eq e ∪ (B_s ∩₁ same_tid e) × eq e)\n≡ is_init × eq e ∪ (E_t ∩₁ same_tid e) × eq e ∪ (B_s ∩₁ same_tid e) × eq e.","proofString":"now rewrite <- unionA."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗E_t ∪₁ B_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n≡ WCore.sb_delta e E_t ∪ (B_s ∩₁ same_tid e) × eq e.","proofString":"rewrite id_union, !seq_union_l.\napply union_more; [apply (sb_deltaEE ADD') |].\nunfold extra_a.\ndesf; [| basic_solver].\nunfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗E_t⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ∪ ⦗B_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n≡ WCore.sb_delta e E_t ∪ (B_s ∩₁ same_tid e) × eq e.","proofString":"apply union_more; [apply (sb_deltaEE ADD') |].\nunfold extra_a.\ndesf; [| basic_solver].\nunfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗B_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ (B_s ∩₁ same_tid e) × eq e.","proofString":"unfold extra_a.\ndesf; [| basic_solver].\nunfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗ifP ~ E_t a_t /\\ E_t b_t then eq a_t else ∅⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n≡ ((ifP ~ E_t a_t /\\ E_t b_t then eq a_t else ∅) ∩₁ same_tid e) × eq e.","proofString":"desf; [| basic_solver].\nunfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ≡ (eq a_t ∩₁ same_tid e) × eq e.","proofString":"unfold same_tid.\nsplit.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n≡ (eq a_t ∩₁ (fun y : actid => tid e = tid y)) × eq e.","proofString":"split.\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm.\nunfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n⊆ (eq a_t ∩₁ (fun y : actid => tid e = tid y)) × eq e.","proofString":"unfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : forall x y : actid,\na_t = x /\\ ext_sb x y /\\ e = y -> (a_t = x /\\ tid e = tid x) /\\ e = y.","proofString":"intros x y (EQ1 & SB & EQ2).\nsubst x y.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (x y : actid) (EQ1 : a_t = x) (SB : ext_sb x y) (EQ2 : e = y) : (a_t = x /\\ tid e = tid x) /\\ e = y.","proofString":"subst x y.\nauto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (SB : ext_sb a_t e) : (a_t = a_t /\\ tid e = tid a_t) /\\ e = e.","proofString":"auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : (eq a_t ∩₁ (fun y : actid => tid e = tid y)) × eq e\n⊆ ⦗eq a_t⦘ ⨾ ext_sb ⨾ ⦗eq e⦘.","proofString":"unfolder.\nintros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : forall x y : actid,\n(a_t = x /\\ tid e = tid x) /\\ e = y -> a_t = x /\\ ext_sb x y /\\ e = y.","proofString":"intros x y ((EQ1 & TID) & EQ2).\nsubst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (x y : actid) (EQ1 : a_t = x) (TID : tid e = tid x) (EQ2 : e = y) : a_t = x /\\ ext_sb x y /\\ e = y.","proofString":"subst x y.\nexfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (TID : tid e = tid a_t) : a_t = a_t /\\ ext_sb a_t e /\\ e = e.","proofString":"exfalso.\napply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (TID : tid e = tid a_t) : False.","proofString":"apply rsr_Et_restr; [| desf].\nnow rewrite <- (rsr_at_bt_tid INV)."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (TID : tid e = tid a_t) : tid e = tid b_t.","proofString":"now rewrite <- (rsr_at_bt_tid INV)."},{"statement":"⦗E_s'⦘ ⨾ ext_sb ⨾ ⦗E_s'⦘ ≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"simpl.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite !id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\nrewrite (rsr_actsE INV SIMREL) at 2.\nrewrite !id_union, !seq_union_r.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"⦗E_s ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq e⦘ ≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite !id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\nrewrite (rsr_actsE INV SIMREL) at 2.\nrewrite !id_union, !seq_union_r.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗E_s ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E_s ∪₁ eq e⦘ ≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"rewrite !id_union, !seq_union_l, !seq_union_r.\nchange (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\nrewrite (rsr_actsE INV SIMREL) at 2.\nrewrite !id_union, !seq_union_r.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n∪ (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘)\n≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"change (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s.\nrewrite (rsr_actsE INV SIMREL) at 2.\nrewrite !id_union, !seq_union_r.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n∪ (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘)\n≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"rewrite (rsr_actsE INV SIMREL) at 2.\nrewrite !id_union, !seq_union_r.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n∪ (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E_t ∪₁ B_s⦘ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘)\n≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"rewrite !id_union, !seq_union_r.\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n∪ (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E_t⦘ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗B_s⦘\n   ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘) ≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"arewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘).\nenough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto.\nrewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ⊆ ∅₂.","proofString":"enough (~ext_sb e e) by basic_solver.\nintro FALSO; eapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ~ ext_sb e e.","proofString":"intro FALSO; eapply ext_sb_irr; eauto."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘\n∪ (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗E_t⦘ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗B_s⦘ ∪ ∅₂)\n≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"rewrite (sb_deltaEN ADD').\narewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ∪ (∅₂ ∪ ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗B_s⦘ ∪ ∅₂)\n≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"arewrite_false (⦗eq e⦘ ⨾ ext_sb ⨾ ⦗extra_a X_t a_t b_t a_t⦘).\nunfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm.\nnow rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗B_s⦘ ⊆ ∅₂.","proofString":"unfold extra_a; desf; [| basic_solver].\nunfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : ⦗eq e⦘ ⨾ ext_sb ⨾ ⦗eq a_t⦘ ⊆ ∅₂.","proofString":"unfolder.\nintros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) : forall x y : actid, e = x /\\ ext_sb x y /\\ a_t = y -> False.","proofString":"intros x y (EQ1 & SB & EQ2).\nsubst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (x y : actid) (EQ1 : e = x) (SB : ext_sb x y) (EQ2 : a_t = y) : False.","proofString":"subst x y.\napply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t /\\ E_t b_t) (SB : ext_sb e a_t) : False.","proofString":"apply rsr_Et_restr; desf.\nrewrite <- (rsr_at_bt_tid INV); auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) (a : ~ E_t a_t) (a0 : E_t b_t) (SB : ext_sb e a_t) : tid e = tid b_t.","proofString":"rewrite <- (rsr_at_bt_tid INV); auto with xmm."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : sb_s ∪ ⦗E_s⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ∪ (∅₂ ∪ ∅₂ ∪ ∅₂) ≡ sb_s ∪ WCore.sb_delta e E_s.","proofString":"now rewrite !union_false_r, rsr_new_e_sb_delta."},{"statement":"(TEQ : tid a_t = tid b_t) : mapper ↑ WCore.sb_delta e E_t ≡ WCore.sb_delta e E_s.","proofString":"assert (ANINI : ~is_init a_t) by apply INV.\nassert (BNINI : ~is_init b_t) by apply INV.\nunfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mappero; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) : mapper ↑ WCore.sb_delta e E_t ≡ WCore.sb_delta e E_s.","proofString":"assert (BNINI : ~is_init b_t) by apply INV.\nunfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mappero; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑ WCore.sb_delta e E_t ≡ WCore.sb_delta e E_s.","proofString":"unfold WCore.sb_delta.\nrewrite collect_rel_cross, set_collect_eq, rsr_mappero; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑ (is_init ∪₁ E_t ∩₁ same_tid e) × eq e\n≡ (is_init ∪₁ E_s ∩₁ same_tid e) × eq e.","proofString":"rewrite collect_rel_cross, set_collect_eq, rsr_mappero; auto.\nrewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (mapper ↑₁ (is_init ∪₁ E_t ∩₁ same_tid e)) × eq e\n≡ (is_init ∪₁ E_s ∩₁ same_tid e) × eq e.","proofString":"rewrite set_collect_union.\nrewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (mapper ↑₁ is_init ∪₁ mapper ↑₁ (E_t ∩₁ same_tid e)) × eq e\n≡ (is_init ∪₁ E_s ∩₁ same_tid e) × eq e.","proofString":"rewrite <- fixset_set_fixpoint by auto with xmm.\narewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : (is_init ∪₁ mapper ↑₁ (E_t ∩₁ same_tid e)) × eq e\n≡ (is_init ∪₁ E_s ∩₁ same_tid e) × eq e.","proofString":"arewrite (mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e)    ; [| reflexivity].\nrewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑₁ (E_t ∩₁ same_tid e) ≡₁ E_s ∩₁ same_tid e.","proofString":"rewrite (rsr_acts SIMREL), set_inter_union_l.\nrewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑₁ (E_t ∩₁ same_tid e)\n≡₁ mapper ↑₁ E_t ∩₁ same_tid e ∪₁ A_s ∩₁ same_tid e.","proofString":"rewrite rsr_mapper_sametid; auto.\narewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : mapper ↑₁ E_t ∩₁ same_tid e\n≡₁ mapper ↑₁ E_t ∩₁ same_tid e ∪₁ A_s ∩₁ same_tid e.","proofString":"arewrite (A_s ∩₁ same_tid e ≡₁ ∅); [| now rewrite set_union_empty_r].\nunfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) : A_s ∩₁ same_tid e ≡₁ ∅.","proofString":"unfold extra_a, same_tid; desf; [| basic_solver].\nsplit; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) (a : ~ E_t a_t /\\ E_t b_t) : eq b_t ∩₁ (fun y : actid => tid e = tid y) ≡₁ ∅.","proofString":"split; auto with hahn.\nunfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) (a : ~ E_t a_t /\\ E_t b_t) : eq b_t ∩₁ (fun y : actid => tid e = tid y) ⊆₁ ∅.","proofString":"unfolder.\nintros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) (a : ~ E_t a_t /\\ E_t b_t) : forall x : actid, b_t = x /\\ tid e = tid x -> False.","proofString":"intros x (XEQ & TID).\nsubst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) (a : ~ E_t a_t /\\ E_t b_t) (x : actid) (XEQ : b_t = x) (TID : tid e = tid x) : False.","proofString":"subst x.\napply rsr_Et_restr; auto; desf."},{"statement":"(TEQ : tid a_t = tid b_t) (ANINI : ~ is_init a_t) (BNINI : ~ is_init b_t) (a : ~ E_t a_t /\\ E_t b_t) (TID : tid e = tid b_t) : False.","proofString":"apply rsr_Et_restr; auto; desf."},{"statement":"(EIN : E_s e) : False.","proofString":"apply (rsr_actsE INV SIMREL) in EIN.\ndestruct EIN as [EINT | INB].\nnow apply rsr_e_notin.\nunfold extra_a in INB; desf."},{"statement":"(EIN : (E_t ∪₁ B_s) e) : False.","proofString":"destruct EIN as [EINT | INB].\nnow apply rsr_e_notin.\nunfold extra_a in INB; desf."},{"statement":"(EINT : E_t e) : False.","proofString":"now apply rsr_e_notin."},{"statement":"(INB : B_s e) : False.","proofString":"unfold extra_a in INB; desf."},{"statement":"~ E_s e.","proofString":"apply rsr_nanb_notin."},{"statement":"eq_dom E_t' lab_t' (lab_s' ∘ mapper).","proofString":"exact rsr_nanb_lab."},{"statement":"(NEQ : a_t <> b_t) : inj_dom E_t' mapper.","proofString":"eapply inj_dom_mori; auto with xmm.\nred; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) : flip set_subset ⊤₁ E_t'.","proofString":"red; auto with hahn."},{"statement":"(NOTIN : ~ E_s e) : srf_s' ⨾ ⦗E_s⦘ ≡ srf_s ⨾ ⦗E_s⦘.","proofString":"set (NOTIN' := rsr_nanb_notin').\napply (porf_pref_srf G_s G_s'); auto with xmm.\neapply G_s_wf with (X_t := X_t); eauto.\nins.\nauto with hahn.\nrewrite rsr_new_e_sb.\nclear - NOTIN.\nrewrite seq_union_l.\nbasic_solver.\nsimpl.\nclear - NOTIN'.\nbasic_solver.\nsimpl.\nclear - NOTIN NOTIN'.\nbasic_solver 7.\nsimpl.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (WCore.add_event_rmw ADD'), (rsr_rmw SIMREL).\nrewrite collect_rel_union.\nclear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : srf_s' ⨾ ⦗E_s⦘ ≡ srf_s ⨾ ⦗E_s⦘.","proofString":"apply (porf_pref_srf G_s G_s'); auto with xmm.\neapply G_s_wf with (X_t := X_t); eauto.\nins.\nauto with hahn.\nrewrite rsr_new_e_sb.\nclear - NOTIN.\nrewrite seq_union_l.\nbasic_solver.\nsimpl.\nclear - NOTIN'.\nbasic_solver.\nsimpl.\nclear - NOTIN NOTIN'.\nbasic_solver 7.\nsimpl.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (WCore.add_event_rmw ADD'), (rsr_rmw SIMREL).\nrewrite collect_rel_union.\nclear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : Wf G_s.","proofString":"eapply G_s_wf with (X_t := X_t); eauto."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : E_s ⊆₁ E_s'.","proofString":"ins.\nauto with hahn."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : E_s ⊆₁ E_s ∪₁ eq e.","proofString":"auto with hahn."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : sb_s' ⨾ ⦗E_s⦘ ≡ sb_s ⨾ ⦗E_s⦘.","proofString":"rewrite rsr_new_e_sb.\nclear - NOTIN.\nrewrite seq_union_l.\nbasic_solver."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : (sb_s ∪ WCore.sb_delta e E_s) ⨾ ⦗E_s⦘ ≡ sb_s ⨾ ⦗E_s⦘.","proofString":"clear - NOTIN.\nrewrite seq_union_l.\nbasic_solver."},{"statement":"(NOTIN : ~ E_s e) : (sb_s ∪ WCore.sb_delta e E_s) ⨾ ⦗E_s⦘ ≡ sb_s ⨾ ⦗E_s⦘.","proofString":"rewrite seq_union_l.\nbasic_solver."},{"statement":"(NOTIN : ~ E_s e) : sb_s ⨾ ⦗E_s⦘ ∪ WCore.sb_delta e E_s ⨾ ⦗E_s⦘ ≡ sb_s ⨾ ⦗E_s⦘.","proofString":"basic_solver."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : rf_s' ⨾ ⦗E_s⦘ ≡ rf_s ⨾ ⦗E_s⦘.","proofString":"simpl.\nclear - NOTIN'.\nbasic_solver."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : (rf_s ∪ mapper ↑ (rf_t' ⨾ ⦗eq e⦘)) ⨾ ⦗E_s⦘ ≡ rf_s ⨾ ⦗E_s⦘.","proofString":"clear - NOTIN'.\nbasic_solver."},{"statement":"(NOTIN' : ~ E_s (mapper e)) : (rf_s ∪ mapper ↑ (rf_t' ⨾ ⦗eq e⦘)) ⨾ ⦗E_s⦘ ≡ rf_s ⨾ ⦗E_s⦘.","proofString":"basic_solver."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : ⦗E_s⦘ ⨾ co_s' ⨾ ⦗E_s⦘ ≡ ⦗E_s⦘ ⨾ co_s ⨾ ⦗E_s⦘.","proofString":"simpl.\nclear - NOTIN NOTIN'.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : ⦗E_s⦘\n⨾ (co_s ∪ mapper ↑ (⦗eq e⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq e⦘)\n   ∪ add_max (eq e ∩₁ WCore.lab_is_w l)\n       (A_s' ∩₁ W_s ∩₁ Loc_s_ (WCore.lab_loc l))) ⨾ ⦗E_s⦘\n≡ ⦗E_s⦘ ⨾ co_s ⨾ ⦗E_s⦘.","proofString":"clear - NOTIN NOTIN'.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : ⦗E_s⦘\n⨾ (co_s ∪ mapper ↑ (⦗eq e⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq e⦘)\n   ∪ add_max (eq e ∩₁ WCore.lab_is_w l)\n       (A_s' ∩₁ W_s ∩₁ Loc_s_ (WCore.lab_loc l))) ⨾ ⦗E_s⦘\n≡ ⦗E_s⦘ ⨾ co_s ⨾ ⦗E_s⦘.","proofString":"basic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : rmw_s' ⨾ ⦗E_s⦘ ≡ rmw_s ⨾ ⦗E_s⦘.","proofString":"simpl.\ndestruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (WCore.add_event_rmw ADD'), (rsr_rmw SIMREL).\nrewrite collect_rel_union.\nclear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) : mapper ↑ rmw_t' ⨾ ⦗E_s⦘ ≡ rmw_s ⨾ ⦗E_s⦘.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nrewrite (WCore.add_event_rmw ADD'), (rsr_rmw SIMREL).\nrewrite collect_rel_union.\nclear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : mapper ↑ rmw_t' ⨾ ⦗E_s⦘ ≡ rmw_s ⨾ ⦗E_s⦘.","proofString":"rewrite (WCore.add_event_rmw ADD'), (rsr_rmw SIMREL).\nrewrite collect_rel_union.\nclear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : mapper ↑ (rmw_t ∪ WCore.rmw_delta e r) ⨾ ⦗E_s⦘ ≡ mapper ↑ rmw_t ⨾ ⦗E_s⦘.","proofString":"rewrite collect_rel_union.\nclear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' e l r R1 w W1 W2) : (mapper ↑ rmw_t ∪ mapper ↑ WCore.rmw_delta e r) ⨾ ⦗E_s⦘\n≡ mapper ↑ rmw_t ⨾ ⦗E_s⦘.","proofString":"clear - NOTIN' NOTIN.\nbasic_solver 7."},{"statement":"(NOTIN : ~ E_s e) (NOTIN' : ~ E_s (mapper e)) (r : option actid) : (mapper ↑ rmw_t ∪ mapper ↑ WCore.rmw_delta e r) ⨾ ⦗E_s⦘\n≡ mapper ↑ rmw_t ⨾ ⦗E_s⦘.","proofString":"basic_solver 7."},{"statement":"srf_s' ⨾ ⦗A_s⦘ ≡ srf_s ⨾ ⦗A_s⦘.","proofString":"arewrite (A_s ≡₁ E_s ∩₁ A_s).\nrewrite set_inter_absorb_l; [reflexivity |].\nrewrite (rsr_acts SIMREL).\nauto with hahn.\nrewrite id_inter.\nseq_rewrite rsr_nanb_samesrf_helper.\nnow rewrite seqA."},{"statement":"A_s ≡₁ E_s ∩₁ A_s.","proofString":"rewrite set_inter_absorb_l; [reflexivity |].\nrewrite (rsr_acts SIMREL).\nauto with hahn."},{"statement":"A_s ⊆₁ E_s.","proofString":"rewrite (rsr_acts SIMREL).\nauto with hahn."},{"statement":"A_s ⊆₁ mapper ↑₁ E_t ∪₁ A_s.","proofString":"auto with hahn."},{"statement":"srf_s' ⨾ ⦗E_s ∩₁ A_s⦘ ≡ srf_s ⨾ ⦗E_s ∩₁ A_s⦘.","proofString":"rewrite id_inter.\nseq_rewrite rsr_nanb_samesrf_helper.\nnow rewrite seqA."},{"statement":"srf_s' ⨾ ⦗E_s⦘ ⨾ ⦗A_s⦘ ≡ srf_s ⨾ ⦗E_s⦘ ⨾ ⦗A_s⦘.","proofString":"seq_rewrite rsr_nanb_samesrf_helper.\nnow rewrite seqA."},{"statement":"(srf_s ⨾ ⦗E_s⦘) ⨾ ⦗A_s⦘ ≡ srf_s ⨾ ⦗E_s⦘ ⨾ ⦗A_s⦘.","proofString":"now rewrite seqA."}]}