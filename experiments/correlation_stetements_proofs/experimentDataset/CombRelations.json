[{"statement":"Lemma wf_urrD l: urr l ≡ ⦗W_ l⦘ ⨾ urr l.","proof":"split; [|basic_solver].\nunfold urr; rels.\n"},{"statement":"Lemma wf_c_relD i l l' codom: c_rel i l l' codom ≡ \n  ⦗W_ l⦘ ⨾ c_rel i l l' codom ⨾  ⦗ Rel ∩₁ (W_ l' ∪₁ F) ∩₁(Tid_ i ∪₁ Init) ∩₁ codom ⦘.","proof":"split; [|basic_solver].\nunfold c_rel.\nrewrite wf_urrD.\nbasic_solver 21.\n"},{"statement":"Lemma wf_c_curD i l codom: c_cur i l codom ≡ \n  ⦗W_ l⦘ ⨾ c_cur i l codom ⨾   ⦗ (Tid_ i ∪₁ Init) ∩₁ codom ⦘.","proof":"split; [|basic_solver].\nunfold c_cur.\nrewrite wf_urrD.\nbasic_solver 21.\n"},{"statement":"Lemma wf_c_acqD i l codom: c_acq i l codom ≡ \n  ⦗W_ l⦘ ⨾ c_acq i l codom ⨾  ⦗ (Tid_ i ∪₁ Init) ∩₁ codom ⦘.","proof":"split; [|basic_solver].\nunfold c_acq.\nrewrite wf_urrD.\nbasic_solver 21.\n"},{"statement":"Lemma wf_S_tmrD l codom: S_tmr l codom ≡ \n  ⦗W_ l⦘ ⨾ S_tmr l codom ⨾ ⦗ F ∩₁ Sc ∩₁ codom ⦘.","proof":"split; [|basic_solver].\nunfold S_tmr.\nbasic_solver 21.\n"},{"statement":"Lemma wf_t_relD i l l' codom : t_rel i l l' codom ⊆₁ W_ l.","proof":"unfold t_rel.\nrewrite (wf_c_relD i l l' codom).\nbasic_solver 21.\n"},{"statement":"Lemma wf_t_curD i l codom : t_cur i l codom ⊆₁ W_ l.","proof":"unfold t_cur.\nrewrite (wf_c_curD i l codom).\nbasic_solver 21.\n"},{"statement":"Lemma wf_t_acqD i l codom : t_acq i l codom ⊆₁ W_ l.","proof":"unfold t_acq.\nrewrite (wf_c_acqD i l codom).\nbasic_solver 21.\n"},{"statement":"Lemma t_rel_urr_doma l' l a i C (T : t_rel i l l' C a) : W_ l a.","proof":"apply (@wf_t_relD i l l' C) in T.\nrevert T; basic_solver 21.\n"},{"statement":"Lemma urr_codom_n_init l WF WF_SC: urr l ⨾ ⦗ Init ⦘ ⊆ ⦗ Init ⦘.","proof":"unfold urr.\nrewrite (no_hb_to_init WF), (no_sc_to_init WF WF_SC), (no_rf_to_init WF).\nunfolder; ins; desf; eauto.\n"},{"statement":"Lemma urr_refl l : ⦗ W_ l ⦘ ⊆ urr l.","proof":"unfold urr; basic_solver 21.\n"},{"statement":"Lemma urr_hb l : urr l ⨾ hb^? ⊆ urr l.","proof":"unfold urr; generalize (@hb_trans G); basic_solver 21.\n"},{"statement":"Lemma urr_hb' l : urr l ⨾ hb ⊆ urr l.","proof":"unfold urr; generalize (@hb_trans G); basic_solver 21.\n"},{"statement":"Lemma hb_in_urr l : ⦗ W_ l ⦘ ⨾ hb^? ⊆ urr l.","proof":"unfold urr; basic_solver 42.\n"},{"statement":"Lemma urr_f_sc WF WF_SC ACYC_EXT l : urr l ⨾ ⦗ F∩₁Sc ⦘ ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?.","proof":"unfold urr; rewrite !seqA.\ndo 2 hahn_frame_l.\nrewrite (crE sc) at 1; relsf; unionL.\nby generalize (@hb_trans G); basic_solver 21.\nrewrite (crE hb); relsf; unionL; [basic_solver 12|].\nrewrite (dom_r (wf_scD WF_SC)), !seqA.\nrewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ngeneralize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21.\n"},{"statement":"Lemma urr_f_non_sc WF WF_SC l : urr l ⨾ ⦗ F∩₁set_compl Sc ⦘ ⊆ urr l ⨾ (release ⨾ rf)^? ⨾ sb.","proof":"unfold urr; rewrite !seqA.\n- case_refl hb.\n* rewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver 16.\n* do 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nunfold imm_s_hb.sw at 2.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36.\n"},{"statement":"Lemma urr_f_non_acq WF WF_SC l : urr l ⨾ ⦗ F∩₁set_compl Acq ⦘ ⊆ urr l ⨾ sb.","proof":"unfold urr; rewrite !seqA.\n- case_refl hb.\n* rewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\nmode_solver 16.\n* do 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nrewrite (dom_r (wf_swD WF)).\ntype_solver.\n"},{"statement":"Lemma urr_w WF WF_SC l : urr l ⨾ ⦗ W ⦘ ≡ urr l ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘.","proof":"unfold urr; rewrite !seqA.\nsplit.\n- case_refl hb.\n* unionR right.\nrewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver.\n* unionR left.\ndo 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver.\n- rewrite sb_in_hb.\ngeneralize (@hb_trans G); ins; relsf.\nbasic_solver 21.\n"},{"statement":"Lemma urr_non_f WF WF_SC l : urr l ⨾ ⦗ set_compl F ⦘ ⊆ urr l ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗ Acq ⦘.","proof":"unfold urr; rewrite !seqA.\ncase_refl hb.\n- arewrite (sc^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby rewrite (dom_r (wf_scD WF_SC)); basic_solver.\narewrite ((hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby basic_solver.\nbasic_solver 12.\n- unfold imm_s_hb.hb.\nrewrite ct_end at 2; relsf.\nunionL.\nbasic_solver 21.\nunfold imm_s_hb.sw at 3; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21.\n"},{"statement":"Lemma msg_rel_urr WF l : msg_rel l ⨾ rf ⨾ ⦗ Acq ⦘ ⊆ urr l.","proof":"unfold msg_rel.\nrewrite seqA, (release_rf_in_sw WF), sw_in_hb.\narewrite (hb ⊆ hb^?); apply urr_hb.\n"},{"statement":"Lemma t_cur_in_t_acq i l codom:\n  t_cur i l codom ⊆₁ t_acq i l codom.","proof":"unfold t_cur, t_acq, c_cur, c_acq.\nbasic_solver 21.\n"},{"statement":"Lemma t_rel_in_t_cur i l l' codom:\n  t_rel i l l' codom ⊆₁ t_cur i l codom.","proof":"unfold t_rel, t_cur, c_rel, c_cur.\nbasic_solver 21.\n"},{"statement":"Lemma t_rel_in_t_acq i l l' codom:\n  t_rel i l l' codom ⊆₁ t_acq i l codom.","proof":"unfold t_rel, t_acq, c_rel, c_acq.\nbasic_solver 21.\n"},{"statement":"Lemma eco_urr_irr l WF WF_SC CSC COH: irreflexive (eco ⨾ urr l).","proof":"unfold urr.\narewrite_id ⦗W_ l⦘.\narewrite_id ⦗F ∩₁ Sc⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\n- generalize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\n- rewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21.\n"},{"statement":"Lemma transp_rf_co_urr_irr l WF WF_SC CSC COH: irreflexive (rf^{-1} ^? ⨾ co ⨾ urr l).","proof":"arewrite ((rf⁻¹)^? ⨾ co ⊆ eco).\nby unfold Execution_eco.eco, Execution.fr; basic_solver 21.\neby apply eco_urr_irr.\n"},{"statement":"Lemma release_co_urr_irr l WF WF_SC COMP CSC COH: irreflexive (release ⨾ co ⨾ urr l).","proof":"rewrite release_in_hb_co; auto.\n2: by apply coherence_sc_per_loc, COH.\nrewrite seqA.\narewrite (co^? ⨾ co ⊆ co) by generalize (co_trans WF); basic_solver.\nrotate 1.\nsin_rewrite urr_hb.\narewrite (co ⊆ eco).\nby unfold Execution_eco.eco, Execution.fr; basic_solver 21.\nby rotate 1; apply eco_urr_irr.\n"},{"statement":"Lemma sb_transp_rf_co_urr_irr l WF WF_SC CSC COH: irreflexive (sb ⨾ rf^{-1} ^? ⨾ co ⨾ urr l).","proof":"rotate 1.\nrewrite sb_in_hb.\narewrite (hb ⊆ hb^?).\nsin_rewrite urr_hb.\nby rotate 2; apply transp_rf_co_urr_irr.\n"},{"statement":"Lemma urr_hb_irr l WF WF_SC CSC COH ACYC_EXT: irreflexive (urr l ⨾ hb).","proof":"unfold urr.\narewrite_id ⦗W_ l⦘.\narewrite_id ⦗F ∩₁ Sc⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\n- by rotate 1; apply COH.\n- rewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\n* rotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\n* rewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21.\n"},{"statement":"Lemma c_cur_union thread l A B:\n  c_cur thread l (A ∪₁ B) ≡ c_cur thread l A ∪ c_cur thread l B.","proof":"unfold c_cur; basic_solver 21.\n"},{"statement":"Lemma t_cur_union thread l A B:\n  t_cur thread l (A ∪₁ B) ≡₁ t_cur thread l A ∪₁ t_cur thread l B.","proof":"unfold t_cur; rewrite c_cur_union; basic_solver 21.\n"},{"statement":"Lemma c_acq_union thread l A B:\n  c_acq thread l (A ∪₁ B) ≡ c_acq thread l A ∪ c_acq thread l B.","proof":"unfold c_acq; basic_solver 21.\n"},{"statement":"Lemma t_acq_union thread l A B:\n  t_acq thread l (A ∪₁ B) ≡₁ t_acq thread l A ∪₁ t_acq thread l B.","proof":"unfold t_acq; rewrite c_acq_union; basic_solver 21.\n"},{"statement":"Lemma c_rel_union thread l l' A B:\n  c_rel thread l l' (A ∪₁ B) ≡ c_rel thread l l' A ∪ c_rel thread l l' B.","proof":"unfold c_rel; basic_solver 21.\n"},{"statement":"Lemma t_rel_union thread l l' A B:\n  t_rel thread l l' (A ∪₁ B) ≡₁ t_rel thread l l' A ∪₁ t_rel thread l l' B.","proof":"unfold t_rel; rewrite c_rel_union; basic_solver 21.\n"},{"statement":"Lemma s_tmr_union l A B:\n  S_tmr l (A ∪₁ B) ≡ S_tmr l A ∪ S_tmr l B.","proof":"unfold S_tmr; basic_solver 21.\n"},{"statement":"Lemma s_tm_union l A B:\n  S_tm l (A ∪₁ B) ≡₁ S_tm l A ∪₁ S_tm l B.","proof":"unfold S_tm; rewrite s_tmr_union; basic_solver.\n"},{"statement":"Lemma wf_urrE WF WF_SC l: urr l ≡ ⦗ W_ l ⦘ ∪ ⦗ E ⦘ ⨾ urr l ⨾ ⦗ E ⦘.","proof":"split.\n- unfold urr.\nrewrite (wf_rfE WF) at 1.\nrewrite (wf_hbE WF) at 1 2.\nrewrite (wf_scE WF_SC) at 1.\nbasic_solver 21.\n- unionL; [|basic_solver].\nunfold urr; basic_solver 12.\n"},{"statement":"Lemma wf_c_curE WF WF_SC i l codom (IN: codom ⊆₁ E): \n  c_cur i l codom ≡ ⦗ E ⦘ ⨾ c_cur i l codom ⨾ ⦗ E ⦘.","proof":"split; [|basic_solver].\nunfold c_cur.\nrewrite (wf_urrE WF WF_SC l).\ngeneralize IN.\nbasic_solver 21.\n"},{"statement":"Lemma wf_t_curE WF WF_SC i l codom (IN: codom ⊆₁ E): \n  t_cur i l codom ⊆₁ E.","proof":"unfold t_cur.\nrewrite (wf_c_curE WF WF_SC i l IN).\nbasic_solver 21.\n"},{"statement":"Lemma t_cur_other_thread\n      C C' thread l\n      (CINIT  : Init ∩₁ E ⊆₁ C)\n      (CINCL : C ⊆₁ C')\n      (CE : C' ⊆₁ E)\n      (COVSTEP : forall a, tid a = thread -> C' a -> C a) :\n      t_cur thread l C' ≡₁ t_cur thread l C.","proof":"unfold t_cur, c_cur.\nrewrite <- !id_inter.\nrewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\n{\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\n}\nbasic_solver 21.\n"},{"statement":"Lemma t_acq_other_thread\n      C C' thread l\n      (CINIT : Init ∩₁ E ⊆₁ C)\n      (CINCL : C ⊆₁ C')\n      (CE : C' ⊆₁ E)\n      (COVSTEP : forall a, tid a = thread -> C' a -> C a) :\n      t_acq thread l C' ≡₁ t_acq thread l C.","proof":"unfold t_acq, c_acq.\nrewrite <- !id_inter.\nrewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\n{\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\n}\nbasic_solver 21.\n"},{"statement":"Lemma t_rel_other_thread\n      C C' thread l l'\n      (CINIT : Init ∩₁ E ⊆₁ C)\n      (CINCL : C ⊆₁ C')\n      (CE : C' ⊆₁ E)\n      (COVSTEP : forall a, tid a = thread -> C' a -> C a) :\n      t_rel thread l l' C ≡₁ t_rel thread l l' C'.","proof":"unfold t_rel, c_rel.\nrewrite <- !id_inter.\nrewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\n{\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\n}\nbasic_solver 21.\n"},{"statement":"Lemma s_tmr_helper l codom WF: \n  S_tmr l codom ≡ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proof":"unfold S_tmr.\nsplit.\n- unfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf.\nunionL; [basic_solver 21|].\nunfold imm_s_hb.sw at 2; rewrite !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42.\n- arewrite_id ⦗F ∩₁ Sc⦘ at 1.\ngeneralize (@hb_trans G); ins; relsf.\ncase_refl (release ⨾ rf).\n* rewrite (sb_in_hb); relsf.\n* arewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf.\n"},{"statement":"Lemma urr_to_ninit l WF WF_SC:\n  urr l ≡ urr l ⨾ ⦗set_compl is_init⦘ ∪ ⦗Loc_ l ∩₁ is_init⦘.","proof":"rewrite <- seq_id_r with (r := urr l) at 1.\nrewrite set_split_complete with (s' := set_full) (s := is_init), !set_inter_full_l.\nrewrite id_union, seq_union_r.\nrewrite unionC.\napply union_more; [done| ].\nunfold urr.\nassert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20.\n"},{"statement":"Lemma furr_bunion:\n  furr ≡ ⋃ l, urr l.","proof":"unfold furr.\nbasic_solver.\n"},{"statement":"Lemma furr_to_ninit WF WF_SC:\n  furr ≡ furr ⨾ ⦗set_compl is_init⦘ ∪ ⦗is_init⦘.","proof":"rewrite furr_bunion.\nrewrite set_bunion_separation with (S := is_init) (fab := loc) at 2.\narewrite ((fun (_: option location) => True) ≡₁ (⋃₁ l, eq (Some l)) ∪₁ eq None).\n{\nunfolder.\nsplit; ins; destruct x; vauto.\n}\nrewrite set_bunion_union_l.\nrewrite set_bunion_bunion_l.\nerewrite eqv_rel_more with (x := _ ∪₁ _).\n2: {\napply set_equiv_union with (t' := ∅); [reflexivity| ].\nsplit; [| basic_solver].\nunfolder.\nins.\ndesc.\nsubst.\nedestruct is_w_loc; eauto.\n{\neapply init_w; eauto.\n}\nvauto.\n}\nrewrite set_union_empty_r.\nrewrite <- bunion_set_bunion, seq_bunion_l.\nrewrite <- bunion_union_r.\napply bunion_more_equiv; [done| ].\nintros l _.\nrewrite set_bunion_eq.\nrewrite urr_to_ninit at 1; auto.\nbasic_solver.\n"},{"statement":"Lemma wf_furrE WF WF_SC: furr ≡ ⦗ W ⦘ ∪ ⦗ E ⦘ ⨾ furr ⨾ ⦗ E ⦘.","proof":"unfold furr; unfolder; ins; desf.\nsplit; ins; desf; eauto.\napply (wf_urrE WF WF_SC) in H.\nunfolder in H; desf; splits; eauto.\nforward (apply is_w_loc); ins; desf; eauto.\nunfold urr; basic_solver 21.\n"},{"statement":"Lemma rf_in_furr WF : rf ⊆ furr.","proof":"unfold furr, urr.\ndo 2 rewrite (dom_l (wf_rfD WF)).\nunfolder; ins; desc.\napply is_w_loc in H1; desf.\nbasic_solver 21.\n"},{"statement":"Lemma eco_furr_irr WF WF_SC CSC COH : irreflexive (eco ⨾ furr).","proof":"unfold furr.\nunfolder; ins; desf.\neapply eco_urr_irr; basic_solver.\n"},{"statement":"Lemma urr_alt l WF_SC : urr l ≡ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proof":"unfold urr.\nsplit.\narewrite_id ⦗F ∩₁ Sc⦘; rels.\ncase_refl sc.\ngeneralize (@hb_trans G); basic_solver 21.\nrewrite (dom_l (wf_scD WF_SC)); basic_solver 21.\n"},{"statement":"Lemma furr_alt WF_SC : furr ≡ ⦗W⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proof":"unfold furr; split; red; ins; desf.\napply (urr_alt l WF_SC) in H; unfolder in *; basic_solver 21.\nunfolder in H; desc.\nforward (apply is_w_loc); try edone.\nins; desc.\nexists l.\napply (urr_alt l WF_SC).\nbasic_solver 21.\n"},{"statement":"Lemma urr_hb_sc_hb l  WF WF_SC ACYC_EXT : urr l ⨾ hb ⨾ sc^? ⨾ hb^? ⊆ urr l.","proof":"rewrite (urr_alt l WF_SC), !seqA.\ncase_refl sc.\ngeneralize (@hb_trans G); basic_solver 21.\ncase_refl (sc).\ngeneralize (@hb_trans G); basic_solver 21.\nrewrite (dom_l (wf_scD WF_SC)) at 2.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ urr l).\nrewrite (urr_alt l WF_SC).\ngeneralize (@hb_trans G); basic_solver 21.\nsin_rewrite (urr_f_sc WF WF_SC ACYC_EXT).\nrewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21.\n"},{"statement":"Lemma furr_hb_sc_hb  WF WF_SC ACYC_EXT : furr ⨾ hb ⨾ sc^? ⨾ hb^? ⊆ furr.","proof":"unfold furr; red; ins; desf.\nunfolder in *; desc.\nexists l.\napply (urr_hb_sc_hb WF WF_SC ACYC_EXT).\nbasic_solver 21.\n"},{"statement":"Lemma urr_hb_sc_hb_irr WF WF_SC CSC COH ACYC_EXT l: \n  irreflexive (urr l ⨾ hb ⨾ (sc ⨾ hb)^?).","proof":"case_refl _.\napply (urr_hb_irr WF WF_SC CSC COH ACYC_EXT).\narewrite (urr l ⨾ hb ⨾ sc ⊆ urr l).\ngeneralize (@urr_hb_sc_hb l WF WF_SC ACYC_EXT); basic_solver 21.\napply (urr_hb_irr WF WF_SC CSC COH ACYC_EXT).\n"},{"statement":"Lemma furr_hb_sc_hb_irr WF WF_SC CSC COH ACYC_EXT : \n  irreflexive (furr ⨾ hb ⨾ (sc ⨾ hb)^?).","proof":"unfold furr; unfolder; ins; desc.\neapply urr_hb_sc_hb_irr; eauto.\nbasic_solver 21.\n"}]