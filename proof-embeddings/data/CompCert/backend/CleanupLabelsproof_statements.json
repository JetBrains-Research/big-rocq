{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/CleanupLabelsproof.v","fileSamples":[{"statement":"(p : program) : match_prog p (transf_program p).","proofString":"eapply match_transform_program; eauto."},{"statement":"(f : fundef) : funsig (transf_fundef f) = funsig f.","proofString":"destruct f; reflexivity."},{"statement":"(m : mreg) (ls : locset) (f : fundef) (H : Genv.find_funct ge (ls (R m)) = Some f) : Genv.find_funct tge (ls (R m)) = Some (transf_fundef f).","proofString":"apply functions_translated; auto."},{"statement":"(i : ident) (ls : locset) (f : fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : match Genv.find_symbol tge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef f).","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i).\napply function_ptr_translated; auto.\ncongruence."},{"statement":"(i : ident) (ls : locset) (f : fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef f).","proofString":"destruct (Genv.find_symbol ge i).\napply function_ptr_translated; auto.\ncongruence."},{"statement":"(i : ident) (ls : locset) (f : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f) : Genv.find_funct_ptr tge b = Some (transf_fundef f).","proofString":"apply function_ptr_translated; auto."},{"statement":"(i : ident) (ls : locset) (f : fundef) (H : None = Some f) : None = Some (transf_fundef f).","proofString":"congruence."},{"statement":"(ls : Labelset.t) (l : label) (a : Labelset.elt) (H : Labelset.In a ls) : Labelset.In a (Labelset.add l ls).","proofString":"apply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (c : condition) (l : list mreg) (l0 : label) (a : Labelset.elt) (H : Labelset.In a ls) : Labelset.In a (Labelset.add l0 ls).","proofString":"apply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (l : list label) (a : Labelset.elt) (H : Labelset.In a ls) : Labelset.In a (fold_right Labelset.add ls l).","proofString":"revert H; induction l; simpl.\nauto.\nintros; apply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (a : Labelset.elt) : Labelset.In a ls -> Labelset.In a ls.","proofString":"auto."},{"statement":"(ls : Labelset.t) (m : mreg) (a0 : label) (l : list label) (a : Labelset.elt) (IHl : Labelset.In a ls -> Labelset.In a (fold_right Labelset.add ls l)) : Labelset.In a ls ->\nLabelset.In a (Labelset.add a0 (fold_right Labelset.add ls l)).","proofString":"intros; apply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (l lbl : label) (H : lbl = l) : Labelset.In lbl (Labelset.add l ls).","proofString":"apply Labelset.add_1; auto."},{"statement":"(ls : Labelset.t) (c : condition) (l : list mreg) (l0 lbl : label) (H : lbl = l0) : Labelset.In lbl (Labelset.add l0 ls).","proofString":"apply Labelset.add_1; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (l : list label) (lbl : label) (H : In lbl l) : Labelset.In lbl (fold_right Labelset.add ls l).","proofString":"revert H.\ninduction l; simpl; intros.\ncontradiction.\ndestruct H.\napply Labelset.add_1; auto.\napply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (l : list label) (lbl : label) : In lbl l -> Labelset.In lbl (fold_right Labelset.add ls l).","proofString":"induction l; simpl; intros.\ncontradiction.\ndestruct H.\napply Labelset.add_1; auto.\napply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (lbl : label) (H : False) : Labelset.In lbl ls.","proofString":"contradiction."},{"statement":"(ls : Labelset.t) (m : mreg) (a : label) (l : list label) (lbl : label) (IHl : In lbl l -> Labelset.In lbl (fold_right Labelset.add ls l)) (H : a = lbl \\/ In lbl l) : Labelset.In lbl (Labelset.add a (fold_right Labelset.add ls l)).","proofString":"destruct H.\napply Labelset.add_1; auto.\napply Labelset.add_2; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (a : label) (l : list label) (lbl : label) (IHl : In lbl l -> Labelset.In lbl (fold_right Labelset.add ls l)) (H : a = lbl) : Labelset.In lbl (Labelset.add a (fold_right Labelset.add ls l)).","proofString":"apply Labelset.add_1; auto."},{"statement":"(ls : Labelset.t) (m : mreg) (a : label) (l : list label) (lbl : label) (IHl : In lbl l -> Labelset.In lbl (fold_right Labelset.add ls l)) (H : In lbl l) : Labelset.In lbl (Labelset.add a (fold_right Labelset.add ls l)).","proofString":"apply Labelset.add_2; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) : Labelset.In lbl (labels_branched_to c).","proofString":"assert (forall c' bto,             Labelset.Subset bto (fold_left add_label_branched_to c' bto)).\ninduction c'; intros; simpl; red; intros.\nauto.\napply IHc'.\napply add_label_branched_to_incr; auto.\nassert (forall c' bto,             In i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto)).\ninduction c'; simpl; intros.\ncontradiction.\ndestruct H2.\nsubst a.\napply H1.\napply add_label_branched_to_contains; auto.\napply IHc'; auto.\nunfold labels_branched_to.\nauto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) : forall (c' : list instruction) (bto : Labelset.t),\nLabelset.Subset bto (fold_left add_label_branched_to c' bto).","proofString":"induction c'; intros; simpl; red; intros.\nauto.\napply IHc'.\napply add_label_branched_to_incr; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (bto : Labelset.t) (a : Labelset.elt) (H1 : Labelset.In a bto) : Labelset.In a bto.","proofString":"auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (a : instruction) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nLabelset.Subset bto0 (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) (a0 : Labelset.elt) (H1 : Labelset.In a0 bto) : Labelset.In a0\n  (fold_left add_label_branched_to c' (add_label_branched_to bto a)).","proofString":"apply IHc'.\napply add_label_branched_to_incr; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (a : instruction) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nLabelset.Subset bto0 (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) (a0 : Labelset.elt) (H1 : Labelset.In a0 bto) : Labelset.In a0 (add_label_branched_to bto a).","proofString":"apply add_label_branched_to_incr; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c' : list instruction) (bto : Labelset.t),\nLabelset.Subset bto (fold_left add_label_branched_to c' bto)) : Labelset.In lbl (labels_branched_to c).","proofString":"assert (forall c' bto,             In i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto)).\ninduction c'; simpl; intros.\ncontradiction.\ndestruct H2.\nsubst a.\napply H1.\napply add_label_branched_to_contains; auto.\napply IHc'; auto.\nunfold labels_branched_to.\nauto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c' : list instruction) (bto : Labelset.t),\nLabelset.Subset bto (fold_left add_label_branched_to c' bto)) : forall (c' : list instruction) (bto : Labelset.t),\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto).","proofString":"induction c'; simpl; intros.\ncontradiction.\ndestruct H2.\nsubst a.\napply H1.\napply add_label_branched_to_contains; auto.\napply IHc'; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c' : list instruction) (bto0 : Labelset.t),\nLabelset.Subset bto0 (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) (H2 : False) : Labelset.In lbl bto.","proofString":"contradiction."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c'0 : list instruction) (bto0 : Labelset.t),\nLabelset.Subset bto0 (fold_left add_label_branched_to c'0 bto0)) (a : instruction) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) (H2 : a = i \\/ In i c') : Labelset.In lbl\n  (fold_left add_label_branched_to c' (add_label_branched_to bto a)).","proofString":"destruct H2.\nsubst a.\napply H1.\napply add_label_branched_to_contains; auto.\napply IHc'; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c'0 : list instruction) (bto0 : Labelset.t),\nLabelset.Subset bto0 (fold_left add_label_branched_to c'0 bto0)) (a : instruction) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) (H2 : a = i) : Labelset.In lbl\n  (fold_left add_label_branched_to c' (add_label_branched_to bto a)).","proofString":"subst a.\napply H1.\napply add_label_branched_to_contains; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c'0 : list instruction) (bto0 : Labelset.t),\nLabelset.Subset bto0 (fold_left add_label_branched_to c'0 bto0)) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) : Labelset.In lbl\n  (fold_left add_label_branched_to c' (add_label_branched_to bto i)).","proofString":"apply H1.\napply add_label_branched_to_contains; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c'0 : list instruction) (bto0 : Labelset.t),\nLabelset.Subset bto0 (fold_left add_label_branched_to c'0 bto0)) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) : Labelset.In lbl (add_label_branched_to bto i).","proofString":"apply add_label_branched_to_contains; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c'0 : list instruction) (bto0 : Labelset.t),\nLabelset.Subset bto0 (fold_left add_label_branched_to c'0 bto0)) (a : instruction) (c' : list instruction) (IHc' : forall bto0 : Labelset.t,\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto0)) (bto : Labelset.t) (H2 : In i c') : Labelset.In lbl\n  (fold_left add_label_branched_to c' (add_label_branched_to bto a)).","proofString":"apply IHc'; auto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c' : list instruction) (bto : Labelset.t),\nLabelset.Subset bto (fold_left add_label_branched_to c' bto)) (H2 : forall (c' : list instruction) (bto : Labelset.t),\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto)) : Labelset.In lbl (labels_branched_to c).","proofString":"unfold labels_branched_to.\nauto."},{"statement":"(c : list instruction) (i : instruction) (lbl : label) (H : In i c) (H0 : instr_branches_to i lbl) (H1 : forall (c' : list instruction) (bto : Labelset.t),\nLabelset.Subset bto (fold_left add_label_branched_to c' bto)) (H2 : forall (c' : list instruction) (bto : Labelset.t),\nIn i c' -> Labelset.In lbl (fold_left add_label_branched_to c' bto)) : Labelset.In lbl (fold_left add_label_branched_to c Labelset.empty).","proofString":"auto."},{"statement":"(bto : Labelset.t) (i : instruction) (c : list instruction) : list_fold_right (remove_unused bto) (i :: c) nil =\nmatch i with\n| Llabel lbl =>\n    if Labelset.mem lbl bto\n    then i :: list_fold_right (remove_unused bto) c nil\n    else list_fold_right (remove_unused bto) c nil\n| _ => i :: list_fold_right (remove_unused bto) c nil\nend.","proofString":"rewrite list_fold_right_eq.\nauto."},{"statement":"(bto : Labelset.t) (i : instruction) (c : list instruction) : remove_unused bto i (list_fold_right (remove_unused bto) c nil) =\nmatch i with\n| Llabel lbl =>\n    if Labelset.mem lbl bto\n    then i :: list_fold_right (remove_unused bto) c nil\n    else list_fold_right (remove_unused bto) c nil\n| _ => i :: list_fold_right (remove_unused bto) c nil\nend.","proofString":"auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (c' : code) (H0 : None = Some c') : None = Some (remove_unused_labels bto c').","proofString":"congruence."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (a : instruction) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (H0 : (if is_label lbl a then Some c else find_label lbl c) = Some c') : find_label lbl (remove_unused_labels bto (a :: c)) =\nSome (remove_unused_labels bto c').","proofString":"rewrite remove_unused_labels_cons.\nunfold is_label in H0.\ndestruct a; simpl; auto.\ndestruct (peq lbl l).\nsubst l.\ninv H0.\nrewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto.\ndestruct (Labelset.mem l bto); auto.\nsimpl.\nrewrite peq_false; auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (a : instruction) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (H0 : (if is_label lbl a then Some c else find_label lbl c) = Some c') : find_label lbl\n  match a with\n  | Llabel lbl0 =>\n      if Labelset.mem lbl0 bto\n      then a :: remove_unused_labels bto c\n      else remove_unused_labels bto c\n  | _ => a :: remove_unused_labels bto c\n  end = Some (remove_unused_labels bto c').","proofString":"unfold is_label in H0.\ndestruct a; simpl; auto.\ndestruct (peq lbl l).\nsubst l.\ninv H0.\nrewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto.\ndestruct (Labelset.mem l bto); auto.\nsimpl.\nrewrite peq_false; auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (a : instruction) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (H0 : (if\n  match a with\n  | Llabel lbl' => if peq lbl lbl' then true else false\n  | _ => false\n  end\n then Some c\n else find_label lbl c) = Some c') : find_label lbl\n  match a with\n  | Llabel lbl0 =>\n      if Labelset.mem lbl0 bto\n      then a :: remove_unused_labels bto c\n      else remove_unused_labels bto c\n  | _ => a :: remove_unused_labels bto c\n  end = Some (remove_unused_labels bto c').","proofString":"destruct a; simpl; auto.\ndestruct (peq lbl l).\nsubst l.\ninv H0.\nrewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto.\ndestruct (Labelset.mem l bto); auto.\nsimpl.\nrewrite peq_false; auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (l : label) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (H0 : (if if peq lbl l then true else false then Some c else find_label lbl c) =\nSome c') : find_label lbl\n  (if Labelset.mem l bto\n   then Llabel l :: remove_unused_labels bto c\n   else remove_unused_labels bto c) = Some (remove_unused_labels bto c').","proofString":"destruct (peq lbl l).\nsubst l.\ninv H0.\nrewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto.\ndestruct (Labelset.mem l bto); auto.\nsimpl.\nrewrite peq_false; auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (l : label) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (e : lbl = l) (H0 : Some c = Some c') : find_label lbl\n  (if Labelset.mem l bto\n   then Llabel l :: remove_unused_labels bto c\n   else remove_unused_labels bto c) = Some (remove_unused_labels bto c').","proofString":"subst l.\ninv H0.\nrewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (H0 : Some c = Some c') : find_label lbl\n  (if Labelset.mem lbl bto\n   then Llabel lbl :: remove_unused_labels bto c\n   else remove_unused_labels bto c) = Some (remove_unused_labels bto c').","proofString":"inv H0.\nrewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (c' : code) (IHc : forall c'0 : code,\nfind_label lbl c' = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c') =\nSome (remove_unused_labels bto c'0)) : find_label lbl\n  (if Labelset.mem lbl bto\n   then Llabel lbl :: remove_unused_labels bto c'\n   else remove_unused_labels bto c') = Some (remove_unused_labels bto c').","proofString":"rewrite Labelset.mem_1; auto.\nsimpl.\nrewrite peq_true.\nauto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (c' : code) (IHc : forall c'0 : code,\nfind_label lbl c' = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c') =\nSome (remove_unused_labels bto c'0)) : find_label lbl (Llabel lbl :: remove_unused_labels bto c') =\nSome (remove_unused_labels bto c').","proofString":"simpl.\nrewrite peq_true.\nauto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (c' : code) (IHc : forall c'0 : code,\nfind_label lbl c' = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c') =\nSome (remove_unused_labels bto c'0)) : (if if peq lbl lbl then true else false\n then Some (remove_unused_labels bto c')\n else find_label lbl (remove_unused_labels bto c')) =\nSome (remove_unused_labels bto c').","proofString":"rewrite peq_true.\nauto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (c' : code) (IHc : forall c'0 : code,\nfind_label lbl c' = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c') =\nSome (remove_unused_labels bto c'0)) : Some (remove_unused_labels bto c') = Some (remove_unused_labels bto c').","proofString":"auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (l : label) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (n : lbl <> l) (H0 : find_label lbl c = Some c') : find_label lbl\n  (if Labelset.mem l bto\n   then Llabel l :: remove_unused_labels bto c\n   else remove_unused_labels bto c) = Some (remove_unused_labels bto c').","proofString":"destruct (Labelset.mem l bto); auto.\nsimpl.\nrewrite peq_false; auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (l : label) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (n : lbl <> l) (H0 : find_label lbl c = Some c') : find_label lbl (Llabel l :: remove_unused_labels bto c) =\nSome (remove_unused_labels bto c').","proofString":"simpl.\nrewrite peq_false; auto."},{"statement":"(lbl : Labelset.elt) (bto : Labelset.t) (H : Labelset.In lbl bto) (l : label) (c : list instruction) (IHc : forall c'0 : code,\nfind_label lbl c = Some c'0 ->\nfind_label lbl (remove_unused_labels bto c) =\nSome (remove_unused_labels bto c'0)) (c' : code) (n : lbl <> l) (H0 : find_label lbl c = Some c') : (if if peq lbl l then true else false\n then Some (remove_unused_labels bto c)\n else find_label lbl (remove_unused_labels bto c)) =\nSome (remove_unused_labels bto c').","proofString":"rewrite peq_false; auto."},{"statement":"(f : function) (i : instruction) (c' : list instruction) (lbl : label) (c : code) (H : incl (i :: c') (fn_code f)) (H0 : find_label lbl (fn_code f) = Some c) (H1 : instr_branches_to i lbl) : find_label lbl (fn_code (transf_function f)) =\nSome (remove_unused_labels (labels_branched_to (fn_code f)) c).","proofString":"unfold transf_function; unfold cleanup_labels; simpl.\napply find_label_commut.\neapply labels_branched_to_correct; eauto.\napply H; auto with coqlib.\nauto."},{"statement":"(f : function) (i : instruction) (c' : list instruction) (lbl : label) (c : code) (H : incl (i :: c') (fn_code f)) (H0 : find_label lbl (fn_code f) = Some c) (H1 : instr_branches_to i lbl) : find_label lbl\n  (remove_unused_labels (labels_branched_to (fn_code f)) (fn_code f)) =\nSome (remove_unused_labels (labels_branched_to (fn_code f)) c).","proofString":"apply find_label_commut.\neapply labels_branched_to_correct; eauto.\napply H; auto with coqlib.\nauto."},{"statement":"(f : function) (i : instruction) (c' : list instruction) (lbl : label) (c : code) (H : incl (i :: c') (fn_code f)) (H0 : find_label lbl (fn_code f) = Some c) (H1 : instr_branches_to i lbl) : Labelset.In lbl (labels_branched_to (fn_code f)).","proofString":"eapply labels_branched_to_correct; eauto.\napply H; auto with coqlib."},{"statement":"(f : function) (i : instruction) (c' : list instruction) (lbl : label) (c : code) (H : incl (i :: c') (fn_code f)) (H0 : find_label lbl (fn_code f) = Some c) (H1 : instr_branches_to i lbl) : In i (fn_code f).","proofString":"apply H; auto with coqlib."},{"statement":"(f : function) (i : instruction) (c' : list instruction) (lbl : label) (c : code) (H : incl (i :: c') (fn_code f)) (H0 : find_label lbl (fn_code f) = Some c) (H1 : instr_branches_to i lbl) : find_label lbl (fn_code f) = Some c.","proofString":"auto."},{"statement":"(lbl : label) (c' : code) (H : None = Some c') : incl c' nil.","proofString":"discriminate."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall c'0 : code, find_label lbl c = Some c'0 -> incl c'0 c) (c' : code) (H : (if is_label lbl a then Some c else find_label lbl c) = Some c') : incl c' (a :: c).","proofString":"destruct (is_label lbl a).\ninv H; auto with coqlib.\nauto with coqlib."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall c'0 : code, find_label lbl c = Some c'0 -> incl c'0 c) (c' : code) (H : Some c = Some c') : incl c' (a :: c).","proofString":"inv H; auto with coqlib."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall c'0 : code, find_label lbl c = Some c'0 -> incl c'0 c) (c' : code) (H : find_label lbl c = Some c') : incl c' (a :: c).","proofString":"auto with coqlib."},{"statement":"Locmap.init Vundef = Locmap.init Vundef.","proofString":"auto."},{"statement":"(a1 : stackframe) (al : list stackframe) (b1 : stackframe) (bl : list stackframe) (H : match_stackframes a1 b1) (H0 : list_forall2 match_stackframes al bl) (IHlist_forall2 : parent_locset bl = parent_locset al) : match b1 with\n| Stackframe _ _ ls _ => ls\nend = match a1 with\n      | Stackframe _ _ ls _ => ls\n      end.","proofString":"inv H; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (rs : loc -> val) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lgetstack sl ofs ty dst :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lgetstack sl ofs ty dst\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b\n        (Locmap.set (R dst) (rs (S sl ofs ty))\n           (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) s2') \\/\n(measure\n   (State s f sp b\n      (Locmap.set (R dst) (rs (S sl ofs ty))\n         (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m) <\n measure (State s f sp (Lgetstack sl ofs ty dst :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (LTL.undef_regs (LTL.destroyed_by_getstack sl) rs)) m)\n  (State ts (transf_function f) sp\n     (Lgetstack sl ofs ty dst\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (rs : loc -> val) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lsetstack src sl ofs ty :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lsetstack src sl ofs ty\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b\n        (Locmap.set (S sl ofs ty) (rs (R src))\n           (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) s2') \\/\n(measure\n   (State s f sp b\n      (Locmap.set (S sl ofs ty) (rs (R src))\n         (LTL.undef_regs (destroyed_by_setstack ty) rs)) m) <\n measure (State s f sp (Lsetstack src sl ofs ty :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (LTL.undef_regs (destroyed_by_setstack ty) rs)) m)\n  (State ts (transf_function f) sp\n     (Lsetstack src sl ofs ty\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lop op args res :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lop op args res\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b\n        (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)\n     s2') \\/\n(measure\n   (State s f sp b\n      (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m) <\n measure (State s f sp (Lop op args res :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b\n     (Locmap.set (R res) v (LTL.undef_regs (destroyed_by_op op) rs)) m)\n  (State ts (transf_function f) sp\n     (Lop op args res\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor; eauto.\ninstantiate (1 := v).\nrewrite <- H.\napply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lop op args res :: b) (fn_code f)) : eval_operation tge sp op (LTL.reglist rs args) m = Some v.","proofString":"rewrite <- H.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lop op args res :: b) (fn_code f)) : eval_operation tge sp op (LTL.reglist rs args) m =\neval_operation ge sp op (LTL.reglist rs args) m.","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (LTL.reglist rs args) m = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lop op args res :: b) (fn_code f)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lload chunk addr args dst :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lload chunk addr args dst\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b\n        (Locmap.set (R dst) v\n           (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2') \\/\n(measure\n   (State s f sp b\n      (Locmap.set (R dst) v\n         (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (State s f sp (Lload chunk addr args dst :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b\n     (Locmap.set (R dst) v (LTL.undef_regs (destroyed_by_load chunk addr) rs))\n     m)\n  (State ts (transf_function f) sp\n     (Lload chunk addr args dst\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"assert (eval_addressing tge sp addr (LTL.reglist rs args) = Some a).\nrewrite <- H.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neconstructor; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lload chunk addr args dst :: b) (fn_code f)) : eval_addressing tge sp addr (LTL.reglist rs args) = Some a.","proofString":"rewrite <- H.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lload chunk addr args dst :: b) (fn_code f)) : eval_addressing tge sp addr (LTL.reglist rs args) =\neval_addressing ge sp addr (LTL.reglist rs args).","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lload chunk addr args dst :: b) (fn_code f)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b : list instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lload chunk addr args dst :: b) (fn_code f)) (H1 : eval_addressing tge sp addr (LTL.reglist rs args) = Some a) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lload chunk addr args dst\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b\n        (Locmap.set (R dst) v\n           (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) s2') \\/\n(measure\n   (State s f sp b\n      (Locmap.set (R dst) v\n         (LTL.undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (State s f sp (Lload chunk addr args dst :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b\n     (Locmap.set (R dst) v (LTL.undef_regs (destroyed_by_load chunk addr) rs))\n     m)\n  (State ts (transf_function f) sp\n     (Lload chunk addr args dst\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lstore chunk addr args src :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lstore chunk addr args src\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')\n     s2') \\/\n(measure\n   (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (State s f sp (Lstore chunk addr args src :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')\n  (State ts (transf_function f) sp\n     (Lstore chunk addr args src\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"assert (eval_addressing tge sp addr (LTL.reglist rs args) = Some a).\nrewrite <- H.\napply eval_addressing_preserved.\nexact symbols_preserved.\nleft; econstructor; split.\neconstructor; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lstore chunk addr args src :: b) (fn_code f)) : eval_addressing tge sp addr (LTL.reglist rs args) = Some a.","proofString":"rewrite <- H.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lstore chunk addr args src :: b) (fn_code f)) : eval_addressing tge sp addr (LTL.reglist rs args) =\neval_addressing ge sp addr (LTL.reglist rs args).","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lstore chunk addr args src :: b) (fn_code f)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b : list instruction) (rs : LTL.locset) (m m' : mem) (a : val) (H : eval_addressing ge sp addr (LTL.reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lstore chunk addr args src :: b) (fn_code f)) (H1 : eval_addressing tge sp addr (LTL.reglist rs args) = Some a) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lstore chunk addr args src\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')\n     s2') \\/\n(measure\n   (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (State s f sp (Lstore chunk addr args src :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f sp b (LTL.undef_regs (destroyed_by_store chunk addr) rs) m')\n  (State ts (transf_function f) sp\n     (Lstore chunk addr args src\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcall (funsig f') ros :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lcall (funsig f') ros\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\ match_states (Callstate (Stackframe f sp rs b :: s) f' rs m) s2') \\/\n(measure (Callstate (Stackframe f sp rs b :: s) f' rs m) <\n measure (State s f sp (Lcall (funsig f') ros :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate (Stackframe f sp rs b :: s) f' rs m)\n  (State ts (transf_function f) sp\n     (Lcall (funsig f') ros\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor.\neapply find_function_translated; eauto.\nsymmetry; apply sig_function_translated.\neconstructor; eauto.\nconstructor; auto.\nconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcall (funsig f') ros :: b) (fn_code f)) : list_forall2 match_stackframes (Stackframe f sp rs b :: s)\n  (Stackframe (transf_function f) sp rs\n     (remove_unused_labels (labels_branched_to (fn_code f)) b) :: ts).","proofString":"constructor; auto.\nconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ros : mreg + ident) (b : list instruction) (rs : locset) (m : mem) (f' : fundef) (H : find_function ge ros rs = Some f') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcall (funsig f') ros :: b) (fn_code f)) : match_stackframes (Stackframe f sp rs b)\n  (Stackframe (transf_function f) sp rs\n     (remove_unused_labels (labels_branched_to (fn_code f)) b)).","proofString":"constructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (stk : block) (ros : mreg + ident) (b : list instruction) (rs : LTL.locset) (m : mem) (f' : fundef) (m' : mem) (H0 : find_function ge ros (LTL.return_regs (parent_locset s) rs) = Some f') (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Ltailcall (funsig f') ros :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) (Vptr stk Ptrofs.zero)\n        (Ltailcall (funsig f') ros\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n     s2') \\/\n(measure (Callstate s f' (LTL.return_regs (parent_locset s) rs) m') <\n measure\n   (State s f (Vptr stk Ptrofs.zero) (Ltailcall (funsig f') ros :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Callstate s f' (LTL.return_regs (parent_locset s) rs) m')\n  (State ts (transf_function f) (Vptr stk Ptrofs.zero)\n     (Ltailcall (funsig f') ros\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor.\nerewrite match_parent_locset; eauto.\neapply find_function_translated; eauto.\nsymmetry; apply sig_function_translated.\nsimpl.\neauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lbuiltin ef args res :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lbuiltin ef args res\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) t\n     s2' /\\\n   match_states\n     (State s f sp b\n        (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n        m') s2') \\/\n(measure\n   (State s f sp b\n      (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n      m') < measure (State s f sp (Lbuiltin ef args res :: b) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (State s f sp b\n     (Locmap.setres res vres (LTL.undef_regs (destroyed_by_builtin ef) rs))\n     m')\n  (State ts (transf_function f) sp\n     (Lbuiltin ef args res\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lbuiltin ef args res :: b) (fn_code f)) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs : loc -> val) (m : mem) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (b : list instruction) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lbuiltin ef args res :: b) (fn_code f)) : Senv.equiv ge tge.","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (if Labelset.mem lbl (labels_branched_to (fn_code f))\n         then\n          Llabel lbl\n          :: remove_unused_labels (labels_branched_to (fn_code f)) b\n         else remove_unused_labels (labels_branched_to (fn_code f)) b) rs m)\n     E0 s2' /\\ match_states (State s f sp b rs m) s2') \\/\n(measure (State s f sp b rs m) <\n measure (State s f sp (Llabel lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b rs m)\n  (State ts (transf_function f) sp\n     (if Labelset.mem lbl (labels_branched_to (fn_code f))\n      then\n       Llabel lbl :: remove_unused_labels (labels_branched_to (fn_code f)) b\n      else remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"case_eq (Labelset.mem lbl (labels_branched_to (fn_code f))); intros.\nleft; econstructor; split.\nconstructor.\neconstructor; eauto with coqlib.\nright.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = true) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Llabel lbl\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\ match_states (State s f sp b rs m) s2') \\/\n(measure (State s f sp b rs m) <\n measure (State s f sp (Llabel lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b rs m)\n  (State ts (transf_function f) sp\n     (Llabel lbl :: remove_unused_labels (labels_branched_to (fn_code f)) b)\n     rs m).","proofString":"left; econstructor; split.\nconstructor.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\ match_states (State s f sp b rs m) s2') \\/\n(measure (State s f sp b rs m) <\n measure (State s f sp (Llabel lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b rs m)\n  (State ts (transf_function f) sp\n     (remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"right.\nsplit.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : (measure (State s f sp b rs m) <\n measure (State s f sp (Llabel lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b rs m)\n  (State ts (transf_function f) sp\n     (remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"split.\nsimpl.\nlia.\nsplit.\nauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : (measure (State s f sp b rs m) <\n measure (State s f sp (Llabel lbl :: b) rs m))%nat.","proofString":"simpl.\nlia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : (Datatypes.length b < Datatypes.S (Datatypes.length b))%nat.","proofString":"lia."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : E0 = E0 /\\\nmatch_states (State s f sp b rs m)\n  (State ts (transf_function f) sp\n     (remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"split.\nauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : E0 = E0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Llabel lbl :: b) (fn_code f)) (H : Labelset.mem lbl (labels_branched_to (fn_code f)) = false) : match_states (State s f sp b rs m)\n  (State ts (transf_function f) sp\n     (remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"econstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lgoto lbl :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lgoto lbl :: remove_unused_labels (labels_branched_to (fn_code f)) b)\n        rs m) E0 s2' /\\ match_states (State s f sp b' rs m) s2') \\/\n(measure (State s f sp b' rs m) <\n measure (State s f sp (Lgoto lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b' rs m)\n  (State ts (transf_function f) sp\n     (Lgoto lbl :: remove_unused_labels (labels_branched_to (fn_code f)) b)\n     rs m).","proofString":"left; econstructor; split.\neconstructor.\neapply find_label_translated; eauto.\nred; auto.\neconstructor; eauto.\neapply find_label_incl; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lgoto lbl :: b) (fn_code f)) : instr_branches_to (Lgoto lbl) lbl.","proofString":"red; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (lbl : label) (b : list instruction) (rs : locset) (m : mem) (b' : code) (H : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lgoto lbl :: b) (fn_code f)) : incl b' (fn_code f).","proofString":"eapply find_label_incl; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcond cond args lbl :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lcond cond args lbl\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m) <\n measure (State s f sp (Lcond cond args lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b' (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (transf_function f) sp\n     (Lcond cond args lbl\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor.\nauto.\neauto.\neapply find_label_translated; eauto.\nred; auto.\neconstructor; eauto.\neapply find_label_incl; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcond cond args lbl :: b) (fn_code f)) : eval_condition cond (LTL.reglist rs args) m = Some true.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcond cond args lbl :: b) (fn_code f)) : instr_branches_to (Lcond cond args lbl) lbl.","proofString":"red; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (b' : code) (H : eval_condition cond (LTL.reglist rs args) m = Some true) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcond cond args lbl :: b) (fn_code f)) : incl b' (fn_code f).","proofString":"eapply find_label_incl; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (cond : condition) (args : list mreg) (lbl : label) (b : list instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (LTL.reglist rs args) m = Some false) (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lcond cond args lbl :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Lcond cond args lbl\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m) <\n measure (State s f sp (Lcond cond args lbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b (LTL.undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts (transf_function f) sp\n     (Lcond cond args lbl\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neapply exec_Lcond_false; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Ljumptable arg tbl :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) sp\n        (Ljumptable arg tbl\n         :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m) E0\n     s2' /\\\n   match_states\n     (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m) s2') \\/\n(measure (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m) <\n measure (State s f sp (Ljumptable arg tbl :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp b' (LTL.undef_regs destroyed_by_jumptable rs) m)\n  (State ts (transf_function f) sp\n     (Ljumptable arg tbl\n      :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs m).","proofString":"left; econstructor; split.\neconstructor.\neauto.\neauto.\neapply find_label_translated; eauto.\nred.\neapply list_nth_z_in; eauto.\neauto.\neconstructor; eauto.\neapply find_label_incl; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Ljumptable arg tbl :: b) (fn_code f)) : instr_branches_to (Ljumptable arg tbl) lbl.","proofString":"red.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Ljumptable arg tbl :: b) (fn_code f)) : In lbl tbl.","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (arg : mreg) (tbl : list label) (b : list instruction) (rs : loc -> val) (m : mem) (n : int) (lbl : label) (b' : code) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : find_label lbl (fn_code f) = Some b') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Ljumptable arg tbl :: b) (fn_code f)) : incl b' (fn_code f).","proofString":"eapply find_label_incl; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lreturn :: b) (fn_code f)) : (exists s2' : state,\n   step tge\n     (State ts (transf_function f) (Vptr stk Ptrofs.zero)\n        (Lreturn :: remove_unused_labels (labels_branched_to (fn_code f)) b)\n        rs m) E0 s2' /\\\n   match_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m') s2') \\/\n(measure (Returnstate s (LTL.return_regs (parent_locset s) rs) m') <\n measure (State s f (Vptr stk Ptrofs.zero) (Lreturn :: b) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Returnstate s (LTL.return_regs (parent_locset s) rs) m')\n  (State ts (transf_function f) (Vptr stk Ptrofs.zero)\n     (Lreturn :: remove_unused_labels (labels_branched_to (fn_code f)) b) rs\n     m).","proofString":"left; econstructor; split.\neconstructor; eauto.\nerewrite <- match_parent_locset; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (stk : block) (b : list instruction) (rs : locset) (m m' : mem) (H : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (STACKS : list_forall2 match_stackframes s ts) (INCL : incl (Lreturn :: b) (fn_code f)) : match_states (Returnstate s (LTL.return_regs (parent_locset ts) rs) m')\n  (Returnstate ts (LTL.return_regs (parent_locset ts) rs) m').","proofString":"econstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (f : function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (stk : block) (H : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) : (exists s2' : state,\n   step tge (Callstate ts (transf_fundef (Internal f)) rs m) E0 s2' /\\\n   match_states\n     (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n        (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n     s2') \\/\n(measure\n   (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n      (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m') <\n measure (Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (State s f (Vptr stk Ptrofs.zero) (fn_code f)\n     (LTL.undef_regs destroyed_at_function_entry (LTL.call_regs rs)) m')\n  (Callstate ts (transf_fundef (Internal f)) rs m).","proofString":"left; econstructor; split.\neconstructor; simpl; eauto.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) : (exists s2' : state,\n   step tge (Callstate ts (transf_fundef (External ef)) rs1 m) t s2' /\\\n   match_states\n     (Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (LTL.undef_caller_save_regs rs1)) m') s2') \\/\n(measure\n   (Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (LTL.undef_caller_save_regs rs1)) m') <\n measure (Callstate s (External ef) rs1 m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (LTL.undef_caller_save_regs rs1)) m')\n  (Callstate ts (transf_fundef (External ef)) rs1 m).","proofString":"left; econstructor; split.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto with coqlib."},{"statement":"(s : list stackframe) (ef : external_function) (res : val) (rs1 : Locmap.t) (m : mem) (t : trace) (m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs1)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) : Senv.equiv ge tge.","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (ts : list stackframe) (H3 : list_forall2 match_stackframes (Stackframe f sp rs0 c :: s) ts) : (exists s2' : state,\n   step tge (Returnstate ts rs m) E0 s2' /\\\n   match_states (State s f sp c rs m) s2') \\/\n(measure (State s f sp c rs m) <\n measure (Returnstate (Stackframe f sp rs0 c :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (State s f sp c rs m) (Returnstate ts rs m).","proofString":"inv H3.\ninv H1.\nleft; econstructor; split.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (Stackframe f sp rs0 c) b1) (H4 : list_forall2 match_stackframes s bl) : (exists s2' : state,\n   step tge (Returnstate (b1 :: bl) rs m) E0 s2' /\\\n   match_states (State s f sp c rs m) s2') \\/\n(measure (State s f sp c rs m) <\n measure (Returnstate (Stackframe f sp rs0 c :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (State s f sp c rs m) (Returnstate (b1 :: bl) rs m).","proofString":"inv H1.\nleft; econstructor; split.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (rs0 : locset) (c : code) (rs : locset) (m : mem) (bl : list stackframe) (H4 : list_forall2 match_stackframes s bl) (H6 : incl c (fn_code f)) : (exists s2' : state,\n   step tge\n     (Returnstate\n        (Stackframe (transf_function f) sp rs0\n           (remove_unused_labels (labels_branched_to (fn_code f)) c) :: bl)\n        rs m) E0 s2' /\\ match_states (State s f sp c rs m) s2') \\/\n(measure (State s f sp c rs m) <\n measure (Returnstate (Stackframe f sp rs0 c :: s) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (State s f sp c rs m)\n  (Returnstate\n     (Stackframe (transf_function f) sp rs0\n        (remove_unused_labels (labels_branched_to (fn_code f)) c) :: bl) rs m).","proofString":"left; econstructor; split.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(st1 : state) (H : initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","proofString":"inv H.\neconstructor; split.\neapply initial_state_intro with (f := transf_fundef f).\neapply (Genv.init_mem_transf TRANSL); eauto.\nrewrite (match_program_main TRANSL), symbols_preserved; eauto.\napply function_ptr_translated; auto.\nrewrite sig_function_translated.\nauto.\nconstructor; auto.\nconstructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : funsig (transf_fundef f) = signature_main.","proofString":"rewrite sig_function_translated.\nauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : funsig f = signature_main.","proofString":"auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : list_forall2 match_stackframes nil nil.","proofString":"constructor."},{"statement":"(st1 st2 : state) (r : int) (H : match_states st1 st2) (H0 : final_state st1 r) : final_state st2 r.","proofString":"inv H0.\ninv H.\ninv H5.\neconstructor; eauto."},{"statement":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) : final_state st2 r.","proofString":"inv H.\ninv H5.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) (ts : list stackframe) (H5 : list_forall2 match_stackframes nil ts) : final_state (Returnstate ts rs m) r.","proofString":"inv H5.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) : final_state (Returnstate nil rs m) r.","proofString":"econstructor; eauto."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","proofString":"apply senv_preserved."}]}