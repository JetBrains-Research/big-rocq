{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/arm/Asmgenproof.v","fileSamples":[{"statement":"(p : Mach.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"exploit functions_translated; eauto.\nintros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : (exists tf0 : fundef,\n   Genv.find_funct_ptr tge fb = Some tf0 /\\\n   transf_fundef (Internal f) = OK tf0) ->\nGenv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"intros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (tf' : fundef) (A : Genv.find_funct_ptr tge fb = Some tf') (B : transf_fundef (Internal f) = OK tf') : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"monadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (x : function) (A : Genv.find_funct_ptr tge fb = Some (Internal x)) (EQ : transf_function f = OK x) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"rewrite H0 in EQ; inv EQ; auto."},{"statement":"(f : Mach.function) (tf : function) (H : transf_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"monadInv H.\ndestruct (zlt Ptrofs.max_unsigned (list_length_z (fn_code x))); inv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf x : function) (EQ : transl_function f = OK x) (EQ0 : (if zlt Ptrofs.max_unsigned (list_length_z (fn_code x))\n then Error (msg \"code size exceeded\")\n else OK x) = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"destruct (zlt Ptrofs.max_unsigned (list_length_z (fn_code x))); inv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf : function) (g : Ptrofs.max_unsigned >= list_length_z (fn_code tf)) (EQ : transl_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : exec_straight tge tf tc rs m c' rs' m') : plus step tge (State rs m) E0 (State rs' m').","proofString":"inv H.\neapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : plus step tge (State rs m) E0 (State rs' m').","proofString":"eapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"inv H.\nexploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"exploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : (exists ofs' : ptrofs,\n   rs' PC = Vptr fb ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') ->\ntransl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"intros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"rewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (Vptr fb ofs') fb f c' ep' tf tc'.","proofString":"constructor; auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos c = Some pos' /\\\n  code_tail (pos' - pos) c c' /\\ pos < pos' <= pos + list_length_z c) : forall (pos : Z) (c' : code),\nfind_label lbl (a :: c) = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos (a :: c) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"simpl; intros until c'.\ncase (is_label lbl a).\nintro EQ; injection EQ; intro; subst c'.\nexists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia.\nintros.\ngeneralize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) : (if is_label lbl a then Some c else find_label lbl c) = Some c' ->\nexists pos' : Z,\n  (if is_label lbl a then Some (pos + 1) else label_pos lbl (pos + 1) c) =\n  Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"case (is_label lbl a).\nintro EQ; injection EQ; intro; subst c'.\nexists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia.\nintros.\ngeneralize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) : Some c = Some c' ->\nexists pos' : Z,\n  Some (pos + 1) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"intro EQ; injection EQ; intro; subst c'.\nexists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : exists pos' : Z,\n  Some (pos + 1) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"exists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : Some (pos + 1) = Some (pos + 1) /\\\ncode_tail (pos + 1 - pos) (a :: c) c /\\\npos < pos + 1 <= pos + list_length_z (a :: c).","proofString":"split.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : Some (pos + 1) = Some (pos + 1).","proofString":"auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail (pos + 1 - pos) (a :: c) c /\\\npos < pos + 1 <= pos + list_length_z (a :: c).","proofString":"split.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail (pos + 1 - pos) (a :: c) c.","proofString":"replace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail (0 + 1) (a :: c) c.","proofString":"constructor.\nconstructor."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail 0 c c.","proofString":"constructor."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : pos < pos + 1 <= pos + list_length_z (a :: c).","proofString":"rewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : pos < pos + 1 <= pos + (list_length_z c + 1).","proofString":"generalize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : list_length_z c >= 0 -> pos < pos + 1 <= pos + (list_length_z c + 1).","proofString":"lia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) : find_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"intros.\ngeneralize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') : exists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"generalize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') : (exists pos' : Z,\n   label_pos lbl (pos + 1) c = Some pos' /\\\n   code_tail (pos' - (pos + 1)) c c' /\\\n   pos + 1 < pos' <= pos + 1 + list_length_z c) ->\nexists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","proofString":"intros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : exists pos'0 : Z,\n  label_pos lbl (pos + 1) c = Some pos'0 /\\\n  code_tail (pos'0 - pos) (a :: c) c' /\\\n  pos < pos'0 <= pos + list_length_z (a :: c).","proofString":"exists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : label_pos lbl (pos + 1) c = Some pos' /\\\ncode_tail (pos' - pos) (a :: c) c' /\\\npos < pos' <= pos + list_length_z (a :: c).","proofString":"split.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : label_pos lbl (pos + 1) c = Some pos'.","proofString":"auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - pos) (a :: c) c' /\\\npos < pos' <= pos + list_length_z (a :: c).","proofString":"split.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - pos) (a :: c) c'.","proofString":"replace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - (pos + 1) + 1) (a :: c) c'.","proofString":"constructor.\nauto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - (pos + 1)) c c'.","proofString":"auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : pos < pos' <= pos + list_length_z (a :: c).","proofString":"rewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : pos < pos' <= pos + (list_length_z c + 1).","proofString":"lia."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : find_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","proofString":"exploit transl_instr_label; eauto.\ndestruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : match i with\n| Mlabel lbl0 => c = Plabel lbl0 :: k\n| _ => tail_nolabel k c\nend ->\nfind_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","proofString":"destruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) : c = Plabel l :: k ->\nfind_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"intros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) (H0 : c = Plabel l :: k) : find_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"subst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : find_label lbl (Plabel l :: k) =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"simpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : (if if peq lbl l then true else false then Some k else find_label lbl k) =\n(if if peq lbl l then true else false then Some k else find_label lbl k).","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) (tc : list instruction) (H : OK nil = OK tc) : find_label lbl tc = None.","proofString":"inv H.\nauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) : find_label lbl nil = None.","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc : list instruction) (H : bind (transl_code f c (it1_is_parent ep a))\n  (fun k : list instruction => transl_instr f a ep k) = \nOK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","proofString":"monadInv H.\nrewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","proofString":"rewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","proofString":"generalize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : (if Mach.is_label lbl a then a = Mlabel lbl else a <> Mlabel lbl) ->\nmatch (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","proofString":"destruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a = Mlabel lbl) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"subst a.\nsimpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c (it1_is_parent ep (Mlabel lbl)) = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"simpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c false = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"exists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a <> Mlabel lbl) : match Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl x = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl x = None\nend.","proofString":"eapply IHc; eauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exploit (transl_find_label lbl f tf); eauto.\nrewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"rewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : (exists tc : code,\n   find_label lbl (fn_code tf) = Some tc /\\ transl_code f c' false = OK tc) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"intros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : (exists pos' : Z,\n   label_pos lbl 0 (fn_code tf) = Some pos' /\\\n   code_tail (pos' - 0) (fn_code tf) tc /\\\n   0 < pos' <= 0 + list_length_z (fn_code tf)) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"intros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m /\\\ntransl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","proofString":"split.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"unfold goto_label.\nrewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match label_pos lbl 0 (fn_code tf) with\n| Some pos =>\n    match rs PC with\n    | Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos)) m\n    | _ => Stuck\n    end\n| None => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"rewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match rs PC with\n| Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos')) m\n| _ => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"rewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m =\nNext rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","proofString":"split.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc.","proofString":"rewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (Vptr b (Ptrofs.repr pos')) b f c' false tf tc.","proofString":"constructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail (Ptrofs.unsigned (Ptrofs.repr pos')) (fn_code tf) tc.","proofString":"rewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","proofString":"replace (pos' - 0) with pos' in Q.\nauto.\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail pos' (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : pos' = pos' - 0.","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : 0 <= pos' <= Ptrofs.max_unsigned.","proofString":"generalize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned ->\n0 <= pos' <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","proofString":"intros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) (r : preg) (H3 : r <> PC) : rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","proofString":"apply Pregmap.gso; auto."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Mach.semantics return_address_offset prog)) id.","proofString":"apply senv_preserved."}]}