{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Linearizeproof.v","fileSamples":[{"statement":"(p : LTL.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : LTL.program) (tp : program) (H : transf_program p = OK tp)","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(f : LTL.fundef) (tf : fundef) (H : match f with\n| Internal f0 => do f' <- transf_function f0; OK (Internal f')\n| External ef => OK (External ef)\nend = OK tf) : funsig tf = LTL.funsig f.","conclusion":"funsig tf = LTL.funsig f","hypotheses":"(f : LTL.fundef) (tf : fundef) (H : match f with\n| Internal f0 => do f' <- transf_function f0; OK (Internal f')\n| External ef => OK (External ef)\nend = OK tf)","proofString":"destruct f.\nmonadInv H.\nmonadInv EQ.\nreflexivity.\ninv H.\nreflexivity."},{"statement":"(f : LTL.function) (tf : fundef) (H : (do f' <- transf_function f; OK (Internal f')) = OK tf) : funsig tf = LTL.funsig (Internal f).","conclusion":"funsig tf = LTL.funsig (Internal f)","hypotheses":"(f : LTL.function) (tf : fundef) (H : (do f' <- transf_function f; OK (Internal f')) = OK tf)","proofString":"monadInv H.\nmonadInv EQ.\nreflexivity."},{"statement":"(f : LTL.function) (x : function) (EQ : transf_function f = OK x) : funsig (Internal x) = LTL.funsig (Internal f).","conclusion":"funsig (Internal x) = LTL.funsig (Internal f)","hypotheses":"(f : LTL.function) (x : function) (EQ : transf_function f = OK x)","proofString":"monadInv EQ.\nreflexivity."},{"statement":"(f : LTL.function) (x0 : list node) (EQ0 : enumerate f = OK x0) : funsig\n  (Internal\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |}) = LTL.funsig (Internal f).","conclusion":"funsig\n  (Internal\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |}) = LTL.funsig (Internal f)","hypotheses":"(f : LTL.function) (x0 : list node) (EQ0 : enumerate f = OK x0)","proofString":"reflexivity."},{"statement":"(e : external_function) (tf : fundef) (H : OK (External e) = OK tf) : funsig tf = LTL.funsig (External e).","conclusion":"funsig tf = LTL.funsig (External e)","hypotheses":"(e : external_function) (tf : fundef) (H : OK (External e) = OK tf)","proofString":"inv H.\nreflexivity."},{"statement":"(e : external_function) : funsig (External e) = LTL.funsig (External e).","conclusion":"funsig (External e) = LTL.funsig (External e)","hypotheses":"(e : external_function)","proofString":"reflexivity."},{"statement":"(f : LTL.function) (tf : function) (H : transf_function f = OK tf) : fn_stacksize tf = LTL.fn_stacksize f.","conclusion":"fn_stacksize tf = LTL.fn_stacksize f","hypotheses":"(f : LTL.function) (tf : function) (H : transf_function f = OK tf)","proofString":"monadInv H.\nauto."},{"statement":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x) : fn_stacksize\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x)\n  |} = LTL.fn_stacksize f.","conclusion":"fn_stacksize\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x)\n  |} = LTL.fn_stacksize f","hypotheses":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x)","proofString":"auto."},{"statement":"(m : mreg) (ls : LTL.locset) (f : LTL.fundef) (H : Genv.find_funct ge (ls (R m)) = Some f) : exists tf : fundef,\n  Genv.find_funct tge (ls (R m)) = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  Genv.find_funct tge (ls (R m)) = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(m : mreg) (ls : LTL.locset) (f : LTL.fundef) (H : Genv.find_funct ge (ls (R m)) = Some f)","proofString":"apply functions_translated; auto."},{"statement":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : exists tf : fundef,\n  match Genv.find_symbol tge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  match Genv.find_symbol tge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge i).\napply function_ptr_translated; auto.\ncongruence."},{"statement":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : exists tf : fundef,\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  match Genv.find_symbol ge i with\n  | Some b => Genv.find_funct_ptr tge b\n  | None => None\n  end = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (H : match Genv.find_symbol ge i with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f)","proofString":"destruct (Genv.find_symbol ge i).\napply function_ptr_translated; auto.\ncongruence."},{"statement":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f) : exists tf : fundef,\n  Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef,\n  Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f)","proofString":"apply function_ptr_translated; auto."},{"statement":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (H : None = Some f) : exists tf : fundef, None = Some tf /\\ transf_fundef f = OK tf.","conclusion":"exists tf : fundef, None = Some tf /\\ transf_fundef f = OK tf","hypotheses":"(i : ident) (ls : LTL.locset) (f : LTL.fundef) (H : None = Some f)","proofString":"congruence."},{"statement":"(f : LTL.function) : (reachable f) !! (fn_entrypoint f) = true.","conclusion":"(reachable f) !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function)","proofString":"unfold reachable.\ncaseEq (reachable_aux f).\nunfold reachable_aux; intros reach A.\nassert (LBoolean.ge reach!!(f.(fn_entrypoint)) true).\neapply DS.fixpoint_entry.\neexact A.\nauto.\nunfold LBoolean.ge in H.\ntauto.\nintros.\napply PMap.gi."},{"statement":"(f : LTL.function) : match reachable_aux f with\n| Some rs => rs\n| None => PMap.init true\nend !! (fn_entrypoint f) = true.","conclusion":"match reachable_aux f with\n| Some rs => rs\n| None => PMap.init true\nend !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function)","proofString":"caseEq (reachable_aux f).\nunfold reachable_aux; intros reach A.\nassert (LBoolean.ge reach!!(f.(fn_entrypoint)) true).\neapply DS.fixpoint_entry.\neexact A.\nauto.\nunfold LBoolean.ge in H.\ntauto.\nintros.\napply PMap.gi."},{"statement":"(f : LTL.function) : forall t : PMap.t bool,\nreachable_aux f = Some t -> t !! (fn_entrypoint f) = true.","conclusion":"forall t : PMap.t bool,\nreachable_aux f = Some t -> t !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function)","proofString":"unfold reachable_aux; intros reach A.\nassert (LBoolean.ge reach!!(f.(fn_entrypoint)) true).\neapply DS.fixpoint_entry.\neexact A.\nauto.\nunfold LBoolean.ge in H.\ntauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) : reach !! (fn_entrypoint f) = true.","conclusion":"reach !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach)","proofString":"assert (LBoolean.ge reach!!(f.(fn_entrypoint)) true).\neapply DS.fixpoint_entry.\neexact A.\nauto.\nunfold LBoolean.ge in H.\ntauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) : LBoolean.ge reach !! (fn_entrypoint f) true.","conclusion":"LBoolean.ge reach !! (fn_entrypoint f) true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach)","proofString":"eapply DS.fixpoint_entry.\neexact A."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (H : LBoolean.ge reach !! (fn_entrypoint f) true) : reach !! (fn_entrypoint f) = true.","conclusion":"reach !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (H : LBoolean.ge reach !! (fn_entrypoint f) true)","proofString":"auto.\nunfold LBoolean.ge in H.\ntauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (H : LBoolean.ge reach !! (fn_entrypoint f) true) : reach !! (fn_entrypoint f) = true.","conclusion":"reach !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (H : LBoolean.ge reach !! (fn_entrypoint f) true)","proofString":"unfold LBoolean.ge in H.\ntauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (H : reach !! (fn_entrypoint f) = true \\/ reach !! (fn_entrypoint f) = true) : reach !! (fn_entrypoint f) = true.","conclusion":"reach !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (A : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (H : reach !! (fn_entrypoint f) = true \\/ reach !! (fn_entrypoint f) = true)","proofString":"tauto."},{"statement":"(f : LTL.function) : reachable_aux f = None -> (PMap.init true) !! (fn_entrypoint f) = true.","conclusion":"reachable_aux f = None -> (PMap.init true) !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function)","proofString":"intros.\napply PMap.gi."},{"statement":"(f : LTL.function) (H : reachable_aux f = None) : (PMap.init true) !! (fn_entrypoint f) = true.","conclusion":"(PMap.init true) !! (fn_entrypoint f) = true","hypotheses":"(f : LTL.function) (H : reachable_aux f = None)","proofString":"apply PMap.gi."},{"statement":"(f : LTL.function) : forall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) ->\n(reachable f) !! pc = true -> (reachable f) !! pc' = true.","conclusion":"forall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) ->\n(reachable f) !! pc = true -> (reachable f) !! pc' = true","hypotheses":"(f : LTL.function)","proofString":"unfold reachable.\ncaseEq (reachable_aux f).\nunfold reachable_aux.\nintro reach; intros.\nassert (LBoolean.ge reach!!pc' reach!!pc).\nchange (reach!!pc) with ((fun pc r => r) pc (reach!!pc)).\neapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl.\nelim H3; intro.\ncongruence.\nauto.\nintros.\napply PMap.gi."},{"statement":"(f : LTL.function) : forall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) ->\nmatch reachable_aux f with\n| Some rs => rs\n| None => PMap.init true\nend !! pc = true ->\nmatch reachable_aux f with\n| Some rs => rs\n| None => PMap.init true\nend !! pc' = true.","conclusion":"forall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) ->\nmatch reachable_aux f with\n| Some rs => rs\n| None => PMap.init true\nend !! pc = true ->\nmatch reachable_aux f with\n| Some rs => rs\n| None => PMap.init true\nend !! pc' = true","hypotheses":"(f : LTL.function)","proofString":"caseEq (reachable_aux f).\nunfold reachable_aux.\nintro reach; intros.\nassert (LBoolean.ge reach!!pc' reach!!pc).\nchange (reach!!pc) with ((fun pc r => r) pc (reach!!pc)).\neapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl.\nelim H3; intro.\ncongruence.\nauto.\nintros.\napply PMap.gi."},{"statement":"(f : LTL.function) : forall t : PMap.t bool,\nreachable_aux f = Some t ->\nforall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) -> t !! pc = true -> t !! pc' = true.","conclusion":"forall t : PMap.t bool,\nreachable_aux f = Some t ->\nforall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) -> t !! pc = true -> t !! pc' = true","hypotheses":"(f : LTL.function)","proofString":"unfold reachable_aux.\nintro reach; intros.\nassert (LBoolean.ge reach!!pc' reach!!pc).\nchange (reach!!pc) with ((fun pc r => r) pc (reach!!pc)).\neapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl.\nelim H3; intro.\ncongruence.\nauto."},{"statement":"(f : LTL.function) : forall t : PMap.t bool,\nDS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome t ->\nforall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) -> t !! pc = true -> t !! pc' = true.","conclusion":"forall t : PMap.t bool,\nDS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome t ->\nforall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) -> t !! pc = true -> t !! pc' = true","hypotheses":"(f : LTL.function)","proofString":"intro reach; intros.\nassert (LBoolean.ge reach!!pc' reach!!pc).\nchange (reach!!pc) with ((fun pc r => r) pc (reach!!pc)).\neapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl.\nelim H3; intro.\ncongruence.\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) : reach !! pc' = true.","conclusion":"reach !! pc' = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true)","proofString":"assert (LBoolean.ge reach!!pc' reach!!pc).\nchange (reach!!pc) with ((fun pc r => r) pc (reach!!pc)).\neapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl.\nelim H3; intro.\ncongruence.\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) : LBoolean.ge reach !! pc' reach !! pc.","conclusion":"LBoolean.ge reach !! pc' reach !! pc","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true)","proofString":"change (reach!!pc) with ((fun pc r => r) pc (reach!!pc)).\neapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) : LBoolean.ge reach !! pc'\n  ((fun (_ : positive) (r : bool) => r) pc reach !! pc).","conclusion":"LBoolean.ge reach !! pc'\n  ((fun (_ : positive) (r : bool) => r) pc reach !! pc)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true)","proofString":"eapply DS.fixpoint_solution; eauto.\nintros; apply DS.L.eq_refl."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) : positive -> DS.L.eq DS.L.bot DS.L.bot.","conclusion":"positive -> DS.L.eq DS.L.bot DS.L.bot","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true)","proofString":"intros; apply DS.L.eq_refl."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) (H3 : LBoolean.ge reach !! pc' reach !! pc) : reach !! pc' = true.","conclusion":"reach !! pc' = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) (H3 : LBoolean.ge reach !! pc' reach !! pc)","proofString":"elim H3; intro.\ncongruence.\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) (H3 : LBoolean.ge reach !! pc' reach !! pc) (H4 : reach !! pc' = reach !! pc) : reach !! pc' = true.","conclusion":"reach !! pc' = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) (H3 : LBoolean.ge reach !! pc' reach !! pc) (H4 : reach !! pc' = reach !! pc)","proofString":"congruence."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) (H3 : LBoolean.ge reach !! pc' reach !! pc) (H4 : reach !! pc' = true) : reach !! pc' = true.","conclusion":"reach !! pc' = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (H : DS.fixpoint (LTL.fn_code f) successors_block\n  (fun (_ : positive) (r : DS.L.t) => r) (fn_entrypoint f) true = \nSome reach) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : reach !! pc = true) (H3 : LBoolean.ge reach !! pc' reach !! pc) (H4 : reach !! pc' = true)","proofString":"auto."},{"statement":"(f : LTL.function) : reachable_aux f = None ->\nforall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) ->\n(PMap.init true) !! pc = true -> (PMap.init true) !! pc' = true.","conclusion":"reachable_aux f = None ->\nforall (pc : positive) (pc' : node) (b : bblock),\n(LTL.fn_code f) ! pc = Some b ->\nIn pc' (successors_block b) ->\n(PMap.init true) !! pc = true -> (PMap.init true) !! pc' = true","hypotheses":"(f : LTL.function)","proofString":"intros.\napply PMap.gi."},{"statement":"(f : LTL.function) (H : reachable_aux f = None) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : (PMap.init true) !! pc = true) : (PMap.init true) !! pc' = true.","conclusion":"(PMap.init true) !! pc' = true","hypotheses":"(f : LTL.function) (H : reachable_aux f = None) (pc : positive) (pc' : node) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : In pc' (successors_block b)) (H2 : (PMap.init true) !! pc = true)","proofString":"apply PMap.gi."},{"statement":"(s' : Nodeset.t) : (forall pc : Nodeset.elt, Nodeset.In pc s' <-> Nodeset.In pc s' \\/ False) /\\\n(forall pc : node, False -> ~ Nodeset.In pc s').","conclusion":"(forall pc : Nodeset.elt, Nodeset.In pc s' <-> Nodeset.In pc s' \\/ False) /\\\n(forall pc : node, False -> ~ Nodeset.In pc s')","hypotheses":"(s' : Nodeset.t)","proofString":"split.\nintro; tauto.\nintros; tauto."},{"statement":"(s' : Nodeset.t) : forall pc : Nodeset.elt, Nodeset.In pc s' <-> Nodeset.In pc s' \\/ False.","conclusion":"forall pc : Nodeset.elt, Nodeset.In pc s' <-> Nodeset.In pc s' \\/ False","hypotheses":"(s' : Nodeset.t)","proofString":"intro; tauto."},{"statement":"(s' : Nodeset.t) : forall pc : node, False -> ~ Nodeset.In pc s'.","conclusion":"forall pc : node, False -> ~ Nodeset.In pc s'","hypotheses":"(s' : Nodeset.t)","proofString":"intros; tauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : (if Nodeset.mem a s\n then Error (msg \"Linearize: duplicates in enumeration\")\n else nodeset_of_list l (Nodeset.add a s)) = OK s') : list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s).","conclusion":"list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : (if Nodeset.mem a s\n then Error (msg \"Linearize: duplicates in enumeration\")\n else nodeset_of_list l (Nodeset.add a s)) = OK s')","proofString":"generalize H; clear H; caseEq (Nodeset.mem a s); intros.\ninv H0.\nexploit IHl; eauto.\nintros [A [B C]].\nsplit.\nconstructor; auto.\nred; intro.\nelim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto.\nsplit.\nintros.\nrewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto.\nintros.\ndestruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = true) (H0 : Error (msg \"Linearize: duplicates in enumeration\") = OK s') : list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s).","conclusion":"list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = true) (H0 : Error (msg \"Linearize: duplicates in enumeration\") = OK s')","proofString":"inv H0."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') : list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s).","conclusion":"list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s')","proofString":"exploit IHl; eauto.\nintros [A [B C]].\nsplit.\nconstructor; auto.\nred; intro.\nelim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto.\nsplit.\nintros.\nrewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto.\nintros.\ndestruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') : list_norepet l /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) ->\nlist_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s).","conclusion":"list_norepet l /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) ->\nlist_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s')","proofString":"intros [A [B C]].\nsplit.\nconstructor; auto.\nred; intro.\nelim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto.\nsplit.\nintros.\nrewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto.\nintros.\ndestruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s).","conclusion":"list_norepet (a :: l) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"split.\nconstructor; auto.\nred; intro.\nelim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto.\nsplit.\nintros.\nrewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto.\nintros.\ndestruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : list_norepet (a :: l).","conclusion":"list_norepet (a :: l)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"constructor; auto.\nred; intro.\nelim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : ~ In a l.","conclusion":"~ In a l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"red; intro.\nelim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l) : False.","conclusion":"False","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l)","proofString":"elim (C a H1).\napply Nodeset.add_1.\nhnf.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l) : Nodeset.In a (Nodeset.add a s).","conclusion":"Nodeset.In a (Nodeset.add a s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l)","proofString":"apply Nodeset.add_1.\nhnf.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l) : a = a.","conclusion":"a = a","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l)","proofString":"hnf.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l) : a = a.","conclusion":"a = a","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) (H1 : In a l)","proofString":"auto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : (forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s).","conclusion":"(forall pc : Nodeset.elt,\n Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l) /\\\n(forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s)","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"split.\nintros.\nrewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto.\nintros.\ndestruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l.","conclusion":"forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"intros.\nrewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt) : Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l.","conclusion":"Nodeset.In pc s' <-> Nodeset.In pc s \\/ a = pc \\/ In pc l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt)","proofString":"rewrite B.\nrewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt) : Nodeset.In pc (Nodeset.add a s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l.","conclusion":"Nodeset.In pc (Nodeset.add a s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt)","proofString":"rewrite NodesetFacts.add_iff.\nunfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt) : (a = pc \\/ Nodeset.In pc s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l.","conclusion":"(a = pc \\/ Nodeset.In pc s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt)","proofString":"unfold Nodeset.E.eq.\nunfold OrderedPositive.eq.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt) : (a = pc \\/ Nodeset.In pc s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l.","conclusion":"(a = pc \\/ Nodeset.In pc s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt)","proofString":"unfold OrderedPositive.eq.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt) : (a = pc \\/ Nodeset.In pc s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l.","conclusion":"(a = pc \\/ Nodeset.In pc s) \\/ In pc l <->\nNodeset.In pc s \\/ a = pc \\/ In pc l","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : Nodeset.elt)","proofString":"tauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s.","conclusion":"forall pc : node, a = pc \\/ In pc l -> ~ Nodeset.In pc s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"intros.\ndestruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : a = pc \\/ In pc l) : ~ Nodeset.In pc s.","conclusion":"~ Nodeset.In pc s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : a = pc \\/ In pc l)","proofString":"destruct H1.\nsubst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto.\ngeneralize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : a = pc) : ~ Nodeset.In pc s.","conclusion":"~ Nodeset.In pc s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : a = pc)","proofString":"subst pc.\nrewrite NodesetFacts.not_mem_iff.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : ~ Nodeset.In a s.","conclusion":"~ Nodeset.In a s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"rewrite NodesetFacts.not_mem_iff.\nauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s)) : Nodeset.mem a s = false.","conclusion":"Nodeset.mem a s = false","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc : Nodeset.elt, Nodeset.In pc s'0 <-> Nodeset.In pc s0 \\/ In pc l) /\\\n(forall pc : node, In pc l -> ~ Nodeset.In pc s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc : Nodeset.elt,\nNodeset.In pc s' <-> Nodeset.In pc (Nodeset.add a s) \\/ In pc l) (C : forall pc : node, In pc l -> ~ Nodeset.In pc (Nodeset.add a s))","proofString":"auto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : In pc l) : ~ Nodeset.In pc s.","conclusion":"~ Nodeset.In pc s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : In pc l)","proofString":"generalize (C pc H1).\nrewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : In pc l) : ~ Nodeset.In pc (Nodeset.add a s) -> ~ Nodeset.In pc s.","conclusion":"~ Nodeset.In pc (Nodeset.add a s) -> ~ Nodeset.In pc s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : In pc l)","proofString":"rewrite NodesetFacts.add_iff.\ntauto."},{"statement":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : In pc l) : ~ (a = pc \\/ Nodeset.In pc s) -> ~ Nodeset.In pc s.","conclusion":"~ (a = pc \\/ Nodeset.In pc s) -> ~ Nodeset.In pc s","hypotheses":"(a : node) (l : list node) (IHl : forall s0 s'0 : Nodeset.t,\nnodeset_of_list l s0 = OK s'0 ->\nlist_norepet l /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 s'0 <-> Nodeset.In pc0 s0 \\/ In pc0 l) /\\\n(forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 s0)) (s s' : Nodeset.t) (H : Nodeset.mem a s = false) (H0 : nodeset_of_list l (Nodeset.add a s) = OK s') (A : list_norepet l) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 s' <-> Nodeset.In pc0 (Nodeset.add a s) \\/ In pc0 l) (C : forall pc0 : node, In pc0 l -> ~ Nodeset.In pc0 (Nodeset.add a s)) (pc : node) (H1 : In pc l)","proofString":"tauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) : forall (pc : positive) (i : bblock),\ncheck_reachable f reach s = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s.","conclusion":"forall (pc : positive) (i : bblock),\ncheck_reachable f reach s = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t)","proofString":"assert (forall l ok,    List.fold_left (fun a p => check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->    ok = true /\\    (forall pc i,     In (pc, i) l ->     reach!!pc = true ->     Nodeset.In pc s)).\ninduction l; simpl; intros.\nsplit.\nauto.\nintros.\ndestruct H0.\ndestruct a as [pc1 i1].\nsimpl in H.\nexploit IHl; eauto.\nintros [A B].\nunfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto.\nintros pc i.\nunfold check_reachable.\nrewrite PTree.fold_spec.\nintros.\nexploit H; eauto.\nintros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t)","proofString":"induction l; simpl; intros.\nsplit.\nauto.\nintros.\ndestruct H0.\ndestruct a as [pc1 i1].\nsimpl in H.\nexploit IHl; eauto.\nintros [A B].\nunfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (ok : bool) (H : ok = true) : ok = true.","conclusion":"ok = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (ok : bool) (H : ok = true)","proofString":"auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (ok : bool) (H : ok = true) (pc : node) (i : bblock) (H0 : False) (H1 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (ok : bool) (H : ok = true) (pc : node) (i : bblock) (H0 : False) (H1 : reach !! pc = true)","proofString":"destruct H0."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (a : node * bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a0 : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a0 (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a0 : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a0 (fst p) (snd p)) l\n  (check_reachable_aux reach s ok (fst a) (snd a)) = true) : ok = true /\\\n(forall (pc : node) (i : bblock),\n a = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"ok = true /\\\n(forall (pc : node) (i : bblock),\n a = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (a : node * bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a0 : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a0 (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a0 : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a0 (fst p) (snd p)) l\n  (check_reachable_aux reach s ok (fst a) (snd a)) = true)","proofString":"destruct a as [pc1 i1].\nsimpl in H.\nexploit IHl; eauto.\nintros [A B].\nunfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok (fst (pc1, i1)) (snd (pc1, i1))) = true) : ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok (fst (pc1, i1)) (snd (pc1, i1))) = true)","proofString":"simpl in H.\nexploit IHl; eauto.\nintros [A B].\nunfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) : ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true)","proofString":"exploit IHl; eauto.\nintros [A B].\nunfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) : check_reachable_aux reach s ok pc1 i1 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) ->\nok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"check_reachable_aux reach s ok pc1 i1 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) ->\nok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true)","proofString":"intros [A B].\nunfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : check_reachable_aux reach s ok pc1 i1 = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : check_reachable_aux reach s ok pc1 i1 = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"unfold check_reachable_aux in A.\nsplit.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s).","conclusion":"ok = true /\\\n(forall (pc : node) (i : bblock),\n (pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"split.\ndestruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto.\nintros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : ok = true.","conclusion":"ok = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"destruct (reach!!pc1).\nelim (andb_prop _ _ A).\nauto.\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : ok && Nodeset.mem pc1 s = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : ok = true.","conclusion":"ok = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : ok && Nodeset.mem pc1 s = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"elim (andb_prop _ _ A).\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : ok && Nodeset.mem pc1 s = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : ok = true -> Nodeset.mem pc1 s = true -> ok = true.","conclusion":"ok = true -> Nodeset.mem pc1 s = true -> ok = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : ok && Nodeset.mem pc1 s = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : ok = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : ok = true.","conclusion":"ok = true","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : ok = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s) : forall (pc : node) (i : bblock),\n(pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s.","conclusion":"forall (pc : node) (i : bblock),\n(pc1, i1) = (pc, i) \\/ In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc : node) (i : bblock),\nIn (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)","proofString":"intros.\ndestruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (pc : node) (i : bblock) (H0 : (pc1, i1) = (pc, i) \\/ In (pc, i) l) (H1 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (pc : node) (i : bblock) (H0 : (pc1, i1) = (pc, i) \\/ In (pc, i) l) (H1 : reach !! pc = true)","proofString":"destruct H0.\ninv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (pc : node) (i : bblock) (H0 : (pc1, i1) = (pc, i)) (H1 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (pc : node) (i : bblock) (H0 : (pc1, i1) = (pc, i)) (H1 : reach !! pc = true)","proofString":"inv H0.\nrewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (pc : node) (A : (if reach !! pc then ok && Nodeset.mem pc s else ok) = true) (i : bblock) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc i) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (H1 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (pc : node) (A : (if reach !! pc then ok && Nodeset.mem pc s else ok) = true) (i : bblock) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc i) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (H1 : reach !! pc = true)","proofString":"rewrite H1 in A.\ndestruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (pc : node) (A : ok && Nodeset.mem pc s = true) (i : bblock) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc i) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (H1 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (pc : node) (A : ok && Nodeset.mem pc s = true) (i : bblock) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc i) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (H1 : reach !! pc = true)","proofString":"destruct (andb_prop _ _ A).\napply Nodeset.mem_2; auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (pc : node) (A : ok && Nodeset.mem pc s = true) (i : bblock) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc i) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (H1 : reach !! pc = true) (H0 : ok = true) (H2 : Nodeset.mem pc s = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (pc : node) (A : ok && Nodeset.mem pc s = true) (i : bblock) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc i) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (H1 : reach !! pc = true) (H0 : ok = true) (H2 : Nodeset.mem pc s = true)","proofString":"apply Nodeset.mem_2; auto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (pc : node) (i : bblock) (H0 : In (pc, i) l) (H1 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (pc1 : node) (i1 : bblock) (l : list (node * bblock)) (IHl : forall ok0 : bool,\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok0 = true ->\nok0 = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (ok : bool) (H : fold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l\n  (check_reachable_aux reach s ok pc1 i1) = true) (A : (if reach !! pc1 then ok && Nodeset.mem pc1 s else ok) = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s) (pc : node) (i : bblock) (H0 : In (pc, i) l) (H1 : reach !! pc = true)","proofString":"eauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s)) : forall (pc : positive) (i : bblock),\ncheck_reachable f reach s = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s.","conclusion":"forall (pc : positive) (i : bblock),\ncheck_reachable f reach s = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc : node) (i : bblock),\n In (pc, i) l -> reach !! pc = true -> Nodeset.In pc s))","proofString":"intros pc i.\nunfold check_reachable.\nrewrite PTree.fold_spec.\nintros.\nexploit H; eauto.\nintros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) : check_reachable f reach s = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s.","conclusion":"check_reachable f reach s = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock)","proofString":"unfold check_reachable.\nrewrite PTree.fold_spec.\nintros.\nexploit H; eauto.\nintros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) : PTree.fold (check_reachable_aux reach s) (LTL.fn_code f) true = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s.","conclusion":"PTree.fold (check_reachable_aux reach s) (LTL.fn_code f) true = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock)","proofString":"rewrite PTree.fold_spec.\nintros.\nexploit H; eauto.\nintros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s.","conclusion":"fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true ->\n(LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock)","proofString":"intros.\nexploit H; eauto.\nintros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) (H0 : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true) (H1 : (LTL.fn_code f) ! pc = Some i) (H2 : reach !! pc = true) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) (H0 : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true) (H1 : (LTL.fn_code f) ! pc = Some i) (H2 : reach !! pc = true)","proofString":"exploit H; eauto.\nintros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) (H0 : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true) (H1 : (LTL.fn_code f) ! pc = Some i) (H2 : reach !! pc = true) : true = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) (PTree.elements (LTL.fn_code f)) ->\n reach !! pc0 = true -> Nodeset.In pc0 s) -> Nodeset.In pc s.","conclusion":"true = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) (PTree.elements (LTL.fn_code f)) ->\n reach !! pc0 = true -> Nodeset.In pc0 s) -> Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) (H0 : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true) (H1 : (LTL.fn_code f) ! pc = Some i) (H2 : reach !! pc = true)","proofString":"intros [A B].\neapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) (H0 : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true) (H1 : (LTL.fn_code f) ! pc = Some i) (H2 : reach !! pc = true) (A : true = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) (PTree.elements (LTL.fn_code f)) ->\nreach !! pc0 = true -> Nodeset.In pc0 s) : Nodeset.In pc s.","conclusion":"Nodeset.In pc s","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (s : Nodeset.t) (H : forall (l : list (node * bblock)) (ok : bool),\nfold_left\n  (fun (a : bool) (p : node * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p)) l ok = true ->\nok = true /\\\n(forall (pc0 : node) (i0 : bblock),\n In (pc0, i0) l -> reach !! pc0 = true -> Nodeset.In pc0 s)) (pc : positive) (i : bblock) (H0 : fold_left\n  (fun (a : bool) (p : positive * bblock) =>\n   check_reachable_aux reach s a (fst p) (snd p))\n  (PTree.elements (LTL.fn_code f)) true = true) (H1 : (LTL.fn_code f) ! pc = Some i) (H2 : reach !! pc = true) (A : true = true) (B : forall (pc0 : node) (i0 : bblock),\nIn (pc0, i0) (PTree.elements (LTL.fn_code f)) ->\nreach !! pc0 = true -> Nodeset.In pc0 s)","proofString":"eapply B; eauto.\napply PTree.elements_correct.\neauto."},{"statement":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) : enumerate f = OK enum ->\n(LTL.fn_code f) ! pc = Some i -> (reachable f) !! pc = true -> In pc enum.","conclusion":"enumerate f = OK enum ->\n(LTL.fn_code f) ! pc = Some i -> (reachable f) !! pc = true -> In pc enum","hypotheses":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock)","proofString":"unfold enumerate.\nset (reach := reachable f).\nintros.\nmonadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit check_reachable_correct; eauto.\nintro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) : (do s <- nodeset_of_list (enumerate_aux f (reachable f)) Nodeset.empty;\n if check_reachable f (reachable f) s\n then OK (enumerate_aux f (reachable f))\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum ->\n(LTL.fn_code f) ! pc = Some i -> (reachable f) !! pc = true -> In pc enum.","conclusion":"(do s <- nodeset_of_list (enumerate_aux f (reachable f)) Nodeset.empty;\n if check_reachable f (reachable f) s\n then OK (enumerate_aux f (reachable f))\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum ->\n(LTL.fn_code f) ! pc = Some i -> (reachable f) !! pc = true -> In pc enum","hypotheses":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock)","proofString":"set (reach := reachable f).\nintros.\nmonadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit check_reachable_correct; eauto.\nintro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) (reach : PMap.t bool) : (do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum -> (LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> In pc enum.","conclusion":"(do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum -> (LTL.fn_code f) ! pc = Some i -> reach !! pc = true -> In pc enum","hypotheses":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) (reach : PMap.t bool)","proofString":"intros.\nmonadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit check_reachable_correct; eauto.\nintro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) (reach : PMap.t bool) (H : (do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) : In pc enum.","conclusion":"In pc enum","hypotheses":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) (reach : PMap.t bool) (H : (do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true)","proofString":"monadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit check_reachable_correct; eauto.\nintro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (EQ0 : (if check_reachable f reach x\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum) : In pc enum.","conclusion":"In pc enum","hypotheses":"(f : LTL.function) (enum : list node) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (EQ0 : (if check_reachable f reach x\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum)","proofString":"generalize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit check_reachable_correct; eauto.\nintro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) : In pc (enumerate_aux f reach).","conclusion":"In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true)","proofString":"exploit check_reachable_correct; eauto.\nintro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) : Nodeset.In pc x -> In pc (enumerate_aux f reach).","conclusion":"Nodeset.In pc x -> In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true)","proofString":"intro.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc x) : In pc (enumerate_aux f reach).","conclusion":"In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc x)","proofString":"exploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc x) : list_norepet (enumerate_aux f reach) /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 x <->\n Nodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) /\\\n(forall pc0 : node,\n In pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty) ->\nIn pc (enumerate_aux f reach).","conclusion":"list_norepet (enumerate_aux f reach) /\\\n(forall pc0 : Nodeset.elt,\n Nodeset.In pc0 x <->\n Nodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) /\\\n(forall pc0 : node,\n In pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty) ->\nIn pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc x)","proofString":"intros [A [B C]].\nrewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc x) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty) : In pc (enumerate_aux f reach).","conclusion":"In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc x) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty)","proofString":"rewrite B in H2.\ndestruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc Nodeset.empty \\/ In pc (enumerate_aux f reach)) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty) : In pc (enumerate_aux f reach).","conclusion":"In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc Nodeset.empty \\/ In pc (enumerate_aux f reach)) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty)","proofString":"destruct H2.\nelim (Nodeset.empty_1 H2).\nauto."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc Nodeset.empty) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty) : In pc (enumerate_aux f reach).","conclusion":"In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : Nodeset.In pc Nodeset.empty) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty)","proofString":"elim (Nodeset.empty_1 H2)."},{"statement":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : In pc (enumerate_aux f reach)) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty) : In pc (enumerate_aux f reach).","conclusion":"In pc (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (pc : positive) (i : bblock) (reach : PMap.t bool) (H0 : (LTL.fn_code f) ! pc = Some i) (H1 : reach !! pc = true) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (H2 : In pc (enumerate_aux f reach)) (A : list_norepet (enumerate_aux f reach)) (B : forall pc0 : Nodeset.elt,\nNodeset.In pc0 x <->\nNodeset.In pc0 Nodeset.empty \\/ In pc0 (enumerate_aux f reach)) (C : forall pc0 : node,\nIn pc0 (enumerate_aux f reach) -> ~ Nodeset.In pc0 Nodeset.empty)","proofString":"auto."},{"statement":"(f : LTL.function) (enum : list node) : enumerate f = OK enum -> list_norepet enum.","conclusion":"enumerate f = OK enum -> list_norepet enum","hypotheses":"(f : LTL.function) (enum : list node)","proofString":"unfold enumerate.\nset (reach := reachable f).\nintros.\nmonadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (enum : list node) : (do s <- nodeset_of_list (enumerate_aux f (reachable f)) Nodeset.empty;\n if check_reachable f (reachable f) s\n then OK (enumerate_aux f (reachable f))\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum -> list_norepet enum.","conclusion":"(do s <- nodeset_of_list (enumerate_aux f (reachable f)) Nodeset.empty;\n if check_reachable f (reachable f) s\n then OK (enumerate_aux f (reachable f))\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum -> list_norepet enum","hypotheses":"(f : LTL.function) (enum : list node)","proofString":"set (reach := reachable f).\nintros.\nmonadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (enum : list node) (reach : PMap.t bool) : (do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum -> list_norepet enum.","conclusion":"(do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum -> list_norepet enum","hypotheses":"(f : LTL.function) (enum : list node) (reach : PMap.t bool)","proofString":"intros.\nmonadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (enum : list node) (reach : PMap.t bool) (H : (do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum) : list_norepet enum.","conclusion":"list_norepet enum","hypotheses":"(f : LTL.function) (enum : list node) (reach : PMap.t bool) (H : (do s <- nodeset_of_list (enumerate_aux f reach) Nodeset.empty;\n if check_reachable f reach s\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum)","proofString":"monadInv H.\ngeneralize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (enum : list node) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (EQ0 : (if check_reachable f reach x\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum) : list_norepet enum.","conclusion":"list_norepet enum","hypotheses":"(f : LTL.function) (enum : list node) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (EQ0 : (if check_reachable f reach x\n then OK (enumerate_aux f reach)\n else Error (msg \"Linearize: wrong enumeration\")) = \nOK enum)","proofString":"generalize EQ0; clear EQ0.\ncaseEq (check_reachable f reach x); intros; inv EQ0.\nexploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) : list_norepet (enumerate_aux f reach).","conclusion":"list_norepet (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true)","proofString":"exploit nodeset_of_list_correct; eauto.\nintros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) : list_norepet (enumerate_aux f reach) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc x <->\n Nodeset.In pc Nodeset.empty \\/ In pc (enumerate_aux f reach)) /\\\n(forall pc : node,\n In pc (enumerate_aux f reach) -> ~ Nodeset.In pc Nodeset.empty) ->\nlist_norepet (enumerate_aux f reach).","conclusion":"list_norepet (enumerate_aux f reach) /\\\n(forall pc : Nodeset.elt,\n Nodeset.In pc x <->\n Nodeset.In pc Nodeset.empty \\/ In pc (enumerate_aux f reach)) /\\\n(forall pc : node,\n In pc (enumerate_aux f reach) -> ~ Nodeset.In pc Nodeset.empty) ->\nlist_norepet (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true)","proofString":"intros [A [B C]].\nauto."},{"statement":"(f : LTL.function) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (A : list_norepet (enumerate_aux f reach)) (B : forall pc : Nodeset.elt,\nNodeset.In pc x <->\nNodeset.In pc Nodeset.empty \\/ In pc (enumerate_aux f reach)) (C : forall pc : node,\nIn pc (enumerate_aux f reach) -> ~ Nodeset.In pc Nodeset.empty) : list_norepet (enumerate_aux f reach).","conclusion":"list_norepet (enumerate_aux f reach)","hypotheses":"(f : LTL.function) (reach : PMap.t bool) (x : Nodeset.t) (EQ : nodeset_of_list (enumerate_aux f reach) Nodeset.empty = OK x) (H : check_reachable f reach x = true) (A : list_norepet (enumerate_aux f reach)) (B : forall pc : Nodeset.elt,\nNodeset.In pc x <->\nNodeset.In pc Nodeset.empty \\/ In pc (enumerate_aux f reach)) (C : forall pc : node,\nIn pc (enumerate_aux f reach) -> ~ Nodeset.In pc Nodeset.empty)","proofString":"auto."},{"statement":"(lbl : label) (c1 : list instruction) : forall c3 : code,\nis_tail (Llabel lbl :: c1) nil ->\nunique_labels nil -> find_label lbl nil = Some c3 -> c1 = c3.","conclusion":"forall c3 : code,\nis_tail (Llabel lbl :: c1) nil ->\nunique_labels nil -> find_label lbl nil = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction)","proofString":"simpl; intros; discriminate."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c3 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c3 -> c1 = c3) : forall c3 : code,\nis_tail (Llabel lbl :: c1) (a :: c2) ->\nunique_labels (a :: c2) -> find_label lbl (a :: c2) = Some c3 -> c1 = c3.","conclusion":"forall c3 : code,\nis_tail (Llabel lbl :: c1) (a :: c2) ->\nunique_labels (a :: c2) -> find_label lbl (a :: c2) = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c3 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c3 -> c1 = c3)","proofString":"intros c3 TAIL UNIQ.\nsimpl.\ngeneralize (is_label_correct lbl a).\ncase (is_label lbl a); intro ISLBL.\nsubst a.\nintro.\ninversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto.\ninversion TAIL.\ncongruence.\napply IHc2.\nauto.\ndestruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) : find_label lbl (a :: c2) = Some c3 -> c1 = c3.","conclusion":"find_label lbl (a :: c2) = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2))","proofString":"simpl.\ngeneralize (is_label_correct lbl a).\ncase (is_label lbl a); intro ISLBL.\nsubst a.\nintro.\ninversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto.\ninversion TAIL.\ncongruence.\napply IHc2.\nauto.\ndestruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) : (if is_label lbl a then Some c2 else find_label lbl c2) = Some c3 -> c1 = c3.","conclusion":"(if is_label lbl a then Some c2 else find_label lbl c2) = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2))","proofString":"generalize (is_label_correct lbl a).\ncase (is_label lbl a); intro ISLBL.\nsubst a.\nintro.\ninversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto.\ninversion TAIL.\ncongruence.\napply IHc2.\nauto.\ndestruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) : (if is_label lbl a then a = Llabel lbl else a <> Llabel lbl) ->\n(if is_label lbl a then Some c2 else find_label lbl c2) = Some c3 -> c1 = c3.","conclusion":"(if is_label lbl a then a = Llabel lbl else a <> Llabel lbl) ->\n(if is_label lbl a then Some c2 else find_label lbl c2) = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2))","proofString":"case (is_label lbl a); intro ISLBL.\nsubst a.\nintro.\ninversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto.\ninversion TAIL.\ncongruence.\napply IHc2.\nauto.\ndestruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a = Llabel lbl) : Some c2 = Some c3 -> c1 = c3.","conclusion":"Some c2 = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a = Llabel lbl)","proofString":"subst a.\nintro.\ninversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto."},{"statement":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) : Some c2 = Some c3 -> c1 = c3.","conclusion":"Some c2 = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2))","proofString":"intro.\ninversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto."},{"statement":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) : c1 = c3.","conclusion":"c1 = c3","hypotheses":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3)","proofString":"inversion TAIL.\ncongruence.\nelim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto."},{"statement":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (c : list instruction) (H0 : c = Llabel lbl :: c1) (H2 : c1 = c2) : c2 = c3.","conclusion":"c2 = c3","hypotheses":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (c : list instruction) (H0 : c = Llabel lbl :: c1) (H2 : c1 = c2)","proofString":"congruence."},{"statement":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (i : instruction) (c0 c4 : list instruction) (H2 : is_tail (Llabel lbl :: c1) c2) (H1 : c0 = Llabel lbl :: c1) (H0 : i = Llabel lbl) (H3 : c4 = c2) : c1 = c3.","conclusion":"c1 = c3","hypotheses":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (i : instruction) (c0 c4 : list instruction) (H2 : is_tail (Llabel lbl :: c1) c2) (H1 : c0 = Llabel lbl :: c1) (H0 : i = Llabel lbl) (H3 : c4 = c2)","proofString":"elim UNIQ; intros.\nelim H4.\napply is_tail_in with c1; auto."},{"statement":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (i : instruction) (c0 c4 : list instruction) (H2 : is_tail (Llabel lbl :: c1) c2) (H1 : c0 = Llabel lbl :: c1) (H0 : i = Llabel lbl) (H3 : c4 = c2) (H4 : ~ In (Llabel lbl) c2) (H5 : unique_labels c2) : c1 = c3.","conclusion":"c1 = c3","hypotheses":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (i : instruction) (c0 c4 : list instruction) (H2 : is_tail (Llabel lbl :: c1) c2) (H1 : c0 = Llabel lbl :: c1) (H0 : i = Llabel lbl) (H3 : c4 = c2) (H4 : ~ In (Llabel lbl) c2) (H5 : unique_labels c2)","proofString":"elim H4.\napply is_tail_in with c1; auto."},{"statement":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (i : instruction) (c0 c4 : list instruction) (H2 : is_tail (Llabel lbl :: c1) c2) (H1 : c0 = Llabel lbl :: c1) (H0 : i = Llabel lbl) (H3 : c4 = c2) (H4 : ~ In (Llabel lbl) c2) (H5 : unique_labels c2) : In (Llabel lbl) c2.","conclusion":"In (Llabel lbl) c2","hypotheses":"(lbl : label) (c1 c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (UNIQ : unique_labels (Llabel lbl :: c2)) (TAIL : is_tail (Llabel lbl :: c1) (Llabel lbl :: c2)) (H : Some c2 = Some c3) (i : instruction) (c0 c4 : list instruction) (H2 : is_tail (Llabel lbl :: c1) c2) (H1 : c0 = Llabel lbl :: c1) (H0 : i = Llabel lbl) (H3 : c4 = c2) (H4 : ~ In (Llabel lbl) c2) (H5 : unique_labels c2)","proofString":"apply is_tail_in with c1; auto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) : find_label lbl c2 = Some c3 -> c1 = c3.","conclusion":"find_label lbl c2 = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl)","proofString":"inversion TAIL.\ncongruence.\napply IHc2.\nauto.\ndestruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (c : list instruction) (H : c = Llabel lbl :: c1) (H1 : Llabel lbl = a) (H2 : c1 = c2) : find_label lbl c2 = Some c3 -> c2 = c3.","conclusion":"find_label lbl c2 = Some c3 -> c2 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c0 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c0 -> c1 = c0) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (c : list instruction) (H : c = Llabel lbl :: c1) (H1 : Llabel lbl = a) (H2 : c1 = c2)","proofString":"congruence."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (i : instruction) (c0 c4 : list instruction) (H1 : is_tail (Llabel lbl :: c1) c2) (H0 : c0 = Llabel lbl :: c1) (H : i = a) (H2 : c4 = c2) : find_label lbl c2 = Some c3 -> c1 = c3.","conclusion":"find_label lbl c2 = Some c3 -> c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (i : instruction) (c0 c4 : list instruction) (H1 : is_tail (Llabel lbl :: c1) c2) (H0 : c0 = Llabel lbl :: c1) (H : i = a) (H2 : c4 = c2)","proofString":"apply IHc2.\nauto.\ndestruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (i : instruction) (c0 c4 : list instruction) (H1 : is_tail (Llabel lbl :: c1) c2) (H0 : c0 = Llabel lbl :: c1) (H : i = a) (H2 : c4 = c2) : is_tail (Llabel lbl :: c1) c2.","conclusion":"is_tail (Llabel lbl :: c1) c2","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (i : instruction) (c0 c4 : list instruction) (H1 : is_tail (Llabel lbl :: c1) c2) (H0 : c0 = Llabel lbl :: c1) (H : i = a) (H2 : c4 = c2)","proofString":"auto."},{"statement":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (i : instruction) (c0 c4 : list instruction) (H1 : is_tail (Llabel lbl :: c1) c2) (H0 : c0 = Llabel lbl :: c1) (H : i = a) (H2 : c4 = c2) : unique_labels c2.","conclusion":"unique_labels c2","hypotheses":"(lbl : label) (c1 : list instruction) (a : instruction) (c2 : list instruction) (IHc2 : forall c5 : code,\nis_tail (Llabel lbl :: c1) c2 ->\nunique_labels c2 -> find_label lbl c2 = Some c5 -> c1 = c5) (c3 : code) (TAIL : is_tail (Llabel lbl :: c1) (a :: c2)) (UNIQ : unique_labels (a :: c2)) (ISLBL : a <> Llabel lbl) (i : instruction) (c0 c4 : list instruction) (H1 : is_tail (Llabel lbl :: c1) c2) (H0 : c0 = Llabel lbl :: c1) (H : i = a) (H2 : c4 = c2)","proofString":"destruct a; simpl in UNIQ; tauto."},{"statement":"(lbl : label) : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail nil c2 ->\nunique_labels c2 ->\nstarts_with lbl nil = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp nil ls m) E0 (State s f sp c3 ls m).","conclusion":"forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail nil c2 ->\nunique_labels c2 ->\nstarts_with lbl nil = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp nil ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl : label)","proofString":"simpl; intros; discriminate."},{"statement":"(lbl : label) (a : instruction) (c1 : list instruction) (IHc1 : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail c1 c2 ->\nunique_labels c2 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)) : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail (a :: c1) c2 ->\nunique_labels c2 ->\nstarts_with lbl (a :: c1) = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp (a :: c1) ls m) E0 (State s f sp c3 ls m).","conclusion":"forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail (a :: c1) c2 ->\nunique_labels c2 ->\nstarts_with lbl (a :: c1) = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp (a :: c1) ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl : label) (a : instruction) (c1 : list instruction) (IHc1 : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail c1 c2 ->\nunique_labels c2 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m))","proofString":"simpl starts_with.\ndestruct a; try (intros; discriminate).\nintros.\napply plus_left with E0 (State s f sp c1 ls m) E0.\nsimpl.\nconstructor.\ndestruct (peq lbl l).\nsubst l.\nreplace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto.\napply plus_star.\napply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto.\ntraceEq."},{"statement":"(lbl : label) (a : instruction) (c1 : list instruction) (IHc1 : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail c1 c2 ->\nunique_labels c2 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)) : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail (a :: c1) c2 ->\nunique_labels c2 ->\nmatch a with\n| Llabel lbl' => if peq lbl lbl' then true else starts_with lbl c1\n| _ => false\nend = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp (a :: c1) ls m) E0 (State s f sp c3 ls m).","conclusion":"forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail (a :: c1) c2 ->\nunique_labels c2 ->\nmatch a with\n| Llabel lbl' => if peq lbl lbl' then true else starts_with lbl c1\n| _ => false\nend = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp (a :: c1) ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl : label) (a : instruction) (c1 : list instruction) (IHc1 : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail c1 c2 ->\nunique_labels c2 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m))","proofString":"destruct a; try (intros; discriminate).\nintros.\napply plus_left with E0 (State s f sp c1 ls m) E0.\nsimpl.\nconstructor.\ndestruct (peq lbl l).\nsubst l.\nreplace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto.\napply plus_star.\napply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto.\ntraceEq."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail c1 c2 ->\nunique_labels c2 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)) : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail (Llabel l :: c1) c2 ->\nunique_labels c2 ->\n(if peq lbl l then true else starts_with lbl c1) = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c3 ls m).","conclusion":"forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail (Llabel l :: c1) c2 ->\nunique_labels c2 ->\n(if peq lbl l then true else starts_with lbl c1) = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c2 : list instruction) (c3 : code) (s : list stackframe)\n  (f : function) (sp : val) (ls : locset) (m : mem),\nis_tail c1 c2 ->\nunique_labels c2 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c2 = Some c3 ->\nplus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m))","proofString":"intros.\napply plus_left with E0 (State s f sp c1 ls m) E0.\nsimpl.\nconstructor.\ndestruct (peq lbl l).\nsubst l.\nreplace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto.\napply plus_star.\napply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto.\ntraceEq."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3) : plus step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c3 ls m).","conclusion":"plus step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3)","proofString":"apply plus_left with E0 (State s f sp c1 ls m) E0.\nsimpl.\nconstructor.\ndestruct (peq lbl l).\nsubst l.\nreplace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto.\napply plus_star.\napply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto.\ntraceEq."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3) : step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c1 ls m).","conclusion":"step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c1 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3)","proofString":"simpl.\nconstructor."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3) : step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c1 ls m).","conclusion":"step tge (State s f sp (Llabel l :: c1) ls m) E0 (State s f sp c1 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3)","proofString":"constructor."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3) : star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).","conclusion":"star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3)","proofString":"destruct (peq lbl l).\nsubst l.\nreplace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto.\napply plus_star.\napply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (e : lbl = l) (H1 : true = true) (H2 : find_label lbl c2 = Some c3) : star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).","conclusion":"star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (e : lbl = l) (H1 : true = true) (H2 : find_label lbl c2 = Some c3)","proofString":"subst l.\nreplace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto."},{"statement":"(lbl : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel lbl :: c1) c2) (H0 : unique_labels c2) (H1 : true = true) (H2 : find_label lbl c2 = Some c3) : star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).","conclusion":"star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel lbl :: c1) c2) (H0 : unique_labels c2) (H1 : true = true) (H2 : find_label lbl c2 = Some c3)","proofString":"replace c3 with c1.\nconstructor.\napply find_label_unique with lbl c2; auto."},{"statement":"(lbl : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel lbl :: c1) c2) (H0 : unique_labels c2) (H1 : true = true) (H2 : find_label lbl c2 = Some c3) : star step tge (State s f sp c1 ls m) E0 (State s f sp c1 ls m).","conclusion":"star step tge (State s f sp c1 ls m) E0 (State s f sp c1 ls m)","hypotheses":"(lbl : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel lbl :: c1) c2) (H0 : unique_labels c2) (H1 : true = true) (H2 : find_label lbl c2 = Some c3)","proofString":"constructor."},{"statement":"(lbl : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel lbl :: c1) c2) (H0 : unique_labels c2) (H1 : true = true) (H2 : find_label lbl c2 = Some c3) : c1 = c3.","conclusion":"c1 = c3","hypotheses":"(lbl : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel lbl :: c1) c2) (H0 : unique_labels c2) (H1 : true = true) (H2 : find_label lbl c2 = Some c3)","proofString":"apply find_label_unique with lbl c2; auto."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (n : lbl <> l) (H1 : starts_with lbl c1 = true) (H2 : find_label lbl c2 = Some c3) : star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).","conclusion":"star step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (n : lbl <> l) (H1 : starts_with lbl c1 = true) (H2 : find_label lbl c2 = Some c3)","proofString":"apply plus_star.\napply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (n : lbl <> l) (H1 : starts_with lbl c1 = true) (H2 : find_label lbl c2 = Some c3) : plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).","conclusion":"plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m)","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (n : lbl <> l) (H1 : starts_with lbl c1 = true) (H2 : find_label lbl c2 = Some c3)","proofString":"apply IHc1 with c2; auto.\neapply is_tail_cons_left; eauto."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (n : lbl <> l) (H1 : starts_with lbl c1 = true) (H2 : find_label lbl c2 = Some c3) : is_tail c1 c2.","conclusion":"is_tail c1 c2","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (n : lbl <> l) (H1 : starts_with lbl c1 = true) (H2 : find_label lbl c2 = Some c3)","proofString":"eapply is_tail_cons_left; eauto."},{"statement":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3) : E0 = E0 ** E0.","conclusion":"E0 = E0 ** E0","hypotheses":"(lbl l : label) (c1 : list instruction) (IHc1 : forall (c0 : list instruction) (c4 : code) (s0 : list stackframe)\n  (f0 : function) (sp0 : val) (ls0 : locset) (m0 : mem),\nis_tail c1 c0 ->\nunique_labels c0 ->\nstarts_with lbl c1 = true ->\nfind_label lbl c0 = Some c4 ->\nplus step tge (State s0 f0 sp0 c1 ls0 m0) E0 (State s0 f0 sp0 c4 ls0 m0)) (c2 : list instruction) (c3 : code) (s : list stackframe) (f : function) (sp : val) (ls : locset) (m : mem) (H : is_tail (Llabel l :: c1) c2) (H0 : unique_labels c2) (H1 : (if peq lbl l then true else starts_with lbl c1) = true) (H2 : find_label lbl c2 = Some c3)","proofString":"traceEq."},{"statement":"(lbl : label) (k : code) (s : label) : find_label lbl (add_branch s k) = find_label lbl k.","conclusion":"find_label lbl (add_branch s k) = find_label lbl k","hypotheses":"(lbl : label) (k : code) (s : label)","proofString":"unfold add_branch.\ndestruct (starts_with s k); auto."},{"statement":"(lbl : label) (k : code) (s : label) : find_label lbl (if starts_with s k then k else Lgoto s :: k) =\nfind_label lbl k.","conclusion":"find_label lbl (if starts_with s k then k else Lgoto s :: k) =\nfind_label lbl k","hypotheses":"(lbl : label) (k : code) (s : label)","proofString":"destruct (starts_with s k); auto."},{"statement":"(lbl : label) (k : code) : forall b : bblock, find_label lbl (linearize_block b k) = find_label lbl k.","conclusion":"forall b : bblock, find_label lbl (linearize_block b k) = find_label lbl k","hypotheses":"(lbl : label) (k : code)","proofString":"generalize (find_label_add_branch lbl k); intro.\ninduction b; simpl; auto.\ndestruct a; simpl; auto.\ncase (starts_with s1 k); simpl; auto."},{"statement":"(lbl : label) (k : code) (H : forall s : label, find_label lbl (add_branch s k) = find_label lbl k) : forall b : bblock, find_label lbl (linearize_block b k) = find_label lbl k.","conclusion":"forall b : bblock, find_label lbl (linearize_block b k) = find_label lbl k","hypotheses":"(lbl : label) (k : code) (H : forall s : label, find_label lbl (add_branch s k) = find_label lbl k)","proofString":"induction b; simpl; auto.\ndestruct a; simpl; auto.\ncase (starts_with s1 k); simpl; auto."},{"statement":"(lbl : label) (k : code) (H : forall s : label, find_label lbl (add_branch s k) = find_label lbl k) (a : LTL.instruction) (b : list LTL.instruction) (IHb : find_label lbl (linearize_block b k) = find_label lbl k) : find_label lbl\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b k\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b k\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b k\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b k\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b k\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b k\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: k\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b k\n  | Lbranch s => add_branch s k\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 k\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n      else Lcond cond args s1 :: add_branch s2 k\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: k\n  | LTL.Lreturn => Lreturn :: k\n  end = find_label lbl k.","conclusion":"find_label lbl\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b k\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b k\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b k\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b k\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b k\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b k\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: k\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b k\n  | Lbranch s => add_branch s k\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 k\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n      else Lcond cond args s1 :: add_branch s2 k\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: k\n  | LTL.Lreturn => Lreturn :: k\n  end = find_label lbl k","hypotheses":"(lbl : label) (k : code) (H : forall s : label, find_label lbl (add_branch s k) = find_label lbl k) (a : LTL.instruction) (b : list LTL.instruction) (IHb : find_label lbl (linearize_block b k) = find_label lbl k)","proofString":"destruct a; simpl; auto.\ncase (starts_with s1 k); simpl; auto."},{"statement":"(lbl : label) (k : code) (H : forall s : label, find_label lbl (add_branch s k) = find_label lbl k) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : find_label lbl (linearize_block b k) = find_label lbl k) : find_label lbl\n  (if starts_with s1 k\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n   else Lcond cond args s1 :: add_branch s2 k) = find_label lbl k.","conclusion":"find_label lbl\n  (if starts_with s1 k\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n   else Lcond cond args s1 :: add_branch s2 k) = find_label lbl k","hypotheses":"(lbl : label) (k : code) (H : forall s : label, find_label lbl (add_branch s k) = find_label lbl k) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : find_label lbl (linearize_block b k) = find_label lbl k)","proofString":"case (starts_with s1 k); simpl; auto."},{"statement":"(f : LTL.function) (pc : node) (enum : list node) : linearize_body f (pc :: enum) =\nmatch (LTL.fn_code f) ! pc with\n| Some b => Llabel pc :: linearize_block b (linearize_body f enum)\n| None => linearize_body f enum\nend.","conclusion":"linearize_body f (pc :: enum) =\nmatch (LTL.fn_code f) ! pc with\n| Some b => Llabel pc :: linearize_block b (linearize_body f enum)\n| None => linearize_body f enum\nend","hypotheses":"(f : LTL.function) (pc : node) (enum : list node)","proofString":"unfold linearize_body.\nrewrite list_fold_right_eq.\nunfold linearize_node.\ndestruct (LTL.fn_code f)!pc; auto."},{"statement":"(f : LTL.function) (pc : node) (enum : list node) : list_fold_right (linearize_node f) (pc :: enum) nil =\nmatch (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b (list_fold_right (linearize_node f) enum nil)\n| None => list_fold_right (linearize_node f) enum nil\nend.","conclusion":"list_fold_right (linearize_node f) (pc :: enum) nil =\nmatch (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b (list_fold_right (linearize_node f) enum nil)\n| None => list_fold_right (linearize_node f) enum nil\nend","hypotheses":"(f : LTL.function) (pc : node) (enum : list node)","proofString":"rewrite list_fold_right_eq.\nunfold linearize_node.\ndestruct (LTL.fn_code f)!pc; auto."},{"statement":"(f : LTL.function) (pc : node) (enum : list node) : linearize_node f pc (list_fold_right (linearize_node f) enum nil) =\nmatch (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b (list_fold_right (linearize_node f) enum nil)\n| None => list_fold_right (linearize_node f) enum nil\nend.","conclusion":"linearize_node f pc (list_fold_right (linearize_node f) enum nil) =\nmatch (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b (list_fold_right (linearize_node f) enum nil)\n| None => list_fold_right (linearize_node f) enum nil\nend","hypotheses":"(f : LTL.function) (pc : node) (enum : list node)","proofString":"unfold linearize_node.\ndestruct (LTL.fn_code f)!pc; auto."},{"statement":"(f : LTL.function) (pc : node) (enum : list node) : match (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b\n         (list_fold_right\n            (fun (pc0 : node) (k : code) =>\n             match (LTL.fn_code f) ! pc0 with\n             | Some b0 => Llabel pc0 :: linearize_block b0 k\n             | None => k\n             end) enum nil)\n| None =>\n    list_fold_right\n      (fun (pc0 : node) (k : code) =>\n       match (LTL.fn_code f) ! pc0 with\n       | Some b => Llabel pc0 :: linearize_block b k\n       | None => k\n       end) enum nil\nend =\nmatch (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b\n         (list_fold_right\n            (fun (pc0 : node) (k : code) =>\n             match (LTL.fn_code f) ! pc0 with\n             | Some b0 => Llabel pc0 :: linearize_block b0 k\n             | None => k\n             end) enum nil)\n| None =>\n    list_fold_right\n      (fun (pc0 : node) (k : code) =>\n       match (LTL.fn_code f) ! pc0 with\n       | Some b => Llabel pc0 :: linearize_block b k\n       | None => k\n       end) enum nil\nend.","conclusion":"match (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b\n         (list_fold_right\n            (fun (pc0 : node) (k : code) =>\n             match (LTL.fn_code f) ! pc0 with\n             | Some b0 => Llabel pc0 :: linearize_block b0 k\n             | None => k\n             end) enum nil)\n| None =>\n    list_fold_right\n      (fun (pc0 : node) (k : code) =>\n       match (LTL.fn_code f) ! pc0 with\n       | Some b => Llabel pc0 :: linearize_block b k\n       | None => k\n       end) enum nil\nend =\nmatch (LTL.fn_code f) ! pc with\n| Some b =>\n    Llabel pc\n    :: linearize_block b\n         (list_fold_right\n            (fun (pc0 : node) (k : code) =>\n             match (LTL.fn_code f) ! pc0 with\n             | Some b0 => Llabel pc0 :: linearize_block b0 k\n             | None => k\n             end) enum nil)\n| None =>\n    list_fold_right\n      (fun (pc0 : node) (k : code) =>\n       match (LTL.fn_code f) ! pc0 with\n       | Some b => Llabel pc0 :: linearize_block b k\n       | None => k\n       end) enum nil\nend","hypotheses":"(f : LTL.function) (pc : node) (enum : list node)","proofString":"destruct (LTL.fn_code f)!pc; auto."},{"statement":"(f : LTL.function) (pc : positive) (b : bblock) (H : In pc nil) (H0 : (LTL.fn_code f) ! pc = Some b) : exists k : code,\n  find_label pc (linearize_body f nil) = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc (linearize_body f nil) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (pc : positive) (b : bblock) (H : In pc nil) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"elim H."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : exists k : code,\n  find_label pc (linearize_body f (a :: enum)) = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc (linearize_body f (a :: enum)) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"rewrite linearize_body_cons.\ndestruct (peq a pc).\nsubst a.\nexists (linearize_body f enum).\nrewrite H0.\nsimpl.\nrewrite peq_true.\nauto.\nassert (In pc enum).\nsimpl in H.\ntauto.\ndestruct (IHenum pc b H1 H0) as [k FIND].\nexists k.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"destruct (peq a pc).\nsubst a.\nexists (linearize_body f enum).\nrewrite H0.\nsimpl.\nrewrite peq_true.\nauto.\nassert (In pc enum).\nsimpl in H.\ntauto.\ndestruct (IHenum pc b H1 H0) as [k FIND].\nexists k.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (e : a = pc) : exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (e : a = pc)","proofString":"subst a.\nexists (linearize_body f enum).\nrewrite H0.\nsimpl.\nrewrite peq_true.\nauto."},{"statement":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! pc with\n    | Some b0 => Llabel pc :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! pc with\n    | Some b0 => Llabel pc :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"exists (linearize_body f enum).\nrewrite H0.\nsimpl.\nrewrite peq_true.\nauto."},{"statement":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : find_label pc\n  match (LTL.fn_code f) ! pc with\n  | Some b0 => Llabel pc :: linearize_block b0 (linearize_body f enum)\n  | None => linearize_body f enum\n  end = Some (linearize_block b (linearize_body f enum)).","conclusion":"find_label pc\n  match (LTL.fn_code f) ! pc with\n  | Some b0 => Llabel pc :: linearize_block b0 (linearize_body f enum)\n  | None => linearize_body f enum\n  end = Some (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"rewrite H0.\nsimpl.\nrewrite peq_true.\nauto."},{"statement":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : find_label pc (Llabel pc :: linearize_block b (linearize_body f enum)) =\nSome (linearize_block b (linearize_body f enum)).","conclusion":"find_label pc (Llabel pc :: linearize_block b (linearize_body f enum)) =\nSome (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"simpl.\nrewrite peq_true.\nauto."},{"statement":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : (if if peq pc pc then true else false\n then Some (linearize_block b (linearize_body f enum))\n else find_label pc (linearize_block b (linearize_body f enum))) =\nSome (linearize_block b (linearize_body f enum)).","conclusion":"(if if peq pc pc then true else false\n then Some (linearize_block b (linearize_body f enum))\n else find_label pc (linearize_block b (linearize_body f enum))) =\nSome (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"rewrite peq_true.\nauto."},{"statement":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) : Some (linearize_block b (linearize_body f enum)) =\nSome (linearize_block b (linearize_body f enum)).","conclusion":"Some (linearize_block b (linearize_body f enum)) =\nSome (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (pc :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b)","proofString":"auto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) : exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc)","proofString":"assert (In pc enum).\nsimpl in H.\ntauto.\ndestruct (IHenum pc b H1 H0) as [k FIND].\nexists k.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) : In pc enum.","conclusion":"In pc enum","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc)","proofString":"simpl in H.\ntauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : a = pc \\/ In pc enum) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) : In pc enum.","conclusion":"In pc enum","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : a = pc \\/ In pc enum) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc)","proofString":"tauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) : exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum)","proofString":"destruct (IHenum pc b H1 H0) as [k FIND].\nexists k.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) : exists k0 : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k0).","conclusion":"exists k0 : code,\n  find_label pc\n    match (LTL.fn_code f) ! a with\n    | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n    | None => linearize_body f enum\n    end = Some (linearize_block b k0)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k))","proofString":"exists k.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) : find_label pc\n  match (LTL.fn_code f) ! a with\n  | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n  | None => linearize_body f enum\n  end = Some (linearize_block b k).","conclusion":"find_label pc\n  match (LTL.fn_code f) ! a with\n  | Some b0 => Llabel a :: linearize_block b0 (linearize_body f enum)\n  | None => linearize_body f enum\n  end = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k))","proofString":"destruct (LTL.fn_code f)!a.\nsimpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock) : find_label pc (Llabel a :: linearize_block b0 (linearize_body f enum)) =\nSome (linearize_block b k).","conclusion":"find_label pc (Llabel a :: linearize_block b0 (linearize_body f enum)) =\nSome (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock)","proofString":"simpl.\nrewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock) : (if if peq pc a then true else false\n then Some (linearize_block b0 (linearize_body f enum))\n else find_label pc (linearize_block b0 (linearize_body f enum))) =\nSome (linearize_block b k).","conclusion":"(if if peq pc a then true else false\n then Some (linearize_block b0 (linearize_body f enum))\n else find_label pc (linearize_block b0 (linearize_body f enum))) =\nSome (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock)","proofString":"rewrite peq_false.\nrewrite find_label_lin_block.\nauto.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock) : find_label pc (linearize_block b0 (linearize_body f enum)) =\nSome (linearize_block b k).","conclusion":"find_label pc (linearize_block b0 (linearize_body f enum)) =\nSome (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock)","proofString":"rewrite find_label_lin_block.\nauto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock) : find_label pc (linearize_body f enum) = Some (linearize_block b k).","conclusion":"find_label pc (linearize_body f enum) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock)","proofString":"auto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock) : pc <> a.","conclusion":"pc <> a","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b1 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b1 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b1 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) (b0 : bblock)","proofString":"auto."},{"statement":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k)) : find_label pc (linearize_body f enum) = Some (linearize_block b k).","conclusion":"find_label pc (linearize_body f enum) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (a : positive) (enum : list positive) (IHenum : forall (pc0 : positive) (b0 : bblock),\nIn pc0 enum ->\n(LTL.fn_code f) ! pc0 = Some b0 ->\nexists k0 : code,\n  find_label pc0 (linearize_body f enum) = Some (linearize_block b0 k0)) (pc : positive) (b : bblock) (H : In pc (a :: enum)) (H0 : (LTL.fn_code f) ! pc = Some b) (n : a <> pc) (H1 : In pc enum) (k : code) (FIND : find_label pc (linearize_body f enum) = Some (linearize_block b k))","proofString":"auto."},{"statement":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) : exists k : code, find_label pc (fn_code tf) = Some (linearize_block b k).","conclusion":"exists k : code, find_label pc (fn_code tf) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true)","proofString":"monadInv H.\nsimpl.\nrewrite find_label_add_branch.\napply find_label_lin_rec.\neapply enumerate_complete; eauto.\nauto."},{"statement":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x) : exists k : code,\n  find_label pc\n    (fn_code\n       {|\n         fn_sig := LTL.fn_sig f;\n         fn_stacksize := LTL.fn_stacksize f;\n         fn_code := add_branch (fn_entrypoint f) (linearize_body f x)\n       |}) = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc\n    (fn_code\n       {|\n         fn_sig := LTL.fn_sig f;\n         fn_stacksize := LTL.fn_stacksize f;\n         fn_code := add_branch (fn_entrypoint f) (linearize_body f x)\n       |}) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x)","proofString":"simpl.\nrewrite find_label_add_branch.\napply find_label_lin_rec.\neapply enumerate_complete; eauto.\nauto."},{"statement":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x) : exists k : code,\n  find_label pc (add_branch (fn_entrypoint f) (linearize_body f x)) =\n  Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc (add_branch (fn_entrypoint f) (linearize_body f x)) =\n  Some (linearize_block b k)","hypotheses":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x)","proofString":"rewrite find_label_add_branch.\napply find_label_lin_rec.\neapply enumerate_complete; eauto.\nauto."},{"statement":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x) : exists k : code,\n  find_label pc (linearize_body f x) = Some (linearize_block b k).","conclusion":"exists k : code,\n  find_label pc (linearize_body f x) = Some (linearize_block b k)","hypotheses":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x)","proofString":"apply find_label_lin_rec.\neapply enumerate_complete; eauto.\nauto."},{"statement":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x) : In pc x.","conclusion":"In pc x","hypotheses":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x)","proofString":"eapply enumerate_complete; eauto."},{"statement":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x) : (LTL.fn_code f) ! pc = Some b.","conclusion":"(LTL.fn_code f) ! pc = Some b","hypotheses":"(f : LTL.function) (pc : positive) (b : bblock) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (x : list node) (EQ : enumerate f = OK x)","proofString":"auto."},{"statement":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k) : exists k' : code, k = linearize_block b k'.","conclusion":"exists k' : code, k = linearize_block b k'","hypotheses":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k)","proofString":"exploit find_label_lin; eauto.\nintros [k' FIND].\nexists k'.\ncongruence."},{"statement":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k) : (exists k0 : code, find_label pc (fn_code tf) = Some (linearize_block b k0)) ->\nexists k' : code, k = linearize_block b k'.","conclusion":"(exists k0 : code, find_label pc (fn_code tf) = Some (linearize_block b k0)) ->\nexists k' : code, k = linearize_block b k'","hypotheses":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k)","proofString":"intros [k' FIND].\nexists k'.\ncongruence."},{"statement":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k) (k' : code) (FIND : find_label pc (fn_code tf) = Some (linearize_block b k')) : exists k'0 : code, k = linearize_block b k'0.","conclusion":"exists k'0 : code, k = linearize_block b k'0","hypotheses":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k) (k' : code) (FIND : find_label pc (fn_code tf) = Some (linearize_block b k'))","proofString":"exists k'.\ncongruence."},{"statement":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k) (k' : code) (FIND : find_label pc (fn_code tf) = Some (linearize_block b k')) : k = linearize_block b k'.","conclusion":"k = linearize_block b k'","hypotheses":"(f : LTL.function) (tf : function) (pc : positive) (b : bblock) (k : code) (H : transf_function f = OK tf) (H0 : (LTL.fn_code f) ! pc = Some b) (H1 : (reachable f) !! pc = true) (H2 : find_label pc (fn_code tf) = Some k) (k' : code) (FIND : find_label pc (fn_code tf) = Some (linearize_block b k'))","proofString":"congruence."},{"statement":"(lbl s : label) (k : code) : In (Llabel lbl) (if starts_with s k then k else Lgoto s :: k) ->\nIn (Llabel lbl) k.","conclusion":"In (Llabel lbl) (if starts_with s k then k else Lgoto s :: k) ->\nIn (Llabel lbl) k","hypotheses":"(lbl s : label) (k : code)","proofString":"destruct (starts_with s k); simpl; intuition congruence."},{"statement":"(lbl : label) (k : code) (H : In (Llabel lbl) k) : In (Llabel lbl) k.","conclusion":"In (Llabel lbl) k","hypotheses":"(lbl : label) (k : code) (H : In (Llabel lbl) k)","proofString":"auto."},{"statement":"(lbl : label) (k : code) (a : LTL.instruction) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : In (Llabel lbl)\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b k\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b k\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b k\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b k\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b k\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b k\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: k\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b k\n  | Lbranch s => add_branch s k\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 k\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n      else Lcond cond args s1 :: add_branch s2 k\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: k\n  | LTL.Lreturn => Lreturn :: k\n  end) : In (Llabel lbl) k.","conclusion":"In (Llabel lbl) k","hypotheses":"(lbl : label) (k : code) (a : LTL.instruction) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : In (Llabel lbl)\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b k\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b k\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b k\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b k\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b k\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b k\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: k\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b k\n  | Lbranch s => add_branch s k\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 k\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n      else Lcond cond args s1 :: add_branch s2 k\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: k\n  | LTL.Lreturn => Lreturn :: k\n  end)","proofString":"destruct a; simpl in H; try (intuition congruence).\napply label_in_add_branch with s; intuition congruence.\ndestruct (starts_with s1 k); simpl in H.\napply label_in_add_branch with s1; intuition congruence.\napply label_in_add_branch with s2; intuition congruence."},{"statement":"(lbl : label) (k : code) (s : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : In (Llabel lbl) (add_branch s k)) : In (Llabel lbl) k.","conclusion":"In (Llabel lbl) k","hypotheses":"(lbl : label) (k : code) (s : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : In (Llabel lbl) (add_branch s k))","proofString":"apply label_in_add_branch with s; intuition congruence."},{"statement":"(lbl : label) (k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : In (Llabel lbl)\n  (if starts_with s1 k\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n   else Lcond cond args s1 :: add_branch s2 k)) : In (Llabel lbl) k.","conclusion":"In (Llabel lbl) k","hypotheses":"(lbl : label) (k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : In (Llabel lbl)\n  (if starts_with s1 k\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n   else Lcond cond args s1 :: add_branch s2 k))","proofString":"destruct (starts_with s1 k); simpl in H.\napply label_in_add_branch with s1; intuition congruence.\napply label_in_add_branch with s2; intuition congruence."},{"statement":"(lbl : label) (k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : Lcond (negate_condition cond) args s2 = Llabel lbl \\/\nIn (Llabel lbl) (add_branch s1 k)) : In (Llabel lbl) k.","conclusion":"In (Llabel lbl) k","hypotheses":"(lbl : label) (k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : Lcond (negate_condition cond) args s2 = Llabel lbl \\/\nIn (Llabel lbl) (add_branch s1 k))","proofString":"apply label_in_add_branch with s1; intuition congruence."},{"statement":"(lbl : label) (k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : Lcond cond args s1 = Llabel lbl \\/ In (Llabel lbl) (add_branch s2 k)) : In (Llabel lbl) k.","conclusion":"In (Llabel lbl) k","hypotheses":"(lbl : label) (k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k) (H : Lcond cond args s1 = Llabel lbl \\/ In (Llabel lbl) (add_branch s2 k))","proofString":"apply label_in_add_branch with s2; intuition congruence."},{"statement":"(f : LTL.function) (lbl : label) : In (Llabel lbl) (linearize_body f nil) -> In lbl nil.","conclusion":"In (Llabel lbl) (linearize_body f nil) -> In lbl nil","hypotheses":"(f : LTL.function) (lbl : label)","proofString":"simpl; auto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) : In (Llabel lbl) (linearize_body f (a :: enum)) -> In lbl (a :: enum).","conclusion":"In (Llabel lbl) (linearize_body f (a :: enum)) -> In lbl (a :: enum)","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum)","proofString":"rewrite linearize_body_cons.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nintros [A|B].\nleft; congruence.\nright.\napply IHenum.\neapply label_in_lin_block; eauto.\nintro; right; auto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) : In (Llabel lbl)\n  match (LTL.fn_code f) ! a with\n  | Some b => Llabel a :: linearize_block b (linearize_body f enum)\n  | None => linearize_body f enum\n  end -> In lbl (a :: enum).","conclusion":"In (Llabel lbl)\n  match (LTL.fn_code f) ! a with\n  | Some b => Llabel a :: linearize_block b (linearize_body f enum)\n  | None => linearize_body f enum\n  end -> In lbl (a :: enum)","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum)","proofString":"destruct (LTL.fn_code f)!a.\nsimpl.\nintros [A|B].\nleft; congruence.\nright.\napply IHenum.\neapply label_in_lin_block; eauto.\nintro; right; auto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) : In (Llabel lbl) (Llabel a :: linearize_block b (linearize_body f enum)) ->\nIn lbl (a :: enum).","conclusion":"In (Llabel lbl) (Llabel a :: linearize_block b (linearize_body f enum)) ->\nIn lbl (a :: enum)","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock)","proofString":"simpl.\nintros [A|B].\nleft; congruence.\nright.\napply IHenum.\neapply label_in_lin_block; eauto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) : Llabel a = Llabel lbl \\/\nIn (Llabel lbl) (linearize_block b (linearize_body f enum)) ->\na = lbl \\/ In lbl enum.","conclusion":"Llabel a = Llabel lbl \\/\nIn (Llabel lbl) (linearize_block b (linearize_body f enum)) ->\na = lbl \\/ In lbl enum","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock)","proofString":"intros [A|B].\nleft; congruence.\nright.\napply IHenum.\neapply label_in_lin_block; eauto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (A : Llabel a = Llabel lbl) : a = lbl \\/ In lbl enum.","conclusion":"a = lbl \\/ In lbl enum","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (A : Llabel a = Llabel lbl)","proofString":"left; congruence."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (B : In (Llabel lbl) (linearize_block b (linearize_body f enum))) : a = lbl \\/ In lbl enum.","conclusion":"a = lbl \\/ In lbl enum","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (B : In (Llabel lbl) (linearize_block b (linearize_body f enum)))","proofString":"right.\napply IHenum.\neapply label_in_lin_block; eauto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (B : In (Llabel lbl) (linearize_block b (linearize_body f enum))) : In lbl enum.","conclusion":"In lbl enum","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (B : In (Llabel lbl) (linearize_block b (linearize_body f enum)))","proofString":"apply IHenum.\neapply label_in_lin_block; eauto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (B : In (Llabel lbl) (linearize_block b (linearize_body f enum))) : In (Llabel lbl) (linearize_body f enum).","conclusion":"In (Llabel lbl) (linearize_body f enum)","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) (b : bblock) (B : In (Llabel lbl) (linearize_block b (linearize_body f enum)))","proofString":"eapply label_in_lin_block; eauto."},{"statement":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum) : In (Llabel lbl) (linearize_body f enum) -> In lbl (a :: enum).","conclusion":"In (Llabel lbl) (linearize_body f enum) -> In lbl (a :: enum)","hypotheses":"(f : LTL.function) (lbl : label) (a : node) (enum : list node) (IHenum : In (Llabel lbl) (linearize_body f enum) -> In lbl enum)","proofString":"intro; right; auto."},{"statement":"(lbl : label) (k : code) (H : unique_labels k) : unique_labels (if starts_with lbl k then k else Lgoto lbl :: k).","conclusion":"unique_labels (if starts_with lbl k then k else Lgoto lbl :: k)","hypotheses":"(lbl : label) (k : code) (H : unique_labels k)","proofString":"destruct (starts_with lbl k); simpl; intuition."},{"statement":"(k : code) (H : unique_labels k) : unique_labels k.","conclusion":"unique_labels k","hypotheses":"(k : code) (H : unique_labels k)","proofString":"auto."},{"statement":"(k : code) (a : LTL.instruction) (b : list LTL.instruction) (IHb : unique_labels k -> unique_labels (linearize_block b k)) (H : unique_labels k) : unique_labels\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b k\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b k\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b k\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b k\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b k\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b k\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: k\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b k\n  | Lbranch s => add_branch s k\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 k\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n      else Lcond cond args s1 :: add_branch s2 k\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: k\n  | LTL.Lreturn => Lreturn :: k\n  end.","conclusion":"unique_labels\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b k\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b k\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b k\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b k\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b k\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b k\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: k\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b k\n  | Lbranch s => add_branch s k\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 k\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n      else Lcond cond args s1 :: add_branch s2 k\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: k\n  | LTL.Lreturn => Lreturn :: k\n  end","hypotheses":"(k : code) (a : LTL.instruction) (b : list LTL.instruction) (IHb : unique_labels k -> unique_labels (linearize_block b k)) (H : unique_labels k)","proofString":"destruct a; auto; try (apply unique_labels_add_branch; auto).\ncase (starts_with s1 k); simpl; apply unique_labels_add_branch; auto."},{"statement":"(k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : unique_labels k -> unique_labels (linearize_block b k)) (H : unique_labels k) : unique_labels\n  (if starts_with s1 k\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n   else Lcond cond args s1 :: add_branch s2 k).","conclusion":"unique_labels\n  (if starts_with s1 k\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 k\n   else Lcond cond args s1 :: add_branch s2 k)","hypotheses":"(k : code) (cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : unique_labels k -> unique_labels (linearize_block b k)) (H : unique_labels k)","proofString":"case (starts_with s1 k); simpl; apply unique_labels_add_branch; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) : list_norepet (a :: enum) -> unique_labels (linearize_body f (a :: enum)).","conclusion":"list_norepet (a :: enum) -> unique_labels (linearize_body f (a :: enum))","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum))","proofString":"rewrite linearize_body_cons.\nintro.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nsplit.\nred.\nintro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto.\napply unique_labels_lin_block.\napply IHenum.\ninversion H; auto.\napply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) : list_norepet (a :: enum) ->\nunique_labels\n  match (LTL.fn_code f) ! a with\n  | Some b => Llabel a :: linearize_block b (linearize_body f enum)\n  | None => linearize_body f enum\n  end.","conclusion":"list_norepet (a :: enum) ->\nunique_labels\n  match (LTL.fn_code f) ! a with\n  | Some b => Llabel a :: linearize_block b (linearize_body f enum)\n  | None => linearize_body f enum\n  end","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum))","proofString":"intro.\ndestruct (LTL.fn_code f)!a.\nsimpl.\nsplit.\nred.\nintro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto.\napply unique_labels_lin_block.\napply IHenum.\ninversion H; auto.\napply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) : unique_labels\n  match (LTL.fn_code f) ! a with\n  | Some b => Llabel a :: linearize_block b (linearize_body f enum)\n  | None => linearize_body f enum\n  end.","conclusion":"unique_labels\n  match (LTL.fn_code f) ! a with\n  | Some b => Llabel a :: linearize_block b (linearize_body f enum)\n  | None => linearize_body f enum\n  end","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum))","proofString":"destruct (LTL.fn_code f)!a.\nsimpl.\nsplit.\nred.\nintro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto.\napply unique_labels_lin_block.\napply IHenum.\ninversion H; auto.\napply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : unique_labels (Llabel a :: linearize_block b (linearize_body f enum)).","conclusion":"unique_labels (Llabel a :: linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"simpl.\nsplit.\nred.\nintro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto.\napply unique_labels_lin_block.\napply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : ~ In (Llabel a) (linearize_block b (linearize_body f enum)) /\\\nunique_labels (linearize_block b (linearize_body f enum)).","conclusion":"~ In (Llabel a) (linearize_block b (linearize_body f enum)) /\\\nunique_labels (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"split.\nred.\nintro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto.\napply unique_labels_lin_block.\napply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : ~ In (Llabel a) (linearize_block b (linearize_body f enum)).","conclusion":"~ In (Llabel a) (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"red.\nintro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : In (Llabel a) (linearize_block b (linearize_body f enum)) -> False.","conclusion":"In (Llabel a) (linearize_block b (linearize_body f enum)) -> False","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"intro.\ninversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) : False.","conclusion":"False","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum)))","proofString":"inversion H.\nelim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum) : False.","conclusion":"False","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum)","proofString":"elim H3.\napply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum) : In a enum.","conclusion":"In a enum","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum)","proofString":"apply label_in_lin_rec with f.\napply label_in_lin_block with b.\nauto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum) : In (Llabel a) (linearize_body f enum).","conclusion":"In (Llabel a) (linearize_body f enum)","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum)","proofString":"apply label_in_lin_block with b.\nauto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum) : In (Llabel a) (linearize_block b (linearize_body f enum)).","conclusion":"In (Llabel a) (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) (H0 : In (Llabel a) (linearize_block b (linearize_body f enum))) (hd : node) (tl : list node) (H3 : ~ In a enum) (H4 : list_norepet enum) (H1 : hd = a) (H2 : tl = enum)","proofString":"auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : unique_labels (linearize_block b (linearize_body f enum)).","conclusion":"unique_labels (linearize_block b (linearize_body f enum))","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"apply unique_labels_lin_block.\napply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : unique_labels (linearize_body f enum).","conclusion":"unique_labels (linearize_body f enum)","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"apply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock) : list_norepet enum.","conclusion":"list_norepet enum","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) (b : bblock)","proofString":"inversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) : unique_labels (linearize_body f enum).","conclusion":"unique_labels (linearize_body f enum)","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum))","proofString":"apply IHenum.\ninversion H; auto."},{"statement":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum)) : list_norepet enum.","conclusion":"list_norepet enum","hypotheses":"(f : LTL.function) (a : node) (enum : list node) (IHenum : list_norepet enum -> unique_labels (linearize_body f enum)) (H : list_norepet (a :: enum))","proofString":"inversion H; auto."},{"statement":"(f : LTL.function) (tf : function) (H : transf_function f = OK tf) : unique_labels (fn_code tf).","conclusion":"unique_labels (fn_code tf)","hypotheses":"(f : LTL.function) (tf : function) (H : transf_function f = OK tf)","proofString":"monadInv H.\nsimpl.\napply unique_labels_add_branch.\napply unique_labels_lin_rec.\neapply enumerate_norepet; eauto."},{"statement":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x) : unique_labels\n  (fn_code\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x)\n     |}).","conclusion":"unique_labels\n  (fn_code\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x)\n     |})","hypotheses":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x)","proofString":"simpl.\napply unique_labels_add_branch.\napply unique_labels_lin_rec.\neapply enumerate_norepet; eauto."},{"statement":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x) : unique_labels (add_branch (fn_entrypoint f) (linearize_body f x)).","conclusion":"unique_labels (add_branch (fn_entrypoint f) (linearize_body f x))","hypotheses":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x)","proofString":"apply unique_labels_add_branch.\napply unique_labels_lin_rec.\neapply enumerate_norepet; eauto."},{"statement":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x) : unique_labels (linearize_body f x).","conclusion":"unique_labels (linearize_body f x)","hypotheses":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x)","proofString":"apply unique_labels_lin_rec.\neapply enumerate_norepet; eauto."},{"statement":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x) : list_norepet x.","conclusion":"list_norepet x","hypotheses":"(f : LTL.function) (x : list node) (EQ : enumerate f = OK x)","proofString":"eapply enumerate_norepet; eauto."},{"statement":"(lbl : label) (c2 : code) : None = Some c2 -> is_tail c2 nil.","conclusion":"None = Some c2 -> is_tail c2 nil","hypotheses":"(lbl : label) (c2 : code)","proofString":"intros; discriminate."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) : (if is_label lbl a then Some c1 else find_label lbl c1) = Some c2 ->\nis_tail c2 (a :: c1).","conclusion":"(if is_label lbl a then Some c1 else find_label lbl c1) = Some c2 ->\nis_tail c2 (a :: c1)","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1)","proofString":"case (is_label lbl a).\nintro.\ninjection H; intro.\nsubst c2.\nconstructor.\nconstructor.\nintro.\nconstructor.\nauto."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) : Some c1 = Some c2 -> is_tail c2 (a :: c1).","conclusion":"Some c1 = Some c2 -> is_tail c2 (a :: c1)","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1)","proofString":"intro.\ninjection H; intro.\nsubst c2.\nconstructor.\nconstructor."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : Some c1 = Some c2) : is_tail c2 (a :: c1).","conclusion":"is_tail c2 (a :: c1)","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : Some c1 = Some c2)","proofString":"injection H; intro.\nsubst c2.\nconstructor.\nconstructor."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : Some c1 = Some c2) (H0 : c1 = c2) : is_tail c2 (a :: c1).","conclusion":"is_tail c2 (a :: c1)","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : Some c1 = Some c2) (H0 : c1 = c2)","proofString":"subst c2.\nconstructor.\nconstructor."},{"statement":"(lbl : label) (a : instruction) (c1 : list instruction) (H : Some c1 = Some c1) (IHc1 : find_label lbl c1 = Some c1 -> is_tail c1 c1) : is_tail c1 (a :: c1).","conclusion":"is_tail c1 (a :: c1)","hypotheses":"(lbl : label) (a : instruction) (c1 : list instruction) (H : Some c1 = Some c1) (IHc1 : find_label lbl c1 = Some c1 -> is_tail c1 c1)","proofString":"constructor.\nconstructor."},{"statement":"(lbl : label) (a : instruction) (c1 : list instruction) (H : Some c1 = Some c1) (IHc1 : find_label lbl c1 = Some c1 -> is_tail c1 c1) : is_tail c1 c1.","conclusion":"is_tail c1 c1","hypotheses":"(lbl : label) (a : instruction) (c1 : list instruction) (H : Some c1 = Some c1) (IHc1 : find_label lbl c1 = Some c1 -> is_tail c1 c1)","proofString":"constructor."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) : find_label lbl c1 = Some c2 -> is_tail c2 (a :: c1).","conclusion":"find_label lbl c1 = Some c2 -> is_tail c2 (a :: c1)","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1)","proofString":"intro.\nconstructor.\nauto."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : find_label lbl c1 = Some c2) : is_tail c2 (a :: c1).","conclusion":"is_tail c2 (a :: c1)","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : find_label lbl c1 = Some c2)","proofString":"constructor.\nauto."},{"statement":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : find_label lbl c1 = Some c2) : is_tail c2 c1.","conclusion":"is_tail c2 c1","hypotheses":"(lbl : label) (c2 : code) (a : instruction) (c1 : list instruction) (IHc1 : find_label lbl c1 = Some c2 -> is_tail c2 c1) (H : find_label lbl c1 = Some c2)","proofString":"auto."},{"statement":"(lbl : label) (c1 : code) (c2 : list instruction) : is_tail (add_branch lbl c1) c2 -> is_tail c1 c2.","conclusion":"is_tail (add_branch lbl c1) c2 -> is_tail c1 c2","hypotheses":"(lbl : label) (c1 : code) (c2 : list instruction)","proofString":"unfold add_branch.\ndestruct (starts_with lbl c1).\nauto.\neauto with coqlib."},{"statement":"(lbl : label) (c1 : code) (c2 : list instruction) : is_tail (if starts_with lbl c1 then c1 else Lgoto lbl :: c1) c2 ->\nis_tail c1 c2.","conclusion":"is_tail (if starts_with lbl c1 then c1 else Lgoto lbl :: c1) c2 ->\nis_tail c1 c2","hypotheses":"(lbl : label) (c1 : code) (c2 : list instruction)","proofString":"destruct (starts_with lbl c1).\nauto.\neauto with coqlib."},{"statement":"(lbl : label) (c1 : code) (c2 : list instruction) : is_tail c1 c2 -> is_tail c1 c2.","conclusion":"is_tail c1 c2 -> is_tail c1 c2","hypotheses":"(lbl : label) (c1 : code) (c2 : list instruction)","proofString":"auto."},{"statement":"(lbl : label) (c1 : code) (c2 : list instruction) : is_tail (Lgoto lbl :: c1) c2 -> is_tail c1 c2.","conclusion":"is_tail (Lgoto lbl :: c1) c2 -> is_tail c1 c2","hypotheses":"(lbl : label) (c1 : code) (c2 : list instruction)","proofString":"eauto with coqlib."},{"statement":"(c1 : code) (c2 : list instruction) (H : is_tail c1 c2) : is_tail c1 c2.","conclusion":"is_tail c1 c2","hypotheses":"(c1 : code) (c2 : list instruction) (H : is_tail c1 c2)","proofString":"auto."},{"statement":"(a : LTL.instruction) (b : list LTL.instruction) (IHb : forall (c0 : code) (c3 : list instruction),\nis_tail (linearize_block b c0) c3 -> is_tail c0 c3) (c1 : code) (c2 : list instruction) (H : is_tail\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b c1\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b c1\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b c1\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b c1\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b c1\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b c1\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: c1\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b c1\n  | Lbranch s => add_branch s c1\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 c1\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 c1\n      else Lcond cond args s1 :: add_branch s2 c1\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: c1\n  | LTL.Lreturn => Lreturn :: c1\n  end c2) : is_tail c1 c2.","conclusion":"is_tail c1 c2","hypotheses":"(a : LTL.instruction) (b : list LTL.instruction) (IHb : forall (c0 : code) (c3 : list instruction),\nis_tail (linearize_block b c0) c3 -> is_tail c0 c3) (c1 : code) (c2 : list instruction) (H : is_tail\n  match a with\n  | LTL.Lop op args res => Lop op args res :: linearize_block b c1\n  | LTL.Lload chunk addr args dst =>\n      Lload chunk addr args dst :: linearize_block b c1\n  | LTL.Lgetstack sl ofs ty dst =>\n      Lgetstack sl ofs ty dst :: linearize_block b c1\n  | LTL.Lsetstack src sl ofs ty =>\n      Lsetstack src sl ofs ty :: linearize_block b c1\n  | LTL.Lstore chunk addr args src =>\n      Lstore chunk addr args src :: linearize_block b c1\n  | LTL.Lcall sig ros => Lcall sig ros :: linearize_block b c1\n  | LTL.Ltailcall sig ros => Ltailcall sig ros :: c1\n  | LTL.Lbuiltin ef args res => Lbuiltin ef args res :: linearize_block b c1\n  | Lbranch s => add_branch s c1\n  | LTL.Lcond cond args s1 s2 =>\n      if starts_with s1 c1\n      then Lcond (negate_condition cond) args s2 :: add_branch s1 c1\n      else Lcond cond args s1 :: add_branch s2 c1\n  | LTL.Ljumptable arg tbl => Ljumptable arg tbl :: c1\n  | LTL.Lreturn => Lreturn :: c1\n  end c2)","proofString":"destruct a; eauto with coqlib.\neapply is_tail_add_branch; eauto.\ndestruct (starts_with s1 c1); eapply is_tail_add_branch; eauto with coqlib."},{"statement":"(s : node) (b : list LTL.instruction) (IHb : forall (c0 : code) (c3 : list instruction),\nis_tail (linearize_block b c0) c3 -> is_tail c0 c3) (c1 : code) (c2 : list instruction) (H : is_tail (add_branch s c1) c2) : is_tail c1 c2.","conclusion":"is_tail c1 c2","hypotheses":"(s : node) (b : list LTL.instruction) (IHb : forall (c0 : code) (c3 : list instruction),\nis_tail (linearize_block b c0) c3 -> is_tail c0 c3) (c1 : code) (c2 : list instruction) (H : is_tail (add_branch s c1) c2)","proofString":"eapply is_tail_add_branch; eauto."},{"statement":"(cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : forall (c0 : code) (c3 : list instruction),\nis_tail (linearize_block b c0) c3 -> is_tail c0 c3) (c1 : code) (c2 : list instruction) (H : is_tail\n  (if starts_with s1 c1\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 c1\n   else Lcond cond args s1 :: add_branch s2 c1) c2) : is_tail c1 c2.","conclusion":"is_tail c1 c2","hypotheses":"(cond : condition) (args : list mreg) (s1 s2 : node) (b : list LTL.instruction) (IHb : forall (c0 : code) (c3 : list instruction),\nis_tail (linearize_block b c0) c3 -> is_tail c0 c3) (c1 : code) (c2 : list instruction) (H : is_tail\n  (if starts_with s1 c1\n   then Lcond (negate_condition cond) args s2 :: add_branch s1 c1\n   else Lcond cond args s1 :: add_branch s2 c1) c2)","proofString":"destruct (starts_with s1 c1); eapply is_tail_add_branch; eauto with coqlib."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) : plus step tge (State s tf sp (add_branch lbl k) ls m) E0\n  (State s tf sp c ls m).","conclusion":"plus step tge (State s tf sp (add_branch lbl k) ls m) E0\n  (State s tf sp c ls m)","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c)","proofString":"unfold add_branch.\ncaseEq (starts_with lbl k); intro SW.\neapply starts_with_correct; eauto.\neapply unique_labels_transf_function; eauto.\napply plus_one.\napply exec_Lgoto.\nauto."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) : plus step tge\n  (State s tf sp (if starts_with lbl k then k else Lgoto lbl :: k) ls m) E0\n  (State s tf sp c ls m).","conclusion":"plus step tge\n  (State s tf sp (if starts_with lbl k then k else Lgoto lbl :: k) ls m) E0\n  (State s tf sp c ls m)","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c)","proofString":"caseEq (starts_with lbl k); intro SW.\neapply starts_with_correct; eauto.\neapply unique_labels_transf_function; eauto.\napply plus_one.\napply exec_Lgoto.\nauto."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = true) : plus step tge (State s tf sp k ls m) E0 (State s tf sp c ls m).","conclusion":"plus step tge (State s tf sp k ls m) E0 (State s tf sp c ls m)","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = true)","proofString":"eapply starts_with_correct; eauto.\neapply unique_labels_transf_function; eauto."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = true) : unique_labels (fn_code tf).","conclusion":"unique_labels (fn_code tf)","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = true)","proofString":"eapply unique_labels_transf_function; eauto."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = false) : plus step tge (State s tf sp (Lgoto lbl :: k) ls m) E0 (State s tf sp c ls m).","conclusion":"plus step tge (State s tf sp (Lgoto lbl :: k) ls m) E0 (State s tf sp c ls m)","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = false)","proofString":"apply plus_one.\napply exec_Lgoto.\nauto."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = false) : step tge (State s tf sp (Lgoto lbl :: k) ls m) E0 (State s tf sp c ls m).","conclusion":"step tge (State s tf sp (Lgoto lbl :: k) ls m) E0 (State s tf sp c ls m)","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = false)","proofString":"apply exec_Lgoto.\nauto."},{"statement":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = false) : find_label lbl (fn_code tf) = Some c.","conclusion":"find_label lbl (fn_code tf) = Some c","hypotheses":"(lbl : label) (c : code) (k : list instruction) (s : list stackframe) (f : LTL.function) (tf : function) (sp : val) (ls : locset) (m : mem) (H : transf_function f = OK tf) (H0 : is_tail k (fn_code tf)) (H1 : find_label lbl (fn_code tf) = Some c) (SW : starts_with lbl k = false)","proofString":"auto."},{"statement":"Locmap.init Vundef = Locmap.init Vundef.","conclusion":"Locmap.init Vundef = Locmap.init Vundef","hypotheses":"","proofString":"auto."},{"statement":"(a1 : LTL.stackframe) (al : list LTL.stackframe) (b1 : stackframe) (bl : list stackframe) (H : match_stackframes a1 b1) (H0 : list_forall2 match_stackframes al bl) (IHlist_forall2 : parent_locset bl = LTL.parent_locset al) : match b1 with\n| Stackframe _ _ ls _ => ls\nend = match a1 with\n      | LTL.Stackframe _ _ ls _ => ls\n      end.","conclusion":"match b1 with\n| Stackframe _ _ ls _ => ls\nend = match a1 with\n      | LTL.Stackframe _ _ ls _ => ls\n      end","hypotheses":"(a1 : LTL.stackframe) (al : list LTL.stackframe) (b1 : stackframe) (bl : list stackframe) (H : match_stackframes a1 b1) (H0 : list_forall2 match_stackframes al bl) (IHlist_forall2 : parent_locset bl = LTL.parent_locset al)","proofString":"inv H; auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge (State ts tf sp (add_branch pc c) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) < measure (LTL.State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (State ts tf sp (add_branch pc c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (add_branch pc c) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) < measure (LTL.State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (State ts tf sp (add_branch pc c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exploit find_label_lin; eauto.\nintros [k F].\nleft; econstructor; split.\neapply add_branch_correct; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists k : code, find_label pc (fn_code tf) = Some (linearize_block bb k)) ->\n(exists s2' : state,\n   plus step tge (State ts tf sp (add_branch pc c) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) < measure (LTL.State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (State ts tf sp (add_branch pc c) rs m).","conclusion":"(exists k : code, find_label pc (fn_code tf) = Some (linearize_block bb k)) ->\n(exists s2' : state,\n   plus step tge (State ts tf sp (add_branch pc c) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) < measure (LTL.State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (State ts tf sp (add_branch pc c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"intros [k F].\nleft; econstructor; split.\neapply add_branch_correct; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : (exists s2' : state,\n   plus step tge (State ts tf sp (add_branch pc c) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) < measure (LTL.State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (State ts tf sp (add_branch pc c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (add_branch pc c) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) < measure (LTL.State s f sp pc rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m) (State ts tf sp (add_branch pc c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"left; econstructor; split.\neapply add_branch_correct; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : forall pc0 : node,\nIn pc0 (successors_block bb) -> (reachable f) !! pc0 = true.","conclusion":"forall pc0 : node,\nIn pc0 (successors_block bb) -> (reachable f) !! pc0 = true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"intros; eapply reachable_successors; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : is_tail k (fn_code tf).","conclusion":"is_tail k (fn_code tf)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (rs : LTL.locset) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"eapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) : (exists s2' : state,\n   plus step tge (State ts tf sp (Lcond cond args pc :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m) <\n measure (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n  (State ts tf sp (Lcond cond args pc :: c) ls m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (Lcond cond args pc :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m) <\n measure (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n  (State ts tf sp (Lcond cond args pc :: c) ls m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true)","proofString":"exploit find_label_lin; eauto.\nintros [k F].\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_true; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) : (exists k : code, find_label pc (fn_code tf) = Some (linearize_block bb k)) ->\n(exists s2' : state,\n   plus step tge (State ts tf sp (Lcond cond args pc :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m) <\n measure (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n  (State ts tf sp (Lcond cond args pc :: c) ls m).","conclusion":"(exists k : code, find_label pc (fn_code tf) = Some (linearize_block bb k)) ->\n(exists s2' : state,\n   plus step tge (State ts tf sp (Lcond cond args pc :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m) <\n measure (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n  (State ts tf sp (Lcond cond args pc :: c) ls m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true)","proofString":"intros [k F].\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_true; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : (exists s2' : state,\n   plus step tge (State ts tf sp (Lcond cond args pc :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m) <\n measure (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n  (State ts tf sp (Lcond cond args pc :: c) ls m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (Lcond cond args pc :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m) <\n measure (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs (destroyed_by_cond cond) ls) m)\n  (State ts tf sp (Lcond cond args pc :: c) ls m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"left; econstructor; split.\napply plus_one.\neapply exec_Lcond_true; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : forall pc0 : node,\nIn pc0 (successors_block bb) -> (reachable f) !! pc0 = true.","conclusion":"forall pc0 : node,\nIn pc0 (successors_block bb) -> (reachable f) !! pc0 = true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"intros; eapply reachable_successors; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : is_tail k (fn_code tf).","conclusion":"is_tail k (fn_code tf)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : LTL.locset) (tf : function) (ts : list stackframe) (cond : condition) (args : list mreg) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (JUMP : eval_condition cond (reglist ls args) m = Some true) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"eapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) : (exists s2' : state,\n   plus step tge (State ts tf sp (Ljumptable arg tbl :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m) <\n measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n  (State ts tf sp (Ljumptable arg tbl :: c) ls m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (Ljumptable arg tbl :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m) <\n measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n  (State ts tf sp (Ljumptable arg tbl :: c) ls m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc)","proofString":"exploit find_label_lin; eauto.\nintros [k F].\nleft; econstructor; split.\napply plus_one.\neapply exec_Ljumptable; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) : (exists k : code, find_label pc (fn_code tf) = Some (linearize_block bb k)) ->\n(exists s2' : state,\n   plus step tge (State ts tf sp (Ljumptable arg tbl :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m) <\n measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n  (State ts tf sp (Ljumptable arg tbl :: c) ls m).","conclusion":"(exists k : code, find_label pc (fn_code tf) = Some (linearize_block bb k)) ->\n(exists s2' : state,\n   plus step tge (State ts tf sp (Ljumptable arg tbl :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m) <\n measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n  (State ts tf sp (Ljumptable arg tbl :: c) ls m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc)","proofString":"intros [k F].\nleft; econstructor; split.\napply plus_one.\neapply exec_Ljumptable; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : (exists s2' : state,\n   plus step tge (State ts tf sp (Ljumptable arg tbl :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m) <\n measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n  (State ts tf sp (Ljumptable arg tbl :: c) ls m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (Ljumptable arg tbl :: c) ls m) E0 s2' /\\\n   match_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n     s2') \\/\n(measure (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m) <\n measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable ls) m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb (undef_regs destroyed_by_jumptable ls) m)\n  (State ts tf sp (Ljumptable arg tbl :: c) ls m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"left; econstructor; split.\napply plus_one.\neapply exec_Ljumptable; eauto.\neconstructor; eauto.\nintros; eapply reachable_successors; eauto.\neapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : forall pc0 : node,\nIn pc0 (successors_block bb) -> (reachable f) !! pc0 = true.","conclusion":"forall pc0 : node,\nIn pc0 (successors_block bb) -> (reachable f) !! pc0 = true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"intros; eapply reachable_successors; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k)) : is_tail k (fn_code tf).","conclusion":"is_tail k (fn_code tf)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : positive) (m : mem) (bb : bblock) (H : (LTL.fn_code f) ! pc = Some bb) (ls : loc -> val) (tf : function) (ts : list stackframe) (arg : mreg) (tbl : list positive) (c : list instruction) (n : int) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : (reachable f) !! pc = true) (ARG : ls (R arg) = Vint n) (JUMP : list_nth_z tbl (Int.unsigned n) = Some pc) (k : code) (F : find_label pc (fn_code tf) = Some (linearize_block bb k))","proofString":"eapply is_tail_lin_block; eauto.\neapply is_tail_find_label; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lop op args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lop op args res :: bb) c) rs m) E0\n     s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) <\n measure (Block s f sp (LTL.Lop op args res :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lop op args res :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lop op args res :: bb) c) rs m) E0\n     s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m) <\n measure (Block s f sp (LTL.Lop op args res :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lop op args res :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lop op args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\ninstantiate (1 := v); rewrite <- H; apply eval_operation_preserved.\nexact symbols_preserved.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lop op args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (op : operation) (args : list mreg) (res : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (v : val) (H : eval_operation ge sp op (reglist rs args) m = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lop op args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exact symbols_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lload chunk addr args dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lload chunk addr args dst :: bb) c) rs m) E0\n     s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs))\n        m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (Block s f sp (LTL.Lload chunk addr args dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lload chunk addr args dst :: bb) c)\n     rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lload chunk addr args dst :: bb) c) rs m) E0\n     s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs))\n        m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m) <\n measure (Block s f sp (LTL.Lload chunk addr args dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) v (undef_regs (destroyed_by_load chunk addr) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lload chunk addr args dst :: bb) c)\n     rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lload chunk addr args dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor.\ninstantiate (1 := a).\nrewrite <- H; apply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lload chunk addr args dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : eval_addressing tge sp addr (reglist rs args) = Some a.","conclusion":"eval_addressing tge sp addr (reglist rs args) = Some a","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lload chunk addr args dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"rewrite <- H; apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lload chunk addr args dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a v : val) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.loadv chunk m a = Some v) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lload chunk addr args dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exact symbols_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lgetstack sl ofs ty dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lgetstack sl ofs ty dst :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) (rs (S sl ofs ty))\n           (undef_regs (destroyed_by_getstack sl) rs)) m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) (rs (S sl ofs ty))\n         (undef_regs (destroyed_by_getstack sl) rs)) m) <\n measure (Block s f sp (LTL.Lgetstack sl ofs ty dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (undef_regs (destroyed_by_getstack sl) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lgetstack sl ofs ty dst :: bb) c) rs\n     m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lgetstack sl ofs ty dst :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (R dst) (rs (S sl ofs ty))\n           (undef_regs (destroyed_by_getstack sl) rs)) m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (R dst) (rs (S sl ofs ty))\n         (undef_regs (destroyed_by_getstack sl) rs)) m) <\n measure (Block s f sp (LTL.Lgetstack sl ofs ty dst :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (R dst) (rs (S sl ofs ty))\n        (undef_regs (destroyed_by_getstack sl) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lgetstack sl ofs ty dst :: bb) c) rs\n     m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lgetstack sl ofs ty dst :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lsetstack src sl ofs ty :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lsetstack src sl ofs ty :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (S sl ofs ty) (rs (R src))\n           (undef_regs (destroyed_by_setstack ty) rs)) m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (S sl ofs ty) (rs (R src))\n         (undef_regs (destroyed_by_setstack ty) rs)) m) <\n measure (Block s f sp (LTL.Lsetstack src sl ofs ty :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (undef_regs (destroyed_by_setstack ty) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lsetstack src sl ofs ty :: bb) c) rs\n     m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lsetstack src sl ofs ty :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.set (S sl ofs ty) (rs (R src))\n           (undef_regs (destroyed_by_setstack ty) rs)) m) s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.set (S sl ofs ty) (rs (R src))\n         (undef_regs (destroyed_by_setstack ty) rs)) m) <\n measure (Block s f sp (LTL.Lsetstack src sl ofs ty :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.set (S sl ofs ty) (rs (R src))\n        (undef_regs (destroyed_by_setstack ty) rs)) m)\n  (State ts tf sp (linearize_block (LTL.Lsetstack src sl ofs ty :: bb) c) rs\n     m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lsetstack src sl ofs ty :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lstore chunk addr args src :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lstore chunk addr args src :: bb) c) rs m) E0\n     s2' /\\\n   match_states\n     (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (Block s f sp (LTL.Lstore chunk addr args src :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n  (State ts tf sp (linearize_block (LTL.Lstore chunk addr args src :: bb) c)\n     rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lstore chunk addr args src :: bb) c) rs m) E0\n     s2' /\\\n   match_states\n     (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') s2') \\/\n(measure (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m') <\n measure (Block s f sp (LTL.Lstore chunk addr args src :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (Block s f sp bb (undef_regs (destroyed_by_store chunk addr) rs) m')\n  (State ts tf sp (linearize_block (LTL.Lstore chunk addr args src :: bb) c)\n     rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lstore chunk addr args src :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor.\ninstantiate (1 := a).\nrewrite <- H; apply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lstore chunk addr args src :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : eval_addressing tge sp addr (reglist rs args) = Some a.","conclusion":"eval_addressing tge sp addr (reglist rs args) = Some a","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lstore chunk addr args src :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"rewrite <- H; apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lstore chunk addr args src :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (a : val) (m' : mem) (H : eval_addressing ge sp addr (reglist rs args) = Some a) (H0 : Mem.storev chunk m a (rs (R src)) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lstore chunk addr args src :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exact symbols_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c) rs m) E0\n     s2' /\\\n   match_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) s2') \\/\n(measure (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (LTL.Lcall (LTL.funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m)\n  (State ts tf sp (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c)\n     rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c) rs m) E0\n     s2' /\\\n   match_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) s2') \\/\n(measure (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (LTL.Lcall (LTL.funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m)\n  (State ts tf sp (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c)\n     rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exploit find_function_translated; eauto.\nintros [tfd [A B]].\nleft; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nsymmetry; eapply sig_preserved; eauto.\neconstructor; eauto.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists tf0 : fundef,\n   find_function tge ros rs = Some tf0 /\\ transf_fundef fd = OK tf0) ->\n(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c) rs m) E0\n     s2' /\\\n   match_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) s2') \\/\n(measure (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (LTL.Lcall (LTL.funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m)\n  (State ts tf sp (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c)\n     rs m).","conclusion":"(exists tf0 : fundef,\n   find_function tge ros rs = Some tf0 /\\ transf_fundef fd = OK tf0) ->\n(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c) rs m) E0\n     s2' /\\\n   match_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) s2') \\/\n(measure (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (LTL.Lcall (LTL.funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m)\n  (State ts tf sp (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c)\n     rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"intros [tfd [A B]].\nleft; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nsymmetry; eapply sig_preserved; eauto.\neconstructor; eauto.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c) rs m) E0\n     s2' /\\\n   match_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) s2') \\/\n(measure (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (LTL.Lcall (LTL.funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m)\n  (State ts tf sp (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c)\n     rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c) rs m) E0\n     s2' /\\\n   match_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) s2') \\/\n(measure (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m) <\n measure (Block s f sp (LTL.Lcall (LTL.funsig fd) ros :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate (LTL.Stackframe f sp rs bb :: s) fd rs m)\n  (State ts tf sp (linearize_block (LTL.Lcall (LTL.funsig fd) ros :: bb) c)\n     rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd)","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nsymmetry; eapply sig_preserved; eauto.\neconstructor; eauto.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd) : LTL.funsig fd = funsig tfd.","conclusion":"LTL.funsig fd = funsig tfd","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd)","proofString":"symmetry; eapply sig_preserved; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd) : list_forall2 match_stackframes (LTL.Stackframe f sp rs bb :: s)\n  (Stackframe tf sp rs (linearize_block bb c) :: ts).","conclusion":"list_forall2 match_stackframes (LTL.Stackframe f sp rs bb :: s)\n  (Stackframe tf sp rs (linearize_block bb c) :: ts)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd)","proofString":"constructor; auto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd) : match_stackframes (LTL.Stackframe f sp rs bb)\n  (Stackframe tf sp rs (linearize_block bb c)).","conclusion":"match_stackframes (LTL.Stackframe f sp rs bb)\n  (Stackframe tf sp rs (linearize_block bb c))","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (H : LTL.find_function ge ros rs = Some fd) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros rs = Some tfd) (B : transf_fundef fd = OK tfd)","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') s2') \\/\n(measure (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Ptrofs.zero) (LTL.Ltailcall (LTL.funsig fd) ros :: bb)\n      rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero)\n     (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') s2') \\/\n(measure (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Ptrofs.zero) (LTL.Ltailcall (LTL.funsig fd) ros :: bb)\n      rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero)\n     (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exploit find_function_translated; eauto.\nintros [tfd [A B]].\nleft; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nrewrite (match_parent_locset _ _ STACKS).\neauto.\nsymmetry; eapply sig_preserved; eauto.\nrewrite (stacksize_preserved _ _ TRF); eauto.\nrewrite (match_parent_locset _ _ STACKS).\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists tf0 : fundef,\n   find_function tge ros (return_regs (LTL.parent_locset s) rs) = Some tf0 /\\\n   transf_fundef fd = OK tf0) ->\n(exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') s2') \\/\n(measure (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Ptrofs.zero) (LTL.Ltailcall (LTL.funsig fd) ros :: bb)\n      rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero)\n     (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m).","conclusion":"(exists tf0 : fundef,\n   find_function tge ros (return_regs (LTL.parent_locset s) rs) = Some tf0 /\\\n   transf_fundef fd = OK tf0) ->\n(exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') s2') \\/\n(measure (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Ptrofs.zero) (LTL.Ltailcall (LTL.funsig fd) ros :: bb)\n      rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero)\n     (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"intros [tfd [A B]].\nleft; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nrewrite (match_parent_locset _ _ STACKS).\neauto.\nsymmetry; eapply sig_preserved; eauto.\nrewrite (stacksize_preserved _ _ TRF); eauto.\nrewrite (match_parent_locset _ _ STACKS).\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros (return_regs (LTL.parent_locset s) rs) = Some tfd) (B : transf_fundef fd = OK tfd) : (exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') s2') \\/\n(measure (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Ptrofs.zero) (LTL.Ltailcall (LTL.funsig fd) ros :: bb)\n      rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero)\n     (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') s2') \\/\n(measure (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m') <\n measure\n   (Block s f (Vptr sp Ptrofs.zero) (LTL.Ltailcall (LTL.funsig fd) ros :: bb)\n      rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero)\n     (linearize_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros (return_regs (LTL.parent_locset s) rs) = Some tfd) (B : transf_fundef fd = OK tfd)","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nrewrite (match_parent_locset _ _ STACKS).\neauto.\nsymmetry; eapply sig_preserved; eauto.\nrewrite (stacksize_preserved _ _ TRF); eauto.\nrewrite (match_parent_locset _ _ STACKS).\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros (return_regs (LTL.parent_locset s) rs) = Some tfd) (B : transf_fundef fd = OK tfd) : match_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (Callstate ts tfd (return_regs (LTL.parent_locset s) rs) m').","conclusion":"match_states (LTL.Callstate s fd (return_regs (LTL.parent_locset s) rs) m')\n  (Callstate ts tfd (return_regs (LTL.parent_locset s) rs) m')","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (ros : mreg + ident) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (fd : LTL.fundef) (m' : mem) (H0 : LTL.find_function ge ros (return_regs (LTL.parent_locset s) rs) = Some fd) (H2 : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Ltailcall (LTL.funsig fd) ros :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (tfd : fundef) (A : find_function tge ros (return_regs (LTL.parent_locset s) rs) = Some tfd) (B : transf_fundef fd = OK tfd)","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lbuiltin ef args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lbuiltin ef args res :: bb) c) rs\n        m) t s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n     s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m') <\n measure (Block s f sp (LTL.Lbuiltin ef args res :: bb) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n  (State ts tf sp (linearize_block (LTL.Lbuiltin ef args res :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lbuiltin ef args res :: bb) c) rs\n        m) t s2' /\\\n   match_states\n     (Block s f sp bb\n        (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n     s2') \\/\n(measure\n   (Block s f sp bb\n      (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m') <\n measure (Block s f sp (LTL.Lbuiltin ef args res :: bb) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (Block s f sp bb\n     (Locmap.setres res vres (undef_regs (destroyed_by_builtin ef) rs)) m')\n  (State ts tf sp (linearize_block (LTL.Lbuiltin ef args res :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lbuiltin ef args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neapply exec_Lbuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lbuiltin ef args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","conclusion":"forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lbuiltin ef args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"exact symbols_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lbuiltin ef args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_builtin_args ge rs sp m args vargs) (H0 : external_call ef ge vargs m t vres m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lbuiltin ef args res :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"apply senv_preserved."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)\n     E0 s2' /\\ match_states (LTL.State s f sp pc rs m) s2') \\/\n(measure (LTL.State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)\n     E0 s2' /\\ match_states (LTL.State s f sp pc rs m) s2') \\/\n(measure (LTL.State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf))","proofString":"assert ((reachable f)!!pc = true).\napply REACH; simpl; auto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nsimpl.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) : (reachable f) !! pc = true.","conclusion":"(reachable f) !! pc = true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf))","proofString":"apply REACH; simpl; auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true) : (exists s2' : state,\n   plus step tge (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)\n     E0 s2' /\\ match_states (LTL.State s f sp pc rs m) s2') \\/\n(measure (LTL.State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)\n     E0 s2' /\\ match_states (LTL.State s f sp pc rs m) s2') \\/\n(measure (LTL.State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true)","proofString":"right; split.\nsimpl; lia.\nsplit.\nauto.\nsimpl.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true) : (measure (LTL.State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat.","conclusion":"(measure (LTL.State s f sp pc rs m) <\n measure (Block s f sp (Lbranch pc :: bb) rs m))%nat","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true)","proofString":"simpl; lia."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true) : E0 = E0 /\\\nmatch_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m).","conclusion":"E0 = E0 /\\\nmatch_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true)","proofString":"split.\nauto.\nsimpl.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true) : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true)","proofString":"auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true) : match_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m).","conclusion":"match_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (linearize_block (Lbranch pc :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true)","proofString":"simpl.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true) : match_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (add_branch pc c) rs m).","conclusion":"match_states (LTL.State s f sp pc rs m)\n  (State ts tf sp (add_branch pc c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (pc : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (Lbranch pc :: bb)) -> (reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (H : (reachable f) !! pc = true)","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c) rs\n     m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c) rs\n     m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"assert (REACH1: (reachable f)!!pc1 = true) by (apply REACH; simpl; auto).\nassert (REACH2: (reachable f)!!pc2 = true) by (apply REACH; simpl; auto).\nsimpl linearize_block.\ndestruct (starts_with pc1 c).\nassert (DC: destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond).\ndestruct cond; reflexivity.\ndestruct b.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\ndestruct b.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c) rs\n     m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c) rs\n     m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true)","proofString":"assert (REACH2: (reachable f)!!pc2 = true) by (apply REACH; simpl; auto).\nsimpl linearize_block.\ndestruct (starts_with pc1 c).\nassert (DC: destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond).\ndestruct cond; reflexivity.\ndestruct b.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\ndestruct b.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c) rs\n     m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c)\n        rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (linearize_block (LTL.Lcond cond args pc1 pc2 :: bb) c) rs\n     m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"simpl linearize_block.\ndestruct (starts_with pc1 c).\nassert (DC: destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond).\ndestruct cond; reflexivity.\ndestruct b.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\ndestruct b.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (if starts_with pc1 c\n         then Lcond (negate_condition cond) args pc2 :: add_branch pc1 c\n         else Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (if starts_with pc1 c\n      then Lcond (negate_condition cond) args pc2 :: add_branch pc1 c\n      else Lcond cond args pc1 :: add_branch pc2 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (if starts_with pc1 c\n         then Lcond (negate_condition cond) args pc2 :: add_branch pc1 c\n         else Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (if starts_with pc1 c\n      then Lcond (negate_condition cond) args pc2 :: add_branch pc1 c\n      else Lcond cond args pc1 :: add_branch pc2 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"destruct (starts_with pc1 c).\nassert (DC: destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond).\ndestruct cond; reflexivity.\ndestruct b.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\ndestruct b.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"assert (DC: destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond).\ndestruct cond; reflexivity.\ndestruct b.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond.","conclusion":"destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"destruct cond; reflexivity."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"destruct b.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"left; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\nrewrite eval_negate_condition.\nrewrite H.\nauto.\neauto.\nrewrite DC.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : eval_condition (negate_condition cond) (reglist rs args) m = Some false.","conclusion":"eval_condition (negate_condition cond) (reglist rs args) m = Some false","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"rewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : option_map negb (eval_condition cond (reglist rs args) m) = Some false.","conclusion":"option_map negb (eval_condition cond (reglist rs args) m) = Some false","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"rewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : option_map negb (Some true) = Some false.","conclusion":"option_map negb (Some true) = Some false","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : match_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (add_branch pc1 c) (undef_regs (destroyed_by_cond cond) rs)\n     m).","conclusion":"match_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (add_branch pc1 c) (undef_regs (destroyed_by_cond cond) rs)\n     m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp\n        (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m) E0\n     s2' /\\\n   match_states\n     (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"right; split.\nsimpl; lia.\nsplit.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : (measure (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat.","conclusion":"(measure (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"simpl; lia."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : E0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"E0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"split.\nauto.\nrewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : match_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"match_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"rewrite <- DC.\neconstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : match_states\n  (LTL.State s f sp pc2\n     (undef_regs (destroyed_by_cond (negate_condition cond)) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m).","conclusion":"match_states\n  (LTL.State s f sp pc2\n     (undef_regs (destroyed_by_cond (negate_condition cond)) rs) m)\n  (State ts tf sp\n     (Lcond (negate_condition cond) args pc2 :: add_branch pc1 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"econstructor; eauto.\nrewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : eval_condition (negate_condition cond) (reglist rs args) m = Some true.","conclusion":"eval_condition (negate_condition cond) (reglist rs args) m = Some true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"rewrite eval_negate_condition.\nrewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : option_map negb (eval_condition cond (reglist rs args) m) = Some true.","conclusion":"option_map negb (eval_condition cond (reglist rs args) m) = Some true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"rewrite H.\nauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond) : option_map negb (Some false) = Some true.","conclusion":"option_map negb (Some false) = Some true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) (DC : destroyed_by_cond (negate_condition cond) = destroyed_by_cond cond)","proofString":"auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp (if b then pc1 else pc2)\n        (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure\n   (LTL.State s f sp (if b then pc1 else pc2)\n      (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp (if b then pc1 else pc2)\n     (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (b : bool) (m : mem) (H : eval_condition cond (reglist rs args) m = Some b) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"destruct b.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto.\nleft; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"right; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (measure (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat.","conclusion":"(measure (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"simpl; lia."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : E0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m).","conclusion":"E0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"split.\nauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : match_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m).","conclusion":"match_states\n  (LTL.State s f sp pc1 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some true) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) s2') \\/\n(measure (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m) <\n measure (Block s f sp (LTL.Lcond cond args pc1 pc2 :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f sp pc2 (undef_regs (destroyed_by_cond cond) rs) m)\n  (State ts tf sp (Lcond cond args pc1 :: add_branch pc2 c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"left; econstructor; split.\napply plus_one.\neapply exec_Lcond_false.\neauto.\neauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true) : eval_condition cond (reglist rs args) m = Some false.","conclusion":"eval_condition cond (reglist rs args) m = Some false","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (cond : condition) (args : list mreg) (pc1 pc2 : node) (bb : list LTL.instruction) (rs : LTL.locset) (m : mem) (H : eval_condition cond (reglist rs args) m = Some false) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lcond cond args pc1 pc2 :: bb)) ->\n(reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) (REACH1 : (reachable f) !! pc1 = true) (REACH2 : (reachable f) !! pc2 = true)","proofString":"eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) s2') \\/\n(measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (LTL.Ljumptable arg tbl :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) s2') \\/\n(measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (LTL.Ljumptable arg tbl :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf))","proofString":"assert (REACH': (reachable f)!!pc = true).\napply REACH.\nsimpl.\neapply list_nth_z_in; eauto.\nright; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) : (reachable f) !! pc = true.","conclusion":"(reachable f) !! pc = true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf))","proofString":"apply REACH.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) : In pc (successors_block (LTL.Ljumptable arg tbl :: bb)).","conclusion":"In pc (successors_block (LTL.Ljumptable arg tbl :: bb))","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf))","proofString":"simpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) : In pc tbl.","conclusion":"In pc tbl","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf))","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true) : (exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) s2') \\/\n(measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (LTL.Ljumptable arg tbl :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)\n     E0 s2' /\\\n   match_states\n     (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) s2') \\/\n(measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (LTL.Ljumptable arg tbl :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true)","proofString":"right; split.\nsimpl; lia.\nsplit.\nauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true) : (measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (LTL.Ljumptable arg tbl :: bb) rs m))%nat.","conclusion":"(measure (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m) <\n measure (Block s f sp (LTL.Ljumptable arg tbl :: bb) rs m))%nat","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true)","proofString":"simpl; lia."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true) : E0 = E0 /\\\nmatch_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m).","conclusion":"E0 = E0 /\\\nmatch_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true)","proofString":"split.\nauto.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true) : E0 = E0.","conclusion":"E0 = E0","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true)","proofString":"auto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true) : match_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m).","conclusion":"match_states (LTL.State s f sp pc (undef_regs destroyed_by_jumptable rs) m)\n  (State ts tf sp (linearize_block (LTL.Ljumptable arg tbl :: bb) c) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : val) (arg : mreg) (tbl : list node) (bb : list LTL.instruction) (rs : loc -> val) (m : mem) (n : int) (pc : node) (H : rs (R arg) = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some pc) (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc0 : node,\nIn pc0 (successors_block (LTL.Ljumptable arg tbl :: bb)) ->\n(reachable f) !! pc0 = true) (TAIL : is_tail c (fn_code tf)) (REACH' : (reachable f) !! pc = true)","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (bb : list LTL.instruction) (rs : LTL.locset) (m m' : mem) (H : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lreturn :: bb)) -> (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Lreturn :: bb) c) rs m) E0 s2' /\\\n   match_states (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m')\n     s2') \\/\n(measure (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m') <\n measure (Block s f (Vptr sp Ptrofs.zero) (LTL.Lreturn :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero) (linearize_block (LTL.Lreturn :: bb) c)\n     rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (State ts tf (Vptr sp Ptrofs.zero)\n        (linearize_block (LTL.Lreturn :: bb) c) rs m) E0 s2' /\\\n   match_states (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m')\n     s2') \\/\n(measure (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m') <\n measure (Block s f (Vptr sp Ptrofs.zero) (LTL.Lreturn :: bb) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m')\n  (State ts tf (Vptr sp Ptrofs.zero) (linearize_block (LTL.Lreturn :: bb) c)\n     rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (bb : list LTL.instruction) (rs : LTL.locset) (m m' : mem) (H : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lreturn :: bb)) -> (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\nsimpl.\napply plus_one.\neconstructor; eauto.\nrewrite (stacksize_preserved _ _ TRF).\neauto.\nrewrite (match_parent_locset _ _ STACKS).\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (bb : list LTL.instruction) (rs : LTL.locset) (m m' : mem) (H : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lreturn :: bb)) -> (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf)) : match_states (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m')\n  (Returnstate ts (return_regs (LTL.parent_locset s) rs) m').","conclusion":"match_states (LTL.Returnstate s (return_regs (LTL.parent_locset s) rs) m')\n  (Returnstate ts (return_regs (LTL.parent_locset s) rs) m')","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (sp : block) (bb : list LTL.instruction) (rs : LTL.locset) (m m' : mem) (H : Mem.free m sp 0 (LTL.fn_stacksize f) = Some m') (tf : function) (ts : list stackframe) (c : list instruction) (STACKS : list_forall2 match_stackframes s ts) (TRF : transf_function f = OK tf) (REACH : forall pc : node,\nIn pc (successors_block (LTL.Lreturn :: bb)) -> (reachable f) !! pc = true) (TAIL : is_tail c (fn_code tf))","proofString":"econstructor; eauto."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf) : (exists s2' : state,\n   plus step tge (Callstate ts tf rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') s2') \\/\n(measure\n   (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (LTL.Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts tf rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Callstate ts tf rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') s2') \\/\n(measure\n   (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (LTL.Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts tf rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf)","proofString":"assert (REACH: (reachable f)!!(LTL.fn_entrypoint f) = true).\napply reachable_entrypoint.\nmonadInv H7.\nleft; econstructor; split.\napply plus_one.\neapply exec_function_internal; eauto.\nrewrite (stacksize_preserved _ _ EQ).\neauto.\ngeneralize EQ; intro EQ'; monadInv EQ'.\nsimpl.\neconstructor; eauto.\nsimpl.\neapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf) : (reachable f) !! (fn_entrypoint f) = true.","conclusion":"(reachable f) !! (fn_entrypoint f) = true","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf)","proofString":"apply reachable_entrypoint."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf) (REACH : (reachable f) !! (fn_entrypoint f) = true) : (exists s2' : state,\n   plus step tge (Callstate ts tf rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') s2') \\/\n(measure\n   (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (LTL.Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts tf rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Callstate ts tf rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') s2') \\/\n(measure\n   (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (LTL.Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts tf rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (tf : fundef) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (H7 : transf_fundef (Internal f) = OK tf) (REACH : (reachable f) !! (fn_entrypoint f) = true)","proofString":"monadInv H7.\nleft; econstructor; split.\napply plus_one.\neapply exec_function_internal; eauto.\nrewrite (stacksize_preserved _ _ EQ).\neauto.\ngeneralize EQ; intro EQ'; monadInv EQ'.\nsimpl.\neconstructor; eauto.\nsimpl.\neapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x : function) (EQ : transf_function f = OK x) : (exists s2' : state,\n   plus step tge (Callstate ts (Internal x) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') s2') \\/\n(measure\n   (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (LTL.Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts (Internal x) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Callstate ts (Internal x) rs m) E0 s2' /\\\n   match_states\n     (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n        (undef_regs destroyed_at_function_entry (call_regs rs)) m') s2') \\/\n(measure\n   (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n      (undef_regs destroyed_at_function_entry (call_regs rs)) m') <\n measure (LTL.Callstate s (Internal f) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (Callstate ts (Internal x) rs m)","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x : function) (EQ : transf_function f = OK x)","proofString":"left; econstructor; split.\napply plus_one.\neapply exec_function_internal; eauto.\nrewrite (stacksize_preserved _ _ EQ).\neauto.\ngeneralize EQ; intro EQ'; monadInv EQ'.\nsimpl.\neconstructor; eauto.\nsimpl.\neapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0) : match_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (State ts\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |} (Vptr sp Ptrofs.zero)\n     (fn_code\n        {|\n          fn_sig := LTL.fn_sig f;\n          fn_stacksize := LTL.fn_stacksize f;\n          fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n        |}) (undef_regs destroyed_at_function_entry (call_regs rs)) m').","conclusion":"match_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (State ts\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |} (Vptr sp Ptrofs.zero)\n     (fn_code\n        {|\n          fn_sig := LTL.fn_sig f;\n          fn_stacksize := LTL.fn_stacksize f;\n          fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n        |}) (undef_regs destroyed_at_function_entry (call_regs rs)) m')","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0)","proofString":"simpl.\neconstructor; eauto.\nsimpl.\neapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0) : match_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (State ts\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |} (Vptr sp Ptrofs.zero)\n     (add_branch (fn_entrypoint f) (linearize_body f x0))\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m').","conclusion":"match_states\n  (LTL.State s f (Vptr sp Ptrofs.zero) (fn_entrypoint f)\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')\n  (State ts\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |} (Vptr sp Ptrofs.zero)\n     (add_branch (fn_entrypoint f) (linearize_body f x0))\n     (undef_regs destroyed_at_function_entry (call_regs rs)) m')","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0)","proofString":"econstructor; eauto.\nsimpl.\neapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0) : is_tail (linearize_body f x0)\n  (fn_code\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |}).","conclusion":"is_tail (linearize_body f x0)\n  (fn_code\n     {|\n       fn_sig := LTL.fn_sig f;\n       fn_stacksize := LTL.fn_stacksize f;\n       fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n     |})","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0)","proofString":"simpl.\neapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0) : is_tail (linearize_body f x0)\n  (add_branch (fn_entrypoint f) (linearize_body f x0)).","conclusion":"is_tail (linearize_body f x0)\n  (add_branch (fn_entrypoint f) (linearize_body f x0))","hypotheses":"(s : list LTL.stackframe) (f : LTL.function) (rs : LTL.locset) (m : mem) (m' : Mem.mem') (sp : block) (H : Mem.alloc m 0 (LTL.fn_stacksize f) = (m', sp)) (ts : list stackframe) (H6 : list_forall2 match_stackframes s ts) (REACH : (reachable f) !! (fn_entrypoint f) = true) (x0 : list node) (EQ : transf_function f =\nOK\n  {|\n    fn_sig := LTL.fn_sig f;\n    fn_stacksize := LTL.fn_stacksize f;\n    fn_code := add_branch (fn_entrypoint f) (linearize_body f x0)\n  |}) (EQ0 : enumerate f = OK x0)","proofString":"eapply is_tail_add_branch.\nconstructor."},{"statement":"(s : list LTL.stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (tf : fundef) (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) (H8 : transf_fundef (External ef) = OK tf) : (exists s2' : state,\n   plus step tge (Callstate ts tf rs m) t s2' /\\\n   match_states\n     (LTL.Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') s2') \\/\n(measure\n   (LTL.Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (LTL.Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (LTL.Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m') (Callstate ts tf rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Callstate ts tf rs m) t s2' /\\\n   match_states\n     (LTL.Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') s2') \\/\n(measure\n   (LTL.Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (LTL.Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (LTL.Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m') (Callstate ts tf rs m)","hypotheses":"(s : list LTL.stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (tf : fundef) (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) (H8 : transf_fundef (External ef) = OK tf)","proofString":"monadInv H8.\nleft; econstructor; split.\napply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) : (exists s2' : state,\n   plus step tge (Callstate ts (External ef) rs m) t s2' /\\\n   match_states\n     (LTL.Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') s2') \\/\n(measure\n   (LTL.Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (LTL.Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (LTL.Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m') (Callstate ts (External ef) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Callstate ts (External ef) rs m) t s2' /\\\n   match_states\n     (LTL.Returnstate s\n        (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n           (undef_caller_save_regs rs)) m') s2') \\/\n(measure\n   (LTL.Returnstate s\n      (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n         (undef_caller_save_regs rs)) m') <\n measure (LTL.Callstate s (External ef) rs m))%nat /\\\nt = E0 /\\\nmatch_states\n  (LTL.Returnstate s\n     (Locmap.setpair (Conventions1.loc_result (ef_sig ef)) res\n        (undef_caller_save_regs rs)) m') (Callstate ts (External ef) rs m)","hypotheses":"(s : list LTL.stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts)","proofString":"left; econstructor; split.\napply plus_one.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(s : list LTL.stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list LTL.stackframe) (ef : external_function) (t : trace) (res : val) (rs : Locmap.t) (m m' : mem) (H0 : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p rs)\n     (Conventions1.loc_arguments (ef_sig ef))) m t res m') (ts : list stackframe) (H7 : list_forall2 match_stackframes s ts)","proofString":"apply senv_preserved."},{"statement":"(f : LTL.function) (sp : val) (rs1 : LTL.locset) (bb : bblock) (s : list LTL.stackframe) (rs : LTL.locset) (m : mem) (ts : list stackframe) (H3 : list_forall2 match_stackframes (LTL.Stackframe f sp rs1 bb :: s) ts) : (exists s2' : state,\n   plus step tge (Returnstate ts rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) <\n measure (LTL.Returnstate (LTL.Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (Block s f sp bb rs m) (Returnstate ts rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Returnstate ts rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) <\n measure (LTL.Returnstate (LTL.Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (Block s f sp bb rs m) (Returnstate ts rs m)","hypotheses":"(f : LTL.function) (sp : val) (rs1 : LTL.locset) (bb : bblock) (s : list LTL.stackframe) (rs : LTL.locset) (m : mem) (ts : list stackframe) (H3 : list_forall2 match_stackframes (LTL.Stackframe f sp rs1 bb :: s) ts)","proofString":"inv H3.\ninv H1.\nleft; econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : LTL.function) (sp : val) (rs1 : LTL.locset) (bb : bblock) (s : list LTL.stackframe) (rs : LTL.locset) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (LTL.Stackframe f sp rs1 bb) b1) (H4 : list_forall2 match_stackframes s bl) : (exists s2' : state,\n   plus step tge (Returnstate (b1 :: bl) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) <\n measure (LTL.Returnstate (LTL.Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (Block s f sp bb rs m) (Returnstate (b1 :: bl) rs m).","conclusion":"(exists s2' : state,\n   plus step tge (Returnstate (b1 :: bl) rs m) E0 s2' /\\\n   match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) <\n measure (LTL.Returnstate (LTL.Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\ match_states (Block s f sp bb rs m) (Returnstate (b1 :: bl) rs m)","hypotheses":"(f : LTL.function) (sp : val) (rs1 : LTL.locset) (bb : bblock) (s : list LTL.stackframe) (rs : LTL.locset) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_stackframes (LTL.Stackframe f sp rs1 bb) b1) (H4 : list_forall2 match_stackframes s bl)","proofString":"inv H1.\nleft; econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(f : LTL.function) (sp : val) (rs1 : LTL.locset) (bb : bblock) (s : list LTL.stackframe) (rs : LTL.locset) (m : mem) (bl : list stackframe) (H4 : list_forall2 match_stackframes s bl) (tf : function) (c : list instruction) (H6 : transf_function f = OK tf) (H7 : forall pc : node, In pc (successors_block bb) -> (reachable f) !! pc = true) (H8 : is_tail c (fn_code tf)) : (exists s2' : state,\n   plus step tge\n     (Returnstate (Stackframe tf sp rs1 (linearize_block bb c) :: bl) rs m)\n     E0 s2' /\\ match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) <\n measure (LTL.Returnstate (LTL.Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (Returnstate (Stackframe tf sp rs1 (linearize_block bb c) :: bl) rs m).","conclusion":"(exists s2' : state,\n   plus step tge\n     (Returnstate (Stackframe tf sp rs1 (linearize_block bb c) :: bl) rs m)\n     E0 s2' /\\ match_states (Block s f sp bb rs m) s2') \\/\n(measure (Block s f sp bb rs m) <\n measure (LTL.Returnstate (LTL.Stackframe f sp rs1 bb :: s) rs m))%nat /\\\nE0 = E0 /\\\nmatch_states (Block s f sp bb rs m)\n  (Returnstate (Stackframe tf sp rs1 (linearize_block bb c) :: bl) rs m)","hypotheses":"(f : LTL.function) (sp : val) (rs1 : LTL.locset) (bb : bblock) (s : list LTL.stackframe) (rs : LTL.locset) (m : mem) (bl : list stackframe) (H4 : list_forall2 match_stackframes s bl) (tf : function) (c : list instruction) (H6 : transf_function f = OK tf) (H7 : forall pc : node, In pc (successors_block bb) -> (reachable f) !! pc = true) (H8 : is_tail c (fn_code tf))","proofString":"left; econstructor; split.\napply plus_one.\neconstructor.\neconstructor; eauto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","conclusion":"exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1)","proofString":"inversion H.\nexploit function_ptr_translated; eauto.\nintros [tf [A B]].\nexists (Callstate nil tf (Locmap.init Vundef) m0); split.\neconstructor; eauto.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\neauto.\nrewrite <- H3.\napply sig_preserved.\nauto.\nconstructor.\nconstructor.\nauto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : Genv.init_mem tprog = Some m0.","conclusion":"Genv.init_mem tprog = Some m0","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"eapply (Genv.init_mem_transf_partial TRANSF); eauto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : funsig tf = signature_main.","conclusion":"funsig tf = signature_main","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"rewrite <- H3.\napply sig_preserved.\nauto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : funsig tf = LTL.funsig f.","conclusion":"funsig tf = LTL.funsig f","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"apply sig_preserved.\nauto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : transf_fundef f = OK tf.","conclusion":"transf_fundef f = OK tf","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"auto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : match_states (LTL.Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil tf (Locmap.init Vundef) m0).","conclusion":"match_states (LTL.Callstate nil f (Locmap.init Vundef) m0)\n  (Callstate nil tf (Locmap.init Vundef) m0)","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"constructor.\nconstructor.\nauto."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : list_forall2 match_stackframes nil nil.","conclusion":"list_forall2 match_stackframes nil nil","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"constructor."},{"statement":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf) : transf_fundef f = OK tf.","conclusion":"transf_fundef f = OK tf","hypotheses":"(st1 : LTL.state) (H : LTL.initial_state prog st1) (b : block) (f : LTL.fundef) (m0 : mem) (ge0 : Genv.t LTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : LTL.funsig f = signature_main) (H4 : LTL.Callstate nil f (Locmap.init Vundef) m0 = st1) (tf : fundef) (A : Genv.find_funct_ptr tge b = Some tf) (B : transf_fundef f = OK tf)","proofString":"auto."},{"statement":"(st1 : LTL.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : LTL.final_state st1 r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st1 : LTL.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : LTL.final_state st1 r)","proofString":"inv H0.\ninv H.\ninv H5.\neconstructor; eauto."},{"statement":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (LTL.Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st2 : state) (r : int) (rs : Locmap.t) (m : mem) (H : match_states (LTL.Returnstate nil rs m) st2) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r)","proofString":"inv H.\ninv H5.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) (ts : list stackframe) (H5 : list_forall2 match_stackframes nil ts) : final_state (Returnstate ts rs m) r.","conclusion":"final_state (Returnstate ts rs m) r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) (ts : list stackframe) (H5 : list_forall2 match_stackframes nil ts)","proofString":"inv H5.\neconstructor; eauto."},{"statement":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r) : final_state (Returnstate nil rs m) r.","conclusion":"final_state (Returnstate nil rs m) r","hypotheses":"(r : int) (rs : Locmap.t) (m : mem) (H1 : Locmap.getpair (map_rpair R (Conventions1.loc_result signature_main)) rs =\nVint r)","proofString":"econstructor; eauto."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (LTL.semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (LTL.semantics prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}