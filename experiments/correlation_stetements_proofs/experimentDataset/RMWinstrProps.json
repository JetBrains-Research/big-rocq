[{"statement":"Lemma w_ex_is_xacq_add_preserves thread s s'\n      (WF : wf_thread_state thread s) lbl vl lc cl ff\n      (UG : G s' =\n            add (G s) thread (eindex s) lbl vl lc cl ff) \n      (SS : w_ex_is_xacq s) :\n    w_ex_is_xacq s'.","proof":"unfold w_ex_is_xacq in *.\napply set_subset_inter_r.\nsplit; [done|].\nunfold W_ex in *.\nunfold add in UG.\nrewrite UG at 1.\nsimpls.\nrewrite SS.\nrewrite (dom_r (wft_rmwE WF)).\nrewrite codom_eqv1.\nrewrite set_interA.\nunfolder.\nins.\ndesc.\nunfold is_xacq, xmod.\nerewrite add_preserves_lab; eauto.\n"},{"statement":"Lemma w_ex_is_xacq_add_rmw_preserves thread s s'\n      (WF : wf_thread_state thread s) lbl1 ordw vl lc vl' lc' cl ff\n      (UG : G s' =\n            add_rmw (G s) thread (eindex s) lbl1\n                    (Astore Xacq ordw vl lc) vl' lc' cl ff) \n      (SS : w_ex_is_xacq s) :\n    w_ex_is_xacq s'.","proof":"unfold w_ex_is_xacq in *.\napply set_subset_inter_r.\nsplit; [done|].\nunfold W_ex in *.\nunfold add_rmw in UG.\nrewrite UG at 1.\nsimpls.\nrewrite codom_union.\nunionL.\n2: {\nrewrite SS.\nrewrite (dom_r (wft_rmwE WF)).\nrewrite codom_eqv1.\nrewrite set_interA.\nunfolder.\nins.\ndesc.\nunfold is_xacq, xmod.\nerewrite add_rmw_preserves_lab; eauto.\n}\nsubst.\nunfolder.\nins.\ndesf.\nrewrite UG.\nsimpls.\nunfold is_xacq, xmod.\nby rewrite upds.\n"},{"statement":"Lemma rmw_is_xacq_instr_xmod rmw rexmod xmod ordr ordw reg lexpr s\n      (XACQIN : rmw_is_xacq_instrs (instrs s))\n      (ISTEP :\n         Some\n           (Instr.update rmw rexmod xmod ordr ordw reg\n                         lexpr) = nth_error (instrs s) (pc s)) :\n  xmod = Xacq.","proof":"symmetry in ISTEP; apply nth_error_In in ISTEP.\napply XACQIN in ISTEP; simpls; desf.\n"},{"statement":"Lemma w_ex_is_xacq_thread_step thread s s'\n      (XACQIN : rmw_is_xacq_instrs (instrs s))\n      (WF : wf_thread_state thread s)\n      (STEP : step thread s s')\n      (SS : w_ex_is_xacq s) :\n  w_ex_is_xacq s'.","proof":"unfold w_ex_is_xacq in *.\ndestruct STEP as [ll STEP].\ncdes STEP.\ndestruct ISTEP0.\n1,2: by rewrite UG.\n1-4: by eapply w_ex_is_xacq_add_preserves; eauto.\nall: assert (xmod = Xacq); subst;    [ |eapply w_ex_is_xacq_add_rmw_preserves; eauto].\nall: eapply rmw_is_xacq_instr_xmod; eauto.\n"},{"statement":"Lemma dom_rmw_in_rex_add_preserves thread s s'\n      (WF : wf_thread_state thread s) lbl vl lc cl ff\n      (UG : G s' =\n            add (G s) thread (eindex s) lbl vl lc cl ff) \n      (SS : dom_rmw_in_rex s) :\n    dom_rmw_in_rex s'.","proof":"unfold dom_rmw_in_rex in *.\nunfold add in UG.\nrewrite UG.\nsimpls.\nrewrite (dom_l (wft_rmwE WF)).\nrewrite dom_eqv1.\nrewrite SS.\nunfold R_ex.\nunfolder.\nins.\ndesc.\nrewrite updo; auto.\nintros HH; subst.\napply (acts_rep WF) in H.\ndesf.\nlia.\n"},{"statement":"Lemma dom_rmw_in_rex_add_rmw_preserves thread s s'\n      (WF : wf_thread_state thread s) lbl1 rexmod ordw vl lc vl' lc' cl ff\n      (UG : G s' =\n            add_rmw (G s) thread (eindex s) (Aload rexmod ordw vl lc)\n                    lbl1 vl' lc' cl ff) \n      (REX : rexmod = true)\n      (SS : dom_rmw_in_rex s) :\n    dom_rmw_in_rex s'.","proof":"unfold dom_rmw_in_rex, R_ex in *.\nunfold add_rmw in UG.\nrewrite UG.\nsimpls.\nrewrite dom_union.\nunionL.\n2: {\nrewrite (dom_l (wft_rmwE WF)).\nrewrite dom_eqv1.\nunfolder.\nins.\ndesc.\nrewrite !updo; auto.\n{\napply SS.\nred.\neauto.\n}\nall: intros HH; subst.\nall: apply (acts_rep WF) in H; desf; lia.\n}\nunfolder.\nins.\ndesc; subst.\nrewrite updo.\n{\nby rewrite upds.\n}\nintros HH.\ninv HH.\nlia.\n"},{"statement":"Lemma rmw_is_rex_instr_rexmod rmw rexmod xmod ordr ordw reg lexpr s\n      (RMWREX : rmw_is_rex_instrs (instrs s))\n      (ISTEP :\n         Some\n           (Instr.update rmw rexmod xmod ordr ordw reg\n                         lexpr) = nth_error (instrs s) (pc s)) :\n  rexmod = true.","proof":"symmetry in ISTEP; apply nth_error_In in ISTEP.\napply RMWREX in ISTEP; simpls; desf.\n"},{"statement":"Lemma dom_rmw_in_rex_thread_step thread s s'\n      (RMWREX : rmw_is_rex_instrs (instrs s))\n      (WF : wf_thread_state thread s)\n      (STEP : step thread s s')\n      (SS : dom_rmw_in_rex s) :\n  dom_rmw_in_rex s'.","proof":"unfold dom_rmw_in_rex in *.\ndestruct STEP as [ll STEP].\ncdes STEP.\ndestruct ISTEP0.\n1,2: by rewrite UG.\n1-4: by eapply dom_rmw_in_rex_add_preserves; eauto.\nall: eapply dom_rmw_in_rex_add_rmw_preserves; eauto.\nall: rewrite II in ISTEP.\nall: eapply rmw_is_rex_instr_rexmod; eauto.\n"},{"statement":"Lemma cas_produces_R_ex_instr_rexmod old new rexmod xmod ordr ordw reg lexpr s\n      (RMWREX : cas_produces_R_ex_instrs (instrs s))\n      (ISTEP :\n         Some\n           (Instr.update (Instr.cas old new) rexmod xmod ordr ordw reg\n                         lexpr) = nth_error (instrs s) (pc s)) :\n  rexmod = true.","proof":"symmetry in ISTEP; apply nth_error_In in ISTEP.\napply RMWREX in ISTEP; simpls; desf.\n"},{"statement":"Lemma dom_rmw_in_rex_thread_steps thread s s'\n      (RMWREX : rmw_is_rex_instrs (instrs s))\n      (WF : wf_thread_state thread s)\n      (STEPS : (step thread)^* s s')\n      (SS : dom_rmw_in_rex s) :\n  dom_rmw_in_rex s'.","proof":"apply clos_rt_rtn1_iff in STEPS.\ninduction STEPS; auto.\napply clos_rt_rtn1_iff in STEPS.\neapply dom_rmw_in_rex_thread_step with (s:=y); eauto.\n{\nerewrite steps_preserve_instrs; eauto.\n}\neapply wf_thread_state_steps; eauto.\n"}]