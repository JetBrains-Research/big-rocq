{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/reordering/ReorderingExecA.v","fileSamples":[{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : E_t' ≡₁ E_t ∪₁ eq a_t.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : tid a_t <> tid_init.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ~ is_init a_t.","proofString":"apply ADD'."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ~ E_t a_t.","proofString":"apply ADD'."},{"statement":"(E_t ∪₁ eq a_t) a_t.","proofString":"now right."},{"statement":"(r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : lab_t' = upd lab_t a_t l_a.","proofString":"apply ADD'."},{"statement":"E_t b_t.","proofString":"assert (NEQ : a_t <> b_t) by apply INV'.\nassert (IN' : E_t' b_t) by apply rsr_bt_in'.\napply rsr_step_acts in IN'.\nunfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) : E_t b_t.","proofString":"assert (IN' : E_t' b_t) by apply rsr_bt_in'.\napply rsr_step_acts in IN'.\nunfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (IN' : E_t' b_t) : E_t b_t.","proofString":"apply rsr_step_acts in IN'.\nunfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (IN' : (E_t ∪₁ eq a_t) b_t) : E_t b_t.","proofString":"unfolder in IN'.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (IN' : E_t b_t \\/ a_t = b_t) : E_t b_t.","proofString":"desf."},{"statement":"E_t b_t.","proofString":"apply rsr_bt_in."},{"statement":"eq_dom E_t' lab_t' (lab_s' ∘ mapper).","proofString":"exact rsr_nanb_lab."},{"statement":"(NEQ : a_t <> b_t) : inj_dom E_t' mapper.","proofString":"eapply inj_dom_mori; auto with xmm.\nred; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) : flip set_subset ⊤₁ E_t'.","proofString":"red; auto with hahn."},{"statement":"eq_dom cmt (upd lab_s b_t l_a) lab_s.","proofString":"apply eq_dom_upd_l; [| reflexivity].\nunfold cmt.\nclear.\nunfolder.\ntauto."},{"statement":"~ cmt b_t.","proofString":"unfold cmt.\nclear.\nunfolder.\ntauto."},{"statement":"~ (E_s \\₁ eq b_t) b_t.","proofString":"clear.\nunfolder.\ntauto."},{"statement":"~ (E_s \\₁ eq b_t) b_t.","proofString":"unfolder.\ntauto."},{"statement":"~ (E_s b_t /\\ b_t <> b_t).","proofString":"tauto."},{"statement":"eq_dom cmt lab_s' lab_s.","proofString":"exact rsr_a_labeq."},{"statement":"(mapper ↑₁ E_t ∪₁ A_s) b_t.","proofString":"right.\nnow apply rsr_old_exa."},{"statement":"A_s b_t.","proofString":"now apply rsr_old_exa."},{"statement":"(NEQ : a_t <> b_t) : E_s a_t.","proofString":"apply (rsr_acts SIMREL).\nleft.\nexists b_t; split; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) : (mapper ↑₁ E_t ∪₁ A_s) a_t.","proofString":"left.\nexists b_t; split; auto with xmm."},{"statement":"(NEQ : a_t <> b_t) : (mapper ↑₁ E_t) a_t.","proofString":"exists b_t; split; auto with xmm."},{"statement":"⦗E_s'⦘ ⨾ ext_sb ⨾ ⦗E_s'⦘ ≡ sb_s.","proofString":"simpl.\nnow change (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s."},{"statement":"⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘ ≡ sb_s.","proofString":"now change (⦗E_s⦘ ⨾ ext_sb ⨾ ⦗E_s⦘) with sb_s."},{"statement":"(ANIN : ~ E_t a_t) : ⦗eq a_t⦘ ⨾ sb_s ⊆ ∅₂.","proofString":"assert (ANINI : ~is_init a_t) by apply INV.\nrewrite (rsr_sbE INV SIMREL), seq_union_r.\napply inclusion_union_l.\nrewrite wf_sbE.\nbasic_solver.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ sb_s ⊆ ∅₂.","proofString":"rewrite (rsr_sbE INV SIMREL), seq_union_r.\napply inclusion_union_l.\nrewrite wf_sbE.\nbasic_solver.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ sb_t ∪ ⦗eq a_t⦘ ⨾ (is_init ∪₁ E_t ∩₁ Tid_ (tid b_t)) × B_s ⊆ ∅₂.","proofString":"apply inclusion_union_l.\nrewrite wf_sbE.\nbasic_solver.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ sb_t ⊆ ∅₂.","proofString":"rewrite wf_sbE.\nbasic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ ⦗E_t⦘ ⨾ sb_t ⨾ ⦗E_t⦘ ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(ANIN : ~ E_t a_t) (ANINI : ~ is_init a_t) : ⦗eq a_t⦘ ⨾ (is_init ∪₁ E_t ∩₁ Tid_ (tid b_t)) × B_s ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(WF_t : Wf G_t) : rf_s' ≡ mapper ↑ rf_t'.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nsimpl.\nrewrite (rsr_rf SIMREL), (rf_delta_RE WF_t ADD'),          !seq_union_l.\narewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : rf_s' ≡ mapper ↑ rf_t'.","proofString":"simpl.\nrewrite (rsr_rf SIMREL), (rf_delta_RE WF_t ADD'),          !seq_union_l.\narewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : rf_s ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ (rf_t' ⨾ ⦗eq a_t⦘) ≡ mapper ↑ rf_t'.","proofString":"rewrite (rsr_rf SIMREL), (rf_delta_RE WF_t ADD'),          !seq_union_l.\narewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ (srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘\n∪ mapper ↑ WCore.rf_delta_R a_t w ≡ mapper ↑ rf_t'.","proofString":"arewrite_false ((srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : (srf_s ⨾ ⦗A_s ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘ ⊆ ∅₂.","proofString":"rewrite rsr_old_exa.\nbasic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : (srf_s ⨾ ⦗eq b_t ∩₁ R_s⦘) ⨾ ⦗E_s \\₁ eq b_t⦘ ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ ∅₂ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ rf_t'.","proofString":"rewrite (WCore.add_event_rf ADD'),          (add_event_to_rf_complete ADD' WF_t (rsr_Gt_rfc INV)).\nrewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ ∅₂ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ (rf_t ∪ WCore.rf_delta_R a_t w ∪ ∅₂).","proofString":"rewrite !union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ WCore.rf_delta_R a_t w\n≡ mapper ↑ rf_t ∪ mapper ↑ WCore.rf_delta_R a_t w.","proofString":"apply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘ ≡ mapper ↑ rf_t.","proofString":"split; [basic_solver 11 |].\nrewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ rf_t ⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘.","proofString":"rewrite (wf_rfE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ (⦗E_t⦘ ⨾ rf_t ⨾ ⦗E_t⦘) ⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘.","proofString":"rewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ⦗E_s \\₁ eq b_t⦘ ⨾ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘\n⊆ mapper ↑ rf_t ⨾ ⦗E_s \\₁ eq b_t⦘.","proofString":"basic_solver 11."},{"statement":"(WF_t : Wf G_t) : co_s' ≡ mapper ↑ co_t'.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nsimpl.\nrewrite (rsr_co SIMREL), (co_deltaE WF_t ADD'),          restr_union.\narewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : co_s' ≡ mapper ↑ co_t'.","proofString":"simpl.\nrewrite (rsr_co SIMREL), (co_deltaE WF_t ADD'),          restr_union.\narewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) co_s\n∪ mapper ↑ (⦗eq a_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq a_t⦘) ≡ \nmapper ↑ co_t'.","proofString":"rewrite (rsr_co SIMREL), (co_deltaE WF_t ADD'),          restr_union.\narewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t)\n∪ restr_rel (E_s \\₁ eq b_t)\n    (add_max (extra_co_D E_s lab_s (loc_s b_t)) (A_s ∩₁ W_s))\n∪ mapper ↑ WCore.co_delta a_t W1 W2 ≡ mapper ↑ co_t'.","proofString":"arewrite_false (    restr_rel      (E_s \\₁ eq b_t)      (add_max        (extra_co_D E_s lab_s (loc_s b_t))        (A_s ∩₁ W_s))  ).\nrewrite rsr_old_exa.\nbasic_solver.\nrewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t)\n  (add_max (extra_co_D E_s lab_s (loc_s b_t)) (A_s ∩₁ W_s)) ⊆ ∅₂.","proofString":"rewrite rsr_old_exa.\nbasic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t)\n  (add_max (extra_co_D E_s lab_s (loc_s b_t)) (eq b_t ∩₁ W_s)) ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ ∅₂\n∪ mapper ↑ WCore.co_delta a_t W1 W2 ≡ mapper ↑ co_t'.","proofString":"rewrite (WCore.add_event_co ADD').\nrewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ ∅₂\n∪ mapper ↑ WCore.co_delta a_t W1 W2\n≡ mapper ↑ (co_t ∪ WCore.co_delta a_t W1 W2).","proofString":"rewrite union_false_r, collect_rel_union.\napply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ∪ mapper ↑ WCore.co_delta a_t W1 W2\n≡ mapper ↑ co_t ∪ mapper ↑ WCore.co_delta a_t W1 W2.","proofString":"apply union_more; [| reflexivity].\nsplit; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t) ≡ mapper ↑ co_t.","proofString":"split; [basic_solver 11 |].\nrewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ co_t ⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t).","proofString":"rewrite (wf_coE WF_t) at 1.\nrewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑ (⦗E_t⦘ ⨾ co_t ⨾ ⦗E_t⦘) ⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t).","proofString":"rewrite !collect_rel_seqi, !collect_rel_eqv,          rsr_oldacts.\nbasic_solver 11."},{"statement":"(WF_t : Wf G_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : ⦗E_s \\₁ eq b_t⦘ ⨾ mapper ↑ co_t ⨾ ⦗E_s \\₁ eq b_t⦘\n⊆ restr_rel (E_s \\₁ eq b_t) (mapper ↑ co_t).","proofString":"basic_solver 11."},{"statement":"(NEQ : a_t <> b_t) : E_s' ≡₁ mapper ↑₁ E_t'.","proofString":"destruct ADD as (r & R1 & w & W1 & W2 & ADD').\nsimpl.\nrewrite (rsr_acts SIMREL), (WCore.add_event_acts ADD'),          set_collect_union, set_collect_eq, rsr_old_exa.\nrewrite rsr_mapper_at; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : E_s' ≡₁ mapper ↑₁ E_t'.","proofString":"simpl.\nrewrite (rsr_acts SIMREL), (WCore.add_event_acts ADD'),          set_collect_union, set_collect_eq, rsr_old_exa.\nrewrite rsr_mapper_at; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : E_s ≡₁ mapper ↑₁ E_t'.","proofString":"rewrite (rsr_acts SIMREL), (WCore.add_event_acts ADD'),          set_collect_union, set_collect_eq, rsr_old_exa.\nrewrite rsr_mapper_at; auto with hahn."},{"statement":"(NEQ : a_t <> b_t) (r : option actid) (R1 : actid -> Prop) (w : option actid) (W1 W2 : actid -> Prop) (ADD' : WCore.add_event_gen X_t X_t' a_t l_a r R1 w W1 W2) : mapper ↑₁ E_t ∪₁ eq b_t ≡₁ mapper ↑₁ E_t ∪₁ eq (mapper a_t).","proofString":"rewrite rsr_mapper_at; auto with hahn."},{"statement":"E_s ≡₁ E_s.","proofString":"reflexivity."},{"statement":"E_s \\₁ (eq b_t ∪₁ eq a_t) ⊆₁ E_s.","proofString":"basic_solver."},{"statement":"E_s \\₁ eq b_t ⊆₁ E_s.","proofString":"basic_solver."},{"statement":"E_s \\₁ (eq b_t ∪₁ eq a_t) ⊆₁ E_s \\₁ eq b_t.","proofString":"basic_solver."},{"statement":"(ANINI : ~ is_init b_t) : is_init ⊆₁ dtrmt.","proofString":"assert (BNINI : ~is_init a_t) by apply INV.\nunfold dtrmt.\nrewrite <- (rsr_init_acts_s INV SIMREL).\nrewrite set_minus_disjoint; basic_solver."},{"statement":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t) : is_init ⊆₁ dtrmt.","proofString":"unfold dtrmt.\nrewrite <- (rsr_init_acts_s INV SIMREL).\nrewrite set_minus_disjoint; basic_solver."},{"statement":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t) : is_init ⊆₁ E_s \\₁ (eq b_t ∪₁ eq a_t).","proofString":"rewrite <- (rsr_init_acts_s INV SIMREL).\nrewrite set_minus_disjoint; basic_solver."},{"statement":"(ANINI : ~ is_init b_t) (BNINI : ~ is_init a_t) : is_init ⊆₁ is_init \\₁ (eq b_t ∪₁ eq a_t).","proofString":"rewrite set_minus_disjoint; basic_solver."},{"statement":"(BIN : E_s a_t) : cmt \\₁ dtrmt ≡₁ eq a_t.","proofString":"assert (NEQ : a_t <> b_t) by apply INV'.\nunfold cmt, dtrmt.\nrewrite set_minus_union_r, set_minus_inter_r.\nrewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : cmt \\₁ dtrmt ≡₁ eq a_t.","proofString":"unfold cmt, dtrmt.\nrewrite set_minus_union_r, set_minus_inter_r.\nrewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ (E_s \\₁ (eq b_t ∪₁ eq a_t)) ≡₁ eq a_t.","proofString":"rewrite set_minus_union_r, set_minus_inter_r.\nrewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq b_t) ∪₁ (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq a_t)\n≡₁ eq a_t.","proofString":"rewrite set_minusK, set_union_empty_l.\nrewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ (E_s \\₁ eq a_t) ≡₁ eq a_t.","proofString":"rewrite set_minus_minus_r.\narewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ E_s ∪₁ (E_s \\₁ eq b_t) ∩₁ eq a_t ≡₁ eq a_t.","proofString":"arewrite ((E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅).\nbasic_solver.\nrewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : (E_s \\₁ eq b_t) \\₁ E_s ≡₁ ∅.","proofString":"basic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : ∅ ∪₁ (E_s \\₁ eq b_t) ∩₁ eq a_t ≡₁ eq a_t.","proofString":"rewrite set_union_empty_l, set_inter_absorb_l.\nreflexivity.\nbasic_solver."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : eq a_t ≡₁ eq a_t.","proofString":"reflexivity."},{"statement":"(BIN : E_s a_t) (NEQ : a_t <> b_t) : eq a_t ⊆₁ E_s \\₁ eq b_t.","proofString":"basic_solver."},{"statement":"tid ↑₁ (E_s' \\₁ dtrmt) ≡₁ eq (tid b_t).","proofString":"rewrite rsr_a_ndtrmt.\nrewrite set_collect_union, !set_collect_eq.\nrewrite set_union_absorb_r; [reflexivity |].\nunfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"tid ↑₁ (eq b_t ∪₁ eq a_t) ≡₁ eq (tid b_t).","proofString":"rewrite set_collect_union, !set_collect_eq.\nrewrite set_union_absorb_r; [reflexivity |].\nunfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"eq (tid b_t) ∪₁ eq (tid a_t) ≡₁ eq (tid b_t).","proofString":"rewrite set_union_absorb_r; [reflexivity |].\nunfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"eq (tid a_t) ⊆₁ eq (tid b_t).","proofString":"unfolder.\nins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"forall x : BinNums.positive, tid a_t = x -> tid b_t = x.","proofString":"ins.\ndesf.\nsymmetry.\napply INV'."},{"statement":"(x : BinNums.positive) (H : tid a_t = x) : tid b_t = x.","proofString":"desf.\nsymmetry.\napply INV'."},{"statement":"tid b_t = tid a_t.","proofString":"symmetry.\napply INV'."},{"statement":"tid a_t = tid b_t.","proofString":"apply INV'."},{"statement":"(BTID : tid b_t <> tid_init) : strict_partial_order thrdle.","proofString":"constructor; unfold thrdle.\nbasic_solver.\nunfolder.\nintros x y z HXY HYZ.\ndesf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) : irreflexive\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)).","proofString":"basic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : transitive\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)).","proofString":"unfolder.\nintros x y z HXY HYZ.\ndesf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) : forall x y z : BinNums.positive,\ntid_init = x /\\ tid_init <> y \\/ tid b_t <> x /\\ tid b_t = y ->\ntid_init = y /\\ tid_init <> z \\/ tid b_t <> y /\\ tid b_t = z ->\ntid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z.","proofString":"intros x y z HXY HYZ.\ndesf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) (x y z : BinNums.positive) (HXY : tid_init = x /\\ tid_init <> y \\/ tid b_t <> x /\\ tid b_t = y) (HYZ : tid_init = y /\\ tid_init <> z \\/ tid b_t <> y /\\ tid b_t = z) : tid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z.","proofString":"desf; eauto.\ncongruence."},{"statement":"(BTID : tid b_t <> tid_init) (x z : BinNums.positive) (HXY : tid b_t <> x) (HYZ : tid_init = tid b_t) (HYZ0 : tid_init <> z) : tid_init = x /\\ tid_init <> z \\/ tid b_t <> x /\\ tid b_t = z.","proofString":"congruence."},{"statement":"(BTID : tid b_t <> tid_init) : WCore.stable_uncmt_reads_gen X_s' cmt thrdle.","proofString":"constructor.\nunfold thrdle.\nbasic_solver.\nunfold thrdle.\nunfolder.\nintros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV).\napply rsr_a_thrdle.\nrewrite rsr_a_ncmt.\nseq_rewrite (    split_rel ⊤₁ ⊤₁      (vf_s' ⨾ same_tid)      same_tid  ).\nrewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : least_elt thrdle tid_init.","proofString":"unfold thrdle.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : least_elt\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)) tid_init.","proofString":"basic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : min_elt thrdle tid_init.","proofString":"unfold thrdle.\nunfolder.\nintros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) : min_elt\n  (eq tid_init × set_compl (eq tid_init)\n   ∪ set_compl (eq (tid b_t)) × eq (tid b_t)) tid_init.","proofString":"unfolder.\nintros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) : forall b : BinNums.positive,\ntid_init = b /\\ tid_init <> tid_init \\/ tid b_t <> b /\\ tid b_t = tid_init ->\nFalse.","proofString":"intros b [(EQ & NIN) | (NB & IN)]; [congruence |].\nnow apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) (b : BinNums.positive) (NB : tid b_t <> b) (IN : tid b_t = tid_init) : False.","proofString":"now apply (rsr_bt_tid INV)."},{"statement":"(BTID : tid b_t <> tid_init) : strict_partial_order thrdle.","proofString":"apply rsr_a_thrdle."},{"statement":"(BTID : tid b_t <> tid_init) : vf_s' ⨾ same_tid ⨾ ⦗E_s' \\₁ cmt⦘ ⊆ tid ↓ thrdle ∪ same_tid.","proofString":"rewrite rsr_a_ncmt.\nseq_rewrite (    split_rel ⊤₁ ⊤₁      (vf_s' ⨾ same_tid)      same_tid  ).\nrewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : vf_s' ⨾ same_tid ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle ∪ same_tid.","proofString":"seq_rewrite (    split_rel ⊤₁ ⊤₁      (vf_s' ⨾ same_tid)      same_tid  ).\nrewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : ((vf_s' ⨾ same_tid) ∩ same_tid ∪ vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ thrdle ∪ same_tid.","proofString":"rewrite unionC, seq_union_l.\napply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘\n∪ (vf_s' ⨾ same_tid) ∩ same_tid ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle ∪ same_tid.","proofString":"apply union_mori; [| basic_solver].\nremember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (vf_s' ⨾ same_tid \\ same_tid) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle.","proofString":"remember (vf_s' ⨾ same_tid \\ same_tid) as vfsbt.\narewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : vfsbt ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle.","proofString":"arewrite (vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt).\nrewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l.\nunfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : vfsbt ⊆ ⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt.","proofString":"rewrite <- seq_union_l, <- id_union.\nnow rewrite set_compl_union_id, seq_id_l."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : vfsbt ⊆ ⦗is_init ∪₁ set_compl is_init⦘ ⨾ vfsbt.","proofString":"now rewrite set_compl_union_id, seq_id_l."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ thrdle.","proofString":"unfold thrdle.\nrewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt ∪ ⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid\n  ↓ (eq tid_init × set_compl (eq tid_init)\n     ∪ set_compl (eq (tid b_t)) × eq (tid b_t)).","proofString":"rewrite seq_union_l, map_rel_union.\napply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ∪ (⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ eq tid_init × set_compl (eq tid_init)\n  ∪ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","proofString":"apply union_mori.\nunfold is_init.\nbasic_solver.\nsubst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ eq tid_init × set_compl (eq tid_init).","proofString":"unfold is_init.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗fun e : actid =>\n  match e with\n  | InitEvent _ => true\n  | ThreadEvent _ _ => false\n  end⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘ ⊆ tid ↓ eq tid_init × set_compl (eq tid_init).","proofString":"basic_solver."},{"statement":"(BTID : tid b_t <> tid_init) (vfsbt : relation actid) (Heqvfsbt : vfsbt = vf_s' ⨾ same_tid \\ same_tid) : (⦗set_compl is_init⦘ ⨾ vfsbt) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","proofString":"subst vfsbt.\nunfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (⦗set_compl is_init⦘ ⨾ (vf_s' ⨾ same_tid \\ same_tid)) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","proofString":"unfold same_tid.\nbasic_solver."},{"statement":"(BTID : tid b_t <> tid_init) : (⦗set_compl is_init⦘\n ⨾ (vf_s' ⨾ (fun x y : actid => tid x = tid y) \\\n    (fun x y : actid => tid x = tid y))) ⨾ ⦗eq b_t⦘\n⊆ tid ↓ set_compl (eq (tid b_t)) × eq (tid b_t).","proofString":"basic_solver."},{"statement":"(NEQ : a_t <> b_t) : upward_closed rpo_imm_s' cmt.","proofString":"unfold upward_closed, cmt.\nintros x y RPO CMT.\nsplit.\napply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf.\nintro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) : forall x y : actid, rpo_imm_s' x y -> (E_s \\₁ eq b_t) y -> (E_s \\₁ eq b_t) x.","proofString":"intros x y RPO CMT.\nsplit.\napply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf.\nintro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) : (E_s \\₁ eq b_t) x.","proofString":"split.\napply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf.\nintro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) : E_s x.","proofString":"apply (wf_rpo_immE (G_s_wf INV' rsr_a_sim)) in RPO.\nunfolder in RPO.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : (⦗E_s'⦘ ⨾ rpo_imm_s' ⨾ ⦗E_s'⦘) x y) (CMT : (E_s \\₁ eq b_t) y) : E_s x.","proofString":"unfolder in RPO.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (CMT : (E_s \\₁ eq b_t) y) (RPO : E_s' x /\\ rpo_imm_s' x y /\\ E_s' y) : E_s x.","proofString":"desf."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) : b_t <> x.","proofString":"intro FALSO.\nsubst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (x y : actid) (RPO : rpo_imm_s' x y) (CMT : (E_s \\₁ eq b_t) y) (FALSO : b_t = x) : False.","proofString":"subst x.\nassert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : False.","proofString":"assert (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y).\nexists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb.\nassert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : (⦗eq b_t⦘ ⨾ sb_s') b_t y.","proofString":"exists b_t.\nsplit; [basic_solver 1|].\nnow apply rpo_imm_in_sb."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : ⦗eq b_t⦘ b_t b_t /\\ sb_s' b_t y.","proofString":"split; [basic_solver 1|].\nnow apply rpo_imm_in_sb."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) : sb_s' b_t y.","proofString":"now apply rpo_imm_in_sb."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) : False.","proofString":"assert (YEQ : y = a_t).\napply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf.\nsubst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) : y = a_t.","proofString":"apply rsr_a_sb_froma in SB.\nunfolder in SB.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (eq b_t × eq a_t) b_t y) : y = a_t.","proofString":"unfolder in SB.\ndesf."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : b_t = b_t /\\ a_t = y) : y = a_t.","proofString":"desf."},{"statement":"(NEQ : a_t <> b_t) (y : actid) (RPO : rpo_imm_s' b_t y) (CMT : (E_s \\₁ eq b_t) y) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t y) (YEQ : y = a_t) : False.","proofString":"subst y.\napply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : False.","proofString":"apply (rsr_nrpo INV' rsr_a_sim) with b_t a_t.\nunfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : (⦗mapper ↑₁ (eq a_t ∩₁ E_t')⦘ ⨾ rpo_s' ⨾ ⦗mapper ↑₁ (eq b_t ∩₁ E_t')⦘) b_t\n  a_t.","proofString":"unfolder.\nsplits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : (exists y : actid, (a_t = y /\\ E_t' y) /\\ mapper y = b_t) /\\\nrpo_s' b_t a_t /\\ (exists y : actid, (b_t = y /\\ E_t' y) /\\ mapper y = a_t).","proofString":"splits; eauto with xmm.\nunfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : rpo_s' b_t a_t.","proofString":"unfold rpo.\nnow apply ct_step."},{"statement":"(NEQ : a_t <> b_t) (SB : (⦗eq b_t⦘ ⨾ sb_s') b_t a_t) (CMT : (E_s \\₁ eq b_t) a_t) (RPO : rpo_imm_s' b_t a_t) : rpo_imm_s'⁺ b_t a_t.","proofString":"now apply ct_step."},{"statement":"(AIN : E_s b_t) : restr_rel cmt rpo_s' ⊆ rpo_s.","proofString":"assert (BIN : E_s a_t) by apply rsr_a_bin.\nunfold rpo at 1.\nrewrite restr_rel_ct; [| apply rsr_a_rpoimm_upward].\nnow rewrite rsr_a_restr_rpoimm."},{"statement":"(AIN : E_s b_t) (BIN : E_s a_t) : restr_rel cmt rpo_s' ⊆ rpo_s.","proofString":"unfold rpo at 1.\nrewrite restr_rel_ct; [| apply rsr_a_rpoimm_upward].\nnow rewrite rsr_a_restr_rpoimm."},{"statement":"(AIN : E_s b_t) (BIN : E_s a_t) : restr_rel cmt rpo_imm_s'⁺ ⊆ rpo_s.","proofString":"rewrite restr_rel_ct; [| apply rsr_a_rpoimm_upward].\nnow rewrite rsr_a_restr_rpoimm."},{"statement":"(AIN : E_s b_t) (BIN : E_s a_t) : (restr_rel cmt rpo_imm_s')⁺ ⊆ rpo_s.","proofString":"now rewrite rsr_a_restr_rpoimm."},{"statement":"dtrmt ⊆₁ dtrmt ∩₁ E_s.","proofString":"rewrite set_inter_absorb_r; auto with xmm hahn."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) : WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","proofString":"assert (NEQ : a_t <> b_t) by apply INV'.\nassert (NEQ' : b_t <> a_t) by now symmetry.\nconstructor; ins.\nrewrite set_inter_absorb_r; basic_solver.\nunfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf.\nnow rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_data rsr_a_pfx).\nnow rewrite (prf_ctrl rsr_a_pfx).\nnow rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) : WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","proofString":"assert (NEQ' : b_t <> a_t) by now symmetry.\nconstructor; ins.\nrewrite set_inter_absorb_r; basic_solver.\nunfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf.\nnow rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_data rsr_a_pfx).\nnow rewrite (prf_ctrl rsr_a_pfx).\nnow rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","proofString":"constructor; ins.\nrewrite set_inter_absorb_r; basic_solver.\nunfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf.\nnow rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l.\nnow rewrite (prf_data rsr_a_pfx).\nnow rewrite (prf_ctrl rsr_a_pfx).\nnow rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : dtrmt ∩₁ E_s ∩₁ dtrmt ≡₁ E_s ∩₁ dtrmt.","proofString":"rewrite set_inter_absorb_r; basic_solver."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : eq_dom dtrmt lab_s (upd lab_s b_t l_a).","proofString":"unfold dtrmt.\nrewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : eq_dom (E_s \\₁ (eq b_t ∪₁ eq a_t)) lab_s (upd lab_s b_t l_a).","proofString":"rewrite set_minus_union_r.\napply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : eq_dom ((E_s \\₁ eq b_t) ∩₁ (E_s \\₁ eq a_t)) lab_s (upd lab_s b_t l_a).","proofString":"apply eq_dom_upd_r; [| reflexivity].\nunfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : ~ ((E_s \\₁ eq b_t) ∩₁ (E_s \\₁ eq a_t)) b_t.","proofString":"unfolder.\nintro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : ~ ((E_s b_t /\\ b_t <> b_t) /\\ E_s b_t /\\ a_t <> b_t).","proofString":"intro FALSO; desf."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt (rf_s ⨾ ⦗E_s \\₁ eq b_t⦘ ∪ mapper ↑ (rf_t' ⨾ ⦗eq a_t⦘)).","proofString":"now rewrite (prf_rf rsr_a_pfx), restr_restr, set_inter_absorb_l."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ co_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt\n    (restr_rel (E_s \\₁ eq b_t) co_s\n     ∪ mapper ↑ (⦗eq a_t⦘ ⨾ co_t' ∪ co_t' ⨾ ⦗eq a_t⦘)).","proofString":"now rewrite (prf_co rsr_a_pfx), restr_restr, set_inter_absorb_l."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ rmw_s ⨾ ⦗dtrmt⦘)\n≡ restr_rel dtrmt (mapper ↑ rmw_t').","proofString":"now rewrite (prf_rmw rsr_a_pfx), restr_restr, set_inter_absorb_l."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ data_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt data_s.","proofString":"now rewrite (prf_data rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ ctrl_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt ctrl_s.","proofString":"now rewrite (prf_ctrl rsr_a_pfx)."},{"statement":"(SUB : dtrmt ⊆₁ dtrmt ∩₁ E_s) (NEQ : a_t <> b_t) (NEQ' : b_t <> a_t) : restr_rel dtrmt (⦗dtrmt⦘ ⨾ rmw_dep_s ⨾ ⦗dtrmt⦘) ≡ restr_rel dtrmt rmw_dep_s.","proofString":"now rewrite (prf_rmw_dep rsr_a_pfx)."},{"statement":"Wf (WCore.G (WCore.X_start X_s dtrmt)).","proofString":"apply sub_WF with (G := G_s) (sc := ∅₂) (sc' := ∅₂).\nins.\nnow rewrite <- rsr_a_dtrmt_init.\napply (G_s_wf INV SIMREL).\napply restrict_sub; [basic_solver |].\nauto with xmm."},{"statement":"is_init ∩₁ E_s ⊆₁ acts_set (WCore.G (WCore.X_start X_s dtrmt)).","proofString":"ins.\nnow rewrite <- rsr_a_dtrmt_init."},{"statement":"is_init ∩₁ E_s ⊆₁ dtrmt ∩₁ E_s.","proofString":"now rewrite <- rsr_a_dtrmt_init."},{"statement":"Wf G_s.","proofString":"apply (G_s_wf INV SIMREL)."},{"statement":"sub_execution G_s (WCore.G (WCore.X_start X_s dtrmt)) ∅₂ ∅₂.","proofString":"apply restrict_sub; [basic_solver |].\nauto with xmm."},{"statement":"dtrmt ⊆₁ E_s.","proofString":"auto with xmm."},{"statement":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s'\n  (acts_set (WCore.G (WCore.X_start X_s dtrmt)) ∩₁ cmt).","proofString":"ins.\nrewrite set_interA, set_inter_absorb_r.\napply rsr_a_restr_eq.\nrewrite set_inter_absorb_l; auto with xmm."},{"statement":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' (dtrmt ∩₁ E_s ∩₁ cmt).","proofString":"rewrite set_interA, set_inter_absorb_r.\napply rsr_a_restr_eq.\nrewrite set_inter_absorb_l; auto with xmm."},{"statement":"WCore.exec_restr_eq (WCore.X_start X_s dtrmt) X_s' dtrmt.","proofString":"apply rsr_a_restr_eq."},{"statement":"dtrmt ⊆₁ E_s ∩₁ cmt.","proofString":"rewrite set_inter_absorb_l; auto with xmm."},{"statement":"rf_complete (restrict G_s' cmt).","proofString":"apply rsr_a_gs_crfc."},{"statement":"acts_set (WCore.G (WCore.X_start X_s dtrmt))\n∩₁ (fun a : actid => is_r (lab (WCore.G (WCore.X_start X_s dtrmt))) a)\n⊆₁ codom_rel (rf (WCore.G (WCore.X_start X_s dtrmt))) ∪₁ cmt.","proofString":"ins.\nrewrite <- rsr_a_dtrmt_in_cmt.\nbasic_solver."},{"statement":"dtrmt ∩₁ E_s ∩₁ R_s ⊆₁ codom_rel (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘) ∪₁ cmt.","proofString":"rewrite <- rsr_a_dtrmt_in_cmt.\nbasic_solver."},{"statement":"dtrmt ∩₁ E_s ∩₁ R_s ⊆₁ codom_rel (⦗dtrmt⦘ ⨾ rf_s ⨾ ⦗dtrmt⦘) ∪₁ dtrmt.","proofString":"basic_solver."}]}