{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/simhelpers/ViewRelHelpers.v","fileSamples":[{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) : ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘ ⊆ ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘.","proofString":"unfolder; ins; desc; splits; eauto; eexists; splits; eauto; subst.\nassert (~ is_init a) as NA.\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) : sb y a.","proofString":"assert (~ is_init a) as NA.\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) : ~ is_init a.","proofString":"intros H; apply NEXT, IC.\nsplit; auto.\napply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a) : (Init ∩₁ E) a.","proofString":"split; auto.\napply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a) : E a.","proofString":"apply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) : sb y a.","proofString":"assert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) : E y.","proofString":"by apply CE."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) : sb y a.","proofString":"assert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) : E a.","proofString":"by apply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","proofString":"desf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid y = tid a) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","proofString":"symmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (H0 : tid a = tid y) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","proofString":"eapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y \\/ sb y a) : sb y a.","proofString":"desf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y) : sb y a.","proofString":"exfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y) : False.","proofString":"red in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : False.","proofString":"apply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : C a.","proofString":"apply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) (y : actid) (H1 : dom_cond sb C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : C a.","proofString":"apply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) : ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘ ⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘.","proofString":"rewrite sb_tid_init'.\nunfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next G C a) : ⦗dom_rel ((sb ∩ same_tid ∪ ⦗Init⦘ ⨾ sb) ⨾ ⦗eq a⦘)⦘\n⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘.","proofString":"unfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next G C y0) (y : actid) (H2 : tid y = tid y0) (H0 : sb y y0) : C y.","proofString":"apply NEXT; basic_solver 10."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next G C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : C z.","proofString":"apply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next G C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : (Init ∩₁ E) z.","proofString":"split; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next G C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : E z.","proofString":"apply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next G C y0) (z : actid) (H3 : is_init z) (H2 : (⦗E⦘ ⨾ sb) z y0) : E z.","proofString":"apply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next G C y0) (z : actid) (H3 : is_init z) (H2 : E z /\\ sb z y0) : E z.","proofString":"desf."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) : forall l : location,\nS_tm G l (covered T ∪₁ eq f)\n≡₁ S_tm G l (covered T) ∪₁ t_acq G sc thread l (covered T).","proofString":"intro l; split.\nunfold S_tm, t_acq.\nrewrite s_tmr_union; relsf; unionL; splits; [basic_solver|].\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\nunfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42.\nunionL; [by unfold S_tm; rewrite s_tmr_union; basic_solver|].\nunfold t_acq, S_tm.\nrewrite s_tmr_union.\nrelsf.\nunfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : S_tm G l (covered T ∪₁ eq f)\n⊆₁ S_tm G l (covered T) ∪₁ t_acq G sc thread l (covered T).","proofString":"unfold S_tm, t_acq.\nrewrite s_tmr_union; relsf; unionL; splits; [basic_solver|].\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\nunfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel (S_tmr G l (covered T ∪₁ eq f))\n⊆₁ dom_rel (S_tmr G l (covered T))\n   ∪₁ dom_rel (c_acq G sc thread l (covered T)).","proofString":"rewrite s_tmr_union; relsf; unionL; splits; [basic_solver|].\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\nunfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel (S_tmr G l (eq f))\n⊆₁ dom_rel (S_tmr G l (covered T))\n   ∪₁ dom_rel (c_acq G sc thread l (covered T)).","proofString":"unionR right.\nrewrite (s_tmr_helper _ _ WF).\nunfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel (S_tmr G l (eq f)) ⊆₁ dom_rel (c_acq G sc thread l (covered T)).","proofString":"rewrite (s_tmr_helper _ _ WF).\nunfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘)\n⊆₁ dom_rel (c_acq G sc thread l (covered T)).","proofString":"unfold c_acq, urr.\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘)\n⊆₁ dom_rel\n     ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?)\n      ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘).","proofString":"arewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘).\nby revert NEXT; unfold next, dom_cond; basic_solver 21.\narewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘ ⊆ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘.","proofString":"by revert NEXT; unfold next, dom_cond; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n       ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘)\n⊆₁ dom_rel\n     (⦗W_ l⦘\n      ⨾ rf^?\n        ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n          ⨾ sc^?\n            ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘).","proofString":"arewrite (⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?).\nby unfolder; ins; desf; splits; eauto using sb_tid_init.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : ⦗covered T⦘ ⨾ sb ⨾ ⦗eq f⦘ ⊆ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?.","proofString":"by unfolder; ins; desf; splits; eauto using sb_tid_init."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n       ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⨾ sb^?)\n⊆₁ dom_rel\n     (⦗W_ l⦘\n      ⨾ rf^?\n        ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n          ⨾ sc^?\n            ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘).","proofString":"basic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : S_tm G l (covered T) ∪₁ t_acq G sc thread l (covered T)\n⊆₁ S_tm G l (covered T ∪₁ eq f).","proofString":"unionL; [by unfold S_tm; rewrite s_tmr_union; basic_solver|].\nunfold t_acq, S_tm.\nrewrite s_tmr_union.\nrelsf.\nunfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : t_acq G sc thread l (covered T) ⊆₁ S_tm G l (covered T ∪₁ eq f).","proofString":"unfold t_acq, S_tm.\nrewrite s_tmr_union.\nrelsf.\nunfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel (c_acq G sc thread l (covered T))\n⊆₁ dom_rel (S_tmr G l (covered T ∪₁ eq f)).","proofString":"rewrite s_tmr_union.\nrelsf.\nunfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel (c_acq G sc thread l (covered T))\n⊆₁ dom_rel (S_tmr G l (covered T) ∪ S_tmr G l (eq f)).","proofString":"relsf.\nunfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel (c_acq G sc thread l (covered T))\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"unfold c_acq, urr.\nrewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?)\n   ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"rewrite (crE sc); relsf; unionL; splits.\nunionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42.\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^?)\n   ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"unionR right.\nrewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^?)\n   ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘)\n⊆₁ dom_rel (S_tmr G l (eq f)).","proofString":"rewrite (s_tmr_helper _ _ WF).\narewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^?)\n   ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘)\n⊆₁ dom_rel\n     (⦗W_ l⦘\n      ⨾ rf^?\n        ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n          ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘).","proofString":"arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel(sb ⨾ ⦗eq f⦘)⦘).\nby rewrite <- TID; rewrite next_helper'; basic_solver.\narewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗dom_rel (sb ⨾ ⦗eq f⦘)⦘.","proofString":"by rewrite <- TID; rewrite next_helper'; basic_solver."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗dom_rel (sb ⨾ ⦗eq f⦘)⦘)\n⊆₁ dom_rel\n     (⦗W_ l⦘\n      ⨾ rf^?\n        ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n          ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘).","proofString":"arewrite (⦗eq f⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘) at 1 by type_solver.\nbasic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n       ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗dom_rel (sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘)⦘)\n⊆₁ dom_rel\n     (⦗W_ l⦘\n      ⨾ rf^?\n        ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n          ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗eq f⦘).","proofString":"basic_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ hb^?)\n   ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"arewrite (⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘).\nbasic_solver.\narewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘.","proofString":"basic_solver."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n       ⨾ sc ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗covered T⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"arewrite ((release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?).\nby case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver].\narewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : (release ⨾ rf)^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ (release ⨾ rf)^?.","proofString":"by case_refl _;      [basic_solver| rewrite !seqA; rewrite release_rf_covered; auto; basic_solver]."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n       ⨾ sc ⨾ hb^? ⨾ ⦗covered T⦘ ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"arewrite (hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?).\nby case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver].\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : hb^? ⨾ ⦗covered T⦘ ⊆ ⦗covered T⦘ ⨾ hb^?.","proofString":"by case_refl _; [basic_solver| rewrite hb_covered; auto; basic_solver]."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n       ⨾ sc ⨾ ⦗covered T⦘ ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"arewrite (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).\nrewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42.\nsin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc.","proofString":"rewrite (dom_l (@wf_scD G sc Wf_sc)) at 1; rewrite (dom_r (wf_rfD WF)) at 1; hahn_frame_r; type_solver 42."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ hb\n       ⨾ ⦗F ∩₁ Sc⦘\n         ⨾ sc ⨾ ⦗covered T⦘ ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"sin_rewrite sc_covered; eauto.\nunfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (f : actid) (ordf : mode) (thread : BinNums.positive) (TID : tid f = thread) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (NEXT : next G (covered T) f) (FPARAMS : lab f = Afence ordf) (SC : Sc f) (Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) (l : location) : dom_rel\n  (⦗W_ l⦘\n   ⨾ rf^?\n     ⨾ hb\n       ⨾ ⦗F ∩₁ Sc⦘\n         ⨾ (⦗covered T⦘ ⨾ sc)\n           ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘)\n⊆₁ dom_rel (S_tmr G l (covered T)) ∪₁ dom_rel (S_tmr G l (eq f)).","proofString":"unfold S_tmr; basic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : t_acq G sc (tid f) l (eq f) ⊆₁ t_acq G sc (tid f) l (covered T).","proofString":"unfold t_acq, c_acq.\narewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘) by basic_solver.\nrewrite next_helper'; auto.\nrewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘)\n⊆₁ dom_rel\n     (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗covered T⦘).","proofString":"arewrite (⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗eq f⦘ ⊆ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘) by basic_solver.\nrewrite next_helper'; auto.\nrewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel\n     (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘ ⨾ ⦗covered T⦘).","proofString":"rewrite next_helper'; auto.\nrewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗dom_rel (sb ⨾ ⦗eq f⦘)⦘).","proofString":"rewrite <- !seqA.\nrewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (((urr G sc l ⨾ (release ⨾ rf)^?) ⨾ ⦗eq f⦘) ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel ((urr G sc l ⨾ (release ⨾ rf)^?) ⨾ ⦗dom_rel (sb ⨾ ⦗eq f⦘)⦘).","proofString":"rewrite !dom_rel_eqv_dom_rel.\nrewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (((urr G sc l ⨾ (release ⨾ rf)^?) ⨾ ⦗eq f⦘) ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel ((urr G sc l ⨾ (release ⨾ rf)^?) ⨾ sb ⨾ ⦗eq f⦘).","proofString":"rewrite !seqA.\nrewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘).","proofString":"rewrite (dom_r (wf_rfD WF)) at 1.\nrewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel\n  (urr G sc l ⨾ (release ⨾ rf ⨾ ⦗R⦘)^? ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘).","proofString":"rewrite crE at 1; relsf; unionL; splits; [|type_solver].\narewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (urr G sc l ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘).","proofString":"arewrite (⦗eq f⦘ ⊆ ⦗ F∩₁set_compl Sc ⦘ ⨾ ⦗eq f⦘) at 1 by basic_solver.\nsin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel (urr G sc l ⨾ ⦗F ∩₁ set_compl Sc⦘ ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘).","proofString":"sin_rewrite (urr_f_non_sc WF); auto.\nbasic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (NSC : ~ is_sc lab f) (NEXT : next G (covered T) f) (l : location) : dom_rel\n  ((urr G sc l ⨾ (release ⨾ rf)^? ⨾ sb) ⨾ ⦗eq f⦘ ⨾ ⦗Tid_ (tid f) ∪₁ Init⦘)\n⊆₁ dom_rel (urr G sc l ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗eq f⦘).","proofString":"basic_solver 21."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : (E ∩₁ (fun e : actid => dom_rel (sb ⨾ ⦗eq e⦘) ⊆₁ covered T)\n ∩₁ (W ∩₁ issued T\n     ∪₁ R ∩₁ (fun e : actid => dom_rel (rf ⨾ ⦗eq e⦘) ⊆₁ issued T)\n     ∪₁ F ∩₁ (fun e : actid => dom_rel (sc ⨾ ⦗eq e⦘) ⊆₁ covered T))) f) (NCOV : ~ covered T f) (ICOV : Init ∩₁ E ⊆₁ covered T) (CC : covered T\n⊆₁ E ∩₁ (fun e : actid => dom_rel (sb ⨾ ⦗eq e⦘) ⊆₁ covered T)\n   ∩₁ (W ∩₁ issued T\n       ∪₁ R ∩₁ (fun e : actid => dom_rel (rf ⨾ ⦗eq e⦘) ⊆₁ issued T)\n       ∪₁ F ∩₁ (fun e : actid => dom_rel (sc ⨾ ⦗eq e⦘) ⊆₁ covered T))) (II : issued T ⊆₁ issuable G sc T) : ⦗F ∩₁ Sc⦘ ⨾ ⦗covered T⦘ ≡ ⦗dom_rel (sc ⨾ ⦗eq f⦘)⦘.","proofString":"unfolder in *; desf; [type_solver| type_solver|].\nsplit.\nins; desf; splits; eauto.\neexists; splits; eauto.\neapply tot_ex.\napply Wf_sc.\nbasic_solver.\ngeneralize (coveredE TCCOH); basic_solver.\nintro; apply NCOV.\nspecialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto.\nintro; subst; eauto.\nins; desf.\nhahn_rewrite (wf_scD Wf_sc) in H0.\nunfolder in *; desf; splits; eauto 20."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y z : actid, sb x z /\\ z = y /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y z : actid, sc x z /\\ z = y /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y z : actid, sb x0 z /\\ z = y /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y z : actid, rf x0 z /\\ z = y /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y z : actid, sc x0 z /\\ z = y /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) : (forall x y : actid,\n x = y /\\ (is_f lab x /\\ is_sc lab x) /\\ covered T x ->\n x = y /\\ (exists y0 : actid, sc x y0 /\\ f = y0)) /\\\n(forall x y : actid,\n x = y /\\ (exists y0 : actid, sc x y0 /\\ f = y0) ->\n x = y /\\ (is_f lab x /\\ is_sc lab x) /\\ covered T x).","proofString":"split.\nins; desf; splits; eauto.\neexists; splits; eauto.\neapply tot_ex.\napply Wf_sc.\nbasic_solver.\ngeneralize (coveredE TCCOH); basic_solver.\nintro; apply NCOV.\nspecialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto.\nintro; subst; eauto.\nins; desf.\nhahn_rewrite (wf_scD Wf_sc) in H0.\nunfolder in *; desf; splits; eauto 20."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y z : actid, sb x z /\\ z = y /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y z : actid, sc x z /\\ z = y /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y z : actid, sb x0 z /\\ z = y /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y z : actid, rf x0 z /\\ z = y /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y z : actid, sc x0 z /\\ z = y /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) : forall x y : actid,\nx = y /\\ (is_f lab x /\\ is_sc lab x) /\\ covered T x ->\nx = y /\\ (exists y0 : actid, sc x y0 /\\ f = y0).","proofString":"ins; desf; splits; eauto.\neexists; splits; eauto.\neapply tot_ex.\napply Wf_sc.\nbasic_solver.\ngeneralize (coveredE TCCOH); basic_solver.\nintro; apply NCOV.\nspecialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto.\nintro; subst; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sb x0 z /\\ z = y0 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y0 z : actid, rf x0 z /\\ z = y0 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sc x0 z /\\ z = y0 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H1 : covered T y) (H2 : is_sc lab y) (H0 : is_f lab y) : exists y0 : actid, sc y y0 /\\ f = y0.","proofString":"eexists; splits; eauto.\neapply tot_ex.\napply Wf_sc.\nbasic_solver.\ngeneralize (coveredE TCCOH); basic_solver.\nintro; apply NCOV.\nspecialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto.\nintro; subst; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sb x0 z /\\ z = y0 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y0 z : actid, rf x0 z /\\ z = y0 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sc x0 z /\\ z = y0 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H1 : covered T y) (H2 : is_sc lab y) (H0 : is_f lab y) : sc y f.","proofString":"eapply tot_ex.\napply Wf_sc.\nbasic_solver.\ngeneralize (coveredE TCCOH); basic_solver.\nintro; apply NCOV.\nspecialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto.\nintro; subst; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sb x0 z /\\ z = y0 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y0 z : actid, rf x0 z /\\ z = y0 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sc x0 z /\\ z = y0 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H1 : covered T y) (H2 : is_sc lab y) (H0 : is_f lab y) : ~ sc f y.","proofString":"intro; apply NCOV.\nspecialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sb x0 z /\\ z = y0 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y0 z : actid, rf x0 z /\\ z = y0 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sc x0 z /\\ z = y0 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H1 : covered T y) (H2 : is_sc lab y) (H0 : is_f lab y) (H : sc f y) : covered T f.","proofString":"specialize (CC y H1); desf; [type_solver|type_solver|].\napply CC2; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (y : actid) (CC : E y) (CC1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ y = z) -> covered T x) (CC0 : true) (CC2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ y = z) -> covered T x) (II : forall x : actid, issued T x -> issuable G sc T x) (H1 : covered T y) (H2 : is_sc lab y) (H0 : is_f lab y) (H : sc f y) : covered T f.","proofString":"apply CC2; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y0 z : actid, sb x z /\\ z = y0 /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y0 z : actid, sc x z /\\ z = y0 /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sb x0 z /\\ z = y0 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y0 z : actid, rf x0 z /\\ z = y0 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y0 z : actid, sc x0 z /\\ z = y0 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H1 : covered T y) (H2 : is_sc lab y) (H0 : is_f lab y) : f <> y.","proofString":"intro; subst; eauto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (f : actid) (FENCE : is_f lab f) (SC : is_sc lab f) (COV : E f) (COV1 : forall x : actid,\n(exists y z : actid, sb x z /\\ z = y /\\ f = z) -> covered T x) (COV0 : true) (COV2 : forall x : actid,\n(exists y z : actid, sc x z /\\ z = y /\\ f = z) -> covered T x) (NCOV : ~ covered T f) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y z : actid, sb x0 z /\\ z = y /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y z : actid, rf x0 z /\\ z = y /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y z : actid, sc x0 z /\\ z = y /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) : forall x y : actid,\nx = y /\\ (exists y0 : actid, sc x y0 /\\ f = y0) ->\nx = y /\\ (is_f lab x /\\ is_sc lab x) /\\ covered T x.","proofString":"ins; desf.\nhahn_rewrite (wf_scD Wf_sc) in H0.\nunfolder in *; desf; splits; eauto 20."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (y0 : actid) (COV1 : forall x : actid,\n(exists y1 z : actid, sb x z /\\ z = y1 /\\ y0 = z) -> covered T x) (COV : E y0) (SC : is_sc lab y0) (FENCE : is_f lab y0) (COV0 : true) (NCOV : ~ covered T y0) (COV2 : forall x : actid,\n(exists y1 z : actid, sc x z /\\ z = y1 /\\ y0 = z) -> covered T x) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y1 z : actid, sb x0 z /\\ z = y1 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y1 z : actid, rf x0 z /\\ z = y1 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y1 z : actid, sc x0 z /\\ z = y1 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H0 : sc y y0) : y = y /\\ (is_f lab y /\\ is_sc lab y) /\\ covered T y.","proofString":"hahn_rewrite (wf_scD Wf_sc) in H0.\nunfolder in *; desf; splits; eauto 20."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (Wf_sc : wf_sc G sc) (y0 : actid) (COV1 : forall x : actid,\n(exists y1 z : actid, sb x z /\\ z = y1 /\\ y0 = z) -> covered T x) (COV : E y0) (SC : is_sc lab y0) (FENCE : is_f lab y0) (COV0 : true) (NCOV : ~ covered T y0) (COV2 : forall x : actid,\n(exists y1 z : actid, sc x z /\\ z = y1 /\\ y0 = z) -> covered T x) (ICOV : forall x : actid, is_init x /\\ E x -> covered T x) (CC : forall x : actid,\ncovered T x ->\n(E x /\\\n (forall x0 : actid,\n  (exists y1 z : actid, sb x0 z /\\ z = y1 /\\ x = z) -> covered T x0)) /\\\n((is_w lab x /\\ issued T x \\/\n  is_r lab x /\\\n  (forall x0 : actid,\n   (exists y1 z : actid, rf x0 z /\\ z = y1 /\\ x = z) -> issued T x0)) \\/\n is_f lab x /\\\n (forall x0 : actid,\n  (exists y1 z : actid, sc x0 z /\\ z = y1 /\\ x = z) -> covered T x0))) (II : forall x : actid, issued T x -> issuable G sc T x) (y : actid) (H0 : (⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) y y0) : y = y /\\ (is_f lab y /\\ is_sc lab y) /\\ covered T y.","proofString":"unfolder in *; desf; splits; eauto 20."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = true) : forall l : location,\nt_cur G sc (tid f) l (covered T ∪₁ eq f)\n≡₁ S_tm G l (covered T) ∪₁ t_acq G sc (tid f) l (covered T).","proofString":"apply t_cur_sc_fence_step; auto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : forall l : location,\nt_cur G sc (tid f) l (covered T ∪₁ eq f)\n≡₁ (if is_acq lab f\n    then t_acq G sc (tid f) l (covered T)\n    else t_cur G sc (tid f) l (covered T)).","proofString":"apply t_cur_n_sc_fence_step; auto.\nby apply IMMCON.\nby ins; desf.\nby split; [apply COV|apply NCOV]."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : wf_sc G sc.","proofString":"by apply IMMCON."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : ~ is_sc lab f.","proofString":"by ins; desf."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (RELCOV : W ∩₁ Rel ∩₁ issued T ⊆₁ covered T) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : next G (covered T) f.","proofString":"by split; [apply COV|apply NCOV]."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = true) : forall l : location,\nt_acq G sc (tid f) l (covered T ∪₁ eq f)\n≡₁ t_acq G sc (tid f) l (covered T) ∪₁ S_tm G l (covered T).","proofString":"apply t_acq_sc_fence_step; auto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : forall l : location,\nt_acq G sc (tid f) l (covered T ∪₁ eq f)\n≡₁ t_acq G sc (tid f) l (covered T) ∪₁ ∅.","proofString":"ins; rewrite set_union_empty_r; apply t_acq_n_sc_fence_step; auto.\nby apply IMMCON.\nby ins; desf.\nby split; [apply COV|apply NCOV]."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : is_f lab f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) (l : location) : wf_sc G sc.","proofString":"by apply IMMCON."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : is_f lab f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) (l : location) : ~ is_sc lab f.","proofString":"by ins; desf."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : is_f lab f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) (l : location) : next G (covered T) f.","proofString":"by split; [apply COV|apply NCOV]."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = true) : forall l l' : location,\nt_rel G sc (tid f) l l' (covered T ∪₁ eq f)\n∪₁ (if LocSet.Facts.eq_dec l l'\n    then W_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T ∪₁ eq f)\n    else ∅) ≡₁ S_tm G l (covered T) ∪₁ t_acq G sc (tid f) l (covered T).","proofString":"apply t_rel_sc_fence_step; auto."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : forall l l' : location,\nt_rel G sc (tid f) l l' (covered T ∪₁ eq f)\n∪₁ (if LocSet.Facts.eq_dec l l'\n    then W_ l' ∩₁ Tid_ (tid f) ∩₁ (covered T ∪₁ eq f)\n    else ∅)\n≡₁ (if is_acqrel lab f\n    then t_acq G sc (tid f) l (covered T)\n    else\n     if is_rel lab f\n     then t_cur G sc (tid f) l (covered T)\n     else\n      t_rel G sc (tid f) l l' (covered T)\n      ∪₁ (if LocSet.Facts.eq_dec l l'\n          then W_ l' ∩₁ Tid_ (tid f) ∩₁ covered T\n          else ∅)).","proofString":"apply t_rel_n_sc_fence_step; auto.\nby apply IMMCON.\nby ins; desf.\nby split; [apply COV|apply NCOV]."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : wf_sc G sc.","proofString":"by apply IMMCON."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : ~ is_sc lab f.","proofString":"by ins; desf."},{"statement":"(T : trav_config) (TCCOH : tc_coherent G sc T) (IMMCON : imm_consistent G sc) (f : actid) (FENCE : F f) (COV : coverable G sc T f) (NCOV : ~ covered T f) (H : is_sc lab f = false) : next G (covered T) f.","proofString":"by split; [apply COV|apply NCOV]."}]}